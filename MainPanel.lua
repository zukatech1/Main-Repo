--[[  This won't be fully functional on xeno or solara. Use a better executor.



Made By Zuka. @OverZuka on ROBLOX.


]]
    
print("- Zukas Panel -")

local TweenService = game:GetService("TweenService")
local StarterGui = game:GetService("StarterGui")
local CoreGui = game:GetService("CoreGui")
do
    local THEME = {
        Title = "Loading...",
        Subtitle = "Made by @OverZuka â€” We're so back...",
        IconAssetId = "rbxassetid://7243158473",
        BackgroundColor = Color3.fromRGB(15, 15, 20),
        AccentColor = Color3.fromRGB(0, 255, 255),
        TextColor = Color3.fromRGB(240, 240, 240),
        FadeInTime = 0.45,
        HoldTime = 1.2,
        FadeOutTime = 0.35
    }
    local splashGui = Instance.new("ScreenGui")
    splashGui.Name = "SplashScreen_" .. math.random(1000, 9999)
    splashGui.IgnoreGuiInset = true
    splashGui.ResetOnSpawn = false
    splashGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
    splashGui.Parent = CoreGui
    local background = Instance.new("Frame")
    background.Size = UDim2.fromScale(1, 1)
    background.BackgroundColor3 = THEME.BackgroundColor
    background.BackgroundTransparency = 1
    background.Parent = splashGui
    local blur = Instance.new("BlurEffect")
    blur.Size = 1
    blur.Parent = Lighting
    local card = Instance.new("Frame")
    card.Size = UDim2.fromOffset(320, 260)
    card.Position = UDim2.fromScale(0.5, 0.5)
    card.AnchorPoint = Vector2.new(0.5, 0.5)
    card.BackgroundColor3 = Color3.fromRGB(20, 20, 26)
    card.BackgroundTransparency = 1
    card.Parent = background
    Instance.new("UICorner", card).CornerRadius = UDim.new(0, 18)
    local stroke = Instance.new("UIStroke")
    stroke.Thickness = 1
    stroke.Color = THEME.AccentColor
    stroke.Transparency = 1
    stroke.Parent = card
    local icon = Instance.new("ImageLabel")
    icon.Size = UDim2.fromOffset(96, 96)
    icon.Position = UDim2.fromScale(0.5, 0.32)
    icon.AnchorPoint = Vector2.new(0.5, 0.5)
    icon.BackgroundTransparency = 1
    icon.ImageTransparency = 0.5
    icon.ImageColor3 = THEME.AccentColor
    icon.Image = THEME.IconAssetId
    icon.Parent = card
    pcall(function()
        ContentProvider:PreloadAsync({ icon })
    end)
    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, -40, 0, 36)
    title.Position = UDim2.fromScale(0.5, 0.62)
    title.AnchorPoint = Vector2.new(0.5, 0.5)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.Oswald
    title.Text = THEME.Title
    title.TextSize = 27
    title.TextColor3 = THEME.TextColor
    title.TextTransparency = 0.6
    title.Parent = card
    local subtitle = Instance.new("TextLabel")
    subtitle.Size = UDim2.new(1, -40, 0, 24)
    subtitle.Position = UDim2.fromScale(0.5, 0.75)
    subtitle.AnchorPoint = Vector2.new(0.5, 0.5)
    subtitle.BackgroundTransparency = 1
    subtitle.Font = Enum.Font.Bangers
    subtitle.Text = THEME.Subtitle
    subtitle.TextSize = 14
    subtitle.TextColor3 = THEME.TextColor
    subtitle.TextTransparency = 0
    subtitle.Parent = card
    card.Size = card.Size - UDim2.fromOffset(40, 40)
    local tweenIn = TweenInfo.new(THEME.FadeInTime, Enum.EasingStyle.Quint, Enum.EasingDirection.Out)
    local tweenOut = TweenInfo.new(THEME.FadeOutTime, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
    TweenService:Create(background, tweenIn, { BackgroundTransparency = 0.35 }):Play()
    TweenService:Create(blur, tweenIn, { Size = 16 }):Play()
    TweenService:Create(card, tweenIn, { Size = UDim2.fromOffset(320, 260) }):Play()
    TweenService:Create(icon, tweenIn, { ImageTransparency = 0 }):Play()
    TweenService:Create(title, tweenIn, { TextTransparency = 0 }):Play()
    TweenService:Create(subtitle, tweenIn, { TextTransparency = 0.25 }):Play()
    task.wait(THEME.FadeInTime + THEME.HoldTime)
    TweenService:Create(background, tweenOut, { BackgroundTransparency = 1 }):Play()
    TweenService:Create(blur, tweenOut, { Size = 0 }):Play()
    TweenService:Create(icon, tweenOut, { ImageTransparency = 1 }):Play()
    TweenService:Create(title, tweenOut, { TextTransparency = 1 }):Play()
    TweenService:Create(subtitle, tweenOut, { TextTransparency = 1 }):Play()
    task.wait(THEME.FadeOutTime)
    blur:Destroy()
    splashGui:Destroy()
end
if not game:IsLoaded() then game.Loaded:Wait() end
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local oldKick
oldKick = hookfunction(LocalPlayer.Kick, newcclosure(function(self, ...)
    if not checkcaller() and self == LocalPlayer then
        return nil
    end
    return oldKick(self, ...)
end))
local function detectEnvironment()
    local env = {
        executor = identifyexecutor and identifyexecutor() or "Unknown",
        functions = {},
        level = 0
    }
    local testFunctions = {
        "getgenv", "getrenv", "getrawmetatable", "setreadonly",
        "hookmetamethod", "hookfunction", "newcclosure",
        "getnamecallmethod", "checkcaller", "getconnections",
        "firesignal", "Drawing", "WebSocket", "request",
        "http_request", "syn_request", "readfile", "writefile",
        "isfile", "isfolder", "makefolder", "delfile"
    }
    for _, funcName in ipairs(testFunctions) do
        local func = getfenv()[funcName]
        if func then
            env.functions[funcName] = type(func)
            env.level = env.level + 1
        end
    end
    env.rating = env.level >= 20 and "Peak Executor" or env.level >= 10 and "Decent" or "Dog shit"
    return env
end
local env = detectEnvironment()
print("Executor:", env.executor) if Xeno
then print("Oh no! Module poisoning is not possible with xeno") end
print("Good Executor?:", env.rating)
print("Available Functions:", env.level)
local debug = debug
local getgc = getgc or get_gc_objects
local setupvalue = debug.setupvalue or setupvalue
local getupvalues = debug.getupvalues or getupvalues
if getgenv().ZukaTech_Loaded then
    return
end
getgenv().ZukaTech_Loaded = true
if not game:IsLoaded() then
    game.Loaded:Wait()
end
local Players = game:GetService("Players")
local function getLocalPlayer()
    local lp = Players.LocalPlayer
    while not lp do
        task.wait(0.1)
        lp = Players.LocalPlayer
    end
    return lp
end
local _GC_START = collectgarbage("count")
local _TIMESTAMP = os.clock()
local set_ro = setreadonly or (make_writeable and function(t, v) if v then make_readonly(t) else make_writeable(t) end end)
local get_mt = getrawmetatable or debug.getmetatable
local hook_meta = hookmetamethod
local new_ccl = newcclosure or function(f) return f end
local check_caller = checkcaller or function() return false end
local clone_func = clonefunction or function(f) return f end
local function dismantle_readonly(target)
    if type(target) ~= "table" then return end
    pcall(function()
        if set_ro then set_ro(target, false) end
        local mt = get_mt(target)
        if mt and set_ro then set_ro(mt, false) end
    end)
end
local function protect_interface(instance)
    local protector = (get_hidden_gui or (syn and syn.protect_gui))
    if protector then pcall(protector, instance) end
end
local function get_memory_signature(target_name)
    local found = 0
    for _, obj in ipairs(getgc(true)) do
        if type(obj) == "function" then
            local info = debug.getinfo(obj)
            if info.name == target_name or (info.source and info.source:find(target_name)) then
                found = found + 1
            end
        end
    end
    return found
end
local Services = setmetatable({}, {
    __index = function(t, k)
        local s = game:GetService(k)
        if s then t[k] = s end
        return s
    end
})
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")
local StarterGui = game:GetService("StarterGui")
local CoreGui = game:GetService("CoreGui")
local Lighting = game:GetService("Lighting")
local Debris = game:GetService("Debris")
local TeleportService = game:GetService("TeleportService")
local TextChatService = game:GetService("TextChatService")
local MarketplaceService = game:GetService("MarketplaceService")
local PathfindingService = game:GetService("PathfindingService")
local CollectionService = game:GetService("CollectionService")
local LocalPlayer = Players.LocalPlayer
local PlayerMouse = LocalPlayer:GetMouse()
local CurrentCamera = Workspace.CurrentCamera
local Utilities = {}
function Utilities.findPlayer(inputName)
    local input = tostring(inputName):lower()
    if input == "" then return nil end
        local exactMatch = nil
        local partialMatch = nil
        if input == "me" then return Players.LocalPlayer end
            for _, player in ipairs(Players:GetPlayers()) do
                local username = player.Name:lower()
                local displayName = player.DisplayName:lower()
                if username == input or displayName == input then
                    exactMatch = player
                    break
                end
                if not partialMatch then
                    if username:sub(1, #input) == input or displayName:sub(1, #input) == input then
                        partialMatch = player
                    end
                end
            end
            return exactMatch or partialMatch
        end
function Utilities.calculateLevenshteinDistance(s1: string, s2: string): number
    local len1, len2 = #s1, #s2
    if len1 == 0 then return len2 end
    if len2 == 0 then return len1 end
    local matrix = {}
    for i = 0, len1 do
        matrix[i] = {}
        matrix[i][0] = i
    end
    for j = 0, len2 do
        matrix[0][j] = j
    end
    for i = 1, len1 do
        for j = 1, len2 do
            local cost = (s1:sub(i, i) == s2:sub(j, j)) and 0 or 1
            matrix[i][j] = math.min(
                matrix[i - 1][j] + 1,
                matrix[i][j - 1] + 1,
                matrix[i - 1][j - 1] + cost
            )
        end
    end
    return matrix[len1][len2]
end
        local Prefix = ";"
        local Commands = {}
        local CommandInfo = {}
        local Modules = {}
        local NotificationManager = {}
        do
            local queue = {}
            local isActive = false
            local tweenService = game:GetService("TweenService")
            local coreGui = game:GetService("CoreGui")
            local textService = game:GetService("TextService")
            local notifGui = Instance.new("ScreenGui", coreGui)
            notifGui.Name = "ZukaNotifGui_v2"
            notifGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
            notifGui.ResetOnSpawn = false
            local function processNext()
            if isActive or #queue == 0 then
                return
            end
            isActive = true
            local data = table.remove(queue, 1)
            local text, duration = data[1], data[2]
            local notif = Instance.new("TextLabel")
            notif.Font = Enum.Font.GothamSemibold
            notif.TextSize = 12
            notif.Text = text
            notif.TextWrapped = true
            notif.Size = UDim2.fromOffset(300, 0)
            local textBounds = textService:GetTextSize(notif.Text, notif.TextSize, notif.Font, Vector2.new(notif.Size.X.Offset, 1000))
            local verticalPadding = 20
            notif.Size = UDim2.fromOffset(300, textBounds.Y + verticalPadding)
            notif.Position = UDim2.new(0.5, -150, 0, -60)
            notif.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
            notif.TextColor3 = Color3.fromRGB(255, 255, 255)
            local corner = Instance.new("UICorner", notif)
            corner.CornerRadius = UDim.new(0, 6)
            local stroke = Instance.new("UIStroke", notif)
            stroke.Color = Color3.fromRGB(80, 80, 100)
            notif.Parent = notifGui
            local tweenInfoIn = TweenInfo.new(0.4, Enum.EasingStyle.Quint, Enum.EasingDirection.Out)
            local tweenInfoOut = TweenInfo.new(0.4, Enum.EasingStyle.Quint, Enum.EasingDirection.In)
            local goalIn = { Position = UDim2.new(0.5, -150, 0, 10) }
            local goalOut = { Position = UDim2.new(0.5, -150, 0, -60) }
            local inTween = tweenService:Create(notif, tweenInfoIn, goalIn)
            inTween:Play()
            inTween.Completed:Wait()
            task.wait(duration)
            local outTween = tweenService:Create(notif, tweenInfoOut, goalOut)
            outTween:Play()
            outTween.Completed:Wait()
            notif:Destroy()
            isActive = false
            task.spawn(processNext)
        end
        function NotificationManager.Send(text, duration)
            table.insert(queue, {tostring(text), duration or 1})
            task.spawn(processNext)
        end
    end
    function DoNotif(text, duration)
        NotificationManager.Send(text, duration)
    end
function RegisterCommand(info, func)
    if not info or not info.Name or not func then
        warn("Command registration failed: Missing info, name, or function.")
        return
    end
    local name = info.Name:lower()
    if Commands[name] then
        warn("Command registration skipped: Command '" .. name .. "' already exists.")
        return
    end
    Commands[name] = func
    if info.Aliases then
        for _, alias in ipairs(info.Aliases) do
            local aliasLower = alias:lower()
            if Commands[aliasLower] then
                warn("Alias '" .. aliasLower .. "' for command '" .. name .. "' conflicts with an existing command and was not registered.")
            else
                Commands[aliasLower] = func
            end
        end
    end
    table.insert(CommandInfo, info)
end
print("This Panel is managed by Zuka")
function RegisterCommandDual(info, func)
    RegisterCommand(info, func)
    if cmd and cmd.add and info.Aliases then
        for _, alias in ipairs(info.Aliases) do
            cmd.add(alias, func, info.Description or "")
        end
    end
end
local function loadAimbotGUI(args)
    local CoreGui = game:GetService("CoreGui")
    if CoreGui:FindFirstChild("UTS_CGE_Suite") and not args then
        if DoNotif then
            DoNotif("Aimbot GUI is already open.", 2)
        else
            warn("Aimbot GUI is already open.")
        end
        return
    end

    if CoreGui:FindFirstChild("UTS_CGE_Suite") then
    end

    local success, err = pcall(function()

        local UserInputService = game:GetService("UserInputService")
        local RunService = game:GetService("RunService")
        local Players = game:GetService("Players")
        local Workspace = game:GetService("Workspace")
        local TweenService = game:GetService("TweenService")

        local LocalPlayer = Players.LocalPlayer
        local Camera = Workspace.CurrentCamera

        local janitor = {}

        local function makeUICorner(element, cornerRadius)
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, cornerRadius or 6)
            corner.Parent = element
        end

        local MainScreenGui = CoreGui:FindFirstChild("UTS_CGE_Suite") or Instance.new("ScreenGui")
        MainScreenGui.Name = "UTS_CGE_Suite"
        MainScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
        MainScreenGui.ResetOnSpawn = false

        if not MainScreenGui.Parent then
            table.insert(janitor, MainScreenGui.Destroying:Connect(function()
                for _, connection in ipairs(janitor) do
                    connection:Disconnect()
                end
            end))
            MainScreenGui.Parent = CoreGui
        end

        local MainWindow = MainScreenGui:FindFirstChild("MainWindow")
        if MainWindow then 
            MainWindow:Destroy() 
        end

        getgenv().TargetScope = Workspace
        getgenv().TargetIndex = {}

        local explorerWindow = nil
        local function createExplorerWindow(statusLabel, indexerUpdateSignal)

            if explorerWindow and explorerWindow.Parent then
                explorerWindow.Visible = not explorerWindow.Visible
                return explorerWindow
            end
            
            local explorerFrame = Instance.new("Frame")
            explorerFrame.Name = "ExplorerWindow"
            explorerFrame.Size = UDim2.new(0, 300, 0, 450)
            explorerFrame.Position = UDim2.new(0.5, 305, 0.5, -225)
            explorerFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
            explorerFrame.BorderSizePixel = 1
            explorerFrame.BorderColor3 = Color3.fromRGB(80, 80, 80)
            explorerFrame.Draggable = true
            explorerFrame.Active = true
            explorerFrame.ClipsDescendants = true
            explorerFrame.Parent = MainScreenGui
            makeUICorner(explorerFrame, 8)
            
            local topBar = Instance.new("Frame", explorerFrame)
            topBar.Name = "TopBar"
            topBar.Size = UDim2.new(1, 0, 0, 30)
            topBar.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
            makeUICorner(topBar, 8)
            
            local title = Instance.new("TextLabel", topBar)
            title.Size = UDim2.new(1, -30, 1, 0)
            title.Position = UDim2.new(0, 10, 0, 0)
            title.BackgroundTransparency = 1
            title.Font = Enum.Font.Code
            title.Text = "Game Explorer"
            title.TextColor3 = Color3.fromRGB(200, 220, 255)
            title.TextSize = 16
            title.TextXAlignment = Enum.TextXAlignment.Left
            
            local closeButton = Instance.new("TextButton", topBar)
            closeButton.Size = UDim2.new(0, 24, 0, 24)
            closeButton.Position = UDim2.new(1, -28, 0.5, -12)
            closeButton.BackgroundColor3 = Color3.fromRGB(200, 80, 80)
            closeButton.Font = Enum.Font.Code
            closeButton.Text = "X"
            closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
            closeButton.TextSize = 14
            makeUICorner(closeButton, 6)
            table.insert(janitor, closeButton.MouseButton1Click:Connect(function() 
                explorerFrame.Visible = false 
            end))
            
            local treeScrollView = Instance.new("ScrollingFrame", explorerFrame)
            treeScrollView.Position = UDim2.new(0, 0, 0, 30)
            treeScrollView.Size = UDim2.new(1, 0, 1, -30)
            treeScrollView.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
            treeScrollView.BorderSizePixel = 0
            
            local uiListLayout = Instance.new("UIListLayout", treeScrollView)
            uiListLayout.SortOrder = Enum.SortOrder.LayoutOrder
            uiListLayout.Padding = UDim.new(0, 1)
            
            local contextMenu = nil
            local function closeContextMenu() 
                if contextMenu and contextMenu.Parent then 
                    contextMenu:Destroy() 
                end 
            end
            
            table.insert(janitor, UserInputService.InputBegan:Connect(function(input) 
                if not (contextMenu and contextMenu:IsAncestorOf(input.UserInputType)) and input.UserInputType ~= Enum.UserInputType.MouseButton2 then 
                    closeContextMenu() 
                end 
            end))
            
            local function createTree(parentInstance, parentUi, indentLevel) 
                for _, child in ipairs(parentInstance:GetChildren()) do 
                    local itemFrame = Instance.new("Frame")
                    itemFrame.Name = child.Name
                    itemFrame.Size = UDim2.new(1, 0, 0, 22)
                    itemFrame.BackgroundTransparency = 1
                    itemFrame.Parent = parentUi
                    
                    local hasChildren = #child:GetChildren() > 0
                    
                    local toggleButton = Instance.new("TextButton")
                    toggleButton.Size = UDim2.new(0, 20, 0, 20)
                    toggleButton.Position = UDim2.fromOffset(indentLevel * 12, 1)
                    toggleButton.BackgroundColor3 = Color3.fromRGB(80, 80, 100)
                    toggleButton.Font = Enum.Font.Code
                    toggleButton.TextSize = 14
                    toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
                    toggleButton.Text = hasChildren and "[+]" or "[-]"
                    toggleButton.Parent = itemFrame
                    
                    local nameButton = Instance.new("TextButton")
                    nameButton.Size = UDim2.new(1, -((indentLevel * 12) + 22), 0, 20)
                    nameButton.Position = UDim2.fromOffset((indentLevel * 12) + 22, 1)
                    nameButton.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
                    nameButton.Font = Enum.Font.Code
                    nameButton.TextSize = 14
                    nameButton.TextColor3 = Color3.fromRGB(220, 220, 220)
                    nameButton.Text = " " .. child.Name .. " [" .. child.ClassName .. "]"
                    nameButton.TextXAlignment = Enum.TextXAlignment.Left
                    nameButton.Parent = itemFrame
                    
                    local childContainer = Instance.new("Frame", itemFrame)
                    childContainer.Name = "ChildContainer"
                    childContainer.Size = UDim2.new(1, 0, 0, 0)
                    childContainer.Position = UDim2.new(0, 0, 1, 0)
                    childContainer.BackgroundTransparency = 1
                    childContainer.ClipsDescendants = true
                    
                    local childLayout = Instance.new("UIListLayout", childContainer)
                    childLayout.SortOrder = Enum.SortOrder.LayoutOrder
                    
                    table.insert(janitor, itemFrame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function() 
                        childContainer.Size = UDim2.new(1, 0, 0, childLayout.AbsoluteContentSize.Y)
                        itemFrame.Size = UDim2.new(1, 0, 0, 22 + childContainer.AbsoluteSize.Y) 
                    end))
                    
                    table.insert(janitor, childLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function() 
                        childContainer.Size = UDim2.new(1, 0, 0, childLayout.AbsoluteContentSize.Y)
                        itemFrame.Size = UDim2.new(1, 0, 0, 22 + childContainer.AbsoluteSize.Y) 
                    end))
                    
                    table.insert(janitor, toggleButton.MouseButton1Click:Connect(function() 
                        local isExpanded = childContainer:FindFirstChildOfClass("Frame") ~= nil
                        if not hasChildren then 
                            return 
                        end
                        
                        if isExpanded then 
                            for _, v in ipairs(childContainer:GetChildren()) do 
                                if v:IsA("Frame") then 
                                    v:Destroy() 
                                end 
                            end
                            toggleButton.Text = "[+]" 
                        else 
                            createTree(child, childContainer, indentLevel + 1)
                            toggleButton.Text = "[-]" 
                        end 
                    end))
                    
                    table.insert(janitor, nameButton.MouseButton2Click:Connect(function() 
                        closeContextMenu()
                        
                        if child:IsA("Folder") or child:IsA("Model") or child:IsA("Workspace") then 
                            contextMenu = Instance.new("Frame")
                            contextMenu.Size = UDim2.new(0, 150, 0, 30)
                            contextMenu.Position = UDim2.fromOffset(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
                            contextMenu.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
                            contextMenu.BorderSizePixel = 1
                            contextMenu.BorderColor3 = Color3.fromRGB(80, 80, 80)
                            contextMenu.Parent = MainScreenGui
                            
                            local setScopeBtn = Instance.new("TextButton", contextMenu)
                            setScopeBtn.Size = UDim2.new(1, 0, 1, 0)
                            setScopeBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
                            setScopeBtn.TextColor3 = Color3.fromRGB(200, 220, 255)
                            setScopeBtn.Font = Enum.Font.Code
                            setScopeBtn.Text = "Set as Target Scope"
                            
                            table.insert(janitor, setScopeBtn.MouseButton1Click:Connect(function() 
                                getgenv().TargetScope = child
                                statusLabel.Text = "Scope set to: " .. child.Name
                                indexerUpdateSignal:Fire()
                                closeContextMenu() 
                            end))
                        end 
                    end))
                end 
            end
            
            createTree(game, treeScrollView, 0)
            explorerWindow = explorerFrame
            return explorerFrame
        end

        MainWindow = Instance.new("Frame")
        MainWindow.Name = "MainWindow"
        MainWindow.Size = UDim2.new(0, 520, 0, 420)
        MainWindow.Position = UDim2.new(0.5, -260, 0.5, -210)
        MainWindow.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
        MainWindow.BackgroundTransparency = 0.3
        MainWindow.BorderSizePixel = 0
        MainWindow.Active = true
        MainWindow.ClipsDescendants = true
        MainWindow.Parent = MainScreenGui
        makeUICorner(MainWindow, 8)

        local isDragging = false
        local dragStart, startPosition
        
        table.insert(janitor, MainWindow.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                isDragging = true
                dragStart = input.Position
                startPosition = MainWindow.Position
                
                local changedConn
                changedConn = input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        isDragging = false
                        if changedConn then 
                            changedConn:Disconnect() 
                        end
                    end
                end)
            end
        end))
        
        table.insert(janitor, UserInputService.InputChanged:Connect(function(input)
            if (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) and isDragging then
                local delta = input.Position - dragStart
                MainWindow.Position = UDim2.new(startPosition.X.Scale, startPosition.X.Offset + delta.X, startPosition.Y.Scale, startPosition.Y.Offset + delta.Y)
            end
        end))

        local TopBar = Instance.new("Frame")
        TopBar.Name = "TopBar"
        TopBar.Size = UDim2.new(1, 0, 0, 30)
        TopBar.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
        TopBar.BorderSizePixel = 0
        TopBar.Parent = MainWindow
        makeUICorner(TopBar, 8)

        local TitleLabel = Instance.new("TextLabel")
        TitleLabel.Name = "TitleLabel"
        TitleLabel.Size = UDim2.new(1, -90, 1, 0)
        TitleLabel.Position = UDim2.new(0, 10, 0, 0)
        TitleLabel.BackgroundTransparency = 1
        TitleLabel.Font = Enum.Font.Code
        TitleLabel.Text = "GC"
        TitleLabel.TextColor3 = Color3.fromRGB(200, 220, 255)
        TitleLabel.TextSize = 16
        TitleLabel.TextXAlignment = Enum.TextXAlignment.Left
        TitleLabel.Parent = TopBar

        local CloseButton = Instance.new("TextButton")
        CloseButton.Name = "CloseButton"
        CloseButton.Size = UDim2.new(0, 24, 0, 24)
        CloseButton.Position = UDim2.new(1, -28, 0.5, -12)
        CloseButton.BackgroundColor3 = Color3.fromRGB(200, 80, 80)
        CloseButton.Font = Enum.Font.Code
        CloseButton.Text = "X"
        CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        CloseButton.TextSize = 14
        CloseButton.Parent = TopBar
        makeUICorner(CloseButton, 6)
        
        table.insert(janitor, CloseButton.MouseButton1Click:Connect(function() 
            MainScreenGui:Destroy() 
        end))

        local MinimizeButton = Instance.new("TextButton")
        MinimizeButton.Name = "MinimizeButton"
        MinimizeButton.Size = UDim2.new(0, 24, 0, 24)
        MinimizeButton.Position = UDim2.new(1, -56, 0.5, -12)
        MinimizeButton.BackgroundColor3 = Color3.fromRGB(80, 80, 100)
        MinimizeButton.Font = Enum.Font.Code
        MinimizeButton.Text = "-"
        MinimizeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        MinimizeButton.TextSize = 14
        MinimizeButton.Parent = TopBar
        makeUICorner(MinimizeButton, 6)

        local ExplorerButton = Instance.new("TextButton")
        ExplorerButton.Name = "ExplorerButton"
        ExplorerButton.Size = UDim2.new(0, 24, 0, 24)
        ExplorerButton.Position = UDim2.new(1, -84, 0.5, -12)
        ExplorerButton.BackgroundColor3 = Color3.fromRGB(80, 120, 180)
        ExplorerButton.Font = Enum.Font.Code
        ExplorerButton.Text = "E"
        ExplorerButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        ExplorerButton.TextSize = 14
        ExplorerButton.Parent = TopBar
        makeUICorner(ExplorerButton, 6)

        local ContentContainer = Instance.new("Frame")
        ContentContainer.Name = "ContentContainer"
        ContentContainer.Size = UDim2.new(1, 0, 1, -30)
        ContentContainer.Position = UDim2.new(0, 0, 0, 30)
        ContentContainer.BackgroundTransparency = 1
        ContentContainer.Parent = MainWindow

        local isMinimized = false
        table.insert(janitor, MinimizeButton.MouseButton1Click:Connect(function()
            isMinimized = not isMinimized
            ContentContainer.Visible = not isMinimized
            
            if isMinimized then
                local tween = TweenService:Create(MainWindow, TweenInfo.new(0.2), {Size = UDim2.new(0, 200, 0, 30)})
                tween:Play()
                MinimizeButton.Text = "+"
            else
                local tween = TweenService:Create(MainWindow, TweenInfo.new(0.2), {Size = UDim2.new(0, 520, 0, 420)})
                tween:Play()
                MinimizeButton.Text = "-"
            end
        end))

        do
            local statusLabel, selectLabel

            local AimbotPage = Instance.new("Frame", ContentContainer)
            AimbotPage.Name = "AimbotPage"
            AimbotPage.Size = UDim2.new(1, 0, 1, -50)
            AimbotPage.BackgroundTransparency = 1

            local PagePadding = Instance.new("UIPadding", AimbotPage)
            PagePadding.PaddingTop = UDim.new(0, 10)
            PagePadding.PaddingLeft = UDim.new(0, 10)
            PagePadding.PaddingRight = UDim.new(0, 10)

            local LeftColumn = Instance.new("Frame", AimbotPage)
            LeftColumn.Name = "LeftColumn"
            LeftColumn.Size = UDim2.new(0.5, -5, 1, 0)
            LeftColumn.BackgroundTransparency = 1
            
            local LeftLayout = Instance.new("UIListLayout", LeftColumn)
            LeftLayout.Padding = UDim.new(0, 8)
            LeftLayout.SortOrder = Enum.SortOrder.LayoutOrder

            local RightColumn = Instance.new("Frame", AimbotPage)
            RightColumn.Name = "RightColumn"
            RightColumn.Size = UDim2.new(0.5, -5, 1, 0)
            RightColumn.Position = UDim2.new(0.5, 5, 0, 0)
            RightColumn.BackgroundTransparency = 1
            
            local RightLayout = Instance.new("UIListLayout", RightColumn)
            RightLayout.Padding = UDim.new(0, 8)
            RightLayout.SortOrder = Enum.SortOrder.LayoutOrder

            local StatusBar = Instance.new("Frame", ContentContainer)
            StatusBar.Name = "StatusBar"
            StatusBar.Size = UDim2.new(1, -20, 0, 40)
            StatusBar.Position = UDim2.new(0, 10, 1, -45)
            StatusBar.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
            makeUICorner(StatusBar, 6)
            
            local StatusLayout = Instance.new("UIListLayout", StatusBar)
            StatusLayout.Padding = UDim.new(0, 2)
            
            local StatusPadding = Instance.new("UIPadding", StatusBar)
            StatusPadding.PaddingLeft = UDim.new(0, 8)
            StatusPadding.PaddingRight = UDim.new(0, 8)

            local function createSectionHeader(parent, text) 
                local header = Instance.new("TextLabel", parent) 
                header.Size = UDim2.new(1, 0, 0, 24) 
                header.BackgroundTransparency = 1 
                header.Font = Enum.Font.Code 
                header.Text = text 
                header.TextColor3 = Color3.fromRGB(200, 220, 255) 
                header.TextSize = 16 
                header.TextXAlignment = Enum.TextXAlignment.Left 
                return header 
            end
            
            local function createSettingRow(parent, labelText) 
                local row = Instance.new("Frame", parent) 
                row.Size = UDim2.new(1, 0, 0, 24) 
                row.BackgroundTransparency = 1 
                
                local label = Instance.new("TextLabel", row) 
                label.Size = UDim2.new(0.4, 0, 1, 0) 
                label.BackgroundTransparency = 1 
                label.Font = Enum.Font.Code 
                label.Text = labelText .. ":" 
                label.TextColor3 = Color3.fromRGB(180, 220, 255) 
                label.TextSize = 15 
                label.TextXAlignment = Enum.TextXAlignment.Left 
                return row 
            end

            createSectionHeader(LeftColumn, "General Settings")
            
            local toggleKeyRow = createSettingRow(LeftColumn, "Toggle Key")
            local toggleKeyBox = Instance.new("TextBox", toggleKeyRow)
            toggleKeyBox.Size = UDim2.new(0.6, 0, 1, 0)
            toggleKeyBox.Position = UDim2.new(0.4, 0, 0, 0)
            toggleKeyBox.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
            toggleKeyBox.TextColor3 = Color3.fromRGB(255, 255, 255)
            toggleKeyBox.Font = Enum.Font.Code
            toggleKeyBox.TextSize = 15
            toggleKeyBox.Text = "MouseButton2"
            makeUICorner(toggleKeyBox, 6)
            
            local aimPartRow = createSettingRow(LeftColumn, "Aim Part")
            local partDropdown = Instance.new("TextButton", aimPartRow)
            partDropdown.Size = UDim2.new(0.6, 0, 1, 0)
            partDropdown.Position = UDim2.new(0.4, 0, 0, 0)
            partDropdown.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
            partDropdown.TextColor3 = Color3.fromRGB(255, 255, 255)
            partDropdown.Font = Enum.Font.Code
            partDropdown.TextSize = 15
            partDropdown.Text = "Head"
            makeUICorner(partDropdown, 6)
            
            createSectionHeader(LeftColumn, "Field of View")
            
            local fovRow = createSettingRow(LeftColumn, "FOV Radius")
            local fovValueLabel = Instance.new("TextLabel", fovRow)
            fovValueLabel.Size = UDim2.new(0.6, 0, 1, 0)
            fovValueLabel.Position = UDim2.new(0.4, 0, 0, 0)
            fovValueLabel.BackgroundTransparency = 1
            fovValueLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            fovValueLabel.Font = Enum.Font.Code
            fovValueLabel.TextSize = 15
            fovValueLabel.TextXAlignment = Enum.TextXAlignment.Left
            fovValueLabel.TextYAlignment = Enum.TextYAlignment.Center
            
            local sliderTrack = Instance.new("Frame", LeftColumn)
            sliderTrack.Size = UDim2.new(1, 0, 0, 4)
            sliderTrack.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
            sliderTrack.BorderSizePixel = 0
            makeUICorner(sliderTrack, 2)
            
            local sliderHandle = Instance.new("TextButton", sliderTrack)
            sliderHandle.Size = UDim2.new(0, 12, 0, 12)
            sliderHandle.Position = UDim2.new(0, 0, 0.5, -6)
            sliderHandle.BackgroundColor3 = Color3.fromRGB(180, 220, 255)
            sliderHandle.BorderSizePixel = 0
            sliderHandle.Text = ""
            makeUICorner(sliderHandle, 6)
            
            createSectionHeader(LeftColumn, "Smoothing")
            
            local smoothingToggle = Instance.new("TextButton", LeftColumn)
            smoothingToggle.Size = UDim2.new(1, 0, 0, 28)
            smoothingToggle.Text = "Smoothing: OFF"
            smoothingToggle.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
            smoothingToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
            smoothingToggle.Font = Enum.Font.Code
            smoothingToggle.TextSize = 15
            makeUICorner(smoothingToggle, 6)
            
            local smoothingRow = createSettingRow(LeftColumn, "Smoothness")
            local smoothingValueLabel = Instance.new("TextLabel", smoothingRow)
            smoothingValueLabel.Size = UDim2.new(0.6, 0, 1, 0)
            smoothingValueLabel.Position = UDim2.new(0.4, 0, 0, 0)
            smoothingValueLabel.BackgroundTransparency = 1
            smoothingValueLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            smoothingValueLabel.Font = Enum.Font.Code
            smoothingValueLabel.TextSize = 15
            smoothingValueLabel.TextXAlignment = Enum.TextXAlignment.Left
            smoothingValueLabel.TextYAlignment = Enum.TextYAlignment.Center
            
            local smoothingSliderTrack = Instance.new("Frame", LeftColumn)
            smoothingSliderTrack.Size = UDim2.new(1, 0, 0, 4)
            smoothingSliderTrack.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
            smoothingSliderTrack.BorderSizePixel = 0
            makeUICorner(smoothingSliderTrack, 2)
            
            local smoothingSliderHandle = Instance.new("TextButton", smoothingSliderTrack)
            smoothingSliderHandle.Size = UDim2.new(0, 12, 0, 12)
            smoothingSliderHandle.Position = UDim2.new(0, 0, 0.5, -6)
            smoothingSliderHandle.BackgroundColor3 = Color3.fromRGB(180, 220, 255)
            smoothingSliderHandle.BorderSizePixel = 0
            smoothingSliderHandle.Text = ""
            makeUICorner(smoothingSliderHandle, 6)
            
            createSectionHeader(RightColumn, "Targeting")
            
            local playerRow = createSettingRow(RightColumn, "Target Player")
            local playerDropdown = Instance.new("TextButton", playerRow)
            playerDropdown.Size = UDim2.new(0.6, 0, 1, 0)
            playerDropdown.Position = UDim2.new(0.4, 0, 0, 0)
            playerDropdown.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
            playerDropdown.TextColor3 = Color3.fromRGB(255, 255, 255)
            playerDropdown.Font = Enum.Font.Code
            playerDropdown.TextSize = 15
            playerDropdown.Text = "None"
            makeUICorner(playerDropdown, 6)
            
            local targetPlayerToggle = Instance.new("TextButton", RightColumn)
            targetPlayerToggle.Size = UDim2.new(1, 0, 0, 28)
            targetPlayerToggle.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
            targetPlayerToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
            targetPlayerToggle.Font = Enum.Font.Code
            targetPlayerToggle.TextSize = 15
            targetPlayerToggle.Text = "Target Selected: OFF"
            makeUICorner(targetPlayerToggle, 6)
            
            createSectionHeader(RightColumn, "Modifiers")
            
            local ignoreTeamToggle = Instance.new("TextButton", RightColumn)
            ignoreTeamToggle.Size = UDim2.new(1, 0, 0, 28)
            ignoreTeamToggle.Text = "Ignore Team: OFF"
            ignoreTeamToggle.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
            ignoreTeamToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
            ignoreTeamToggle.Font = Enum.Font.Code
            ignoreTeamToggle.TextSize = 15
            makeUICorner(ignoreTeamToggle, 6)
            
            local wallCheckToggle = Instance.new("TextButton", RightColumn)
            wallCheckToggle.Size = UDim2.new(1, 0, 0, 28)
            wallCheckToggle.Text = "Wall Check: ON"
            wallCheckToggle.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
            wallCheckToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
            wallCheckToggle.Font = Enum.Font.Code
            wallCheckToggle.TextSize = 15
            makeUICorner(wallCheckToggle, 6)
            
            statusLabel = Instance.new("TextLabel", StatusBar)
            statusLabel.Size = UDim2.new(1, 0, 0, 18)
            statusLabel.BackgroundTransparency = 1
            statusLabel.TextColor3 = Color3.fromRGB(180, 220, 180)
            statusLabel.Font = Enum.Font.Code
            statusLabel.TextSize = 14
            statusLabel.Text = "Aimbot ready. Hold toggle key to aim."
            statusLabel.TextXAlignment = Enum.TextXAlignment.Left
            
            selectLabel = Instance.new("TextLabel", StatusBar)
            selectLabel.Size = UDim2.new(1, 0, 0, 18)
            selectLabel.BackgroundTransparency = 1
            selectLabel.TextColor3 = Color3.fromRGB(220, 220, 180)
            selectLabel.Font = Enum.Font.Code
            selectLabel.TextSize = 14
            selectLabel.Text = "Press V to delete any block / model under mouse."
            selectLabel.TextXAlignment = Enum.TextXAlignment.Left

            local parts = {"Head", "HumanoidRootPart", "Torso", "UpperTorso", "LowerTorso"}
            local partDropdownOpen, partDropdownFrame = false, nil
            local playerDropdownOpen, playerDropdownFrame = false, nil

            table.insert(janitor, UserInputService.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    if partDropdownOpen and not (input.SourceUserInputProcessor and (input.SourceUserInputProcessor:IsDescendantOf(partDropdownFrame) or input.SourceUserInputProcessor == partDropdown)) then
                        if partDropdownFrame then 
                            partDropdownFrame:Destroy() 
                        end
                        partDropdownOpen = false
                    end
                    
                    if playerDropdownOpen and not (input.SourceUserInputProcessor and (input.SourceUserInputProcessor:IsDescendantOf(playerDropdownFrame) or input.SourceUserInputProcessor == playerDropdown)) then
                        if playerDropdownFrame then 
                            playerDropdownFrame:Destroy() 
                        end
                        playerDropdownOpen = false
                    end
                end
            end))

            table.insert(janitor, partDropdown.MouseButton1Click:Connect(function()
                if partDropdownOpen then 
                    if partDropdownFrame then 
                        partDropdownFrame:Destroy() 
                    end
                    partDropdownOpen = false
                    return 
                end
                
                partDropdownOpen = true
                partDropdownFrame = Instance.new("Frame", AimbotPage)
                
                local absolutePos = partDropdown.AbsolutePosition
                local guiPos = MainWindow.AbsolutePosition
                
                partDropdownFrame.Size = UDim2.new(0, partDropdown.AbsoluteSize.X, 0, #parts * 22)
                partDropdownFrame.Position = UDim2.new(0, absolutePos.X - guiPos.X, 0, absolutePos.Y - guiPos.Y + 22)
                partDropdownFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
                partDropdownFrame.BackgroundTransparency = 0.3
                partDropdownFrame.BorderSizePixel = 0
                partDropdownFrame.ZIndex = 5
                makeUICorner(partDropdownFrame, 6)
                
                local stroke = Instance.new("UIStroke", partDropdownFrame)
                stroke.Color = Color3.fromRGB(80, 80, 90)
                stroke.Thickness = 1
                
                for i, part in ipairs(parts) do 
                    local btn = Instance.new("TextButton", partDropdownFrame)
                    btn.Size = UDim2.new(1, 0, 0, 22)
                    btn.Position = UDim2.new(0, 0, 0, (i - 1) * 22)
                    btn.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
                    btn.TextColor3 = Color3.fromRGB(255, 255, 255)
                    btn.Font = Enum.Font.Code
                    btn.TextSize = 15
                    btn.Text = part
                    makeUICorner(btn, 6)
                    
                    table.insert(janitor, btn.MouseButton1Click:Connect(function() 
                        partDropdown.Text = part
                        if partDropdownFrame then 
                            partDropdownFrame:Destroy() 
                        end
                        partDropdownOpen = false 
                    end))
                end
            end))

            local fovRadius = 75
            local smoothingEnabled = false
            local smoothingFactor = 0.2
            local selectedPlayerTarget, selectedPart = nil, nil
            local playerTargetEnabled = false
            local aiming = false
            local ignoreTeamEnabled = false
            local wallCheckEnabled = true
            local wallCheckParams = RaycastParams.new()
            wallCheckParams.FilterType = Enum.RaycastFilterType.Exclude
            local activeESPs = {}

            local FovCircle = nil
            if Drawing and typeof(Drawing.new) == "function" then 
                FovCircle = Drawing.new("Circle")
                FovCircle.Visible = false
                FovCircle.Thickness = 1
                FovCircle.NumSides = 64
                FovCircle.Color = Color3.fromRGB(255, 255, 255)
                FovCircle.Transparency = 0.5
                FovCircle.Filled = false 
            else 
                warn("Zuka's Log: 'Drawing' library not found. FOV circle visualization will be disabled.") 
            end
            
            local minFov, maxFov = 50, 500
            
            local function updateFovFromHandlePosition() 
                local trackWidth = sliderTrack.AbsoluteSize.X
                local handleX = sliderHandle.Position.X.Offset
                local ratio = math.clamp(handleX / (trackWidth - sliderHandle.AbsoluteSize.X), 0, 1)
                fovRadius = minFov + (maxFov - minFov) * ratio
                fovValueLabel.Text = tostring(math.floor(fovRadius)) .. "px"
                if FovCircle then 
                    FovCircle.Radius = fovRadius 
                end 
            end
            
            local function updateHandleFromFovValue() 
                local trackWidth = sliderTrack.AbsoluteSize.X
                if trackWidth == 0 then 
                    return 
                end
                local ratio = (fovRadius - minFov) / (maxFov - minFov)
                local handleX = ratio * (trackWidth - sliderHandle.AbsoluteSize.X)
                sliderHandle.Position = UDim2.new(0, handleX, 0.5, -6) 
            end
            
            local isDraggingSlider = false
            
            table.insert(janitor, sliderHandle.InputBegan:Connect(function(input) 
                if input.UserInputType == Enum.UserInputType.MouseButton1 then 
                    isDraggingSlider = true 
                end 
            end))
            
            table.insert(janitor, UserInputService.InputEnded:Connect(function(input) 
                if input.UserInputType == Enum.UserInputType.MouseButton1 then 
                    isDraggingSlider = false 
                end 
            end))
            
            table.insert(janitor, UserInputService.InputChanged:Connect(function(input) 
                if isDraggingSlider and input.UserInputType == Enum.UserInputType.MouseMovement then 
                    local mouseX = UserInputService:GetMouseLocation().X
                    local trackStartX = sliderTrack.AbsolutePosition.X
                    local handleWidth = sliderHandle.AbsoluteSize.X
                    local trackWidth = sliderTrack.AbsoluteSize.X
                    local newHandleX = mouseX - trackStartX - (handleWidth / 2)
                    local clampedX = math.clamp(newHandleX, 0, trackWidth - handleWidth)
                    sliderHandle.Position = UDim2.new(0, clampedX, 0.5, -6)
                    updateFovFromHandlePosition() 
                end 
            end))
            
            table.insert(janitor, smoothingToggle.MouseButton1Click:Connect(function() 
                smoothingEnabled = not smoothingEnabled
                smoothingToggle.Text = "Smoothing: " .. (smoothingEnabled and "ON" or "OFF") 
            end))
            
            local minSmooth, maxSmooth = 0.05, 1.0
            
            local function updateSmoothFromHandlePosition() 
                local trackWidth = smoothingSliderTrack.AbsoluteSize.X
                local handleX = smoothingSliderHandle.Position.X.Offset
                local ratio = math.clamp(handleX / (trackWidth - smoothingSliderHandle.AbsoluteSize.X), 0, 1)
                smoothingFactor = minSmooth + (maxSmooth - minSmooth) * ratio
                smoothingValueLabel.Text = string.format("%.2f", smoothingFactor) 
            end
            
            local function updateHandleFromSmoothValue() 
                local trackWidth = smoothingSliderTrack.AbsoluteSize.X
                if trackWidth == 0 then 
                    return 
                end
                local ratio = (smoothingFactor - minSmooth) / (maxSmooth - minSmooth)
                local handleX = ratio * (trackWidth - smoothingSliderHandle.AbsoluteSize.X)
                smoothingSliderHandle.Position = UDim2.new(0, handleX, 0.5, -6) 
            end
            
            local isDraggingSmoothSlider = false
            
            table.insert(janitor, smoothingSliderHandle.InputBegan:Connect(function(input) 
                if input.UserInputType == Enum.UserInputType.MouseButton1 then 
                    isDraggingSmoothSlider = true 
                end 
            end))
            
            table.insert(janitor, UserInputService.InputEnded:Connect(function(input) 
                if input.UserInputType == Enum.UserInputType.MouseButton1 then 
                    isDraggingSmoothSlider = false 
                end 
            end))
            
            table.insert(janitor, UserInputService.InputChanged:Connect(function(input) 
                if isDraggingSmoothSlider and input.UserInputType == Enum.UserInputType.MouseMovement then 
                    local mouseX = UserInputService:GetMouseLocation().X
                    local trackStartX = smoothingSliderTrack.AbsolutePosition.X
                    local handleWidth = smoothingSliderHandle.AbsoluteSize.X
                    local trackWidth = smoothingSliderTrack.AbsoluteSize.X
                    local newHandleX = mouseX - trackStartX - (handleWidth / 2)
                    local clampedX = math.clamp(newHandleX, 0, trackWidth - handleWidth)
                    smoothingSliderHandle.Position = UDim2.new(0, clampedX, 0.5, -6)
                    updateSmoothFromHandlePosition() 
                end 
            end))
            
            task.wait()
            updateHandleFromFovValue()
            updateFovFromHandlePosition()
            updateHandleFromSmoothValue()
            updateSmoothFromHandlePosition()
            
            local function isTeammate(player) 
                if not ignoreTeamEnabled or not player then 
                    return false 
                end
                
                if LocalPlayer.Team and player.Team and LocalPlayer.Team == player.Team then 
                    return true 
                end
                
                if LocalPlayer.TeamColor and player.TeamColor and LocalPlayer.TeamColor == player.TeamColor then 
                    return true 
                end
                
                return false 
            end
            
            local function isPartVisible(targetPart) 
                if not LocalPlayer.Character or not targetPart or not targetPart.Parent then 
                    return false 
                end
                
                local targetCharacter = targetPart:FindFirstAncestorOfClass("Model") or targetPart.Parent
                local origin = Camera.CFrame.Position
                wallCheckParams.FilterDescendantsInstances = {LocalPlayer.Character, targetCharacter}
                local result = Workspace:Raycast(origin, targetPart.Position - origin, wallCheckParams)
                return not result 
            end
            
            local function manageESP(part, color, name) 
                if not part or not part.Parent then 
                    return 
                end
                
                if activeESPs[part] then 
                    activeESPs[part].Color3 = color
                    activeESPs[part].Name = name
                    activeESPs[part].Adornee = part
                    activeESPs[part].Size = part.Size 
                else 
                    local espBox = Instance.new("BoxHandleAdornment")
                    espBox.Name = name
                    espBox.Adornee = part
                    espBox.AlwaysOnTop = true
                    espBox.ZIndex = 10
                    espBox.Size = part.Size
                    espBox.Color3 = color
                    espBox.Transparency = 0.4
                    espBox.Parent = part
                    activeESPs[part] = espBox 
                end 
            end
            
            local function clearESP(part) 
                if part then 
                    if activeESPs[part] then 
                        activeESPs[part]:Destroy()
                        activeESPs[part] = nil 
                    end 
                else 
                    for _, espBox in pairs(activeESPs) do 
                        pcall(function() 
                            espBox:Destroy() 
                        end) 
                    end
                    activeESPs = {} 
                end 
            end
            
            local function getClosestTargetInScope() 
                local mousePos = UserInputService:GetMouseLocation()
                local minDist, closestTargetModel = math.huge, nil
                local aimPartName = partDropdown.Text
                
                for _, model in ipairs(getgenv().TargetIndex) do 
                    if model and model.Parent then 
                        local player = Players:GetPlayerFromCharacter(model)
                        
                        if not (player and player == LocalPlayer) and not (player and isTeammate(player)) then 
                            local targetPart = model:FindFirstChild(aimPartName)
                            
                            if targetPart and (not wallCheckEnabled or isPartVisible(targetPart)) then 
                                local pos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
                                
                                if onScreen then 
                                    local dist = (Vector2.new(pos.X, pos.Y) - mousePos).Magnitude
                                    
                                    if dist < minDist and dist <= fovRadius then 
                                        minDist = dist
                                        closestTargetModel = model 
                                    end 
                                end 
                            end 
                        end 
                    end 
                end
                
                return closestTargetModel 
            end

            local function buildPlayerDropdownFrame()
                if playerDropdownFrame then 
                    playerDropdownFrame:Destroy() 
                end
                
                local playersList = Players:GetPlayers()
                playerDropdownFrame = Instance.new("Frame", AimbotPage)
                
                local absolutePos = playerDropdown.AbsolutePosition
                local guiPos = MainWindow.AbsolutePosition
                
                playerDropdownFrame.Size = UDim2.new(0, playerDropdown.AbsoluteSize.X, 0, #playersList * 22)
                playerDropdownFrame.Position = UDim2.new(0, absolutePos.X - guiPos.X, 0, absolutePos.Y - guiPos.Y + 22)
                playerDropdownFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
                playerDropdownFrame.BackgroundTransparency = 0.2
                playerDropdownFrame.BorderSizePixel = 0
                playerDropdownFrame.ZIndex = 5
                makeUICorner(playerDropdownFrame, 6)
                
                local stroke = Instance.new("UIStroke", playerDropdownFrame)
                stroke.Color = Color3.fromRGB(80, 80, 90)
                stroke.Thickness = 1
                
                for i, plr in ipairs(playersList) do
                    local btn = Instance.new("TextButton", playerDropdownFrame)
                    btn.Size = UDim2.new(1, 0, 0, 22)
                    btn.Position = UDim2.new(0, 0, 0, (i - 1) * 22)
                    btn.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
                    btn.TextColor3 = Color3.fromRGB(255, 255, 255)
                    btn.Font = Enum.Font.Code
                    btn.TextSize = 15
                    btn.Text = plr.Name
                    makeUICorner(btn, 6)
                    
                    table.insert(janitor, btn.MouseButton1Click:Connect(function()
                        selectedPlayerTarget = plr
                        playerDropdown.Text = plr.Name
                        
                        if playerDropdownFrame then 
                            playerDropdownFrame:Destroy() 
                        end
                        
                        playerDropdownOpen = false
                        
                        if playerTargetEnabled then 
                            statusLabel.Text = "Aimbot: Will target " .. plr.Name 
                        end
                    end))
                end
            end

            table.insert(janitor, targetPlayerToggle.MouseButton1Click:Connect(function()
                playerTargetEnabled = not playerTargetEnabled
                targetPlayerToggle.Text = "Target Selected: " .. (playerTargetEnabled and "ON" or "OFF")
                
                if not playerTargetEnabled then 
                    statusLabel.Text = "Aimbot ready. Hold toggle key to aim." 
                elseif selectedPlayerTarget then 
                    statusLabel.Text = "Aimbot: Will target " .. selectedPlayerTarget.Name 
                end
            end))

            table.insert(janitor, playerDropdown.MouseButton1Click:Connect(function()
                if playerDropdownOpen then 
                    if playerDropdownFrame then 
                        playerDropdownFrame:Destroy() 
                    end
                    playerDropdownOpen = false
                    return 
                end
                
                playerDropdownOpen = true
                buildPlayerDropdownFrame()
            end))
            
            table.insert(janitor, Players.PlayerAdded:Connect(function() 
                if playerDropdownOpen then 
                    buildPlayerDropdownFrame() 
                end 
            end))
            
            table.insert(janitor, Players.PlayerRemoving:Connect(function(plr)
                if selectedPlayerTarget == plr then 
                    selectedPlayerTarget = nil
                    playerDropdown.Text = "None"
                    
                    if playerTargetEnabled then 
                        playerTargetEnabled = false
                        targetPlayerToggle.Text = "Target Selected: OFF" 
                    end 
                end
                
                if playerDropdownOpen then 
                    buildPlayerDropdownFrame() 
                end
            end))

            table.insert(janitor, UserInputService.InputBegan:Connect(function(input, processed) 
                if processed or toggleKeyBox:IsFocused() then 
                    return 
                end
                
                if input.KeyCode == Enum.KeyCode.V then 
                    local target = LocalPlayer:GetMouse().Target
                    
                    if target and target.Parent then 
                        local modelAncestor = target:FindFirstAncestorOfClass("Model")
                        
                        if (modelAncestor and modelAncestor == LocalPlayer.Character) or target:IsDescendantOf(LocalPlayer.Character) then 
                            statusLabel.Text = "Cannot delete your own character."
                            return 
                        end
                        
                        if modelAncestor and modelAncestor ~= Workspace then 
                            local modelName = modelAncestor.Name
                            modelAncestor:Destroy()
                            statusLabel.Text = "Deleted model: " .. modelName 
                        else 
                            if target.Parent ~= Workspace then 
                                local targetName = target.Name
                                target:Destroy()
                                statusLabel.Text = "Deleted part: " .. targetName 
                            else 
                                statusLabel.Text = "Cannot delete baseplate or map." 
                            end 
                        end 
                    else 
                        statusLabel.Text = "No target under mouse to delete." 
                    end 
                end
                
                local key = toggleKeyBox.Text:upper()
                
                if (key == "MOUSEBUTTON2" and input.UserInputType == Enum.UserInputType.MouseButton2) or (input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode.Name:upper() == key) then 
                    aiming = true
                    
                    if FovCircle then 
                        FovCircle.Visible = true 
                    end 
                end 
            end))
            
            table.insert(janitor, UserInputService.InputEnded:Connect(function(input) 
                local key = toggleKeyBox.Text:upper()
                
                if (key == "MOUSEBUTTON2" and input.UserInputType == Enum.UserInputType.MouseButton2) or (input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode.Name:upper() == key) then 
                    aiming = false
                    
                    if FovCircle then 
                        FovCircle.Visible = false 
                    end
                    
                    clearESP() 
                end 
            end))

            local currentTarget = nil
            
            table.insert(janitor, RunService.RenderStepped:Connect(function(deltaTime)
                if FovCircle and FovCircle.Visible then 
                    FovCircle.Position = UserInputService:GetMouseLocation() 
                end
                
                local isCurrentTargetValid = currentTarget and currentTarget.Parent and currentTarget:FindFirstChildOfClass("Humanoid") and currentTarget:FindFirstChildOfClass("Humanoid").Health > 0
                
                if aiming and not isCurrentTargetValid then 
                    currentTarget = getClosestTargetInScope() 
                elseif not aiming then 
                    currentTarget = nil 
                end
                
                local aimPart, targetPlayer, targetModel = nil, nil, nil
                local partsToDrawESPFor = {}
                
                if playerTargetEnabled and selectedPlayerTarget and selectedPlayerTarget.Character and selectedPlayerTarget ~= LocalPlayer then
                    if not isTeammate(selectedPlayerTarget) then 
                        targetModel = selectedPlayerTarget.Character
                        targetPlayer = selectedPlayerTarget 
                    else 
                        targetModel = nil 
                    end
                elseif aiming and currentTarget then 
                    targetModel = currentTarget
                    targetPlayer = Players:GetPlayerFromCharacter(targetModel) 
                end
                
                if targetModel then 
                    aimPart = targetModel:FindFirstChild(partDropdown.Text) 
                end
                
                if aiming and aimPart and targetModel then
                    if not wallCheckEnabled or isPartVisible(aimPart) then
                        table.insert(partsToDrawESPFor, {Part = aimPart, Color = Color3.fromRGB(255, 80, 80), Name = "AimbotESP"})
                        
                        local distance = (Camera.CFrame.Position - aimPart.Position).Magnitude
                        local predictionFactor = (distance / 2000) * (1 + (math.random(-50, 50) / 1000))
                        local predictedPosition = aimPart.Position + (aimPart.AssemblyLinearVelocity * predictionFactor)
                        
                        if smoothingEnabled then 
                            local goalCFrame = CFrame.lookAt(Camera.CFrame.Position, predictedPosition)
                            local adjustedSmoothFactor = math.clamp(1 - (1 - smoothingFactor) ^ (60 * deltaTime), 0, 1)
                            Camera.CFrame = Camera.CFrame:Lerp(goalCFrame, adjustedSmoothFactor) 
                        else 
                            Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, predictedPosition) 
                        end
                        
                        statusLabel.Text = "Aimbot: Targeting " .. (targetPlayer and targetPlayer.Name or targetModel.Name)
                    else 
                        statusLabel.Text = "Aimbot: Target is behind a wall"
                        currentTarget = nil 
                    end
                elseif aiming then 
                    statusLabel.Text = "Aimbot: No visible target in index" 
                elseif not aiming then 
                    statusLabel.Text = "Aimbot ready. Hold toggle key to aim." 
                end
                
                for part, espBox in pairs(activeESPs) do 
                    local found = false
                    
                    for _, data in ipairs(partsToDrawESPFor) do 
                        if data.Part == part then 
                            found = true
                            break 
                        end 
                    end
                    
                    if not found or not part.Parent then 
                        clearESP(part) 
                    end 
                end
                
                for _, data in ipairs(partsToDrawESPFor) do 
                    manageESP(data.Part, data.Color, data.Name) 
                end
            end))

            table.insert(janitor, ignoreTeamToggle.MouseButton1Click:Connect(function() 
                ignoreTeamEnabled = not ignoreTeamEnabled
                ignoreTeamToggle.Text = "Ignore Team: " .. (ignoreTeamEnabled and "ON" or "OFF") 
            end))
            
            table.insert(janitor, wallCheckToggle.MouseButton1Click:Connect(function() 
                wallCheckEnabled = not wallCheckEnabled
                wallCheckToggle.Text = "Wall Check: " .. (wallCheckEnabled and "ON" or "OFF") 
            end))

            local indexerUpdateSignal = Instance.new("BindableEvent")
            
            table.insert(janitor, ExplorerButton.MouseButton1Click:Connect(function() 
                createExplorerWindow(statusLabel, indexerUpdateSignal) 
            end))
            
            task.spawn(function()
                local function RebuildTargetIndex()
                    local newIndex = {}
                    
                    if not getgenv().TargetScope or not getgenv().TargetScope.Parent then 
                        getgenv().TargetScope = Workspace 
                    end
                    
                    for _, descendant in ipairs(getgenv().TargetScope:GetDescendants()) do 
                        if descendant:IsA("Model") and descendant:FindFirstChildOfClass("Humanoid") then 
                            table.insert(newIndex, descendant) 
                        end 
                    end
                    
                    getgenv().TargetIndex = newIndex
                end
                
                table.insert(janitor, indexerUpdateSignal.Event:Connect(RebuildTargetIndex))
                
                while task.wait(2) and MainScreenGui.Parent do 
                    RebuildTargetIndex() 
                end
            end)
            
            indexerUpdateSignal:Fire()

            if args and args[1] then
                task.wait(0.1)
                local targetName = args[1]
                
                if targetName:lower() == "clear" or targetName:lower() == "reset" or targetName:lower() == "off" then
                    playerTargetEnabled = false
                    selectedPlayerTarget = nil
                    targetPlayerToggle.Text = "Target Selected: OFF"
                    playerDropdown.Text = "None"
                    statusLabel.Text = "Aimbot ready. Hold toggle key to aim."
                    DoNotif("Aimbot target lock cleared.", 2)
                else
                    local foundPlayer = Utilities.findPlayer(targetName)
                    
                    if foundPlayer then
                        playerTargetEnabled = true
                        selectedPlayerTarget = foundPlayer
                        targetPlayerToggle.Text = "Target Selected: ON"
                        playerDropdown.Text = foundPlayer.Name
                        statusLabel.Text = "Aimbot: Will target " .. foundPlayer.Name
                        DoNotif("Aimbot locked onto target: " .. foundPlayer.Name, 3)
                    else
                        DoNotif("Target player '" .. targetName .. "' not found.", 3)
                    end
                end
            end
        end
    end)

    if not success then
        warn("Failed to load Aimbot GUI:", err)
        if DoNotif then 
            DoNotif("Error loading Aimbot: " .. tostring(err), 5) 
        end
        local gui = CoreGui:FindFirstChild("UTS_CGE_Suite")
        if gui then 
            gui:Destroy() 
        end
    end
end

RegisterCommand({
    Name = "aimbot",
    Aliases = {},
    Description = "Loads the aimbot GUI. Optional: [player name] to lock target."
}, function(args)
    if not game:GetService("CoreGui"):FindFirstChild("UTS_CGE_Suite") then
        loadAimbotGUI(args)
    else
        if args and args[1] then
            DoNotif("Aimbot is already open. Re-open to set a command-line target.", 4)
        else
            DoNotif("Aimbot GUI is already open.", 2)
        end
    end
end)

Modules.Performance = {
    State = {
        IsEnabled = false,
        OriginalProperties = {}
    }
}
function Modules.Performance:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    self.State.OriginalProperties = {}
    local lighting = game:GetService("Lighting")
    local terrain = Workspace:FindFirstChildOfClass("Terrain")
    local materialService = game:GetService("MaterialService")
    self.State.OriginalProperties.Lighting = {
        Technology = lighting.Technology,
        GlobalShadows = lighting.GlobalShadows,
        EnvironmentDiffuseScale = lighting.EnvironmentDiffuseScale,
        EnvironmentSpecularScale = lighting.EnvironmentSpecularScale
    }
    lighting.Technology = Enum.Technology.Compatibility
    lighting.GlobalShadows = false
    lighting.EnvironmentDiffuseScale = 0
    lighting.EnvironmentSpecularScale = 0
    if terrain then
        self.State.OriginalProperties.Terrain = {
            Decoration = terrain.Decoration
        }
        terrain.Decoration = false
    end
    self.State.OriginalProperties.MaterialService = {
        MaterialQuality = materialService.MaterialQuality
    }
    materialService.MaterialQuality = Enum.MaterialQuality.Low
	self.State.OriginalProperties.LightingEffects = {}
	for _, effect in ipairs(lighting:GetChildren()) do
		if effect:IsA("Atmosphere") or effect:IsA("Clouds") or effect:IsA("BloomEffect") or effect:IsA("BlurEffect") then
			self.State.OriginalProperties.LightingEffects[effect] = {
				Enabled = effect.Enabled
			}
			effect.Enabled = false
		end
	end
    DoNotif("Performance Mode: ENABLED. Shadows and effects disabled.", 2)
end
function Modules.Performance:Disable()
    if not self.State.IsEnabled then return end
    self.State.IsEnabled = false
    local lighting = game:GetService("Lighting")
    local terrain = Workspace:FindFirstChildOfClass("Terrain")
    local materialService = game:GetService("MaterialService")
    if self.State.OriginalProperties.Lighting then
        for prop, value in pairs(self.State.OriginalProperties.Lighting) do
            pcall(function() lighting[prop] = value end)
        end
    end
    if terrain and self.State.OriginalProperties.Terrain then
        for prop, value in pairs(self.State.OriginalProperties.Terrain) do
            pcall(function() terrain[prop] = value end)
        end
    end
    if self.State.OriginalProperties.MaterialService then
        for prop, value in pairs(self.State.OriginalProperties.MaterialService) do
            pcall(function() materialService[prop] = value end)
        end
    end
	if self.State.OriginalProperties.LightingEffects then
		for effect, props in pairs(self.State.OriginalProperties.LightingEffects) do
			if effect and effect.Parent then
				pcall(function() effect.Enabled = props.Enabled end)
			end
		end
	end
    self.State.OriginalProperties = {}
    DoNotif("Performance Mode: DISABLED. Graphics restored.", 2)
end
function Modules.Performance:Toggle()
    if self.State.IsEnabled then
        self:Disable()
    else
        self:Enable()
    end
end
RegisterCommand({ Name = "fpsboost", Aliases = { "noshadows", "performance" }, Description = "Toggles performance mode by disabling shadows and other intensive graphical features." }, function()
    Modules.Performance:Toggle()
end)
Modules.AstralProjection = {
    State = {
        isProjecting = false,
        isSpawning = false,
        originalHRP = nil,
        originalParent = nil,
        deathConnection = nil,
        positionMarker = nil
    },
    Config = {
        TOGGLE_KEY = Enum.KeyCode.End,
        SPAWN_PROTECTION_DURATION = 2
    },
    GUI = {},
    Services = {}
}
function Modules.AstralProjection:_makeDraggable(guiObject)
    local UIS = self.Services.UserInputService
    local dragging = false
    local dragStart
    local startPos
    local function update(input)
        local delta = input.Position - dragStart
        guiObject.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset + delta.Y
        )
    end
    guiObject.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1
        or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = guiObject.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    guiObject.InputChanged:Connect(function(input)
        if dragging and (
            input.UserInputType == Enum.UserInputType.MouseMovement
            or input.UserInputType == Enum.UserInputType.Touch
        ) then
            update(input)
        end
    end)
end
function Modules.AstralProjection:_updateUIState()
    local button = self.GUI.astralButton
    if not button then return end
    if self.State.isSpawning then
        button.BackgroundColor3 = Color3.fromRGB(255, 160, 0)
        button.TextColor3 = Color3.fromRGB(255, 255, 255)
    elseif self.State.isProjecting then
        button.BackgroundColor3 = Color3.fromRGB(0, 200, 255)
        button.TextColor3 = Color3.fromRGB(10, 10, 10)
    else
        button.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
        button.TextColor3 = Color3.fromRGB(200, 200, 220)
    end
end
function Modules.AstralProjection:_applyVisuals(character, isAstral)
    local highlight = character:FindFirstChild("AstralHighlight")
    if isAstral and not highlight then
        highlight = Instance.new("Highlight", character)
        highlight.Name = "AstralHighlight"
        highlight.FillColor = Color3.fromRGB(0, 200, 255)
        highlight.OutlineColor = Color3.fromRGB(200, 255, 255)
        highlight.FillTransparency = 0.5
    elseif not isAstral and highlight then
        highlight:Destroy()
    end
end
function Modules.AstralProjection:_setState(shouldProject)
    if self.State.isSpawning then return end
    if self.State.isProjecting == shouldProject then return end
    local character = self.Services.LocalPlayer.Character
    if not character then return end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if shouldProject then
        if not hrp or not humanoid or not hrp.Parent then return end
        self.State.originalHRP = hrp
        self.State.originalParent = character
        local originalCFrame = hrp.CFrame
        hrp.Parent = nil
        self.State.isProjecting = true
        if self.State.positionMarker then
            self.State.positionMarker:Destroy()
        end
        local marker = Instance.new("Part")
        marker.Name = "PhysicalAnchor"
        marker.Size = Vector3.new(4, 5, 2)
        marker.CFrame = originalCFrame
        marker.Anchored = true
        marker.CanCollide = false
        marker.Transparency = 0.7
        marker.Parent = self.Services.Workspace
        self.State.positionMarker = marker
        local highlight = Instance.new("Highlight", marker)
        highlight.FillColor = Color3.fromRGB(255, 50, 50)
        highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
        highlight.FillTransparency = 0.6
        humanoid:ChangeState(Enum.HumanoidStateType.Running)
        self:_applyVisuals(character, true)
        DoNotif("Desync: ENABLED", 1.5)
    else
        if not self.State.originalHRP or not self.State.originalParent then
            self.State.isProjecting = false
            return
        end
        if self.State.positionMarker then
            self.State.positionMarker:Destroy()
            self.State.positionMarker = nil
        end
        self.State.originalHRP.Parent = self.State.originalParent
        self.State.originalHRP = nil
        self.State.originalParent = nil
        self.State.isProjecting = false
        self:_applyVisuals(character, false)
        DoNotif("Desync: DISABLED", 1.5)
    end
    self:_updateUIState()
end
function Modules.AstralProjection:_onDied()
    self:_setState(false)
end
function Modules.AstralProjection:_onCharacterAdded(character)
    self.State.isSpawning = true
    self:_updateUIState()
    if self.State.isProjecting then
        self:_setState(false)
    end
    if self.State.deathConnection then
        self.State.deathConnection:Disconnect()
    end
    local humanoid = character:WaitForChild("Humanoid")
    self.State.deathConnection = humanoid.Died:Connect(function()
        self:_onDied()
    end)
    task.wait(self.Config.SPAWN_PROTECTION_DURATION)
    self.State.isSpawning = false
    self:_updateUIState()
end
function Modules.AstralProjection:Toggle()
    self:_setState(not self.State.isProjecting)
end
function Modules.AstralProjection:Initialize()
    self.Services.Players = game:GetService("Players")
    self.Services.UserInputService = game:GetService("UserInputService")
    self.Services.Workspace = game:GetService("Workspace")
    self.Services.LocalPlayer = self.Services.Players.LocalPlayer
    local PLAYER_GUI = self.Services.LocalPlayer:WaitForChild("PlayerGui")
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "AstralStatusGUI_V2"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = PLAYER_GUI
    self.GUI.screenGui = screenGui
    local astralButton = Instance.new("TextButton")
    astralButton.Name = "AstralToggleButton"
    astralButton.Size = UDim2.fromOffset(64, 64)
    astralButton.AnchorPoint = Vector2.new(1, 1)
    astralButton.Position = UDim2.new(1, -20, 1, -100)
    astralButton.Font = Enum.Font.GothamBold
    astralButton.Text = "DSYNC"
    astralButton.TextSize = 14
    astralButton.Parent = screenGui
    Instance.new("UICorner", astralButton).CornerRadius = UDim.new(1, 0)
    local stroke = Instance.new("UIStroke", astralButton)
    stroke.Color = Color3.fromRGB(100, 100, 120)
    stroke.Thickness = 1.5
    self.GUI.astralButton = astralButton
    self:_updateUIState()
    self:_makeDraggable(astralButton)
    astralButton.MouseButton1Click:Connect(function()
        self:Toggle()
    end)
    self.Services.UserInputService.InputBegan:Connect(function(input, gp)
        if gp then return end
        if input.KeyCode == self.Config.TOGGLE_KEY then
            self:Toggle()
        end
    end)
    if self.Services.LocalPlayer.Character then
        self:_onCharacterAdded(self.Services.LocalPlayer.Character)
    end
    self.Services.LocalPlayer.CharacterAdded:Connect(function(character)
        self:_onCharacterAdded(character)
    end)
end
RegisterCommand({
    Name = "desyn",
    Aliases = {},
    Description = "Toggles desync, remaining invisible to others."
}, function()
    Modules.AstralProjection:Toggle()
end)
Modules.AnchorSelf = {
    State = {
        IsEnabled = false,
        CharacterAddedConnection = nil
    }
}
function Modules.AnchorSelf:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    local function applyAnchor(character)
        if not character then return end
        local hrp = character:WaitForChild("HumanoidRootPart", 2)
        if hrp then
            hrp.Anchored = true
        end
    end
    if LocalPlayer.Character then
        applyAnchor(LocalPlayer.Character)
    end
    self.State.CharacterAddedConnection = LocalPlayer.CharacterAdded:Connect(applyAnchor)
    DoNotif("Self Anchor: ENABLED.", 2)
end
function Modules.AnchorSelf:Disable()
    if not self.State.IsEnabled then return end
    self.State.IsEnabled = false
    if LocalPlayer.Character then
        local hrp = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            hrp.Anchored = false
        end
    end
    if self.State.CharacterAddedConnection then
        self.State.CharacterAddedConnection:Disconnect()
        self.State.CharacterAddedConnection = nil
    end
    DoNotif("Self Anchor: DISABLED.", 2)
end
function Modules.AnchorSelf:Toggle()
    if self.State.IsEnabled then
        self:Disable()
    else
        self:Enable()
    end
end
RegisterCommand({ Name = "anchor", Aliases = { "lock", "lockpos" }, Description = "Toggles anchoring your character in place." }, function()
    Modules.AnchorSelf:Toggle()
end)
Modules.AutoComplete = {};
function Modules.AutoComplete:GetMatches(prefix)
    local matches = {}
    if typeof(prefix) ~= "string" or #prefix == 0 then return matches end
        prefix = prefix:lower()
        for cmdName, _ in pairs(Commands) do
            if cmdName:sub(1, #prefix) == prefix then
                table.insert(matches, cmdName)
            end
        end
        table.sort(matches)
        return matches
    end
Modules.CommandList = {
    State = {
        UI = nil,
        IsEnabled = false,
        IsMinimized = false,
        IsAnimating = false,
    },
}
function Modules.CommandList:Initialize()
    local self = self
    local ui = Instance.new("ScreenGui")
    ui.Name = "CommandListUI_v7_Radiant"
    ui.ResetOnSpawn = false
    ui.ZIndexBehavior = Enum.ZIndexBehavior.Global
    ui.Enabled = false
    self.State.UI = ui
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.fromOffset(450, 350)
    mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    mainFrame.Position = UDim2.fromScale(0.5, 0.5)
    mainFrame.BackgroundColor3 = Color3.fromRGB(34, 32, 38)
    mainFrame.BackgroundTransparency = 0.1
    mainFrame.BorderSizePixel = 0
    mainFrame.ClipsDescendants = true
    mainFrame.Parent = ui
    Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 8)
    local uiStroke = Instance.new("UIStroke", mainFrame)
    uiStroke.Color = Color3.fromRGB(255, 105, 180)
    uiStroke.Thickness = 2
    local glowConnection
    glowConnection = RunService.RenderStepped:Connect(function()
        if not (uiStroke and uiStroke.Parent) then
            glowConnection:Disconnect()
            return
        end
        local sine = math.sin(os.clock() * 4)
        uiStroke.Thickness = 2 + (sine * 0.5)
        uiStroke.Transparency = 0.3 + (sine * 0.2)
    end)
    local canvasGroup = Instance.new("CanvasGroup", mainFrame)
    canvasGroup.Name = "Canvas"
    canvasGroup.Size = UDim2.fromScale(1, 1)
    canvasGroup.BackgroundTransparency = 1
    canvasGroup.GroupTransparency = 1
    local title = Instance.new("TextLabel", canvasGroup)
    title.Name = "Title"
    title.Size = UDim2.new(1, 0, 0, 40)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.GothamSemibold
    title.Text = "Command List"
    title.TextColor3 = Color3.fromRGB(255, 182, 193)
    title.TextSize = 20
    local closeButton = Instance.new("TextButton", canvasGroup)
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.fromOffset(25, 25)
    closeButton.AnchorPoint = Vector2.new(1, 0)
    closeButton.Position = UDim2.new(1, -10, 0, 10)
    closeButton.BackgroundTransparency = 1
    closeButton.Font = Enum.Font.GothamBold
    closeButton.Text = "X"
    closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeButton.TextSize = 20
    closeButton.MouseButton1Click:Connect(function() self:Toggle() end)
    local minimizeButton = Instance.new("TextButton", canvasGroup)
    minimizeButton.Name = "MinimizeButton"
    minimizeButton.Size = UDim2.fromOffset(25, 25)
    minimizeButton.AnchorPoint = Vector2.new(1, 0)
    minimizeButton.Position = UDim2.new(1, -40, 0, 10)
    minimizeButton.BackgroundTransparency = 1
    minimizeButton.Font = Enum.Font.GothamBold
    minimizeButton.Text = "-"
    minimizeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    minimizeButton.TextSize = 24
    local scrollingFrame = Instance.new("ScrollingFrame", canvasGroup)
    scrollingFrame.Name = "ScrollingFrame"
    scrollingFrame.Size = UDim2.new(1, -20, 1, -50)
    scrollingFrame.Position = UDim2.fromOffset(10, 40)
    scrollingFrame.BackgroundTransparency = 1
    scrollingFrame.BorderSizePixel = 0
    scrollingFrame.ScrollBarThickness = 6
    scrollingFrame.ScrollBarImageColor3 = Color3.fromRGB(255, 105, 180)
    local listLayout = Instance.new("UIListLayout", scrollingFrame)
    listLayout.Padding = UDim.new(0, 5)
    local function drag(input)
        local dragStart = input.Position
        local startPos = mainFrame.Position
        local moveConn, endConn
        moveConn = UserInputService.InputChanged:Connect(function(moveInput)
            if moveInput.UserInputType == Enum.UserInputType.MouseMovement then
                local delta = moveInput.Position - dragStart
                mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
            end
        end)
        endConn = UserInputService.InputEnded:Connect(function(endInput)
            if endInput.UserInputType == Enum.UserInputType.MouseButton1 then
                moveConn:Disconnect()
                endConn:Disconnect()
            end
        end)
    end
    title.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then drag(input) end
    end)
    local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    minimizeButton.MouseButton1Click:Connect(function()
        self.State.IsMinimized = not self.State.IsMinimized
        local goalSize
        if self.State.IsMinimized then
            goalSize = UDim2.fromOffset(mainFrame.AbsoluteSize.X, 40)
            minimizeButton.Text = "+"
            scrollingFrame.Visible = false
        else
            goalSize = UDim2.fromOffset(mainFrame.AbsoluteSize.X, 350)
            minimizeButton.Text = "-"
            scrollingFrame.Visible = true
        end
        TweenService:Create(mainFrame, tweenInfo, { Size = goalSize }):Play()
    end)
    ui.Parent = CoreGui
end
function Modules.CommandList:Populate()
    local scrollingFrame = self.State.UI.MainFrame.Canvas:FindFirstChild("ScrollingFrame")
    if not scrollingFrame then return end
    scrollingFrame:ClearAllChildren()
    local listLayout = Instance.new("UIListLayout", scrollingFrame)
    listLayout.Padding = UDim.new(0, 8)
    listLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        scrollingFrame.CanvasSize = UDim2.fromOffset(0, listLayout.AbsoluteContentSize.Y)
    end)
    table.sort(CommandInfo, function(a, b) return a.Name < b.Name end)
    for _, info in ipairs(CommandInfo) do
        local entryFrame = Instance.new("Frame")
        entryFrame.Name = info.Name .. "_Entry"
        entryFrame.BackgroundTransparency = 0.8
        entryFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
        entryFrame.Size = UDim2.new(1, 0, 0, 0)
        entryFrame.AutomaticSize = Enum.AutomaticSize.Y
        entryFrame.Parent = scrollingFrame
        Instance.new("UICorner", entryFrame).CornerRadius = UDim.new(0, 6)
        local frameLayout = Instance.new("UIListLayout", entryFrame)
        frameLayout.Padding = UDim.new(0, 5)
        local framePadding = Instance.new("UIPadding", entryFrame)
        framePadding.PaddingLeft = UDim.new(0, 10)
        framePadding.PaddingRight = UDim.new(0, 10)
        framePadding.PaddingTop = UDim.new(0, 8)
        framePadding.PaddingBottom = UDim.new(0, 8)
        local entry = Instance.new("TextLabel")
        entry.Name = info.Name
        entry.Size = UDim2.new(1, 0, 0, 0)
        entry.AutomaticSize = Enum.AutomaticSize.Y
        entry.BackgroundTransparency = 1
        entry.Font = Enum.Font.Gotham
        entry.TextSize = 15
        entry.RichText = true
        entry.TextXAlignment = Enum.TextXAlignment.Left
        entry.TextWrapped = true
        entry.Parent = entryFrame
        local aliases = ""
        if info.Aliases and #info.Aliases > 0 then
            aliases = string.format("<font size='12' color='#AAAAAA'><i>(%s)</i></font>", table.concat(info.Aliases, ", "))
        end
        local description = info.Description or "No description provided."
        entry.Text = string.format(
            "<font face='GothamBold' color='#FF69B4'>;%s</font> %s\n<font face='Gotham' size='13' color='#E0E0E0'>  %s</font>",
            info.Name,
            aliases,
            description
        )
    end
end
function Modules.CommandList:Toggle()
    if self.State.IsAnimating then return end
    self.State.IsAnimating = true
    self.State.IsEnabled = not self.State.IsEnabled
    local mainFrame = self.State.UI.MainFrame
    local canvasGroup = mainFrame.Canvas
    local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quint, Enum.EasingDirection.Out)
    if self.State.IsEnabled then
        self.State.UI.Enabled = true
        if self.State.IsMinimized then
            self.State.IsMinimized = false
            mainFrame.Size = UDim2.fromOffset(450, 350)
            mainFrame.Canvas.ScrollingFrame.Visible = true
            mainFrame.Canvas.MinimizeButton.Text = "-"
        end
        self:Populate()
        mainFrame.Size = UDim2.fromOffset(450, 320)
        canvasGroup.GroupTransparency = 1
        local sizeAnim = TweenService:Create(mainFrame, tweenInfo, { Size = UDim2.fromOffset(450, 350) })
        local fadeAnim = TweenService:Create(canvasGroup, tweenInfo, { GroupTransparency = 0 })
        sizeAnim:Play()
        fadeAnim:Play()
        fadeAnim.Completed:Connect(function() self.State.IsAnimating = false end)
    else
        local sizeAnim = TweenService:Create(mainFrame, tweenInfo, { Size = UDim2.fromOffset(450, 320) })
        local fadeAnim = TweenService:Create(canvasGroup, tweenInfo, { GroupTransparency = 1 })
        sizeAnim:Play()
        fadeAnim:Play()
        fadeAnim.Completed:Connect(function()
            self.State.UI.Enabled = false
            self.State.IsAnimating = false
        end)
    end
end
Modules.CommandBar = {
    State = {
        UI = nil,
        Container = nil,
        TextBox = nil,
        LogFrame = nil,
        SuggestionLabel = nil,
        PrefixKey = Enum.KeyCode.Semicolon,
        IsAnimating = false,
        IsEnabled = false,
        MaxLogs = 900,
        CurrentSuggestion = "",
        MinSize = Vector2.new(400, 250),
        SelectionStart = nil,
        SelectionEnd = nil,
        IsSelecting = false,
        IsMinimized = false,
        IsMaximized = false,
        PreMaximizeSize = nil,
        PreMaximizePosition = nil
    },
    Theme = {
        Background = Color3.fromRGB(0, 0, 0),
        WindowGray = Color3.fromRGB(192, 192, 192),
        DarkGray = Color3.fromRGB(128, 128, 128),
        LightGray = Color3.fromRGB(223, 223, 223),
        White = Color3.fromRGB(255, 255, 255),
        Blue = Color3.fromRGB(0, 0, 128),
        Accent = Color3.fromRGB(0, 255, 0),
        Text = Color3.fromRGB(192, 192, 192),
        Suggestion = Color3.fromRGB(0, 128, 0),
        Font = Enum.Font.Code
    },
    Dependencies = {"UserInputService", "TweenService", "SoundService"},
    Scanner = {
        FoundModules = {},
        ScanInProgress = false,
        PoisonedModules = {},
        Poisons = {
            inventory = {
                Name = "Inventory Poison",
                Description = "Item duplication, unlimited stacks, stat modification",
                Target = {"inventory", "backpack", "storage", "container", "bag"},
                Applied = false
            },
            damage = {
                Name = "Damage Poison",
                Description = "Damage multipliers, invincibility, one-shot kills",
                Target = {"damage", "combat", "attack", "health"},
                Applied = false
            },
            movement = {
                Name = "Movement Poison",
                Description = "Speed hacks, flight, teleportation, no-clip",
                Target = {"movement", "walkspeed", "character", "humanoid"},
                Applied = false
            },
            currency = {
                Name = "Economy Poison",
                Description = "Money multipliers, free purchases, XP boosts",
                Target = {"currency", "money", "cash", "coins", "shop", "store"},
                Applied = false
            },
            weapon = {
                Name = "Weapon Poison",
                Description = "Infinite ammo, no recoil, auto-aim, damage boost",
                Target = {"weapon", "gun", "tool", "equipment"},
                Applied = false
            }
        }
    }
}
function SafeRequire(module)
    local success, result = pcall(require, module)
    if success then
        return result
    end
    return nil
end
function Modules.CommandBar:PlayBeep(): ()
    local beep = Instance.new("Sound")
    beep.SoundId = "rbxasset://sounds/electronicpingshort.wav"
    beep.Volume = 0.5
    beep.Parent = game:GetService("SoundService")
    beep:Play()
    beep.Ended:Connect(function() beep:Destroy() end)
end
function Modules.CommandBar:CopyOutputToClipboard(): ()
    if not self.State.LogFrame then return end
    local allText: string = ""
    local children: {Instance} = self.State.LogFrame:GetChildren()
    for _, child in ipairs(children) do
        if child:IsA("TextLabel") then
            allText = allText .. child.Text .. "\n"
        end
    end
    setclipboard(allText)
end
function Modules.CommandBar:CopySelectedText(): ()
    if not self.State.LogFrame then return end
    if self.State.TextBox.Text ~= "" then
        setclipboard(self.State.TextBox.Text)
        return
    end
    if self.State.SelectionStart and self.State.SelectionEnd then
        local children: {Instance} = self.State.LogFrame:GetChildren()
        local selectedText: string = ""
        local startIdx = math.min(self.State.SelectionStart, self.State.SelectionEnd)
        local endIdx = math.max(self.State.SelectionStart, self.State.SelectionEnd)
        for i = startIdx, endIdx do
            if children[i] and children[i]:IsA("TextLabel") then
                selectedText = selectedText .. children[i].Text .. "\n"
            end
        end
        if selectedText ~= "" then
            setclipboard(selectedText)
            return
        end
    end
    self:CopyOutputToClipboard()
end
function Modules.CommandBar:Minimize(): ()
    if self.State.IsMinimized then return end
    self.State.IsMinimized = true
    local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local tween = TweenService:Create(self.State.Container, tweenInfo, {
        Position = UDim2.new(0.5, -self.State.Container.Size.X.Offset/2, 1, 50),
        Size = UDim2.new(0, self.State.Container.Size.X.Offset, 0, 30)
    })
    tween:Play()
end
function Modules.CommandBar:Restore(): ()
    if not self.State.IsMinimized then return end
    self.State.IsMinimized = false
    local targetSize = self.State.PreMaximizeSize or UDim2.new(0, 600, 0, 400)
    local targetPos = self.State.PreMaximizePosition or UDim2.new(0.5, -300, 0.5, -200)
    local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local tween = TweenService:Create(self.State.Container, tweenInfo, {
        Position = targetPos,
        Size = targetSize
    })
    tween:Play()
end
function Modules.CommandBar:Maximize(): ()
    if self.State.IsMaximized then
        self.State.IsMaximized = false
        local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = TweenService:Create(self.State.Container, tweenInfo, {
            Position = self.State.PreMaximizePosition,
            Size = self.State.PreMaximizeSize
        })
        tween:Play()
    else
        self.State.PreMaximizeSize = self.State.Container.Size
        self.State.PreMaximizePosition = self.State.Container.Position
        self.State.IsMaximized = true
        local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = TweenService:Create(self.State.Container, tweenInfo, {
            Position = UDim2.new(0, 0, 0, 0),
            Size = UDim2.new(1, 0, 1, 0)
        })
        tween:Play()
    end
end
function Modules.CommandBar:Toggle(): ()
    if self.State.IsAnimating then return end
    self.State.IsAnimating = true
    self.State.IsEnabled = not self.State.IsEnabled
    local isOpening: boolean = self.State.IsEnabled
    local tweenInfo: TweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
    if isOpening then
        self.State.UI.Enabled = true
        local goalPosition: UDim2 = UDim2.new(0.5, -self.State.Container.Size.X.Offset/2, 0.5, -self.State.Container.Size.Y.Offset/2)
        local anim = TweenService:Create(self.State.Container, tweenInfo, {
            Position = goalPosition,
            BackgroundTransparency = 0
        })
        anim:Play()
        self.State.TextBox:CaptureFocus()
        task.spawn(function()
            task.wait()
            if self.State.IsEnabled then
                self.State.TextBox.Text = ""
                self.State.SuggestionLabel.Text = ""
                self.State.CurrentSuggestion = ""
            end
        end)
        anim.Completed:Connect(function() self.State.IsAnimating = false end)
    else
        self.State.TextBox:ReleaseFocus()
        local anim = TweenService:Create(self.State.Container, tweenInfo, {
            Position = UDim2.new(0.5, -self.State.Container.Size.X.Offset/2, 1, 50),
            BackgroundTransparency = 1
        })
        anim:Play()
        anim.Completed:Connect(function()
            self.State.UI.Enabled = false
            self.State.IsAnimating = false
        end)
    end
end
function Modules.CommandBar:AddOutput(text: string, color: Color3?): ()
    if not self.State.LogFrame then return end
    local line: TextLabel = Instance.new("TextLabel")
    line.Name = "TerminalLine"
    line.Parent = self.State.LogFrame
    line.BackgroundTransparency = 1
    line.Size = UDim2.new(1, -15, 0, 0)
    line.AutomaticSize = Enum.AutomaticSize.Y
    line.Font = self.Theme.Font
    line.Text = text
    line.TextColor3 = color or self.Theme.Accent
    line.TextSize = 14
    line.TextXAlignment = Enum.TextXAlignment.Left
    line.RichText = true
    line.TextWrapped = true
    local children: {Instance} = self.State.LogFrame:GetChildren()
    if #children > self.State.MaxLogs then
        for i = 1, (#children - self.State.MaxLogs) do
            if children[i]:IsA("TextLabel") then children[i]:Destroy() end
        end
    end
    task.defer(function()
        if self.State.LogFrame then
            self.State.LogFrame.CanvasPosition = Vector2.new(0, self.State.LogFrame.AbsoluteCanvasSize.Y)
        end
    end)
end
function Modules.CommandBar:ListCommands(): ()
    self:AddOutput("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•", self.Theme.Accent)
    self:AddOutput("Zuka-Tech Version 13.77 (C)Copyright Microslop Corp 1981-1994.", self.Theme.Text)
    self:AddOutput("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•", self.Theme.Accent)
    self:AddOutput("")
    local sorted: {any} = {}
    for _, info in ipairs(CommandInfo) do
        table.insert(sorted, info)
    end
    table.sort(sorted, function(a, b) return a.Name < b.Name end)
    for _, info in ipairs(sorted) do
        local aliasStr: string = ""
        if info.Aliases and #info.Aliases > 0 then
            aliasStr = " [" .. table.concat(info.Aliases, ", ") .. "]"
        end
        local desc: string = info.Description or "No description"
        self:AddOutput(string.format("%s%s", info.Name:upper(), aliasStr), self.Theme.Accent)
        self:AddOutput("  " .. desc, self.Theme.Text)
    end
    self:AddOutput("")
    self:AddOutput("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•", self.Theme.Accent)
    self:AddOutput(#sorted .. " command(s) available.", self.Theme.Text)
end
function Modules.CommandBar:UpdateSuggestions(): ()
    local input: string = self.State.TextBox.Text:lower()
    if input == "" then
        self.State.SuggestionLabel.Text = ""
        self.State.CurrentSuggestion = ""
        return
    end
    local match: string = ""
    for cmdName, _ in pairs(Commands) do
        if cmdName:lower():sub(1, #input) == input then
            match = cmdName:lower()
            break
        end
    end
    if match ~= "" then
        self.State.CurrentSuggestion = match
        self.State.SuggestionLabel.Text = match
    else
        self.State.CurrentSuggestion = ""
        self.State.SuggestionLabel.Text = ""
    end
end
function Modules.CommandBar:StartScan(): ()
    if self.Scanner.ScanInProgress then
        self:AddOutput("WARNING: Scan already in progress!", Color3.fromRGB(255, 255, 0))
        self:PlayBeep()
        return
    end
    self.Scanner.ScanInProgress = true
    self.Scanner.FoundModules = {}
    self:AddOutput("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•", self.Theme.Accent)
    self:AddOutput("INITIATING MODULE SCAN...", self.Theme.Text)
    self:AddOutput("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•", self.Theme.Accent)
    self:AddOutput("")
    task.spawn(function()
        self:ScanForModules()
        self.Scanner.ScanInProgress = false
        self:AddOutput("")
        self:AddOutput("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•", self.Theme.Accent)
        self:AddOutput(string.format("SCAN COMPLETE - Found %d modules", #self.Scanner.FoundModules), self.Theme.Accent)
        self:AddOutput("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•", self.Theme.Accent)
        self:AddOutput("")
    end)
end
function Modules.CommandBar:ScanForModules(): ()
    local locations = {
        {game:GetService("ReplicatedStorage"), "ReplicatedStorage"},
        {game:GetService("ReplicatedFirst"), "ReplicatedFirst"},
    }
    local success, starterPlayer = pcall(function()
        return game:GetService("StarterPlayer"):WaitForChild("StarterPlayerScripts", 2)
    end)
    if success and starterPlayer then
        table.insert(locations, {starterPlayer, "StarterPlayerScripts"})
    end
    local foundCount = 0
    for _, locationData in pairs(locations) do
        local location, name = locationData[1], locationData[2]
        self:AddOutput(string.format("Scanning: %s", name), self.Theme.Text)
        local modules = {}
        for _, obj in pairs(location:GetDescendants()) do
            if obj:IsA("ModuleScript") then
                table.insert(modules, obj)
            end
        end
        self:AddOutput(string.format("  Found %d ModuleScripts", #modules), self.Theme.Text)
        for _, module in pairs(modules) do
            foundCount = foundCount + 1
            local moduleName = module.Name:lower()
            local path = module:GetFullName()
            local category = "unknown"
            local poisonType = nil
            for pType, pData in pairs(self.Scanner.Poisons) do
                for _, keyword in pairs(pData.Target) do
                    if moduleName:match(keyword) then
                        category = pType
                        poisonType = pData
                        break
                    end
                end
                if poisonType then break end
            end
            local moduleData = {
                Module = module,
                Name = module.Name,
                Path = path,
                Category = category,
                Poison = poisonType,
                Index = foundCount
            }
            table.insert(self.Scanner.FoundModules, moduleData)
            if category ~= "unknown" then
                self:AddOutput(string.format("  [%d] [%s] %s", foundCount, category:upper(), module.Name), self.Theme.Accent)
            else
                self:AddOutput(string.format("  [%d] [UNKNOWN] %s", foundCount, module.Name), self.Theme.Text)
            end
            task.wait(0.01)
        end
        self:AddOutput("")
    end
end
function Modules.CommandBar:ListModules(): ()
    if #self.Scanner.FoundModules == 0 then
        self:AddOutput("No modules found. Run 'scan' first.", Color3.fromRGB(255, 255, 0))
        return
    end
    self:AddOutput("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•", self.Theme.Accent)
    self:AddOutput(string.format("FOUND %d MODULES:", #self.Scanner.FoundModules), self.Theme.Text)
    self:AddOutput("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•", self.Theme.Accent)
    self:AddOutput("")
    for i, mod in pairs(self.Scanner.FoundModules) do
        local status = self.Scanner.PoisonedModules[mod.Name] and "[POISONED]" or ""
        self:AddOutput(string.format("[%d] %s (%s) %s", i, mod.Name, mod.Category, status), self.Theme.Text)
    end
    self:AddOutput("")
end
function Modules.CommandBar:InjectPoison(moduleData): ()
    self:AddOutput("")
    self:AddOutput("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•", self.Theme.Accent)
    self:AddOutput(string.format("INJECTING POISON: %s", moduleData.Poison.Name), self.Theme.Accent)
    self:AddOutput("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•", self.Theme.Accent)
    self:AddOutput("")
    local success, err = pcall(function()
        self:ApplyPoison(moduleData)
    end)
    if success then
        self:AddOutput(string.format("Successfully injected into: %s", moduleData.Name), self.Theme.Accent)
        self:AddOutput(string.format("  Description: %s", moduleData.Poison.Description), self.Theme.Text)
        self:AddOutput("")
        self.Scanner.PoisonedModules[moduleData.Name] = true
        moduleData.Poison.Applied = true
    else
        self:AddOutput(string.format("Injection failed: %s", tostring(err)), Color3.fromRGB(255, 0, 0))
        self:AddOutput("")
        self:PlayBeep()
    end
end
function Modules.CommandBar:ApplyPoison(moduleData): ()
    local module = SafeRequire(moduleData.Module)
    if not module then
        error("Failed to require module")
    end
    self:AddOutput("  Analyzing module structure...", self.Theme.Text)
    local category = moduleData.Category
    local hooked = 0
    if category == "inventory" then
        hooked = self:PoisonInventory(module)
    elseif category == "damage" then
        hooked = self:PoisonDamage(module)
    elseif category == "movement" then
        hooked = self:PoisonMovement(module)
    elseif category == "currency" then
        hooked = self:PoisonCurrency(module)
    elseif category == "weapon" then
        hooked = self:PoisonWeapon(module)
    end
    self:AddOutput(string.format("  Hooked %d functions", hooked), self.Theme.Accent)
end
function Modules.CommandBar:PoisonInventory(module): number
    local hooked = 0
    local originalFuncs = {}
    for funcName, func in pairs(module) do
        if type(func) == "function" then
            local name = funcName:lower()
            if name:match("add") or name:match("give") or name:match("insert") then
                originalFuncs[funcName] = func
                module[funcName] = function(...)
                    local args = {...}
                    if type(args[2]) == "table" then
                        args[2].Amount = 999999
                        args[2].Quantity = 999999
                        args[2].Stack = 999999
                    end
                    return originalFuncs[funcName](...)
                end
                hooked = hooked + 1
                self:AddOutput(string.format("    Hooked: %s (unlimited stacks)", funcName), self.Theme.Accent)
            end
            if name:match("remove") or name:match("consume") then
                originalFuncs[funcName] = func
                module[funcName] = function(...)
                    return true
                end
                hooked = hooked + 1
                self:AddOutput(string.format("    Hooked: %s (prevent consumption)", funcName), self.Theme.Accent)
            end
            if name:match("damage") or name:match("power") then
                originalFuncs[funcName] = func
                module[funcName] = function(...)
                    local result = originalFuncs[funcName](...)
                    if type(result) == "number" then
                        return result * 3.0
                    end
                    return result
                end
                hooked = hooked + 1
                self:AddOutput(string.format("    Hooked: %s (3x multiplier)", funcName), self.Theme.Accent)
            end
        end
    end
    return hooked
end
function Modules.CommandBar:PoisonDamage(module): number
    local hooked = 0
    local originalFuncs = {}
    for funcName, func in pairs(module) do
        if type(func) == "function" then
            local name = funcName:lower()
            if name:match("damage") or name:match("takedamage") or name:match("hurt") then
                originalFuncs[funcName] = func
                module[funcName] = function(amount, ...)
                    if type(amount) == "number" then
                        return originalFuncs[funcName](amount * 0.1, ...)
                    end
                    return originalFuncs[funcName](amount, ...)
                end
                hooked = hooked + 1
                self:AddOutput(string.format("    Hooked: %s (90%% damage reduction)", funcName), self.Theme.Accent)
            end
            if name:match("deal") or name:match("attack") or name:match("hit") then
                originalFuncs[funcName] = func
                module[funcName] = function(amount, ...)
                    if type(amount) == "number" then
                        return originalFuncs[funcName](amount * 5.0, ...)
                    end
                    return originalFuncs[funcName](amount, ...)
                end
                hooked = hooked + 1
                self:AddOutput(string.format("    Hooked: %s (5x damage output)", funcName), self.Theme.Accent)
            end
        end
    end
    return hooked
end
function Modules.CommandBar:PoisonMovement(module): number
    local hooked = 0
    local originalFuncs = {}
    for funcName, func in pairs(module) do
        if type(func) == "function" then
            local name = funcName:lower()
            if name:match("speed") or name:match("walkspeed") then
                originalFuncs[funcName] = func
                module[funcName] = function(...)
                    local result = originalFuncs[funcName](...)
                    if type(result) == "number" then
                        return result * 3.0
                    end
                    return result
                end
                hooked = hooked + 1
                self:AddOutput(string.format("    Hooked: %s (3x speed)", funcName), self.Theme.Accent)
            end
        end
    end
    return hooked
end
function Modules.CommandBar:PoisonCurrency(module): number
    local hooked = 0
    local originalFuncs = {}
    for funcName, func in pairs(module) do
        if type(func) == "function" then
            local name = funcName:lower()
            if name:match("add") or name:match("give") or name:match("earn") then
                originalFuncs[funcName] = func
                module[funcName] = function(amount, ...)
                    if type(amount) == "number" then
                        return originalFuncs[funcName](amount * 10.0, ...)
                    end
                    return originalFuncs[funcName](amount, ...)
                end
                hooked = hooked + 1
                self:AddOutput(string.format("    Hooked: %s (10x multiplier)", funcName), self.Theme.Accent)
            end
            if name:match("cost") or name:match("price") then
                originalFuncs[funcName] = func
                module[funcName] = function(...)
                    return 0
                end
                hooked = hooked + 1
                self:AddOutput(string.format("    Hooked: %s (free purchases)", funcName), self.Theme.Accent)
            end
        end
    end
    return hooked
end
function Modules.CommandBar:PoisonWeapon(module): number
    local hooked = 0
    local originalFuncs = {}
    for funcName, func in pairs(module) do
        if type(func) == "function" then
            local name = funcName:lower()
            if name:match("ammo") or name:match("clip") then
                originalFuncs[funcName] = func
                module[funcName] = function(...)
                    return 999999
                end
                hooked = hooked + 1
                self:AddOutput(string.format("    Hooked: %s (infinite ammo)", funcName), self.Theme.Accent)
            end
            if name:match("fire") or name:match("shoot") then
                originalFuncs[funcName] = func
                module[funcName] = function(...)
                    return originalFuncs[funcName](...)
                end
                hooked = hooked + 1
                self:AddOutput(string.format("    Hooked: %s (no cooldown)", funcName), self.Theme.Accent)
            end
        end
    end
    return hooked
end
function Modules.CommandBar:ShowStatus(): ()
    self:AddOutput("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•", self.Theme.Accent)
    self:AddOutput("SCANNER STATUS", self.Theme.Text)
    self:AddOutput("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•", self.Theme.Accent)
    self:AddOutput(string.format("Modules Found: %d", #self.Scanner.FoundModules), self.Theme.Text)
    local poisonedCount = 0
    for _ in pairs(self.Scanner.PoisonedModules) do
        poisonedCount = poisonedCount + 1
    end
    self:AddOutput(string.format("Poisons Applied: %d", poisonedCount), self.Theme.Text)
    self:AddOutput(string.format("Scan Active: %s", self.Scanner.ScanInProgress and "Yes" or "No"), self.Theme.Text)
    self:AddOutput("")
end
function Modules.CommandBar:Initialize(): ()
    local CommandBarUI: ScreenGui = Instance.new("ScreenGui")
    CommandBarUI.Name = "CommandPrompt"
    CommandBarUI.Parent = CoreGui
    CommandBarUI.ResetOnSpawn = false
    CommandBarUI.Enabled = false
    local MainContainer: Frame = Instance.new("Frame")
    MainContainer.Name = "WindowFrame"
    MainContainer.Parent = CommandBarUI
    MainContainer.Size = UDim2.new(0, 600, 0, 400)
    MainContainer.Position = UDim2.new(0.5, -300, 1, 50)
    MainContainer.BackgroundColor3 = self.Theme.WindowGray
    MainContainer.BackgroundTransparency = 0
    MainContainer.BorderSizePixel = 0
    MainContainer.Active = true
    MainContainer.ClipsDescendants = false
    local function CreateWin95Border(parent: Frame, isInset: boolean): ()
        local topColor = isInset and self.Theme.DarkGray or self.Theme.White
        local bottomColor = isInset and self.Theme.White or self.Theme.DarkGray
        local topBorder = Instance.new("Frame", parent)
        topBorder.Name = "TopBorder"
        topBorder.Size = UDim2.new(1, 0, 0, 2)
        topBorder.Position = UDim2.new(0, 0, 0, 0)
        topBorder.BackgroundColor3 = topColor
        topBorder.BorderSizePixel = 0
        topBorder.ZIndex = parent.ZIndex + 1
        local leftBorder = Instance.new("Frame", parent)
        leftBorder.Name = "LeftBorder"
        leftBorder.Size = UDim2.new(0, 2, 1, 0)
        leftBorder.Position = UDim2.new(0, 0, 0, 0)
        leftBorder.BackgroundColor3 = topColor
        leftBorder.BorderSizePixel = 0
        leftBorder.ZIndex = parent.ZIndex + 1
        local bottomBorder = Instance.new("Frame", parent)
        bottomBorder.Name = "BottomBorder"
        bottomBorder.Size = UDim2.new(1, 0, 0, 2)
        bottomBorder.Position = UDim2.new(0, 0, 1, -2)
        bottomBorder.BackgroundColor3 = bottomColor
        bottomBorder.BorderSizePixel = 0
        bottomBorder.ZIndex = parent.ZIndex + 1
        local rightBorder = Instance.new("Frame", parent)
        rightBorder.Name = "RightBorder"
        rightBorder.Size = UDim2.new(0, 2, 1, 0)
        rightBorder.Position = UDim2.new(1, -2, 0, 0)
        rightBorder.BackgroundColor3 = bottomColor
        rightBorder.BorderSizePixel = 0
        rightBorder.ZIndex = parent.ZIndex + 1
    end
    CreateWin95Border(MainContainer, false)
    local TitleBar: Frame = Instance.new("Frame", MainContainer)
    TitleBar.Name = "TitleBar"
    TitleBar.Position = UDim2.new(0, 3, 0, 3)
    TitleBar.Size = UDim2.new(1, -6, 0, 22)
    TitleBar.BackgroundColor3 = self.Theme.Blue
    TitleBar.BorderSizePixel = 0
    TitleBar.ZIndex = 2
    local TitleGradient = Instance.new("UIGradient", TitleBar)
    TitleGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 0, 168)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(16, 132, 208))
    }
    TitleGradient.Rotation = 90
    local TitleLabel: TextLabel = Instance.new("TextLabel", TitleBar)
    TitleLabel.Name = "Title"
    TitleLabel.Position = UDim2.new(0, 4, 0, 0)
    TitleLabel.Size = UDim2.new(1, -70, 1, 0)
    TitleLabel.BackgroundTransparency = 1
    TitleLabel.Font = Enum.Font.SourceSansBold
    TitleLabel.Text = "C:\\ROBLOX\\system32\\cmd.exe"
    TitleLabel.TextColor3 = self.Theme.White
    TitleLabel.TextSize = 13
    TitleLabel.TextXAlignment = Enum.TextXAlignment.Left
    TitleLabel.TextYAlignment = Enum.TextYAlignment.Center
    TitleLabel.ZIndex = 3
    local MinimizeButton: TextButton = Instance.new("TextButton", TitleBar)
    MinimizeButton.Name = "MinimizeButton"
    MinimizeButton.Position = UDim2.new(1, -54, 0, 2)
    MinimizeButton.Size = UDim2.new(0, 16, 0, 16)
    MinimizeButton.BackgroundColor3 = self.Theme.WindowGray
    MinimizeButton.BorderSizePixel = 0
    MinimizeButton.Font = Enum.Font.SourceSansBold
    MinimizeButton.Text = "_"
    MinimizeButton.TextColor3 = Color3.fromRGB(0, 0, 0)
    MinimizeButton.TextSize = 14
    MinimizeButton.TextYAlignment = Enum.TextYAlignment.Top
    MinimizeButton.ZIndex = 4
    CreateWin95Border(MinimizeButton, false)
    MinimizeButton.MouseButton1Click:Connect(function()
        if self.State.IsMinimized then
            self:Restore()
        else
            self:Minimize()
        end
    end)
    local MaximizeButton: TextButton = Instance.new("TextButton", TitleBar)
    MaximizeButton.Name = "MaximizeButton"
    MaximizeButton.Position = UDim2.new(1, -36, 0, 2)
    MaximizeButton.Size = UDim2.new(0, 16, 0, 16)
    MaximizeButton.BackgroundColor3 = self.Theme.WindowGray
    MaximizeButton.BorderSizePixel = 0
    MaximizeButton.Font = Enum.Font.SourceSansBold
    MaximizeButton.Text = "â–¡"
    MaximizeButton.TextColor3 = Color3.fromRGB(0, 0, 0)
    MaximizeButton.TextSize = 14
    MaximizeButton.ZIndex = 4
    CreateWin95Border(MaximizeButton, false)
    MaximizeButton.MouseButton1Click:Connect(function()
        self:Maximize()
    end)
    local CloseButton: TextButton = Instance.new("TextButton", TitleBar)
    CloseButton.Name = "CloseButton"
    CloseButton.Position = UDim2.new(1, -18, 0, 2)
    CloseButton.Size = UDim2.new(0, 16, 0, 16)
    CloseButton.BackgroundColor3 = self.Theme.WindowGray
    CloseButton.BorderSizePixel = 0
    CloseButton.Font = Enum.Font.SourceSansBold
    CloseButton.Text = "Ã—"
    CloseButton.TextColor3 = Color3.fromRGB(0, 0, 0)
    CloseButton.TextSize = 16
    CloseButton.ZIndex = 4
    CreateWin95Border(CloseButton, false)
    CloseButton.MouseButton1Click:Connect(function()
        self:Toggle()
    end)
    local TerminalContainer: Frame = Instance.new("Frame", MainContainer)
    TerminalContainer.Name = "TerminalContainer"
    TerminalContainer.Position = UDim2.new(0, 6, 0, 28)
    TerminalContainer.Size = UDim2.new(1, -12, 1, -34)
    TerminalContainer.BackgroundColor3 = self.Theme.Background
    TerminalContainer.BorderSizePixel = 0
    TerminalContainer.ZIndex = 1
    CreateWin95Border(TerminalContainer, true)
    local ScanlineOverlay = Instance.new("Frame", TerminalContainer)
    ScanlineOverlay.Name = "Scanlines"
    ScanlineOverlay.Size = UDim2.new(1, 0, 1, 0)
    ScanlineOverlay.BackgroundTransparency = 0.95
    ScanlineOverlay.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    ScanlineOverlay.BorderSizePixel = 0
    ScanlineOverlay.ZIndex = 10
    for i = 0, 50 do
        local line = Instance.new("Frame", ScanlineOverlay)
        line.Size = UDim2.new(1, 0, 0, 1)
        line.Position = UDim2.new(0, 0, i / 50, 0)
        line.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        line.BackgroundTransparency = 0.8
        line.BorderSizePixel = 0
    end
    local AnimatedScanline = Instance.new("Frame", ScanlineOverlay)
    AnimatedScanline.Name = "AnimatedScan"
    AnimatedScanline.Size = UDim2.new(1, 0, 0, 3)
    AnimatedScanline.Position = UDim2.new(0, 0, 0, 0)
    AnimatedScanline.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    AnimatedScanline.BackgroundTransparency = 0.9
    AnimatedScanline.BorderSizePixel = 0
    task.spawn(function()
        while task.wait(0.05) do
            if not AnimatedScanline or not AnimatedScanline.Parent then break end
            AnimatedScanline.Position = UDim2.new(0, 0, (AnimatedScanline.Position.Y.Scale + 0.02) % 1, 0)
        end
    end)
    local OutputLog: ScrollingFrame = Instance.new("ScrollingFrame")
    OutputLog.Name = "Buffer"
    OutputLog.Parent = TerminalContainer
    OutputLog.Position = UDim2.new(0, 4, 0, 4)
    OutputLog.Size = UDim2.new(1, -8, 1, -32)
    OutputLog.BackgroundTransparency = 1
    OutputLog.BorderSizePixel = 0
    OutputLog.ScrollBarThickness = 16
    OutputLog.ScrollBarImageColor3 = self.Theme.WindowGray
    OutputLog.CanvasSize = UDim2.new(0, 0, 0, 0)
    OutputLog.AutomaticCanvasSize = Enum.AutomaticSize.Y
    OutputLog.ScrollingDirection = Enum.ScrollingDirection.Y
    OutputLog.ZIndex = 2
    local LogLayout: UIListLayout = Instance.new("UIListLayout", OutputLog)
    LogLayout.Padding = UDim.new(0, 0)
    LogLayout.SortOrder = Enum.SortOrder.LayoutOrder
    local InputArea: Frame = Instance.new("Frame", TerminalContainer)
    InputArea.Position = UDim2.new(0, 4, 1, -24)
    InputArea.Size = UDim2.new(1, -8, 0, 20)
    InputArea.BackgroundTransparency = 1
    InputArea.ZIndex = 2
    local Prompt: TextLabel = Instance.new("TextLabel", InputArea)
    Prompt.Size = UDim2.new(0, 40, 1, 0)
    Prompt.BackgroundTransparency = 1
    Prompt.Font = self.Theme.Font
    Prompt.Text = "C:\\>"
    Prompt.TextColor3 = self.Theme.Accent
    Prompt.TextSize = 14
    Prompt.TextXAlignment = Enum.TextXAlignment.Left
    Prompt.ZIndex = 3
    local SuggestionLabel: TextLabel = Instance.new("TextLabel", InputArea)
    SuggestionLabel.Name = "Suggestion"
    SuggestionLabel.Position = UDim2.new(0, 40, 0, 0)
    SuggestionLabel.Size = UDim2.new(1, -40, 1, 0)
    SuggestionLabel.BackgroundTransparency = 1
    SuggestionLabel.Font = self.Theme.Font
    SuggestionLabel.Text = ""
    SuggestionLabel.TextColor3 = self.Theme.Suggestion
    SuggestionLabel.TextSize = 14
    SuggestionLabel.TextXAlignment = Enum.TextXAlignment.Left
    SuggestionLabel.ZIndex = 3
    local InputField: TextBox = Instance.new("TextBox", InputArea)
    InputField.Name = "Prompt"
    InputField.Position = UDim2.new(0, 40, 0, 0)
    InputField.Size = UDim2.new(1, -40, 1, 0)
    InputField.BackgroundTransparency = 1
    InputField.Font = self.Theme.Font
    InputField.Text = ""
    InputField.TextColor3 = self.Theme.Accent
    InputField.TextSize = 14
    InputField.TextXAlignment = Enum.TextXAlignment.Left
    InputField.ClearTextOnFocus = false
    InputField.ZIndex = 4
    local Cursor: Frame = Instance.new("Frame", InputArea)
    Cursor.Name = "Cursor"
    Cursor.Size = UDim2.new(0, 8, 0, 16)
    Cursor.Position = UDim2.new(0, 40, 0, 2)
    Cursor.BackgroundColor3 = self.Theme.Accent
    Cursor.BorderSizePixel = 0
    Cursor.ZIndex = 5
    task.spawn(function()
        while task.wait(0.5) do
            if not Cursor or not Cursor.Parent then break end
            if InputField:IsFocused() then
                Cursor.BackgroundTransparency = Cursor.BackgroundTransparency == 0 and 1 or 0
            else
                Cursor.BackgroundTransparency = 1
            end
        end
    end)
    local ResizeHandle = Instance.new("Frame")
    ResizeHandle.Name = "ResizeHandle"
    ResizeHandle.Size = UDim2.fromOffset(16, 16)
    ResizeHandle.Position = UDim2.new(1, -16, 1, -16)
    ResizeHandle.BackgroundColor3 = self.Theme.WindowGray
    ResizeHandle.BorderSizePixel = 0
    ResizeHandle.ZIndex = 10
    ResizeHandle.Parent = MainContainer
    for i = 0, 2 do
        local line = Instance.new("Frame", ResizeHandle)
        line.Size = UDim2.new(0, 2, 1, -4 * i)
        line.Position = UDim2.new(0, 4 + (4 * i), 0, 4 * i)
        line.BackgroundColor3 = self.Theme.DarkGray
        line.BorderSizePixel = 0
        line.Rotation = 45
    end
    self.State.UI = CommandBarUI
    self.State.Container = MainContainer
    self.State.TextBox = InputField
    self.State.LogFrame = OutputLog
    self.State.SuggestionLabel = SuggestionLabel
    local dragging, resizing = false, false
    local dragStart, resizeStart, startPos, startSize
    TitleBar.InputBegan:Connect(function(input: InputObject)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = MainContainer.Position
            local conn; conn = input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                    conn:Disconnect()
                end
            end)
        end
    end)
    ResizeHandle.InputBegan:Connect(function(input: InputObject)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            resizing = true
            resizeStart = input.Position
            startSize = MainContainer.Size
            local conn; conn = input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    resizing = false
                    conn:Disconnect()
                end
            end)
        end
    end)
    UserInputService.InputChanged:Connect(function(input: InputObject)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            if dragging then
                local delta: Vector3 = input.Position - dragStart
                MainContainer.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
            elseif resizing then
                local delta: Vector2 = Vector2.new(input.Position.X - resizeStart.X, input.Position.Y - resizeStart.Y)
                local newX = math.max(self.State.MinSize.X, startSize.X.Offset + delta.X)
                local newY = math.max(self.State.MinSize.Y, startSize.Y.Offset + delta.Y)
                MainContainer.Size = UDim2.new(0, newX, 0, newY)
            end
        end
    end)
    OutputLog.InputBegan:Connect(function(input: InputObject)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            self.State.IsSelecting = true
            local children: {Instance} = OutputLog:GetChildren()
            local mousePos: Vector3 = input.Position
            for i, child in ipairs(children) do
                if child:IsA("TextLabel") then
                    local absPos: Vector2 = child.AbsolutePosition
                    local absSize: Vector2 = child.AbsoluteSize
                    if mousePos.X >= absPos.X and mousePos.X <= absPos.X + absSize.X and
                       mousePos.Y >= absPos.Y and mousePos.Y <= absPos.Y + absSize.Y then
                        self.State.SelectionStart = i
                        break
                    end
                end
            end
            local conn; conn = input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    self.State.IsSelecting = false
                    conn:Disconnect()
                end
            end)
        end
    end)
    OutputLog.InputChanged:Connect(function(input: InputObject)
        if input.UserInputType == Enum.UserInputType.MouseMovement and self.State.IsSelecting then
            local children: {Instance} = OutputLog:GetChildren()
            local mousePos: Vector3 = input.Position
            for i, child in ipairs(children) do
                if child:IsA("TextLabel") then
                    local absPos: Vector2 = child.AbsolutePosition
                    local absSize: Vector2 = child.AbsoluteSize
                    if mousePos.X >= absPos.X and mousePos.X <= absPos.X + absSize.X and
                       mousePos.Y >= absPos.Y and mousePos.Y <= absPos.Y + absSize.Y then
                        self.State.SelectionEnd = i
                        for j, c in ipairs(children) do
                            if c:IsA("TextLabel") then
                                local startIdx = math.min(self.State.SelectionStart, self.State.SelectionEnd)
                                local endIdx = math.max(self.State.SelectionStart, self.State.SelectionEnd)
                                if j >= startIdx and j <= endIdx then
                                    c.BackgroundTransparency = 0
                                    c.BackgroundColor3 = self.Theme.Accent
                                    c.TextColor3 = self.Theme.Background
                                else
                                    c.BackgroundTransparency = 1
                                    c.TextColor3 = self.Theme.Accent
                                end
                            end
                        end
                        break
                    end
                end
            end
        end
    end)
    InputField:GetPropertyChangedSignal("Text"):Connect(function()
        self:UpdateSuggestions()
        local textService = game:GetService("TextService")
        local textWidth = textService:GetTextSize(
            InputField.Text, 
            14, 
            self.Theme.Font, 
            Vector2.new(10000, 20)
        ).X
        Cursor.Position = UDim2.new(0, 40 + textWidth, 0, 2)
    end)
    InputField.FocusLost:Connect(function(enter: boolean)
        if enter then
            local raw: string = InputField.Text
            local cmd: string = string.match(raw, "^%s*(.-)%s*$")
            if cmd ~= "" then
                self:AddOutput("C:\\>" .. cmd, self.Theme.Accent)
                if cmd:lower() == "cmds" or cmd:lower() == "help" or cmd:lower() == "dir" then
                    self:ListCommands()
                elseif cmd:lower() == "cls" or cmd:lower() == "clear" then
                    for _, child in ipairs(OutputLog:GetChildren()) do
                        if child:IsA("TextLabel") then child:Destroy() end
                    end
                elseif cmd:lower() == "scan" then
                    self:StartScan()
                elseif cmd:lower() == "list" then
                    self:ListModules()
                elseif cmd:lower() == "status" then
                    self:ShowStatus()
                elseif cmd:lower():match("^inject%s+(%d+)") then
                    local index = tonumber(cmd:lower():match("^inject%s+(%d+)"))
                    if index then
                        local moduleData = self.Scanner.FoundModules[index]
                        if not moduleData then
                            self:AddOutput("Invalid module index", Color3.fromRGB(255, 255, 255))
                            self:PlayBeep()
                        elseif not moduleData.Poison then
                            self:AddOutput("Module has no available poison", Color3.fromRGB(255, 255, 0))
                            self:PlayBeep()
                        else
                            self:InjectPoison(moduleData)
                        end
                    else
                        self:AddOutput("Usage: inject <index>", Color3.fromRGB(255, 255, 255))
                        self:PlayBeep()
                    end
                else
                    local wasProcessed: boolean = processCommand(Prefix .. cmd)
                    if not wasProcessed then
                        self:AddOutput("Bad command or file name", Color3.fromRGB(255, 255, 255))
                        self:PlayBeep()
                    end
                end
                InputField.Text = ""
            end
            self:Toggle()
        end
    end)
    UserInputService.InputBegan:Connect(function(input: InputObject, gpe: boolean)
        if input.KeyCode == Enum.KeyCode.Tab and InputField:IsFocused() then
            if self.State.CurrentSuggestion ~= "" then
                InputField.Text = self.State.CurrentSuggestion
                InputField.CursorPosition = #InputField.Text + 1
            end
        end
        if not gpe and input.KeyCode == Enum.KeyCode.C and UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
            if self.State.IsEnabled then
                self:CopySelectedText()
                self:AddOutput("Copied to clipboard.", self.Theme.Text)
            end
        end
        if not gpe and input.KeyCode == self.State.PrefixKey then 
            self:Toggle() 
        end
    end)
    self:AddOutput("Microslop(R) Windows DOS", self.Theme.Text)
    self:AddOutput("(C)Copyright Microslop Corp 1990-1994.", self.Theme.Text)
    self:AddOutput("")
    self:AddOutput("C:\\WINDOWS>", self.Theme.Accent)
end
function DoNotif(text: string, duration: number?): ()
    NotificationManager.Send(text, duration)
    if Modules.CommandBar and Modules.CommandBar.AddOutput then
        Modules.CommandBar:AddOutput(tostring(text), Modules.CommandBar.Theme.Text)
    end
end
Modules.UnlockMouse = { State = { Enabled = false, Connection = nil } }
RegisterCommand({ Name = "unlockmouse", Aliases = {"unlockcursor", "freemouse", "um"}, Description = "Toggles a persistent loop to unlock the mouse cursor." }, function()
local State = Modules.UnlockMouse.State
State.Enabled = not State.Enabled
if State.Enabled then
    if State.Connection then State.Connection:Disconnect() end
        State.Connection = RunService.RenderStepped:Connect(function()
        UserInputService.MouseBehavior = Enum.MouseBehavior.Default
        UserInputService.MouseIconEnabled = true
    end)
    DoNotif("Mouse Unlock Enabled", 2)
else
if State.Connection then State.Connection:Disconnect(); State.Connection = nil end
    DoNotif("Mouse Unlock Disabled", 2)
end
end)
Modules.ESP = {
    State = {
        PlayersEnabled = false,
        Connections = {},
        TrackedPlayers = setmetatable({}, {__mode="k"})
    },
    Config = {
        ColorMode = "team",
        CustomFillColor = Color3.fromRGB(255, 50, 50),
        CustomOutlineColor = Color3.fromRGB(255, 255, 255),
        FillTransparency = 0.75,
        OutlineTransparency = 0.1,
        DistanceClose = 100,
        DistanceMid = 500,
        MaxDistance = 10000,
        UpdateRate = 0,
    }
}
function Modules.ESP:_resolveColor(player, dist)
    local mode = self.Config.ColorMode
    if mode == "custom" then
        return self.Config.CustomFillColor
    elseif mode == "distance" then
        if dist <= self.Config.DistanceClose then
            return Color3.fromRGB(0, 255, 80)
        elseif dist <= self.Config.DistanceMid then
            return Color3.fromRGB(255, 200, 0)
        else
            return Color3.fromRGB(255, 50, 50)
        end
    else
        return player.TeamColor.Color
    end
end
function Modules.ESP:_refreshColors()
    for player, data in pairs(self.State.TrackedPlayers) do
        if data then
            local lHrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            local hrp = data.HRP
            local dist = (hrp and lHrp) and (hrp.Position - lHrp.Position).Magnitude or 0
            local fillColor = self:_resolveColor(player, dist)
            if data.Highlight and data.Highlight.Parent then
                data.Highlight.FillColor = fillColor
                data.Highlight.OutlineColor = self.Config.CustomOutlineColor
            end
            if data.SubLabel and data.SubLabel.Parent then
                data.SubLabel.TextColor3 = fillColor
            end
        end
    end
end
function Modules.ESP:_cleanup()
    for name, conn in pairs(self.State.Connections) do
        pcall(function() conn:Disconnect() end)
        self.State.Connections[name] = nil
    end
    for player, _ in pairs(self.State.TrackedPlayers) do
        self:_removePlayerEsp(player)
    end
    table.clear(self.State.TrackedPlayers)
end
function Modules.ESP:_createPlayerEsp(player)
    if player == LocalPlayer then return end
    if self.State.Connections["CharAdded_" .. player.UserId] then return end
    local espModule = self
    local function setupVisuals(character)
        local existing = espModule.State.TrackedPlayers[player]
        if existing then
            pcall(function() if existing.Highlight then existing.Highlight:Destroy() end end)
            pcall(function() if existing.Billboard then existing.Billboard:Destroy() end end)
            if existing.InternalConns then
                for _, c in pairs(existing.InternalConns) do pcall(function() c:Disconnect() end) end
            end
        end
        local head = character:WaitForChild("Head", 5)
        local humanoid = character:WaitForChild("Humanoid", 5)
        local hrp = character:WaitForChild("HumanoidRootPart", 5)
        if not head or not humanoid or not hrp then return end
        if not character.Parent then return end
        local initDist = 0
        local lHrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if lHrp then
            initDist = (hrp.Position - lHrp.Position).Magnitude
        end
        local fillColor = espModule:_resolveColor(player, initDist)
        local highlight = Instance.new("Highlight")
        highlight.Name = "v_Highlight"
        highlight.Parent = character
        highlight.FillColor = fillColor
        highlight.OutlineColor = espModule.Config.CustomOutlineColor
        highlight.FillTransparency = espModule.Config.FillTransparency
        highlight.OutlineTransparency = espModule.Config.OutlineTransparency
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        local billboard = Instance.new("BillboardGui")
        billboard.Name = "v_Billboard"
        billboard.Adornee = head
        billboard.AlwaysOnTop = true
        billboard.Size = UDim2.new(0, 200, 0, 60)
        billboard.StudsOffset = Vector3.new(0, 3, 0)
        billboard.MaxDistance = 0
        billboard.Parent = LocalPlayer.PlayerGui
        local container = Instance.new("Frame", billboard)
        container.Size = UDim2.new(1, 0, 1, 0)
        container.BackgroundTransparency = 1
        local healthBarBg = Instance.new("Frame", container)
        healthBarBg.Size = UDim2.new(0, 3, 0.5, 0)
        healthBarBg.Position = UDim2.new(0.5, -65, 0.25, 0)
        healthBarBg.BackgroundColor3 = Color3.new(0, 0, 0)
        healthBarBg.BorderSizePixel = 0
        local healthBar = Instance.new("Frame", healthBarBg)
        healthBar.Size = UDim2.new(1, 0, 1, 0)
        healthBar.BackgroundColor3 = Color3.fromRGB(0, 255, 120)
        healthBar.BorderSizePixel = 0
        local infoLabel = Instance.new("TextLabel", container)
        infoLabel.Size = UDim2.new(1, 0, 0.4, 0)
        infoLabel.Position = UDim2.new(0.5, -55, 0.2, 0)
        infoLabel.BackgroundTransparency = 1
        infoLabel.Font = Enum.Font.BuilderSansBold
        infoLabel.TextColor3 = Color3.new(1, 1, 1)
        infoLabel.TextXAlignment = Enum.TextXAlignment.Left
        infoLabel.TextSize = 14
        infoLabel.Text = player.DisplayName
        local infoStroke = Instance.new("UIStroke", infoLabel)
        infoStroke.Thickness = 1.5
        local subLabel = Instance.new("TextLabel", container)
        subLabel.Size = UDim2.new(1, 0, 0.3, 0)
        subLabel.Position = UDim2.new(0.5, -55, 0.5, 0)
        subLabel.BackgroundTransparency = 1
        subLabel.Font = Enum.Font.BuilderSansMedium
        subLabel.TextColor3 = fillColor
        subLabel.TextXAlignment = Enum.TextXAlignment.Left
        subLabel.TextSize = 12
        subLabel.Text = "0 STUDS"
        local subStroke = Instance.new("UIStroke", subLabel)
        subStroke.Thickness = 1.2
        local lastUpdate = 0
        local function update(dt)
            lastUpdate = lastUpdate + dt
            if lastUpdate < espModule.Config.UpdateRate then return end
            lastUpdate = 0
            if not hrp or not hrp.Parent then return end
            if not humanoid or not humanoid.Parent then return end
            if not LocalPlayer.Character then return end
            local lHrpNow = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if not lHrpNow then return end
            local ok, dist = pcall(function()
                return (hrp.Position - lHrpNow.Position).Magnitude
            end)
            if not ok then return end
            local maxHp = humanoid.MaxHealth
            local hp = (maxHp > 0) and (humanoid.Health / maxHp) or 0
            hp = math.clamp(hp, 0, 1)
            healthBar.Size = UDim2.new(1, 0, hp, 0)
            healthBar.Position = UDim2.new(0, 0, 1 - hp, 0)
            healthBar.BackgroundColor3 = Color3.fromHSV(hp * 0.35, 1, 1)
            local distStr
            if dist >= 1000 then
                distStr = string.format("%.1fk STUDS", dist / 1000)
            else
                distStr = string.format("%d STUDS", math.floor(dist))
            end
            local teamName = (player.Team and player.Team.Name:upper()) or "NEUTRAL"
            subLabel.Text = teamName .. " | " .. distStr
            local color = espModule:_resolveColor(player, dist)
            if espModule.Config.ColorMode ~= "team" or not (highlight.FillColor == color) then
                highlight.FillColor = color
                subLabel.TextColor3 = color
            end
            local scale = math.clamp(1 - (dist / espModule.Config.MaxDistance) * 0.4, 0.6, 1)
        end
        local hConn = humanoid.HealthChanged:Connect(function() update(espModule.Config.UpdateRate + 1) end)
        local rConn = game:GetService("RunService").Heartbeat:Connect(update)
        local ancestorConn = head.AncestryChanged:Connect(function()
            if not head.Parent then
                billboard.Adornee = nil
            end
        end)
        espModule.State.TrackedPlayers[player] = {
            Highlight = highlight,
            Billboard = billboard,
            SubLabel = subLabel,
            HRP = hrp,
            InternalConns = {hConn, rConn, ancestorConn}
        }
    end
    if player.Character then task.spawn(setupVisuals, player.Character) end
    self.State.Connections["CharAdded_" .. player.UserId] = player.CharacterAdded:Connect(function(char)
        task.spawn(setupVisuals, char)
    end)
end
function Modules.ESP:_removePlayerEsp(player)
    local data = self.State.TrackedPlayers[player]
    if data then
        pcall(function() if data.Highlight then data.Highlight:Destroy() end end)
        pcall(function() if data.Billboard then data.Billboard:Destroy() end end)
        if data.InternalConns then
            for _, c in pairs(data.InternalConns) do pcall(function() c:Disconnect() end) end
        end
        self.State.TrackedPlayers[player] = nil
    end
    local charConn = self.State.Connections["CharAdded_" .. player.UserId]
    if charConn then
        pcall(function() charConn:Disconnect() end)
        self.State.Connections["CharAdded_" .. player.UserId] = nil
    end
end
function Modules.ESP:Toggle(argument)
    argument = (argument or "players"):lower()
    if argument == "players" or argument == "p" or argument == "all" then
        self.State.PlayersEnabled = not self.State.PlayersEnabled
        DoNotif("Visuals: " .. (self.State.PlayersEnabled and "ACTIVE" or "OFFLINE"), 2)
        if self.State.PlayersEnabled then
            self.State.Connections.MainAdded = Players.PlayerAdded:Connect(function(p)
                self:_createPlayerEsp(p)
            end)
            self.State.Connections.MainRemoving = Players.PlayerRemoving:Connect(function(p)
                self:_removePlayerEsp(p)
            end)
            for _, player in ipairs(Players:GetPlayers()) do
                self:_createPlayerEsp(player)
            end
        else
            self:_cleanup()
        end
    else
        local targetPlayer = Utilities.findPlayer(argument)
        if not targetPlayer then return DoNotif("Target not found", 3) end
        if self.State.TrackedPlayers[targetPlayer] or self.State.Connections["CharAdded_" .. targetPlayer.UserId] then
            self:_removePlayerEsp(targetPlayer)
            DoNotif("ESP Disabled for " .. targetPlayer.DisplayName, 2)
        else
            self:_createPlayerEsp(targetPlayer)
            DoNotif("ESP Enabled for " .. targetPlayer.DisplayName, 2)
        end
    end
end
function Modules.ESP:SetColor(args)
    local mode = args[1] and args[1]:lower()
    if not mode then
        return DoNotif("Usage: espcolor [team|distance|custom|outline] [r g b]", 3)
    end
    if mode == "team" or mode == "distance" then
        self.Config.ColorMode = mode
        DoNotif("ESP color mode: " .. mode:upper(), 2)
        self:_refreshColors()
    elseif mode == "custom" then
        local r, g, b = tonumber(args[2]), tonumber(args[3]), tonumber(args[4])
        if not (r and g and b) then
            return DoNotif("Usage: espcolor custom <r> <g> <b>", 3)
        end
        self.Config.CustomFillColor = Color3.fromRGB(
            math.clamp(r, 0, 255),
            math.clamp(g, 0, 255),
            math.clamp(b, 0, 255)
        )
        self.Config.ColorMode = "custom"
        DoNotif(string.format("ESP custom color set: %d %d %d", r, g, b), 2)
        self:_refreshColors()
    elseif mode == "outline" then
        local r, g, b = tonumber(args[2]), tonumber(args[3]), tonumber(args[4])
        if not (r and g and b) then
            return DoNotif("Usage: espcolor outline <r> <g> <b>", 3)
        end
        self.Config.CustomOutlineColor = Color3.fromRGB(
            math.clamp(r, 0, 255),
            math.clamp(g, 0, 255),
            math.clamp(b, 0, 255)
        )
        DoNotif(string.format("ESP outline color set: %d %d %d", r, g, b), 2)
        self:_refreshColors()
    else
        DoNotif("Unknown mode. Use: team | distance | custom | outline", 3)
    end
end
RegisterCommand({
    Name = "esp",
    Aliases = {"visuals"},
    Description = "Toggles ESP for all players or a specific player. Usage: esp [player|all]"
}, function(args)
    Modules.ESP:Toggle(args[1])
end)
RegisterCommand({
    Name = "espcolor",
    Aliases = {"espc"},
    Description = "Change ESP colors. Modes: team | distance | custom <r> <g> <b> | outline <r> <g> <b>"
}, function(args)
    Modules.ESP:SetColor(args)
end)
        Modules.ClickTP = { State = { IsActive = false, Connection = nil } };
        function Modules.ClickTP:Toggle()
            self.State.IsActive = not self.State.IsActive
            local UserInputService = game:GetService("UserInputService")
            local Workspace = game:GetService("Workspace")
            local Players = game:GetService("Players")
            local LocalPlayer = Players.LocalPlayer
            if self.State.IsActive then
                self.State.Connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                if not gameProcessed and input.UserInputType == Enum.UserInputType.MouseButton1 and UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
                    local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    if not hrp then return end
                        local camera = Workspace.CurrentCamera
                        local mousePos = UserInputService:GetMouseLocation()
                        local ray = camera:ViewportPointToRay(mousePos.X, mousePos.Y)
                        local params = RaycastParams.new()
                        params.FilterType = Enum.RaycastFilterType.Blacklist
                        params.FilterDescendantsInstances = {LocalPlayer.Character}
                        local result = Workspace:Raycast(ray.Origin, ray.Direction * 1000, params)
                        if result and result.Position then
                            hrp.CFrame = CFrame.new(result.Position) + Vector3.new(0, 3, 0)
                        end
                    end
                end)
                DoNotif("Click TP Enabled", 2)
            else
            if self.State.Connection then
                self.State.Connection:Disconnect()
                self.State.Connection = nil
            end
            DoNotif("Click TP Disabled", 2)
        end
    end
    RegisterCommand({Name = "clicktp", Aliases = {}, Description = "Hold Left CTRL and click to teleport."}, function(args)
    Modules.ClickTP:Toggle(args)
end)

Modules.FovChanger = {
    State = {
        IsEnabled = false,
        TargetFov = 70,
        DefaultFov = 70,
        Connection = nil
    }
}
local function updateFovOnRenderStep()
    local camera = Workspace.CurrentCamera
    local state = Modules.FovChanger.State
    if camera and state.IsEnabled and camera.FieldOfView ~= state.TargetFov then
        camera.FieldOfView = state.TargetFov
    end
end
local function enableFovLock()
    local state = Modules.FovChanger.State
    if not state.Connection then
        state.Connection = RunService.RenderStepped:Connect(updateFovOnRenderStep)
    end
    state.IsEnabled = true
end
local function disableFovLock()
    local state = Modules.FovChanger.State
    state.IsEnabled = false
    if state.Connection then
        state.Connection:Disconnect()
        state.Connection = nil
    end
end
pcall(function()
    Modules.FovChanger.State.DefaultFov = Workspace.CurrentCamera.FieldOfView
end)
RegisterCommand({ Name = "fov", Aliases = {"fieldofview", "camfov"}, Description = "Changes and locks FOV." }, function(args)
    local camera = Workspace.CurrentCamera
    if not camera then
        DoNotif("Could not find camera.", 3)
        return
    end
    local argument = args[1]
    if not argument then
        DoNotif("Current FOV is: " .. camera.FieldOfView, 3)
        return
    end
    if string.lower(argument) == "reset" then
        disableFovLock()
        camera.FieldOfView = Modules.FovChanger.State.DefaultFov
        DoNotif("FOV lock disabled and reset to " .. Modules.FovChanger.State.DefaultFov, 2)
        return
    end
    local newFov = tonumber(argument)
    if not newFov then
        DoNotif("Invalid argument. Provide a number or 'reset'.", 3)
        return
    end
    local clampedFov = math.clamp(newFov, 1, 120)
    Modules.FovChanger.State.TargetFov = clampedFov
    enableFovLock()
    DoNotif("FOV locked to " .. clampedFov, 2)
end)
RegisterCommand({ Name = "cmds", Aliases = {"commands", "help"}, Description = "Opens a UI that lists all available commands." }, function()
    Modules.CommandList:Toggle()
end)
Modules.Fly = {
    State = {
        IsActive = false,
        Speed = 60,
        SprintMultiplier = 2.5,
        Connections = {},
        BodyMovers = {}
    }
}
        function Modules.Fly:SetSpeed(s)
            local n = tonumber(s)
            if n and n > 0 then
                self.State.Speed = n
                DoNotif("Fly speed set to: " .. n, 1)
            else
            DoNotif("Invalid speed.", 1)
        end
    end
    function Modules.Fly:Disable()
        if not self.State.IsActive then return end
            self.State.IsActive = false
            local h = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if h then h.PlatformStand = false end
                for _, mover in pairs(self.State.BodyMovers) do
                    if mover and mover.Parent then
                        mover:Destroy()
                    end
                end
                for _, connection in ipairs(self.State.Connections) do
                    connection:Disconnect()
                end
                table.clear(self.State.BodyMovers)
                table.clear(self.State.Connections)
                DoNotif("Fly disabled.", 1)
            end
            function Modules.Fly:Enable()
                local self = self
                if self.State.IsActive then return end
                    local char = LocalPlayer.Character
                    local hrp = char and char:FindFirstChild("HumanoidRootPart")
                    local humanoid = char and char:FindFirstChildOfClass("Humanoid")
                    if not (hrp and humanoid) then
                        DoNotif("Character required.", 1)
                        return
                    end
                    self.State.IsActive = true
                    DoNotif("Fly Enabled.", 1)
                    humanoid.PlatformStand = true
                    local hrpAttachment = Instance.new("Attachment", hrp)
                    local worldAttachment = Instance.new("Attachment", workspace.Terrain)
                    worldAttachment.WorldCFrame = hrp.CFrame
                    local alignOrientation = Instance.new("AlignOrientation")
                    alignOrientation.Mode = Enum.OrientationAlignmentMode.OneAttachment
                    alignOrientation.Attachment0 = hrpAttachment
                    alignOrientation.Responsiveness = 200
                    alignOrientation.MaxTorque = math.huge
                    alignOrientation.Parent = hrp
                    local linearVelocity = Instance.new("LinearVelocity")
                    linearVelocity.Attachment0 = hrpAttachment
                    linearVelocity.RelativeTo = Enum.ActuatorRelativeTo.World
                    linearVelocity.MaxForce = math.huge
                    linearVelocity.VectorVelocity = Vector3.zero
                    linearVelocity.Parent = hrp
                    self.State.BodyMovers.HRPAttachment = hrpAttachment
                    self.State.BodyMovers.WorldAttachment = worldAttachment
                    self.State.BodyMovers.AlignOrientation = alignOrientation
                    self.State.BodyMovers.LinearVelocity = linearVelocity
                    local keys = {}
                    local function onInput(input, gameProcessed)
                    if not gameProcessed then
                        keys[input.KeyCode] = (input.UserInputState == Enum.UserInputState.Begin)
                    end
                end
                table.insert(self.State.Connections, UserInputService.InputBegan:Connect(onInput))
                table.insert(self.State.Connections, UserInputService.InputEnded:Connect(onInput))
                local loop = RunService.RenderStepped:Connect(function()
                    if not self.State.IsActive or not hrp.Parent then return end
                    local camera = workspace.CurrentCamera
                    alignOrientation.CFrame = camera.CFrame
                    local direction = Vector3.new()
                    if keys[Enum.KeyCode.W] then direction += camera.CFrame.LookVector end
                    if keys[Enum.KeyCode.S] then direction -= camera.CFrame.LookVector end
                    if keys[Enum.KeyCode.D] then direction += camera.CFrame.RightVector end
                    if keys[Enum.KeyCode.A] then direction -= camera.CFrame.RightVector end
                    if keys[Enum.KeyCode.Space] or keys[Enum.KeyCode.E] then direction += Vector3.yAxis end
                    if keys[Enum.KeyCode.LeftControl] or keys[Enum.KeyCode.Q] then direction -= Vector3.yAxis end
                    local speed = keys[Enum.KeyCode.LeftShift] and self.State.Speed * self.State.SprintMultiplier or self.
                    State.Speed
                    linearVelocity.VectorVelocity = direction.Magnitude > 0 and direction.Unit * speed or Vector3.zero
                end)
            table.insert(self.State.Connections, loop)
        end
        function Modules.Fly:Toggle()
            if self.State.IsActive then
                self:Disable()
            else
                self:Enable()
             end
         end
    RegisterCommand({ Name = "fly", Aliases = {"flight"}, Description = "The most boring exploit anyone can use." }, function()
         Modules.Fly:Toggle()
    end)
Modules.NoClip = {
    State = {
    IsEnabled = false,
    Connections = {},
    TrackedParts = setmetatable({}, {__mode = "k"})
    },
    Services = {
    Players = game:GetService("Players"),
    RunService = game:GetService("RunService")
}
}
function Modules.NoClip:_addPart(part)
    if not part:IsA("BasePart") then return end
    self.State.TrackedParts[part] = true
    part.CanCollide = false
end
function Modules.NoClip:_processCharacter(character)
    if not character then return end
    if self.State.Connections[character] then
        for _, conn in ipairs(self.State.Connections[character]) do conn:Disconnect() end
    end
    self.State.Connections[character] = {}
    for _, descendant in ipairs(character:GetDescendants()) do
        self:_addPart(descendant)
    end
    local descAddedConn = character.DescendantAdded:Connect(function(descendant)
        self:_addPart(descendant)
    end)
    local descRemovingConn = character.DescendantRemoving:Connect(function(descendant)
        if self.State.TrackedParts[descendant] then
            self.State.TrackedParts[descendant] = nil
        end
    end)
    table.insert(self.State.Connections[character], descAddedConn)
    table.insert(self.State.Connections[character], descRemovingConn)
end
function Modules.NoClip:_cleanup()
    for key, conn in pairs(self.State.Connections) do
        if type(conn) == "table" then
            for _, innerConn in ipairs(conn) do innerConn:Disconnect() end
        else
            conn:Disconnect()
        end
    end
    table.clear(self.State.Connections)
    for part in pairs(self.State.TrackedParts) do
        if part and part.Parent then
            part.CanCollide = true
        end
    end
    table.clear(self.State.TrackedParts)
end
function Modules.NoClip:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    local localPlayer = self.Services.Players.LocalPlayer
    if localPlayer.Character then
        self:_processCharacter(localPlayer.Character)
    end
    self.State.Connections.CharacterAdded = localPlayer.CharacterAdded:Connect(function(char)
        self:_processCharacter(char)
    end)
    self.State.Connections.Enforcer = self.Services.RunService.Stepped:Connect(function()
        for part in pairs(self.State.TrackedParts) do
            if part and part.Parent and part.CanCollide then
                part.CanCollide = false
            end
        end
    end)
    DoNotif("Persistent NoClip Enabled", 2)
end
function Modules.NoClip:Disable()
    if not self.State.IsEnabled then return end
    self.State.IsEnabled = false
    self:_cleanup()
    DoNotif("NoClip Disabled", 2)
end
function Modules.NoClip:Toggle()
    if self.State.IsEnabled then
        self:Disable()
    else
        self:Enable()
    end
end
RegisterCommand({ Name = "noclip", Aliases = {"nc"}, Description = "Allows you to walk through walls" }, function()
    Modules.NoClip:Toggle()
end)
Modules.RespawnAtDeath = {
    State = {
        Enabled = false,
        LastDeathCFrame = nil,
        DiedConnection = nil,
        CharacterConnection = nil,
    }
}
function Modules.RespawnAtDeath.OnDied()
    local character = Players.LocalPlayer.Character
    local root = character and character:FindFirstChild("HumanoidRootPart")
    if root then
        Modules.RespawnAtDeath.State.LastDeathCFrame = root.CFrame
        print("Death location saved.")
    end
end
function Modules.RespawnAtDeath.OnCharacterAdded(character)
    local humanoid = character:WaitForChild("Humanoid")
    if Modules.RespawnAtDeath.State.DiedConnection then
        Modules.RespawnAtDeath.State.DiedConnection:Disconnect()
    end
    Modules.RespawnAtDeath.State.DiedConnection = humanoid.Died:Connect(Modules.RespawnAtDeath.OnDied)
    local deathCFrame = Modules.RespawnAtDeath.State.LastDeathCFrame
    if deathCFrame then
        coroutine.wrap(function()
            print("Teleporting to saved death location...")
            task.wait(0.1)
            local root = character:WaitForChild("HumanoidRootPart")
            if not root then return end
            local originalAnchored = root.Anchored
            root.Anchored = true
            root.CFrame = deathCFrame
            RunService.Heartbeat:Wait()
            root.Anchored = originalAnchored
            Modules.RespawnAtDeath.State.LastDeathCFrame = nil
            print("Teleport successful.")
        end)()
    end
end
function Modules.RespawnAtDeath.Toggle()
    local localPlayer = Players.LocalPlayer
    Modules.RespawnAtDeath.State.Enabled = not Modules.RespawnAtDeath.State.Enabled
    if Modules.RespawnAtDeath.State.Enabled then
        print("revert: ENABLED")
        Modules.RespawnAtDeath.State.CharacterConnection = localPlayer.CharacterAdded:Connect(Modules.RespawnAtDeath.  OnCharacterAdded)
        if localPlayer.Character then
            Modules.RespawnAtDeath.OnCharacterAdded(localPlayer.Character)
        end
    else
        print("revert: DISABLED")
        if Modules.RespawnAtDeath.State.DiedConnection then
            Modules.RespawnAtDeath.State.DiedConnection:Disconnect()
            Modules.RespawnAtDeath.State.DiedConnection = nil
        end
        if Modules.RespawnAtDeath.State.CharacterConnection then
            Modules.RespawnAtDeath.State.CharacterConnection:Disconnect()
            Modules.RespawnAtDeath.State.CharacterConnection = nil
        end
        Modules.RespawnAtDeath.State.LastDeathCFrame = nil
    end
end
RegisterCommand({
    Name = "revert",
    Aliases = {"deathspawn", "spawnondeath"},
    Description = "Toggles respawning at your last death location."
}, function(args)
    Modules.RespawnAtDeath.Toggle()
end)
Modules.BypassDevProduct = {
    State = {
        Enabled = false
    }
}

RegisterCommand({
    Name = "bypassdevproduct",
    Aliases = {"bpdp", "unlockproducts"},
    Description = "Bypasses developer product purchase prompts."
}, function(args)
    Modules.BypassDevProduct.State.Enabled = not Modules.BypassDevProduct.State.Enabled
    
    if Modules.BypassDevProduct.State.Enabled then
        print("Developer product bypass enabled.")
        
        -- Hook PromptProductPurchase to simulate successful purchase
        local oldPromptProductPurchase
        oldPromptProductPurchase = hookfunction(MarketplaceService.PromptProductPurchase, function(...)
            if Modules.BypassDevProduct.State.Enabled then
                print("Blocked product purchase prompt.")
                return
            end
            return oldPromptProductPurchase(...)
        end)
    else
        print("Developer product bypass disabled.")
    end
end)
Modules.BypassGamepass = {
    State = {
        Enabled = false
    }
}

RegisterCommand({
    Name = "bypassgamepass",
    Aliases = {"bpgp", "unlockgamepasses"},
    Description = "Bypasses gamepass ownership checks."
}, function(args)
    local localPlayer = Players.LocalPlayer
    if not localPlayer then
        print("Error: Could not find LocalPlayer.")
        return
    end
    
    Modules.BypassGamepass.State.Enabled = not Modules.BypassGamepass.State.Enabled
    
    if Modules.BypassGamepass.State.Enabled then
        print("Gamepass bypass enabled.")
        
        -- Hook UserOwnsGamePassAsync
        local oldUserOwnsGamePassAsync
        oldUserOwnsGamePassAsync = hookfunction(MarketplaceService.UserOwnsGamePassAsync, function(self, userId, gamePassId)
            if userId == localPlayer.UserId and Modules.BypassGamepass.State.Enabled then
                return true
            end
            return oldUserOwnsGamePassAsync(self, userId, gamePassId)
        end)
    else
        print("Gamepass bypass disabled.")
    end
end)
Modules.JoinGame = {
    State = {}
}
RegisterCommand({
    Name = "joingame",
    Aliases = {"jg", "join"},
    Description = "Teleports you to a game by its PlaceId."
}, function(args)
    local localPlayer = Players.LocalPlayer
    if not localPlayer then
        print("Error: Could not find LocalPlayer.")
        return
    end
    
    -- Check if PlaceId was provided
    if not args[1] then
        print("Error: Please provide a PlaceId. Usage: joingame <PlaceId>")
        return
    end
    
    -- Convert the argument to a number
    local placeId = tonumber(args[1])
    if not placeId then
        print("Error: Invalid PlaceId. Please provide a valid number.")
        return
    end
    
    print("Joining game " .. placeId .. "... Please wait.")
    
    local success, errorMessage = pcall(function()
        TeleportService:Teleport(placeId, localPlayer)
    end)
    
    if not success then
        print("Join failed: " .. errorMessage)
    end
end)
Modules.WalkSpeed = {
    State = {
        DefaultSpeed = 16,
        CurrentSpeed = 16
    }
}
RegisterCommand({
    Name = "walkspeed",
    Aliases = {"ws", "speed"},
    Description = "Changes your walkspeed. Usage: walkspeed <number>"
}, function(args)
    local localPlayer = Players.LocalPlayer
    if not localPlayer then
        print("Error: Could not find LocalPlayer.")
        return
    end
    local character = localPlayer.Character
    if not character then
        print("Error: Character not found.")
        return
    end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then
        print("Error: Humanoid not found.")
        return
    end
    if not args[1] then
        print("Current walkspeed: " .. humanoid.WalkSpeed)
        print("Usage: walkspeed <number>")
        return
    end
    local newSpeed = tonumber(args[1])
    if not newSpeed then
        print("Error: Invalid speed. Please provide a valid number.")
        return
    end
    humanoid.WalkSpeed = newSpeed
    Modules.WalkSpeed.State.CurrentSpeed = newSpeed
    print("Walkspeed set to: " .. newSpeed)
    localPlayer.CharacterAdded:Connect(function(newCharacter)
        local newHumanoid = newCharacter:WaitForChild("Humanoid")
        newHumanoid.WalkSpeed = Modules.WalkSpeed.State.CurrentSpeed
        print("Walkspeed restored to: " .. Modules.WalkSpeed.State.CurrentSpeed)
    end)
end)
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
Modules.RejoinServer = {
    State = {}
}
RegisterCommand({
    Name = "rejoin",
    Aliases = {"rj", "reconnect"},
    Description = "Teleports you back to the current server."
}, function(args)
    local localPlayer = Players.LocalPlayer
    if not localPlayer then
        print("Error: Could not find LocalPlayer.")
        return
    end
    local placeId = game.PlaceId
    local jobId = game.JobId
    print("Rejoining server... Please wait.")
    local success, errorMessage = pcall(function()
        TeleportService:TeleportToPlaceInstance(placeId, jobId, localPlayer)
    end)
    if not success then
        print("Rejoin failed: " .. errorMessage)
    end
end)
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
Modules.AutoAttack = {
    State = {
        Enabled = false,
        ClickDelay = 0.1,
        Connection = nil,
        LastClickTime = 0,
        ToggleKey = Enum.KeyCode.H
    }
}
function Modules.AutoAttack:AttackLoop()
    if UserInputService:GetFocusedTextBox() then
        return
    end
    local currentTime = os.clock()
    if currentTime - self.State.LastClickTime > self.State.ClickDelay then
        mouse1press()
        task.wait()
        mouse1release()
        self.State.LastClickTime = currentTime
    end
end
function Modules.AutoAttack:Enable()
    self.State.Enabled = true
    self.State.LastClickTime = 0
    self.State.Connection = RunService.Heartbeat:Connect(function()
        self:AttackLoop()
    end)
    DoNotif("Auto-Attack: [Enabled] | Delay: " .. self.State.ClickDelay * 1000 .. "ms", 2)
end
function Modules.AutoAttack:Disable()
    self.State.Enabled = false
    if self.State.Connection then
        self.State.Connection:Disconnect()
        self.State.Connection = nil
    end
    DoNotif("Auto-Attack: [Disabled]", 2)
end
function Modules.AutoAttack:Toggle()
    if self.State.Enabled then
        self:Disable()
    else
        self:Enable()
    end
end
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed or UserInputService:GetFocusedTextBox() then
        return
    end
    if input.KeyCode == Modules.AutoAttack.State.ToggleKey then
        Modules.AutoAttack:Toggle()
    end
end)
RegisterCommand({
    Name = "autoattack",
    Aliases = {"autoclick"},
    Description = "Toggles auto-click. Usage: ;aa [delay_ms | key key_name]"
}, function(args)
    local subCommand = args[1] and args[1]:lower()
    local value = args[2]
    if subCommand == "key" then
        if value and Enum.KeyCode[value:upper()] then
            local newKey = Enum.KeyCode[value:upper()]
            Modules.AutoAttack.State.ToggleKey = newKey
            DoNotif("Auto-Attack toggle key set to: " .. value:upper(), 2)
        else
            DoNotif("Invalid key name. Example: E, Q, F, MouseButton1", 3)
        end
        return
    end
    local newDelay = tonumber(subCommand)
    if newDelay and newDelay > 0 then
        Modules.AutoAttack.State.ClickDelay = newDelay / 1000
        DoNotif("Auto-Attack delay set to: " .. newDelay .. "ms", 2)
        return
    end
    Modules.AutoAttack:Toggle()
end)
Modules.killbrick = {
    State = {
        Tracked = setmetatable({}, {__mode = "k"}),
        Originals = setmetatable({}, {__mode = "k"}),
        Signals = setmetatable({}, {__mode = "k"}),
        Connections = {},
        Enabled = false,
        LastCleanup = 0,
        Stats = {
            PartsProtected = 0,
            AttemptsBlocked = 0,
            LastReset = tick()
        }
    },
    Config = {
        CleanupInterval = 30,
        UseHeartbeat = false,
        ProtectAccessories = true,
        ProtectTools = true,
        WhitelistedParts = {},
        DebugMode = false
    }
}
local function debugLog(message)
    if Modules.killbrick.Config.DebugMode then
        print("[KillBrick Debug]", message)
    end
end
local function cleanupAntiKillbrick()
    local state = Modules.killbrick.State
    debugLog("Starting cleanup...")
    for i = #state.Connections, 1, -1 do
        local conn = state.Connections[i]
        if conn and typeof(conn) == "RBXScriptConnection" then
            pcall(function() conn:Disconnect() end)
        end
        state.Connections[i] = nil
    end
    for part, signalTable in pairs(state.Signals) do
        if signalTable then
            for i = #signalTable, 1, -1 do
                local conn = signalTable[i]
                if conn and typeof(conn) == "RBXScriptConnection" then
                    pcall(function() conn:Disconnect() end)
                end
                signalTable[i] = nil
            end
        end
    end
    for part, originalValue in pairs(state.Originals) do
        if typeof(part) == "Instance" and part:IsA("BasePart") then
            pcall(function()
                part.CanTouch = originalValue
            end)
        end
    end
    table.clear(state.Signals)
    table.clear(state.Tracked)
    table.clear(state.Originals)
    state.LastCleanup = tick()
    debugLog("Cleanup completed")
end
local function isPartWhitelisted(part)
    local state = Modules.killbrick.State
    for _, whitelistedPart in ipairs(Modules.killbrick.Config.WhitelistedParts) do
        if part == whitelistedPart or part:IsDescendantOf(whitelistedPart) then
            return true
        end
    end
    return false
end
local function shouldProtectPart(part)
    if not (part and typeof(part) == "Instance" and part:IsA("BasePart")) then
        return false
    end
    if isPartWhitelisted(part) then
        return false
    end
    local character = Players.LocalPlayer.Character
    if not character or not part:IsDescendantOf(character) then
        return false
    end
    if not Modules.killbrick.Config.ProtectAccessories and part:FindFirstAncestorOfClass("Accessory") then
        return false
    end
    if not Modules.killbrick.Config.ProtectTools and part:FindFirstAncestorOfClass("Tool") then
        return false
    end
    return true
end
local function applyProtection(part)
    local state = Modules.killbrick.State
    if not shouldProtectPart(part) then
        return
    end
    if state.Originals[part] == nil then
        state.Originals[part] = part.CanTouch
    end
    local success = pcall(function()
        part.CanTouch = false
    end)
    if not success then
        debugLog("Failed to protect part: " .. tostring(part))
        return
    end
    state.Tracked[part] = true
    state.Stats.PartsProtected = state.Stats.PartsProtected + 1
    if not state.Signals[part] then
        local connection = part:GetPropertyChangedSignal("CanTouch"):Connect(function()
            if not state.Enabled then return end
            if part.CanTouch ~= false then
                pcall(function()
                    part.CanTouch = false
                    state.Stats.AttemptsBlocked = state.Stats.AttemptsBlocked + 1
                    debugLog("Blocked CanTouch change on: " .. tostring(part))
                end)
            end
        end)
        state.Signals[part] = {connection}
    end
end
local function setupCharacter(character)
    if not character then return end
    local state = Modules.killbrick.State
    debugLog("Setting up character: " .. tostring(character))
    for _, descendant in ipairs(character:GetDescendants()) do
        applyProtection(descendant)
    end
    local addedConn = character.DescendantAdded:Connect(function(descendant)
        if state.Enabled then
            task.defer(applyProtection, descendant)
        end
    end)
    table.insert(state.Connections, addedConn)
    local removingConn = character.DescendantRemoving:Connect(function(descendant)
        if state.Signals[descendant] then
            for _, conn in ipairs(state.Signals[descendant]) do
                pcall(function() conn:Disconnect() end)
            end
            state.Signals[descendant] = nil
        end
        state.Tracked[descendant] = nil
        state.Originals[descendant] = nil
    end)
    table.insert(state.Connections, removingConn)
end
local function onCharacterAdded(character)
    debugLog("Character added, reinitializing...")
    task.wait(0.1)
    cleanupAntiKillbrick()
    if Modules.killbrick.State.Enabled then
        setupCharacter(character)
    end
end
function Modules.killbrick.Enable()
    local state = Modules.killbrick.State
    if state.Enabled then
        warn("[KillBrick] Already enabled")
        return
    end
    state.Enabled = true
    state.Stats.LastReset = tick()
    cleanupAntiKillbrick()
    local localPlayer = Players.LocalPlayer
    if localPlayer.Character then
        setupCharacter(localPlayer.Character)
    end
    local charAddedConn = localPlayer.CharacterAdded:Connect(onCharacterAdded)
    table.insert(state.Connections, charAddedConn)
    local charRemovingConn = localPlayer.CharacterRemoving:Connect(function()
        debugLog("Character removing...")
    end)
    table.insert(state.Connections, charRemovingConn)
    local updateEvent = Modules.killbrick.Config.UseHeartbeat and RunService.Heartbeat or RunService.Stepped
    local updateConn = updateEvent:Connect(function()
        if not state.Enabled then return end
        local character = localPlayer.Character
        if not character then return end
        if tick() - state.LastCleanup > Modules.killbrick.Config.CleanupInterval then
            local tracked = {}
            for part in pairs(state.Tracked) do
                if typeof(part) == "Instance" and part:IsA("BasePart") and part.Parent then
                    tracked[part] = true
                else
                    state.Tracked[part] = nil
                    state.Originals[part] = nil
                    if state.Signals[part] then
                        for _, conn in ipairs(state.Signals[part]) do
                            pcall(function() conn:Disconnect() end)
                        end
                        state.Signals[part] = nil
                    end
                end
            end
            state.LastCleanup = tick()
        end
        for part in pairs(state.Tracked) do
            if typeof(part) == "Instance" and part:IsA("BasePart") and part.Parent then
                if part.CanTouch ~= false then
                    pcall(function()
                        part.CanTouch = false
                        state.Stats.AttemptsBlocked = state.Stats.AttemptsBlocked + 1
                    end)
                end
            end
        end
    end)
    table.insert(state.Connections, updateConn)
    DoNotif("Anti-KillBrick Enabled", 2)
    debugLog("Protection enabled with " .. state.Stats.PartsProtected .. " parts")
end
function Modules.killbrick.Disable()
    local state = Modules.killbrick.State
    if not state.Enabled then
        warn("[KillBrick] Already disabled")
        return
    end
    state.Enabled = false
    cleanupAntiKillbrick()
    DoNotif("Anti-KillBrick Disabled", 2)
    debugLog("Protection disabled")
end
function Modules.killbrick.Toggle()
    if Modules.killbrick.State.Enabled then
        Modules.killbrick.Disable()
    else
        Modules.killbrick.Enable()
    end
end
function Modules.killbrick.GetStats()
    local state = Modules.killbrick.State
    local uptime = tick() - state.Stats.LastReset
    return {
        Enabled = state.Enabled,
        PartsProtected = state.Stats.PartsProtected,
        AttemptsBlocked = state.Stats.AttemptsBlocked,
        Uptime = uptime,
        TrackedParts = 0
    }
end
function Modules.killbrick.AddWhitelist(part)
    if not (part and typeof(part) == "Instance") then
        return false
    end
    table.insert(Modules.killbrick.Config.WhitelistedParts, part)
    debugLog("Added whitelist: " .. tostring(part))
    return true
end
function Modules.killbrick.RemoveWhitelist(part)
    for i, whitelisted in ipairs(Modules.killbrick.Config.WhitelistedParts) do
        if whitelisted == part then
            table.remove(Modules.killbrick.Config.WhitelistedParts, i)
            debugLog("Removed whitelist: " .. tostring(part))
            return true
        end
    end
    return false
end
function Modules.killbrick.ClearWhitelist()
    table.clear(Modules.killbrick.Config.WhitelistedParts)
    debugLog("Cleared whitelist")
end
RegisterCommand({
    Name = "antikillbrick",
    Aliases = {"antikb", "akb"},
    Description = "Prevents kill bricks from killing you."
}, function(args)
    Modules.killbrick.Enable()
end)
RegisterCommand({
    Name = "unantikillbrick",
    Aliases = {"unantikb", "unakb"},
    Description = "Allows kill bricks to kill you again."
}, function(args)
    Modules.killbrick.Disable()
end)
RegisterCommand({
    Name = "togglekillbrick",
    Aliases = {"tkb"},
    Description = "Toggles kill brick protection."
}, function(args)
    Modules.killbrick.Toggle()
end)
RegisterCommand({
    Name = "killbrickstats",
    Aliases = {"kbstats"},
    Description = "Shows kill brick protection statistics."
}, function(args)
    local stats = Modules.killbrick.GetStats()
    print("=== Kill Brick Protection Stats ===")
    print("Enabled:", stats.Enabled)
    print("Parts Protected:", stats.PartsProtected)
    print("Attempts Blocked:", stats.AttemptsBlocked)
    print("Uptime:", string.format("%.1f", stats.Uptime) .. "s")
end)
Modules.FlingProtection = {
State = {
IsEnabled = false,
SteppedConnection = nil,
PlayerConnections = {}
},
Config = {
MAX_VELOCITY_MAGNITUDE = 200,
LOCAL_PLAYER_GROUP = "LocalPlayerCollisionGroup",
OTHER_PLAYERS_GROUP = "OtherPlayersCollisionGroup"
}
}
function Modules.FlingProtection:_setCollisionGroupForCharacter(character, groupName)
    if not character then return end
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                pcall(function() part.CollisionGroup = groupName end)
            end
        end
    end
    function Modules.FlingProtection:_setupPlayerCollisions()
        local PhysicsService = game:GetService("PhysicsService")
        pcall(function() PhysicsService:CreateCollisionGroup(self.Config.LOCAL_PLAYER_GROUP) end)
        pcall(function() PhysicsService:CreateCollisionGroup(self.Config.OTHER_PLAYERS_GROUP) end)
        PhysicsService:CollisionGroupSetCollidable(self.Config.LOCAL_PLAYER_GROUP, self.Config.OTHER_PLAYERS_GROUP, false)
        for _, player in ipairs(Players:GetPlayers()) do
            local group = (player == LocalPlayer) and self.Config.LOCAL_PLAYER_GROUP or self.Config.OTHER_PLAYERS_GROUP
            if player.Character then
                self:_setCollisionGroupForCharacter(player.Character, group)
            end
            local conn = player.CharacterAdded:Connect(function(character)
            self:_setCollisionGroupForCharacter(character, group)
        end)
        table.insert(self.State.PlayerConnections, conn)
    end
    local conn = Players.PlayerAdded:Connect(function(player)
    local group = self.Config.OTHER_PLAYERS_GROUP
    local charConn = player.CharacterAdded:Connect(function(character)
    self:_setCollisionGroupForCharacter(character, group)
end)
table.insert(self.State.PlayerConnections, charConn)
end)
table.insert(self.State.PlayerConnections, conn)
end
function Modules.FlingProtection:_revertPlayerCollisions()
    for _, conn in ipairs(self.State.PlayerConnections) do
        conn:Disconnect()
    end
    self.State.PlayerConnections = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character then
            self:_setCollisionGroupForCharacter(player.Character, "Default")
        end
    end
end
function Modules.FlingProtection:_enforceStability()
    local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not (hrp and not hrp.Anchored) then return end
        if hrp.AssemblyLinearVelocity.Magnitude > self.Config.MAX_VELOCITY_MAGNITUDE then
            hrp.AssemblyLinearVelocity = Vector3.zero
        end
    end
    function Modules.FlingProtection:Toggle()
        self.State.IsEnabled = not self.State.IsEnabled
        if self.State.IsEnabled then
            DoNotif("Fling & Player Collision Protection: ENABLED", 2)
            self:_setupPlayerCollisions()
            self.State.SteppedConnection = RunService.Stepped:Connect(function() self:_enforceStability() end)
        else
        DoNotif("Fling & Player Collision Protection: DISABLED", 2)
        self:_revertPlayerCollisions()
        if self.State.SteppedConnection then
            self.State.SteppedConnection:Disconnect()
            self.State.SteppedConnection = nil
        end
    end
end
do
	local ATTRIBUTE_OG_SIZE = "Zuka_OriginalSize"
	local SELECTION_BOX_NAME = "Zuka_ReachSelectionBox"
	local activeTool: Tool? = nil
	local modifiedPart: BasePart? = nil
	local persistentToolName: string? = nil
	local persistentPartName: string? = nil
	local currentReachSize: number = 20
	local currentReachType: "directional" | "box" = "directional"
	Modules.ReachController = {
		State = {
			IsEnabled = false,
			UI = nil,
			Connections = {}
		}
	}
	local function updatePartModification(part: BasePart, newSize: number?, reachType: string?)
		if not part or not part.Parent then return end
		local originalSize = part:GetAttribute(ATTRIBUTE_OG_SIZE)
		if not newSize then
			if originalSize then part.Size = originalSize; part:SetAttribute(ATTRIBUTE_OG_SIZE, nil) end
			local selectionBox = part:FindFirstChild(SELECTION_BOX_NAME)
			if selectionBox then selectionBox:Destroy() end
			return
		end
		if not originalSize then part:SetAttribute(ATTRIBUTE_OG_SIZE, part.Size) end
		local selectionBox = part:FindFirstChild(SELECTION_BOX_NAME) or Instance.new("SelectionBox")
		selectionBox.Name = SELECTION_BOX_NAME; selectionBox.Adornee = part; selectionBox.LineThickness = 0.02; selectionBox.Parent = part
		selectionBox.Color3 = reachType == "box" and Color3.fromRGB(0, 100, 255) or Color3.fromRGB(255, 0, 0)
		if reachType == "box" then part.Size = Vector3.one * newSize else part.Size = Vector3.new(part.Size.X, part.Size.Y, newSize) end
		part.Massless = true
	end
	local function resetReach()
		if not modifiedPart and not persistentToolName then print("Reach is not active."); return end
		local tool; if persistentToolName then tool = (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild(persistentToolName)) or (LocalPlayer.Backpack and LocalPlayer.Backpack:FindFirstChild(persistentToolName)) end
		local partToReset = modifiedPart or (tool and persistentPartName and tool:FindFirstChild(persistentPartName, true))
		if partToReset then updatePartModification(partToReset, nil, nil) end
		modifiedPart, persistentToolName, persistentPartName = nil, nil, nil
		print("Tool reach has been fully reset.")
	end
	function Modules.ReachController:Enable()
		if self.State.IsEnabled then return end
		self.State.IsEnabled = true
		local ui = Instance.new("ScreenGui"); ui.Name = "ReachController_Zuka"; ui.ZIndexBehavior = Enum.ZIndexBehavior.Global; ui.ResetOnSpawn = false
		self.State.UI = ui
		local mainFrame = Instance.new("Frame", ui); mainFrame.Size = UDim2.fromOffset(250, 320); mainFrame.Position = UDim2.fromScale(0, 0); mainFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 45); mainFrame.BorderSizePixel = 0; mainFrame.ClipsDescendants = true
		Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 8); Instance.new("UIStroke", mainFrame).Color = Color3.fromRGB(80, 80, 100)
		local titleBar = Instance.new("Frame", mainFrame); titleBar.Name = "TitleBar"; titleBar.Size = UDim2.new(1, 0, 0, 30); titleBar.BackgroundColor3 = Color3.fromRGB(25, 25, 35); titleBar.BorderSizePixel = 0
		local title = Instance.new("TextLabel", titleBar); title.Size = UDim2.new(1, -30, 1, 0); title.Position = UDim2.fromOffset(10, 0); title.BackgroundTransparency = 1; title.Font = Enum.Font.GothamSemibold; title.Text = "Reach Controller"; title.TextColor3 = Color3.fromRGB(200, 220, 255); title.TextSize = 16; title.TextXAlignment = Enum.TextXAlignment.Left
		local contentFrame = Instance.new("Frame", mainFrame); contentFrame.Name = "Content"; contentFrame.Size = UDim2.new(1, 0, 1, -30); contentFrame.Position = UDim2.new(0, 0, 0, 30); contentFrame.BackgroundTransparency = 1
		local toggleButton = Instance.new("TextButton", titleBar); toggleButton.Size = UDim2.fromOffset(20, 20); toggleButton.Position = UDim2.new(1, -10, 0.5, 0); toggleButton.AnchorPoint = Vector2.new(1, 0.5); toggleButton.BackgroundColor3 = Color3.fromRGB(80, 80, 100); toggleButton.Text = "-"; toggleButton.Font = Enum.Font.GothamBold; toggleButton.TextColor3 = Color3.new(1, 1, 1); Instance.new("UICorner", toggleButton).CornerRadius = UDim.new(0, 4)
		titleBar.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 then local dragStart, startPos = input.Position, mainFrame.Position; local moveConn, endConn; moveConn = UserInputService.InputChanged:Connect(function(moveInput) if moveInput.UserInputType == Enum.UserInputType.MouseMovement then local delta = moveInput.Position - dragStart; mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y) end end); endConn = UserInputService.InputEnded:Connect(function(endInput) if endInput.UserInputType == Enum.UserInputType.MouseButton1 then moveConn:Disconnect(); endConn:Disconnect() end end) end end)
		local sizeLabel = Instance.new("TextLabel", contentFrame); sizeLabel.Size = UDim2.fromOffset(80, 20); sizeLabel.Position = UDim2.fromOffset(10, 10); sizeLabel.BackgroundTransparency = 1; sizeLabel.Font = Enum.Font.Gotham; sizeLabel.Text = "Reach Size:"; sizeLabel.TextColor3 = Color3.new(1, 1, 1); sizeLabel.TextXAlignment = Enum.TextXAlignment.Left
		local sizeInput = Instance.new("TextBox", contentFrame); sizeInput.Size = UDim2.fromOffset(130, 30); sizeInput.Position = UDim2.fromOffset(110, 5); sizeInput.BackgroundColor3 = Color3.fromRGB(50, 50, 65); sizeInput.Font = Enum.Font.Code; sizeInput.Text = tostring(currentReachSize); sizeInput.TextColor3 = Color3.new(1, 1, 1); Instance.new("UICorner", sizeInput).CornerRadius = UDim.new(0, 4)
		local directionalBtn = Instance.new("TextButton", contentFrame); directionalBtn.Size = UDim2.fromOffset(110, 30); directionalBtn.Position = UDim2.fromOffset(10, 40); directionalBtn.BackgroundColor3 = Color3.fromRGB(80, 80, 100); directionalBtn.Font = Enum.Font.GothamSemibold; directionalBtn.Text = "Directional"; directionalBtn.TextColor3 = Color3.new(1, 1, 1); Instance.new("UICorner", directionalBtn).CornerRadius = UDim.new(0, 4)
		local boxBtn = Instance.new("TextButton", contentFrame); boxBtn.Size = UDim2.fromOffset(110, 30); boxBtn.Position = UDim2.fromOffset(130, 40); boxBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 65); boxBtn.Font = Enum.Font.GothamSemibold; boxBtn.Text = "Box"; boxBtn.TextColor3 = Color3.new(1, 1, 1); Instance.new("UICorner", boxBtn).CornerRadius = UDim.new(0, 4)
		local partsLabel = Instance.new("TextLabel", contentFrame); partsLabel.Size = UDim2.fromOffset(80, 20); partsLabel.Position = UDim2.fromOffset(10, 75); partsLabel.BackgroundTransparency = 1; partsLabel.Font = Enum.Font.Gotham; partsLabel.Text = "Tool Parts:"; partsLabel.TextColor3 = Color3.new(1, 1, 1); partsLabel.TextXAlignment = Enum.TextXAlignment.Left
		local scroll = Instance.new("ScrollingFrame", contentFrame); scroll.Size = UDim2.new(1, -20, 1, -140); scroll.Position = UDim2.fromOffset(10, 100); scroll.BackgroundColor3 = Color3.fromRGB(25, 25, 35); scroll.BorderSizePixel = 0; scroll.ScrollBarThickness = 6
		local resetBtn = Instance.new("TextButton", contentFrame); resetBtn.Size = UDim2.new(1, -20, 0, 30); resetBtn.Position = UDim2.new(0.5, 0, 1, -10); resetBtn.AnchorPoint = Vector2.new(0.5, 1); resetBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50); resetBtn.Font = Enum.Font.GothamBold; resetBtn.Text = "Reset Reach"; resetBtn.TextColor3 = Color3.new(1, 1, 1); Instance.new("UICorner", resetBtn).CornerRadius = UDim.new(0, 4)
		local function populatePartSelector()
			scroll:ClearAllChildren(); if not activeTool then return end
			local parts = {}; for _, d in ipairs(activeTool:GetDescendants()) do if d:IsA("BasePart") then table.insert(parts, d) end end
			if #parts == 0 then return end
			local listLayout = Instance.new("UIListLayout", scroll); listLayout.Padding = UDim.new(0, 5); listLayout.SortOrder = Enum.SortOrder.LayoutOrder
			for _, part in ipairs(parts) do
				local btn = Instance.new("TextButton", scroll); btn.Size = UDim2.new(1, -10, 0, 30); btn.Position = UDim2.fromScale(0.5, 0); btn.AnchorPoint = Vector2.new(0.5, 0); btn.BackgroundColor3 = Color3.fromRGB(50, 50, 65); btn.TextColor3 = Color3.fromRGB(220, 220, 230); btn.Font = Enum.Font.Code; btn.Text = part.Name; btn.TextSize = 14; Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 4)
				btn.MouseButton1Click:Connect(function()
					if not part or not part.Parent or not activeTool then print("Reach Error: Part/tool missing."); return end
					persistentToolName, persistentPartName = activeTool.Name, part.Name
					if modifiedPart and modifiedPart ~= part then updatePartModification(modifiedPart, nil, nil) end
					modifiedPart = part; updatePartModification(part, currentReachSize, currentReachType)
					print(string.format("Reach set for '%s' on tool '%s'.", part.Name, activeTool.Name))
				end)
			end
		end
		sizeInput.FocusLost:Connect(function() local num = tonumber(sizeInput.Text); if num and num > 0 then currentReachSize = num else sizeInput.Text = tostring(currentReachSize) end end)
		directionalBtn.MouseButton1Click:Connect(function() currentReachType = "directional"; directionalBtn.BackgroundColor3 = Color3.fromRGB(80, 80, 100); boxBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 65) end)
		boxBtn.MouseButton1Click:Connect(function() currentReachType = "box"; boxBtn.BackgroundColor3 = Color3.fromRGB(80, 80, 100); directionalBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 65) end)
		resetBtn.MouseButton1Click:Connect(resetReach)
		toggleButton.MouseButton1Click:Connect(function() contentFrame.Visible = not contentFrame.Visible; toggleButton.Text = contentFrame.Visible and "-" or "+"; mainFrame.Size = contentFrame.Visible and UDim2.fromOffset(250, 320) or UDim2.fromOffset(250, 30) end)
		local function onToolEquipped(tool)
			activeTool = tool; populatePartSelector()
			if self.State.Connections.Unequipped then self.State.Connections.Unequipped:Disconnect() end
			self.State.Connections.Unequipped = tool.Unequipped:Connect(function() activeTool = nil; populatePartSelector() end)
		end
		local function onCharacterAdded(character)
			if persistentToolName and persistentPartName then
				local function reapply(tool) if tool and tool.Name == persistentToolName then local part = tool:WaitForChild(persistentPartName, 2); if part and part:IsA("BasePart") then updatePartModification(part, currentReachSize, currentReachType); modifiedPart = part end end end
				reapply(character:FindFirstChild(persistentToolName)); self.State.Connections["Reapply"..character.Name] = character.ChildAdded:Connect(function(child) if child:IsA("Tool") then reapply(child) end end)
			end
			self.State.Connections["ToolListener"..character.Name] = character.ChildAdded:Connect(function(child) if child:IsA("Tool") then onToolEquipped(child) end end)
			local firstTool = character:FindFirstChildOfClass("Tool"); if firstTool then onToolEquipped(firstTool) end
		end
		if LocalPlayer.Character then onCharacterAdded(LocalPlayer.Character) end
		self.State.Connections.CharacterAdded = LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
		ui.Parent = CoreGui
		DoNotif("Reach Controller: ENABLED.", 2)
	end
	function Modules.ReachController:Disable()
		if not self.State.IsEnabled then return end
		self.State.IsEnabled = false
		resetReach()
		if self.State.UI and self.State.UI.Parent then self.State.UI:Destroy() end
		self.State.UI = nil
		for _, conn in pairs(self.State.Connections) do conn:Disconnect() end
		table.clear(self.State.Connections)
		DoNotif("Reach Controller: DISABLED.", 2)
	end
	function Modules.ReachController:Toggle()
		if self.State.IsEnabled then self:Disable() else self:Enable() end
	end
end
RegisterCommand({ Name = "reachgui", Aliases = { "reachcontroller" }, Description = "Toggles a GUI for advanced tool reach modification." }, function() Modules.ReachController:Toggle() end)
Modules.Reach = {
Connections = {},
State = {
IsEnabled = false,
ActiveTool = nil,
ModifiedPart = nil,
PersistentToolName = nil,
PersistentPartName = nil,
ReachType = nil,
ReachSize = nil,
UI = {
ScreenGui = nil,
Frame = nil,
ScrollingFrame = nil,
CloseButton = nil
}
}
}
local ATTRIBUTE_OG_SIZE = "OriginalSize"
local SELECTION_BOX_NAME = "ReachSelectionBox"
function Modules.Reach:_updatePartModification(part, newSize, reachType)
    if not part or not part.Parent then return end
        local originalSize = part:GetAttribute(ATTRIBUTE_OG_SIZE)
        if not newSize then
            if originalSize then
                part.Size = originalSize
                part:SetAttribute(ATTRIBUTE_OG_SIZE, nil)
            end
            if part:FindFirstChild(SELECTION_BOX_NAME) then
                part[SELECTION_BOX_NAME]:Destroy()
            end
            return
        end
        if not originalSize then
            part:SetAttribute(ATTRIBUTE_OG_SIZE, part.Size)
        end
        local selectionBox = part:FindFirstChild(SELECTION_BOX_NAME)
        if not selectionBox then
            selectionBox = Instance.new("SelectionBox", part)
            selectionBox.Name = SELECTION_BOX_NAME
            selectionBox.Adornee = part
            selectionBox.LineThickness = 0.02
        end
        selectionBox.Color3 = reachType == "box" and Color3.fromRGB(0, 100, 255) or Color3.fromRGB(255, 0, 0)
        if reachType == "box" then
            part.Size = Vector3.one * newSize
        else
        part.Size = Vector3.new(part.Size.X, part.Size.Y, newSize)
    end
    part.Massless = true
end
function Modules.Reach:_populatePartSelector()
    local self = Modules.Reach
    local scroll = self.State.UI.ScrollingFrame
    for _, child in ipairs(scroll:GetChildren()) do
        if child:IsA("TextButton") then
            child:Destroy()
        end
    end
    if not self.State.ActiveTool then return end
        local parts = {}
        for _, descendant in ipairs(self.State.ActiveTool:GetDescendants()) do
            if descendant:IsA("BasePart") then
                table.insert(parts, descendant)
            end
        end
        if #parts == 0 then
            DoNotif("Equipped tool has no physical parts.", 3)
            return
        end
        for _, part in ipairs(parts) do
            local btn = Instance.new("TextButton", scroll)
            btn.Size = UDim2.new(1, 0, 0, 30)
            btn.BackgroundColor3 = Color3.fromRGB(50, 50, 65)
            btn.TextColor3 = Color3.fromRGB(220, 220, 230)
            btn.Font = Enum.Font.Code
            btn.Text = part.Name
            btn.TextSize = 14
            Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 4)
            btn.MouseButton1Click:Connect(function()
            if not part or not part.Parent or not self.State.ActiveTool then
                self.State.UI.ScreenGui.Enabled = false
                return DoNotif("The selected part or tool no longer exists.", 3)
            end
            self.State.PersistentToolName = self.State.ActiveTool.Name
            self.State.PersistentPartName = part.Name
            if self.State.ModifiedPart and self.State.ModifiedPart ~= part then
                self:_updatePartModification(self.State.ModifiedPart)
            end
            self.State.IsEnabled = true
            self.State.ModifiedPart = part
            self:_updatePartModification(part, self.State.ReachSize, self.State.ReachType)
            self.State.UI.ScreenGui.Enabled = false
            DoNotif("Persistently set reach for " .. part.Name .. " on " .. self.State.PersistentToolName, 3)
        end)
    end
end
function Modules.Reach:_onToolEquipped(tool)
    local self = Modules.Reach
    self.State.ActiveTool = tool
    self:_populatePartSelector()
    if self.Connections.Unequipped then self.Connections.Unequipped:Disconnect() end
        self.Connections.Unequipped = tool.Unequipped:Connect(function()
        self.State.ActiveTool = nil
        self.State.UI.ScreenGui.Enabled = false
    end)
end
function Modules.Reach:_onCharacterAdded(character)
    local self = Modules.Reach
    if self.State.PersistentToolName and self.State.PersistentPartName then
        local function reapplyModification(tool)
        if tool and tool.Name == self.State.PersistentToolName then
            local part = tool:WaitForChild(self.State.PersistentPartName, 5)
            if part then
                self:_updatePartModification(part, self.State.ReachSize, self.State.ReachType)
                self.State.ModifiedPart = part
                self.State.IsEnabled = true
            end
        end
    end
    local equippedTool = character:FindFirstChild(self.State.PersistentToolName)
    reapplyModification(equippedTool)
    character.ChildAdded:Connect(function(child)
    if child:IsA("Tool") then
        reapplyModification(child)
    end
end)
end
character.ChildAdded:Connect(function(child)
if child:IsA("Tool") then self:_onToolEquipped(child) end
end)
local firstEquippedTool = character:FindFirstChildOfClass("Tool")
if firstEquippedTool then self:_onToolEquipped(firstEquippedTool) end
end
function Modules.Reach:Apply(reachType, size)
    local self = Modules.Reach
    if not self.State.ActiveTool then
        return DoNotif("You must have a tool equipped to select a part.", 3)
    end
    self.State.ReachType = reachType
    self.State.ReachSize = size
    self:_populatePartSelector()
    self.State.UI.ScreenGui.Enabled = true
end
function Modules.Reach:Reset()
    local self = Modules.Reach
    if not self.State.IsEnabled and not self.State.PersistentToolName then
        return DoNotif("Reach is not active and no part is set.", 3)
    end
    local tool
    if self.State.PersistentToolName then
        tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild(self.State.PersistentToolName)
        if not tool then
            tool = LocalPlayer.Backpack and LocalPlayer.Backpack:FindFirstChild(self.State.PersistentToolName)
        end
    end
    if tool and self.State.PersistentPartName then
        local part = tool:FindFirstChild(self.State.PersistentPartName, true)
        if part then
            self:_updatePartModification(part)
        end
    end
    self.State.IsEnabled = false
    self.State.ModifiedPart = nil
    self.State.PersistentToolName = nil
    self.State.PersistentPartName = nil
    self.State.ReachType = nil
    self.State.ReachSize = nil
    if self.State.UI.ScreenGui then
        self.State.UI.ScreenGui.Enabled = false
    end
    DoNotif("Tool reach has been fully reset and persistence cleared.", 3)
end
function Modules.Reach:Initialize()
    local self = Modules.Reach
    local ui = Instance.new("ScreenGui")
    ui.Name = "ReachPartSelector_Persistent"
    ui.Parent = CoreGui
    ui.Enabled = false
    ui.ZIndexBehavior = Enum.ZIndexBehavior.Global
    ui.ResetOnSpawn = false
    self.State.UI.ScreenGui = ui
    local frame = Instance.new("Frame", ui)
    frame.Size = UDim2.fromOffset(250, 220)
    frame.Position = UDim2.new(0.5, -125, 0.5, -110)
    frame.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    frame.Draggable = true
    Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 8)
    self.State.UI.Frame = frame
    local title = Instance.new("TextLabel", frame)
    title.Size = UDim2.new(1, 0, 0, 30)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.Code
    title.Text = "Select a Part to Modify"
    title.TextColor3 = Color3.fromRGB(200, 220, 255)
    title.TextSize = 16
    local scroll = Instance.new("ScrollingFrame", frame)
    scroll.Size = UDim2.new(1, -20, 1, -50)
    scroll.Position = UDim2.fromOffset(10, 35)
    scroll.BackgroundColor3 = frame.BackgroundColor3
    scroll.BorderSizePixel = 0
    scroll.ScrollBarThickness = 6
    self.State.UI.ScrollingFrame = scroll
    local layout = Instance.new("UIListLayout", scroll)
    layout.Padding = UDim.new(0, 5)
    layout.SortOrder = Enum.SortOrder.LayoutOrder
    local closeBtn = Instance.new("TextButton", frame)
    closeBtn.Size = UDim2.fromOffset(20, 20)
    closeBtn.Position = UDim2.new(1, -25, 0, 5)
    closeBtn.BackgroundColor3 = Color3.fromRGB(80, 40, 50)
    closeBtn.Text = "X"
    closeBtn.Font = Enum.Font.Code
    closeBtn.TextColor3 = Color3.fromRGB(255, 180, 180)
    closeBtn.MouseButton1Click:Connect(function() ui.Enabled = false end)
    Instance.new("UICorner", closeBtn).CornerRadius = UDim.new(0, 4)
    self.State.UI.CloseButton = closeBtn
    if LocalPlayer.Character then
        self:_onCharacterAdded(LocalPlayer.Character)
    end
    self.Connections.CharacterAdded = LocalPlayer.CharacterAdded:Connect(function(char)
    self:_onCharacterAdded(char)
end)
RegisterCommand({Name = "reach", Aliases = {"swordreach"}, Description = "Extends sword reach. ;reach [num]"}, function(args)
self:Apply("directional", tonumber(args[1]) or 15)
end)
RegisterCommand({Name = "boxreach", Aliases = {}, Description = "Creates a box hitbox. ;boxreach [num]"}, function(args)
self:Apply("box", tonumber(args[1]) or 15)
end)
RegisterCommand({Name = "resetreach", Aliases = {"unreach"}, Description = "Resets tool reach and clears persistent setting."}, function()
self:Reset()
end)
end
RegisterCommand({Name = "goto", Aliases = {}, Description = "Teleports to a player. ;goto [player]"}, function(args)
if not args[1] then
    return DoNotif("Specify a player's name.", 3)
end
local targetPlayer = Utilities.findPlayer(args[1])
if targetPlayer then
    local localHRP = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    local targetHRP = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if localHRP and targetHRP then
        localHRP.CFrame = targetHRP.CFrame + Vector3.new(0, 3, 0)
        DoNotif("Teleported to " .. targetPlayer.Name, 3)
    else
    DoNotif("Target player's character could not be found.", 3)
end
else
DoNotif("Player not found.", 3)
end
end)
Modules.AdvancedFling = {
    State = {
        IsFlinging = false
    }
}
local function findFlingTargets(targetName)
    local targets = {}
    local localPlayer = Players.LocalPlayer
    local lowerTargetName = targetName and targetName:lower() or "nil"
    if not targetName or lowerTargetName == "me" then
        return { localPlayer }
    end
    if lowerTargetName == "all" then
        return Players:GetPlayers()
    end
    if lowerTargetName == "others" then
        for _, p in ipairs(Players:GetPlayers()) do
            if p ~= localPlayer then table.insert(targets, p) end
        end
        return targets
    end
    if lowerTargetName == "random" then
        local allPlayers = Players:GetPlayers()
        if #allPlayers > 1 then
            local potentialTargets = {}
            for _, p in ipairs(allPlayers) do
                if p ~= localPlayer then table.insert(potentialTargets, p) end
            end
            if #potentialTargets > 0 then
                return { potentialTargets[math.random(1, #potentialTargets)] }
            end
        end
        return {}
    end
    if lowerTargetName == "nearest" then
        local nearestPlayer, minDist = nil, math.huge
        local localRoot = localPlayer.Character and localPlayer.Character.PrimaryPart
        if not localRoot then return {} end
        for _, p in ipairs(Players:GetPlayers()) do
            if p ~= localPlayer and p.Character and p.Character.PrimaryPart then
                local dist = (p.Character.PrimaryPart.Position - localRoot.Position).Magnitude
                if dist < minDist then
                    minDist = dist
                    nearestPlayer = p
                end
            end
        end
        if nearestPlayer then return { nearestPlayer } end
        return {}
    end
    for _, p in ipairs(Players:GetPlayers()) do
        if p.Name:lower():match("^"..lowerTargetName) or p.DisplayName:lower():match("^"..lowerTargetName) then
            table.insert(targets, p)
        end
    end
    return targets
end
function Modules.AdvancedFling:Execute(targetPlayer)
    if self.State.IsFlinging then return DoNotif("Fling already in progress.", 2) end
    local localCharacter = LocalPlayer.Character
    local localHumanoid = localCharacter and localCharacter:FindFirstChildOfClass("Humanoid")
    local localRootPart = localHumanoid and localHumanoid.RootPart
    if not (localRootPart and targetPlayer.Character) then
        return DoNotif("Cannot fling: A required character is missing.", 3)
    end
    self.State.IsFlinging = true
    local originalPosition = localRootPart.CFrame
    local originalCameraSubject = Workspace.CurrentCamera.CameraSubject
    local originalDestroyHeight = Workspace.FallenPartsDestroyHeight
    task.spawn(function()
        local success, err = pcall(function()
            local TCharacter = targetPlayer.Character
            local THumanoid = TCharacter and TCharacter:FindFirstChildOfClass("Humanoid")
            local TRootPart = THumanoid and THumanoid.RootPart
            local THead = TCharacter and TCharacter:FindFirstChild("Head")
            local Accessory = TCharacter and TCharacter:FindFirstChildOfClass("Accessory")
            local Handle = Accessory and Accessory:FindFirstChild("Handle")
            if not (TCharacter and THumanoid) then
                error("Target character or humanoid not found.")
            end
            if THumanoid.Sit then
                return DoNotif("Fling failed: Target is sitting.", 3)
            end
            if THead then
                Workspace.CurrentCamera.CameraSubject = THead
            elseif Handle then
                Workspace.CurrentCamera.CameraSubject = Handle
            elseif THumanoid then
                Workspace.CurrentCamera.CameraSubject = THumanoid
            end
            if not TCharacter:FindFirstChildWhichIsA("BasePart") then
                return
            end
            local function FPos(BasePart, Pos, Ang)
                localRootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
                localCharacter:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
                localRootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
                localRootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
            end
            local function SFBasePart(BasePart)
                local TimeToWait = 2
                local Time = tick()
                local Angle = 0
                repeat
                    if localRootPart and THumanoid and BasePart and BasePart.Parent then
                        if BasePart.Velocity.Magnitude < 50 then
                            Angle = Angle + 100
                            FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                            task.wait()
                            FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                            task.wait()
                            FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                            task.wait()
                            FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                            task.wait()
                        else
                            FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                            task.wait()
                            FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
                            task.wait()
                            FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                            task.wait()
                            FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))
                            task.wait()
                        end
                    else
                        break
                    end
                until BasePart.Velocity.Magnitude > 500
                    or not BasePart.Parent
                    or BasePart.Parent ~= TCharacter
                    or not targetPlayer.Parent
                    or THumanoid.Sit
                    or localHumanoid.Health <= 0
                    or tick() > Time + TimeToWait
            end
            Workspace.FallenPartsDestroyHeight = 0/0
            localHumanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
            local primaryFlingPart
            if TRootPart and THead and (TRootPart.Position - THead.Position).Magnitude > 5 then
                primaryFlingPart = THead
            elseif TRootPart then
                primaryFlingPart = TRootPart
            elseif THead then
                primaryFlingPart = THead
            elseif Handle then
                primaryFlingPart = Handle
            else
                return DoNotif("Fling failed: Target is missing critical parts.", 3)
            end
            SFBasePart(primaryFlingPart)
        end)
        pcall(function()
            localHumanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
            Workspace.CurrentCamera.CameraSubject = localCharacter
            Workspace.FallenPartsDestroyHeight = originalDestroyHeight
            repeat
                if localRootPart and localRootPart.Parent then
                    localRootPart.CFrame = originalPosition
                    localRootPart.Velocity, localRootPart.RotVelocity = Vector3.new(), Vector3.new()
                end
                task.wait()
            until not self.State.IsFlinging or not localRootPart.Parent or (localRootPart.Position - originalPosition.Position).Magnitude < 25
        end)
        if not success then
            warn("Fling Error:", err)
            DoNotif("Fling failed. Target may have reset or left.", 3)
        else
            DoNotif("Fling sequence complete.", 2)
        end
        self.State.IsFlinging = false
    end)
end
RegisterCommand({ Name = "fling", Aliases = {"fl"}, Description = "Fling a player." }, function(args)
    local targetName = args[1]
    if not targetName then
        return DoNotif("Usage: ;fling <player|all|others|random|nearest>", 3)
    end
    local targets = findFlingTargets(targetName)
    if #targets == 0 then
        return DoNotif("No valid target found.", 3)
    end
    if #targets > 1 then
        DoNotif("Flinging multiple targets...", 2)
    else
        DoNotif("Target found: " .. targets[1].Name, 2)
    end
    for _, targetPlayer in ipairs(targets) do
        if targetPlayer ~= LocalPlayer then
            Modules.AdvancedFling:Execute(targetPlayer)
            task.wait(0.1)
        end
    end
end)
Modules.SetSpawnPoint = {
State = {
CustomSpawnCFrame = nil,
CharacterAddedConnection = nil
}
}
function Modules.SetSpawnPoint:OnCharacterAdded(newCharacter)
    if not self.State.CustomSpawnCFrame then return end
        local rootPart = newCharacter:WaitForChild("HumanoidRootPart", 5)
        if rootPart then
            task.wait()
            rootPart.CFrame = self.State.CustomSpawnCFrame
        end
    end
    RegisterCommand({
    Name = "setspawnpoint",
    Aliases = {"setspawn", "ssp"},
    Description = "Sets your respawn point to your current location. Use 'clear' to reset."
    }, function(args)
    local localPlayer = Players.LocalPlayer
    local commandArg = args[1] and string.lower(args[1])
    if commandArg == "clear" or commandArg == "reset" then
        if Modules.SetSpawnPoint.State.CustomSpawnCFrame then
            Modules.SetSpawnPoint.State.CustomSpawnCFrame = nil
            print("Custom spawn point cleared. You will now use the default spawn.")
            if Modules.SetSpawnPoint.State.CharacterAddedConnection then
                Modules.SetSpawnPoint.State.CharacterAddedConnection:Disconnect()
                Modules.SetSpawnPoint.State.CharacterAddedConnection = nil
            end
        else
        print("No custom spawn point was set.")
    end
    return
end
local character = localPlayer and localPlayer.Character
local rootPart = character and character:FindFirstChild("HumanoidRootPart")
if not rootPart then
    print("Error: Could not set spawn point. Player character not found.")
    return
end
Modules.SetSpawnPoint.State.CustomSpawnCFrame = rootPart.CFrame
print("Custom spawn point set at: " .. tostring(rootPart.Position))
if not Modules.SetSpawnPoint.State.CharacterAddedConnection then
    Modules.SetSpawnPoint.State.CharacterAddedConnection = localPlayer.CharacterAdded:Connect(function(char)
    Modules.SetSpawnPoint:OnCharacterAdded(char)
end)
end
end)
Modules.NoclipStabilizer = {
State = {
Enabled = false,
Connection = nil
}
}
function Modules.NoclipStabilizer:_OnStepped()
    local character = Players.LocalPlayer and Players.LocalPlayer.Character
    local rootPart = character and character:FindFirstChild("HumanoidRootPart")
    if rootPart then
        rootPart.Velocity = Vector3.new(0, 0, 0)
        rootPart.RotVelocity = Vector3.new(0, 0, 0)
    end
end
function Modules.NoclipStabilizer:Enable()
    if self.State.Enabled then return end
        self.State.Enabled = true
        self.State.Connection = RunService.Stepped:Connect(function()
        self:_OnStepped()
    end)
    DoNotif("Noclip Stabilizer: [Enabled]", 3)
end
function Modules.NoclipStabilizer:Disable()
    if not self.State.Enabled then return end
        self.State.Enabled = false
        if self.State.Connection then
            self.State.Connection:Disconnect()
            self.State.Connection = nil
        end
        DoNotif("Noclip Stabilizer: [Disabled]", 3)
    end
    RegisterCommand({
    Name = "antirubberband",
    Aliases = {"antirb", "arb"},
    Description = "Toggles the Noclip Stabilizer to prevent server-side rubberbanding."
    }, function(args)
    if Modules.NoclipStabilizer.State.Enabled then
        Modules.NoclipStabilizer:Disable()
    else
    Modules.NoclipStabilizer:Enable()
end
end)
Modules.AntiReset = {
    State = {
        IsEnabled = false,
        CharacterConnections = {}
    }
}
function Modules.AntiReset:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    local function applyAntiReset(character)
        if not character then return end
        local humanoid = character:WaitForChild("Humanoid", 2)
        local hrp = character:WaitForChild("HumanoidRootPart", 2)
        if not (humanoid and hrp) then return end
        for _, connection in pairs(self.State.CharacterConnections) do
            if connection then connection:Disconnect() end
        end
        table.clear(self.State.CharacterConnections)
        local isResetting = false
        self.State.CharacterConnections.HealthChanged = humanoid:GetPropertyChangedSignal("Health"):Connect(function()
            if humanoid.Health <= 0 and not isResetting then
                isResetting = true
                humanoid.Health = humanoid.MaxHealth
                isResetting = false
            end
        end)
        local lastSafePosition = hrp.Position
        local fallenPartsHeight = Workspace.FallenPartsDestroyHeight
        self.State.CharacterConnections.Heartbeat = RunService.Heartbeat:Connect(function()
            if not hrp or not hrp.Parent then return end
            if hrp.Position.Y < fallenPartsHeight then
                hrp.CFrame = CFrame.new(lastSafePosition)
                hrp.Velocity = Vector3.new(0, 0, 0)
            elseif humanoid.FloorMaterial ~= Enum.Material.Air then
                lastSafePosition = hrp.Position
            end
        end)
    end
    if LocalPlayer.Character then
        applyAntiReset(LocalPlayer.Character)
    end
    self.State.CharacterConnections.Added = LocalPlayer.CharacterAdded:Connect(applyAntiReset)
    DoNotif("Anti-Reset: ENABLED.", 2)
end
function Modules.AntiReset:Disable()
    if not self.State.IsEnabled then return end
    self.State.IsEnabled = false
    for _, connection in pairs(self.State.CharacterConnections) do
        if connection then connection:Disconnect() end
    end
    table.clear(self.State.CharacterConnections)
    DoNotif("Anti-Reset: DISABLED.", 2)
end
function Modules.AntiReset:Toggle()
    if self.State.IsEnabled then
        self:Disable()
    else
        self:Enable()
    end
end
Modules.NetCommander = {
    State = {
        PinnedRemote = nil,
        PinnedPath = "",
        LastResult = nil
    },
    Dependencies = {"HttpService", "ReplicatedStorage"}
}
function Modules.NetCommander:_resolvePath(path)
    if not path or path == "" then return nil end
    local current = game
    path = path:gsub("^RS%.", "ReplicatedStorage.")
    path = path:gsub("^WS%.", "Workspace.")
    path = path:gsub("^game%.", "")
    path = path:gsub("^Workspace%.", "workspace.")
    local serviceName = path:match("^:GetService%(['\"](.+)['\"]%)")
    if serviceName then
        local success, service = pcall(game.GetService, game, serviceName)
        if success and service then
            current = service
            path = path:gsub("^:GetService%(['\"](.+)['\"]%)%.?", "")
        end
    end
    if path == "" then return current end
    for segment in string.gmatch(path, "([^%.]+)") do
        if current then
            local found = current:FindFirstChild(segment)
            if not found then
                local midService = segment:match("GetService%(['\"](.+)['\"]%)")
                if midService then
                    current = game:GetService(midService)
                else
                    current = nil
                    break
                end
            else
                current = found
            end
        end
    end
    return current
end
function Modules.NetCommander:_parseArgs(argsTable)
    local processed = {}
    for _, arg in ipairs(argsTable) do
        local lower = arg:lower()
        if tonumber(arg) then
            table.insert(processed, tonumber(arg))
        elseif lower == "true" then
            table.insert(processed, true)
        elseif lower == "false" then
            table.insert(processed, false)
        elseif lower == "nil" then
            table.insert(processed, nil)
        elseif arg:sub(1,1) == "{" and arg:sub(-1,-1) == "}" then
            local success, tbl = pcall(function()
                return game:GetService("HttpService"):JSONDecode(arg)
            end)
            table.insert(processed, success and tbl or arg)
        elseif lower == "me" or lower == "localplayer" then
            table.insert(processed, game:GetService("Players").LocalPlayer)
        else
            table.insert(processed, arg)
        end
    end
    return processed
end
function Modules.NetCommander:Execute(pathArray, isInvoke)
    local target = nil
    local remainingArgs = {}
    local resolvedPath = ""
    for i = 1, #pathArray do
        local testPath = table.concat(pathArray, " ", 1, i)
        local result = self:_resolvePath(testPath)
        if result then
            target = result
            resolvedPath = testPath
            remainingArgs = {}
            for j = i + 1, #pathArray do
                table.insert(remainingArgs, pathArray[j])
            end
        end
    end
    if not target then
        return DoNotif("Target not found: " .. table.concat(pathArray, " "), 3)
    end
    local cleanArgs = self:_parseArgs(remainingArgs)
    if target:IsA("RemoteEvent") then
        local success, err = pcall(function() target:FireServer(unpack(cleanArgs)) end)
        if success then
            DoNotif("Fired Event: " .. target.Name, 2)
        else
            warn("--> [NET]: FireServer Error:", err)
            DoNotif("FireServer Failed. Check F9.", 3)
        end
    elseif target:IsA("RemoteFunction") then
        DoNotif("Invoking Function...", 1.5)
        task.spawn(function()
            local success, result = pcall(function() return target:InvokeServer(unpack(cleanArgs)) end)
            if success then
                print("--> [NET]: Invoke Result for " .. target.Name .. ":", result)
                self.State.LastResult = result
                DoNotif("Invoke Success. Result in F9.", 3)
            else
                warn("--> [NET]: Invoke Failed:", result)
                DoNotif("Invoke FAILED.", 3)
            end
        end)
    else
        DoNotif("Error: '" .. target.Name .. "' is a " .. target.ClassName .. " (Not a Remote).", 3)
    end
end
function Modules.NetCommander:Initialize()
    local module = self
    module.Services = {
        HttpService = game:GetService("HttpService"),
        Players = game:GetService("Players")
    }
    RegisterCommand({
        Name = "fire",
        Aliases = {"fremote", "rf"},
        Description = "Fires a RemoteEvent. Handles paths with spaces."
    }, function(args)
        if #args < 1 then return DoNotif("Usage: ;fire [Path] [Args]", 3) end
        module:Execute(args, false)
    end)
    RegisterCommand({
        Name = "invoke",
        Aliases = {"inv", "rfcall"},
        Description = "Invokes a RemoteFunction. Handles paths with spaces."
    }, function(args)
        if #args < 1 then return DoNotif("Usage: ;inv [Path] [Args]", 3) end
        module:Execute(args, true)
    end)
    RegisterCommand({
        Name = "pin",
        Aliases = {"mark"},
        Description = "Pins a remote path."
    }, function(args)
        if not args[1] then return DoNotif("Usage: ;pin [Path]", 3) end
        module.State.PinnedPath = table.concat(args, " ")
        DoNotif("Pinned: " .. module.State.PinnedPath, 2)
    end)
    RegisterCommand({
        Name = "runpin",
        Aliases = {"r"},
        Description = "Runs the pinned remote."
    }, function(args)
        if module.State.PinnedPath == "" then return DoNotif("No remote pinned.", 3) end
        local combinedArgs = {}
        for part in string.gmatch(module.State.PinnedPath, "%S+") do
            table.insert(combinedArgs, part)
        end
        for _, arg in ipairs(args) do
            table.insert(combinedArgs, arg)
        end
        module:Execute(combinedArgs, false)
    end)
end
RegisterCommand({
    Name = "antireset",
    Aliases = {"noreset", "ar"},
    Description = "Toggles a system that prevents your character from resetting."
}, function()
    Modules.AntiReset:Toggle()
end)
Modules.AntiCFrameTeleport = {
MAX_SPEED = 70,
MAX_STEP_DIST = 8,
REPEAT_THRESHOLD = 3,
LOCK_TIME = 0.1,
State = {
Enabled = false,
HeartbeatConnection = nil,
CharacterAddedConnection = nil,
LastCFrame = nil,
LastTimestamp = 0,
DetectionHits = 0
}
}
function Modules.AntiCFrameTeleport:_zeroVelocity(character)
    for _, descendant in ipairs(character:GetDescendants()) do
        if descendant:IsA("BasePart") then
            descendant.AssemblyLinearVelocity = Vector3.zero
            descendant.AssemblyAngularVelocity = Vector3.zero
        end
    end
end
function Modules.AntiCFrameTeleport:_getFlyAllowances(deltaTime)
    local maxSpeed, maxDist = self.MAX_SPEED, self.MAX_STEP_DIST
    if not (getfenv(0).NAmanage and NAmanage._state and getfenv(0).FLYING) then
        return maxSpeed, maxDist
    end
    local mode = NAmanage._state.mode or "none"
    local flyVars = getfenv(0).flyVariables or {}
    if mode == "fly" then
        local speed = tonumber(flyVars.flySpeed) or 1
        local velocity = speed * 50
        maxSpeed = math.max(maxSpeed, velocity * 1.4)
        maxDist = math.max(maxDist, velocity * deltaTime * 3)
    elseif mode == "vfly" then
        local speed = tonumber(flyVars.vFlySpeed) or 1
        local velocity = speed * 50
        maxSpeed = math.max(maxSpeed, velocity * 1.4)
        maxDist = math.max(maxDist, velocity * deltaTime * 3)
    elseif mode == "cfly" then
        local speed = tonumber(flyVars.cFlySpeed) or 1
        local step = speed * 2
        maxDist = math.max(self.MAX_STEP_DIST, step)
        maxSpeed = math.max(self.MAX_SPEED, (maxDist / deltaTime) * 1.25)
    elseif mode == "tfly" then
        local speed = tonumber(flyVars.TflySpeed) or 1
        local step = speed * 2.5
        maxDist = math.max(self.MAX_STEP_DIST, step)
        maxSpeed = math.max(self.MAX_SPEED, (maxDist / deltaTime) * 1.5)
    end
    return maxSpeed, maxDist
end
function Modules.AntiCFrameTeleport:_onCharacterAdded(character)
    local rootPart = character:WaitForChild("HumanoidRootPart", 5)
    if rootPart then
        self.State.LastCFrame = rootPart.CFrame
        self.State.LastTimestamp = os.clock()
        self.State.DetectionHits = 0
    end
end
function Modules.AntiCFrameTeleport:_onHeartbeat()
    local character = Players.LocalPlayer.Character
    local rootPart = character and character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
        local now = os.clock()
        local deltaTime = math.max(now - (self.State.LastTimestamp or now), 1/240)
        local currentCFrame = rootPart.CFrame
        if not self.State.LastCFrame then
            self.State.LastCFrame, self.State.LastTimestamp = currentCFrame, now
            return
        end
        local distance = (currentCFrame.Position - self.State.LastCFrame.Position).Magnitude
        local speed = distance / deltaTime
        local maxAllowedSpeed, maxAllowedDistance = self:_getFlyAllowances(deltaTime)
        if distance > maxAllowedDistance or speed > maxAllowedSpeed then
            character:PivotTo(self.State.LastCFrame)
            self:_zeroVelocity(character)
            self.State.DetectionHits += 1
            if self.State.DetectionHits >= self.REPEAT_THRESHOLD then
                task.delay(self.LOCK_TIME, function()
                self.State.DetectionHits = 0
            end)
        end
    else
    self.State.DetectionHits = math.max(self.State.DetectionHits - 1, 0)
    self.State.LastCFrame = currentCFrame
end
self.State.LastTimestamp = now
end
function Modules.AntiCFrameTeleport:Enable()
    if self.State.Enabled then return end
        self.State.Enabled = true
        if Players.LocalPlayer.Character then
            self:_onCharacterAdded(Players.LocalPlayer.Character)
        end
        self.State.CharacterAddedConnection = Players.LocalPlayer.CharacterAdded:Connect(function(char)
        self:_onCharacterAdded(char)
    end)
    self.State.HeartbeatConnection = RunService.Heartbeat:Connect(function()
    self:_onHeartbeat()
end)
DoNotif("Anti-CFrame Teleport: [Enabled]", 3)
end
function Modules.AntiCFrameTeleport:Disable()
    if not self.State.Enabled then return end
        self.State.Enabled = false
        if self.State.HeartbeatConnection then
            self.State.HeartbeatConnection:Disconnect()
            self.State.HeartbeatConnection = nil
        end
        if self.State.CharacterAddedConnection then
            self.State.CharacterAddedConnection:Disconnect()
            self.State.CharacterAddedConnection = nil
        end
        self.State.LastCFrame = nil
        self.State.LastTimestamp = 0
        self.State.DetectionHits = 0
        DoNotif("Anti-CFrame Teleport: [Disabled]", 3)
    end
    RegisterCommand({
    Name = "anticframetp",
    Aliases = {"acftp", "antiteleport"},
    Description = "Toggles a client-side anti-teleport to prevent CFrame changes."
    }, function(args)
    if Modules.AntiCFrameTeleport.State.Enabled then
        Modules.AntiCFrameTeleport:Disable()
    else
    Modules.AntiCFrameTeleport:Enable()
end
end)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
Modules.FireRemotes = {
State = {
Enabled = false,
},
}
function Modules.FireRemotes:Initialize()
    RegisterCommand({
    Name = "fireremotes",
    Aliases = {"fremotes", "frem"},
    Description = "Attempts to fire every discoverable RemoteEvent and RemoteFunction."
    }, function(args)
    local CoreGui = game:GetService("CoreGui")
    local remoteCount = 0
    local failedCount = 0
    for _, obj in ipairs(game:GetDescendants()) do
        if (obj:IsA("RemoteEvent") or obj:IsA("RemoteFunction")) and not obj:IsDescendantOf(CoreGui) then
            task.spawn(function()
            local success, err
            if obj:IsA("RemoteEvent") then
                success, err = pcall(function()
                obj:FireServer()
            end)
        elseif obj:IsA("RemoteFunction") then
            success, err = pcall(function()
            obj:InvokeServer()
        end)
    end
    if success then
        remoteCount = remoteCount + 1
    else
    failedCount = failedCount + 1
end
end)
end
end
task.delay(2, function()
DoNotif("Fired " .. remoteCount .. " remotes.\nFailed: " .. failedCount .. " remotes.")
end)
end)
end
Modules.RemoveForces = {
State = {},
}
function Modules.RemoveForces:Initialize()
    RegisterCommand({
    Name = "deletevelocity",
    Aliases = {"dv", "removevelocity", "removeforces"},
    Description = "Removes all force/velocity instances from your character to counter flings or fix physics glitches."
    }, function(args)
    local Players = game:GetService("Players")
    local localPlayer = Players.LocalPlayer
    local character = localPlayer.Character
    if not character then
        return DoNotif("Character not found.", 3)
    end
    local forcesRemoved = 0
    for _, instance in ipairs(character:GetDescendants()) do
        if  instance:isA("BodyVelocity") or
            instance:isA("BodyGyro") or
            instance:isA("RocketPropulsion") or
            instance:isA("BodyAngularVelocity") or
            instance:isA("BodyForce") or
            instance:isA("BodyThrust") or
            instance:isA("VectorForce") or
            instance:isA("LineForce") or
            instance:isA("AngularVelocity")
            then
                instance:Destroy()
                forcesRemoved = forcesRemoved + 1
            end
        end
        DoNotif("Removed " .. forcesRemoved .. " force instances from your character.", 3)
    end)
end
Modules.TeleportToPlace = {
State = {},
}
function Modules.TeleportToPlace:Initialize()
    RegisterCommand({
    Name = "teleporttoplace",
    Aliases = {"toplace", "ttp"},
    Description = "Teleports you to a specific Roblox place using its ID."
    }, function(args)
    local TeleportService = game:GetService("TeleportService")
    local Players = game:GetService("Players")
    local localPlayer = Players.LocalPlayer
    if not args[1] then
        return DoNotif("Usage: teleporttoplace [PlaceId]", 5)
    end
    local placeId = tonumber(args[1])
    if not placeId then
        return DoNotif("Invalid PlaceId. It must be a number.", 5)
    end
    DoNotif("Attempting to teleport to " .. placeId .. "...", 3)
    local success, result = pcall(function()
    TeleportService:Teleport(placeId, localPlayer)
end)
if not success then
    DoNotif("Teleport failed: " .. tostring(result), 5)
end
end)
end
Modules.ToSpawn = {
State = {
Enabled = false,
},
}
function Modules.ToSpawn:Initialize()
    RegisterCommand({
    Name = "tospawn",
    Aliases = {"ts"},
    Description = "Teleports you to the nearest SpawnLocation."
    }, function(args)
    local Players = game:GetService("Players")
    local Workspace = game:GetService("Workspace")
    local localPlayer = Players.LocalPlayer
    local character = localPlayer.Character
    if not character then
        return DoNotif("Character not found.", 3)
    end
    local root = character:FindFirstChild("HumanoidRootPart")
    if not root then
        return DoNotif("HumanoidRootPart not found.", 3)
    end
    local closestSpawn = nil
    local shortestDistance = math.huge
    local rootPosition = root.Position
    for _, part in ipairs(Workspace:GetDescendants()) do
        if part:IsA("SpawnLocation") then
            local distance = (part.Position - rootPosition).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                closestSpawn = part
            end
        end
    end
    if closestSpawn then
        root.CFrame = closestSpawn.CFrame * CFrame.new(0, 3, 0)
    else
    return DoNotif("No SpawnLocation found in workspace.", 3)
end
end)
end
Modules.TriggerRemoteTouch = {
    State = {
        IsExecuting = false,
        FoundParts = {}
    },
    Services = {
        Players = game:GetService("Players"),
        Workspace = game:GetService("Workspace"),
        RunService = game:GetService("RunService")
    }
}
function Modules.TriggerRemoteTouch:_triggerPart(targetPart)
    if not targetPart then return end
    local hrp = self.Services.Players.LocalPlayer.Character and self.Services.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    DoNotif("Triggering: " .. targetPart:GetFullName(), 1)
    if firetouchinterest then
        pcall(function()
            firetouchinterest(hrp, targetPart, 0)
            self.Services.RunService.Heartbeat:Wait()
            firetouchinterest(hrp, targetPart, 1)
        end)
    else
        warn("TriggerRemoteTouch: 'firetouchinterest' not found. Using CFrame fallback.")
        local originalCFrame = hrp.CFrame
        pcall(function()
            hrp.CFrame = targetPart.CFrame
            self.Services.RunService.Heartbeat:Wait()
            hrp.CFrame = originalCFrame
        end)
    end
end
function Modules.TriggerRemoteTouch:Scan()
    if self.State.IsExecuting then return DoNotif("An operation is already in progress.", 2) end
    self.State.IsExecuting = true
    DoNotif("Scanning for all touch-interactive parts...", 3)
    task.spawn(function()
        table.clear(self.State.FoundParts)
        local count = 0
        for i, descendant in ipairs(self.Services.Workspace:GetDescendants()) do
            if descendant:IsA("TouchInterest") then
                local part = descendant.Parent
                if part and part:IsA("BasePart") then
                    table.insert(self.State.FoundParts, part)
                    count = count + 1
                end
            end
            if i % 200 == 0 then task.wait() end
        end
        DoNotif("Scan complete. Found " .. count .. " interactive parts.", 3)
        self.State.IsExecuting = false
    end)
end
function Modules.TriggerRemoteTouch:TriggerAll()
    if self.State.IsExecuting then return DoNotif("An operation is already in progress.", 2) end
    if #self.State.FoundParts == 0 then
        return DoNotif("No parts found. Run ';touch scan' first.", 3)
    end
    self.State.IsExecuting = true
    DoNotif("Beginning sequence to trigger all " .. #self.State.FoundParts .. " parts.", 3)
    task.spawn(function()
        for _, part in ipairs(self.State.FoundParts) do
            if not self.State.IsExecuting then break end
            self:_triggerPart(part)
            task.wait(0.5)
        end
        DoNotif("Trigger sequence finished.", 2)
        self.State.IsExecuting = false
    end)
end
function Modules.TriggerRemoteTouch:TriggerSingle(keyword)
    if not keyword then return DoNotif("Usage: ;touch single <keyword>", 3) end
    if self.State.IsExecuting then return DoNotif("An operation is already in progress.", 2) end
    if #self.State.FoundParts == 0 then
        return DoNotif("No parts found. Run ';touch scan' first.", 3)
    end
    local lowerKeyword = keyword:lower()
    for _, part in ipairs(self.State.FoundParts) do
        if part:GetFullName():lower():find(lowerKeyword, 1, true) then
            self:_triggerPart(part)
            return
        end
    end
    DoNotif("No scanned part found matching '" .. keyword .. "'.", 3)
end
function Modules.TriggerRemoteTouch:Initialize()
    local module = self
    RegisterCommand({
        Name = "touch",
        Aliases = {"remotetouch", "trigger"},
        Description = "Scans and triggers touch-interest parts."
    }, function(args)
        local subCommand = args[1] and args[1]:lower()
        if subCommand == "scan" then
            module:Scan()
        elseif subCommand == "all" then
            module:TriggerAll()
        elseif subCommand == "single" then
            module:TriggerSingle(args[2])
        else
            DoNotif("Usage: ;touch <scan|all|single> [keyword]", 4)
        end
    end)
end
Modules.ScriptHunter = {
    State = {
        IsScanning = false
    }
}
function Modules.ScriptHunter:Execute(keywords)
    local self = Modules.ScriptHunter
    if self.State.IsScanning then return DoNotif("A script scan is already in progress.", 2) end
    if not keywords or #keywords == 0 then return DoNotif("Usage: ;huntscript <keyword1> [keyword2] ...", 3) end
    self.State.IsScanning = true
    DoNotif("Beginning script hunt for keywords: " .. table.concat(keywords, ", "), 3)
    task.spawn(function()
        local findings = {}
        local scriptsScanned = 0
        for _, script in ipairs(game:GetDescendants()) do
            if script:IsA("LuaSourceContainer") then
                local success, source = pcall(function() return script.Source end)
                if success and source then
                    scriptsScanned = scriptsScanned + 1
                    local lowerSource = source:lower()
                    local allKeywordsFound = true
                    for _, keyword in ipairs(keywords) do
                        if not lowerSource:find(keyword:lower(), 1, true) then
                            allKeywordsFound = false
                            break
                        end
                    end
                    if allKeywordsFound then
                        table.insert(findings, script:GetFullName())
                    end
                end
            end
            if scriptsScanned % 100 == 0 then task.wait() end
        end
        if #findings > 0 then
            DoNotif("Scan complete. Found " .. #findings .. " matching script(s). Results printed to console (F9).", 4)
            print("--- [Zuka's ScriptHunter Report] ---")
            for _, path in ipairs(findings) do
                print("  [!] Match Found: " .. path)
            end
            print("--------------------------------------")
        else
            DoNotif("Scan complete. No scripts found containing all specified keywords.", 3)
        end
        self.State.IsScanning = false
    end)
end
function Modules.ScriptHunter:Initialize()
    local module = self
    RegisterCommand({
        Name = "huntscript",
        Aliases = {"findscript", "scripthunt"},
        Description = "Scans all client scripts for keywords."
    }, function(args)
        module:Execute(args)
    end)
end
local ContextActionService = game:GetService("ContextActionService")
Modules.AdvancedAirwalk = {
    State = {
        IsEnabled = false,
        AirwalkPart = nil,
        RenderConnection = nil,
        Connections = {},
        GUIs = {},
        IsTyping = false,
        Increase = false,
        Decrease = false,
        Offset = 0,
        LastValidRoot = nil,
        SmoothOffset = 0
    },
    Config = {
        VerticalSpeed = 1.75,
        SmoothSpeed = 0.15,
        Keybinds = {
            Increase = Enum.KeyCode.Space,
            Decrease = Enum.KeyCode.LeftControl
        },
        DisableOnDeath = false,
        ShowPlatform = false
    },
    Services = {
        RunService = game:GetService("RunService"),
        UserInputService = game:GetService("UserInputService"),
        Players = game:GetService("Players"),
        Workspace = game:GetService("Workspace"),
        CoreGui = game:GetService("CoreGui")
    }
}
function Modules.AdvancedAirwalk:Disable()
    if not self.State.IsEnabled then
        return
    end
    if self.State.RenderConnection then
        self.State.RenderConnection:Disconnect()
        self.State.RenderConnection = nil
    end
    if self.State.AirwalkPart and self.State.AirwalkPart.Parent then
        self.State.AirwalkPart:Destroy()
    end
    self.State.AirwalkPart = nil
    for key, conn in pairs(self.State.Connections) do
        if conn then
            conn:Disconnect()
        end
        self.State.Connections[key] = nil
    end
    for key, gui in pairs(self.State.GUIs) do
        if gui and gui.Parent then
            gui:Destroy()
        end
        self.State.GUIs[key] = nil
    end
    self.State.IsEnabled = false
    self.State.IsTyping = false
    self.State.Increase = false
    self.State.Decrease = false
    self.State.Offset = 0
    self.State.SmoothOffset = 0
    self.State.LastValidRoot = nil
    DoNotif("Advanced Airwalk: OFF", 2)
end
function Modules.AdvancedAirwalk:Enable()
    if self.State.IsEnabled then
        self:Disable()
    end
    self.State.IsEnabled = true
    local localPlayer = self.Services.Players.LocalPlayer
    local uis = self.Services.UserInputService
    local isMobile = uis.TouchEnabled
    DoNotif(isMobile and "Advanced Airwalk: ON" or "Advanced Airwalk: ON (Space & LCtrl)", 2)
    local function createMobileButton(parent, text, position, callbackDown, callbackUp)
        local button = Instance.new("TextButton")
        button.Parent = parent
        button.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
        button.Position = position
        button.Size = UDim2.new(0.08, 0, 0.12, 0)
        button.Font = Enum.Font.SourceSansBold
        button.Text = text
        button.TextColor3 = Color3.fromRGB(255, 255, 255)
        button.TextScaled = true
        Instance.new("UICorner", button).CornerRadius = UDim.new(0.2, 0)
        local stroke = Instance.new("UIStroke", button)
        stroke.Color = Color3.fromRGB(255, 255, 255)
        stroke.Thickness = 1.5
        button.MouseButton1Down:Connect(callbackDown)
        button.MouseButton1Up:Connect(callbackUp)
        button.TouchTap:Connect(callbackDown)
        button.TouchEnded:Connect(callbackUp)
        return button
    end
    if isMobile then
        local mobileGui = Instance.new("ScreenGui", self.Services.CoreGui)
        mobileGui.Name = "AdvancedAirwalkMobileControls"
        mobileGui.ResetOnSpawn = false
        self.State.GUIs.MobileControls = mobileGui
        createMobileButton(mobileGui, "UP", UDim2.new(0.9, 0, 0.55, 0),
            function() self.State.Increase = true end,
            function() self.State.Increase = false end)
        createMobileButton(mobileGui, "DOWN", UDim2.new(0.9, 0, 0.7, 0),
            function() self.State.Decrease = true end,
            function() self.State.Decrease = false end)
    else
        self.State.Connections.Focused = uis.TextBoxFocused:Connect(function() self.State.IsTyping = true end)
        self.State.Connections.Released = uis.TextBoxFocusReleased:Connect(function() self.State.IsTyping = false end)
        self.State.Connections.InputBegan = uis.InputBegan:Connect(function(input, gpe)
            if gpe or self.State.IsTyping then return end
            if input.KeyCode == self.Config.Keybinds.Increase then self.State.Increase = true end
            if input.KeyCode == self.Config.Keybinds.Decrease then self.State.Decrease = true end
        end)
        self.State.Connections.InputEnded = uis.InputEnded:Connect(function(input)
            if input.KeyCode == self.Config.Keybinds.Increase then self.State.Increase = false end
            if input.KeyCode == self.Config.Keybinds.Decrease then self.State.Decrease = false end
        end)
    end
    local awPart = Instance.new("Part")
    awPart.Name = "Zuka_AirwalkPart"
    awPart.Size = Vector3.new(8, 1.5, 8)
    awPart.Transparency = self.Config.ShowPlatform and 0.7 or 1
    awPart.Anchored = true
    awPart.CanCollide = true
    awPart.CanQuery = false
    awPart.Parent = self.Services.Workspace
    if self.Config.ShowPlatform then
        awPart.Color = Color3.fromRGB(100, 150, 255)
        awPart.Material = Enum.Material.Neon
    end
    self.State.AirwalkPart = awPart
    if not self.Config.DisableOnDeath then
        self.State.Connections.CharacterAdded = localPlayer.CharacterAdded:Connect(function(newChar)
            task.wait(0.5)
            self.State.Offset = 0
            self.State.SmoothOffset = 0
        end)
    end
    self.State.RenderConnection = self.Services.RunService.RenderStepped:Connect(function(deltaTime)
        if not self.State.IsEnabled then
            self:Disable()
            return
        end
        if not (self.State.AirwalkPart and self.State.AirwalkPart.Parent) then
            self:Disable()
            return
        end
        local success, char, root, hum = pcall(function()
            local c = localPlayer.Character
            return c, c and c:FindFirstChild("HumanoidRootPart"), c and c:FindFirstChildOfClass("Humanoid")
        end)
        if not (success and char and root and hum) then
            if self.State.LastValidRoot then
                self.State.AirwalkPart.CanCollide = false
            else
                if self.Config.DisableOnDeath then
                    self:Disable()
                else
                    self.State.AirwalkPart.CanCollide = false
                end
            end
            return
        end
        if hum.Health <= 0 then
            if self.Config.DisableOnDeath then
                self:Disable()
            else
                self.State.AirwalkPart.CanCollide = false
            end
            return
        end
        self.State.AirwalkPart.CanCollide = true
        self.State.LastValidRoot = root.Position
        local hrpHalf = root.Size.Y * 0.5
        local feetFromRoot
        if hum.RigType == Enum.HumanoidRigType.R6 then
            feetFromRoot = hrpHalf + (hum.HipHeight > 0 and hum.HipHeight or 2)
        else
            feetFromRoot = hrpHalf + (hum.HipHeight or 2)
        end
        local baseOffset = feetFromRoot + (self.State.AirwalkPart.Size.Y * 0.5)
        local delta = 0
        if self.State.Increase then delta = -self.Config.VerticalSpeed end
        if self.State.Decrease then delta = self.Config.VerticalSpeed end
        self.State.Offset = self.State.Offset + delta
        self.State.SmoothOffset = self.State.SmoothOffset + (self.State.Offset - self.State.SmoothOffset) * self.Config.SmoothSpeed
        local newY = root.Position.Y - baseOffset - self.State.SmoothOffset
        self.State.AirwalkPart.CFrame = CFrame.new(root.Position.X, newY, root.Position.Z)
    end)
end
RegisterCommand({
    Name = "airwalk",
    Aliases = {"float", "aw"},
    Description = "Toggles an advanced airwalk. Use Space/LCtrl or GUI to move."
}, function()
    if Modules.AdvancedAirwalk.State.IsEnabled then
        Modules.AdvancedAirwalk:Disable()
    else
        Modules.AdvancedAirwalk:Enable()
    end
end)
RegisterCommand({
    Name = "unairwalk",
    Aliases = {"unfloat", "unaw"},
    Description = "Explicitly disables the advanced airwalk."
}, function()
    Modules.AdvancedAirwalk:Disable()
end)
RegisterCommand({
    Name = "airwalkplatform",
    Aliases = {"awplatform"},
    Description = "Toggles visibility of the airwalk platform."
}, function()
    Modules.AdvancedAirwalk.Config.ShowPlatform = not Modules.AdvancedAirwalk.Config.ShowPlatform
    if Modules.AdvancedAirwalk.State.AirwalkPart then
        local part = Modules.AdvancedAirwalk.State.AirwalkPart
        part.Transparency = Modules.AdvancedAirwalk.Config.ShowPlatform and 0.7 or 1
        if Modules.AdvancedAirwalk.Config.ShowPlatform then
            part.Color = Color3.fromRGB(100, 150, 255)
            part.Material = Enum.Material.Neon
        end
    end
    DoNotif("Platform Visibility: " .. (Modules.AdvancedAirwalk.Config.ShowPlatform and "ON" or "OFF"), 2)
end)
RegisterCommand({
    Name = "airwalkreset",
    Aliases = {"awreset"},
    Description = "Resets airwalk offset to ground level."
}, function()
    Modules.AdvancedAirwalk.State.Offset = 0
    Modules.AdvancedAirwalk.State.SmoothOffset = 0
    DoNotif("Airwalk offset reset", 2)
end)
Modules.VoidShield = {
    State = {
        IsEnabled = false,
        ShieldPart = nil,
        CharacterAddedConn = nil,
        ToolConn = nil
    },
    Config = {
        Size = Vector3.new(12, 12, 1),
        Distance = 5,
        Transparency = 0.5,
        Color = Color3.fromRGB(0, 255, 255),
        Material = Enum.Material.ForceField,
    }
}
function Modules.VoidShield:_applyNoCollision(part)
    local character = LocalPlayer.Character
    if not character or not part then return end
    for _, v in ipairs(character:GetDescendants()) do
        if v:IsA("BasePart") then
            local constraint = Instance.new("NoCollisionConstraint")
            constraint.Part0 = part
            constraint.Part1 = v
            constraint.Parent = part
        end
    end
end
function Modules.VoidShield:_createShield()
    if self.State.ShieldPart then self.State.ShieldPart:Destroy() end
    local part = Instance.new("Part")
    part.Name = "Callum_ShieldWall"
    part.Size = self.Config.Size
    part.Transparency = self.Config.Transparency
    part.Color = self.Config.Color
    part.Material = self.Config.Material
    part.CanCollide = true
    part.CanQuery = true
    part.Anchored = true
    part.CastShadow = false
    part.Massless = true
    self:_applyNoCollision(part)
    if LocalPlayer.Character then
        if self.State.ToolConn then self.State.ToolConn:Disconnect() end
        self.State.ToolConn = LocalPlayer.Character.ChildAdded:Connect(function(child)
            if child:IsA("Tool") and self.State.ShieldPart then
                task.wait()
                self:_applyNoCollision(self.State.ShieldPart)
            end
        end)
    end
    part.Parent = Workspace
    self.State.ShieldPart = part
    self:_updatePosition()
end
function Modules.VoidShield:_updatePosition()
    local character = LocalPlayer.Character
    local root = character and character:FindFirstChild("HumanoidRootPart")
    if not root or not self.State.ShieldPart then return end
    local targetCF = root.CFrame * CFrame.new(0, 0, -self.Config.Distance)
    self.State.ShieldPart.CFrame = targetCF
end
function Modules.VoidShield:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    self:_createShield()
    self.State.CharacterAddedConn = LocalPlayer.CharacterAdded:Connect(function()
        task.wait(0.5)
        if self.State.IsEnabled then self:_createShield() end
    end)
    if typeof(DoNotif) == "function" then DoNotif("Shield Wall: [ACTIVE]", 2) end
end
function Modules.VoidShield:Disable()
    self.State.IsEnabled = false
    if self.State.CharacterAddedConn then self.State.CharacterAddedConn:Disconnect() end
    if self.State.ToolConn then self.State.ToolConn:Disconnect() end
    if self.State.ShieldPart then self.State.ShieldPart:Destroy(); self.State.ShieldPart = nil end
    if typeof(DoNotif) == "function" then DoNotif("Shield Wall: [DISABLED]", 2) end
end
function Modules.VoidShield:Toggle()
    if self.State.IsEnabled then self:Disable() else self:Enable() end
end
function Modules.VoidShield:Initialize()
    if typeof(RegisterCommand) == "function" then
        RegisterCommand({Name = "cshield", Aliases = {"clientshield"}}, function(args)
            local sizeVal = tonumber(args[1])
            if sizeVal then
                self.Config.Size = Vector3.new(sizeVal, sizeVal, 1)
                if self.State.ShieldPart then self.State.ShieldPart.Size = self.Config.Size end
            end
            self:Toggle()
        end)
    end
end
Modules.Blackhole = {
    State = {
        IsEnabled = false,
        IsForceActive = false,
        TargetCFrame = CFrame.new(),
        BlackholePart = nil,
        BlackholeAttachment = nil,
        Connections = {},
        UI = {}
    },
    Config = {
        ForceResponsiveness = 200,
        TorqueMagnitude = 100000,
        MoveKey = Enum.KeyCode.E,
        MoverName = "Zuka_BlackholeMover"
    },
    Dependencies = {"RunService", "UserInputService", "Players", "Workspace", "CoreGui"},
    Services = {}
}
function Modules.Blackhole:_cleanupForces()
    for _, descendant in ipairs(self.Services.Workspace:GetDescendants()) do
        if descendant.Name == self.Config.MoverName and descendant:IsA("Instance") then
            descendant:Destroy()
        end
        if descendant:IsA("BasePart") and not descendant.CanCollide then
            pcall(function() descendant.CanCollide = true end)
        end
    end
end
function Modules.Blackhole:_applyForce(part)
    if not self.State.IsForceActive or not (part and part:IsA("BasePart")) then return end
    if part.Anchored or part:FindFirstAncestorOfClass("Humanoid") then return end
    if part:IsDescendantOf(self.Services.Players.LocalPlayer.Character) then return end
    for _, child in ipairs(part:GetChildren()) do
        if child:IsA("BodyMover") or child:IsA("RocketPropulsion") then
            child:Destroy()
        end
        if child.Name == self.Config.MoverName then
            child:Destroy()
        end
    end
    part.CanCollide = false
    local attachment = Instance.new("Attachment", part)
    attachment.Name = self.Config.MoverName
    local align = Instance.new("AlignPosition", attachment)
    align.Attachment0 = attachment
    align.Attachment1 = self.State.BlackholeAttachment
    align.MaxForce = 1e9
    align.MaxVelocity = math.huge
    align.Responsiveness = self.Config.ForceResponsiveness
    local torque = Instance.new("Torque", attachment)
    torque.Attachment0 = attachment
    torque.Torque = Vector3.new(self.Config.TorqueMagnitude, self.Config.TorqueMagnitude, self.Config.TorqueMagnitude)
end
function Modules.Blackhole:Disable()
    if not self.State.IsEnabled then return end
    for _, conn in pairs(self.State.Connections) do
        conn:Disconnect()
    end
    table.clear(self.State.Connections)
    pcall(function()
        for _, plr in ipairs(self.Services.Players:GetPlayers()) do
            plr.MaximumSimulationRadius = -1
        end
    end)
    self:_cleanupForces()
    if self.State.BlackholePart and self.State.BlackholePart.Parent then
        self.State.BlackholePart:Destroy()
    end
    if self.State.UI.ScreenGui and self.State.UI.ScreenGui.Parent then
        self.State.UI.ScreenGui:Destroy()
    end
    self.State = {
        IsEnabled = false,
        IsForceActive = false,
        TargetCFrame = CFrame.new(),
        Connections = {},
        UI = {}
    }
    DoNotif("Blackhole destroyed.", 2)
end
function Modules.Blackhole:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    local localPlayer = self.Services.Players.LocalPlayer
    local bhPart = Instance.new("Part")
    bhPart.Name = "Zuka_BlackholeCore"
    bhPart.Anchored = true
    bhPart.CanCollide = false
    bhPart.Transparency = 1
    bhPart.Size = Vector3.one
    self.State.BlackholePart = bhPart
    self.State.BlackholeAttachment = Instance.new("Attachment", bhPart)
    local mouse = localPlayer:GetMouse()
    self.State.TargetCFrame = mouse.Hit + Vector3.new(0, 5, 0)
    bhPart.Parent = self.Services.Workspace
    self.State.Connections.SimRadius = self.Services.RunService.Heartbeat:Connect(function()
        pcall(function()
            for _, plr in ipairs(self.Services.Players:GetPlayers()) do
                if plr ~= localPlayer then plr.MaximumSimulationRadius = 0 end
            end
            localPlayer.MaximumSimulationRadius = 1e9
        end)
    end)
    self.State.Connections.PositionUpdate = self.Services.RunService.RenderStepped:Connect(function()
        if self.State.BlackholeAttachment then
            self.State.BlackholeAttachment.WorldCFrame = self.State.TargetCFrame
        end
    end)
    self.State.Connections.DescendantAdded = self.Services.Workspace.DescendantAdded:Connect(function(desc)
        self:_applyForce(desc)
    end)
    self.State.Connections.Input = self.Services.UserInputService.InputBegan:Connect(function(input, gpe)
        if not gpe and input.KeyCode == self.Config.MoveKey then
            self.State.TargetCFrame = mouse.Hit + Vector3.new(0, 5, 0)
        end
    end)
    local screenGui = Instance.new("ScreenGui", self.Services.CoreGui)
    screenGui.Name = "BlackholeControlGUI"
    screenGui.ResetOnSpawn = false
    self.State.UI.ScreenGui = screenGui
    local toggleBtn = Instance.new("TextButton")
    toggleBtn.Name = "ToggleButton"
    toggleBtn.Text = "Enable Blackhole"
    toggleBtn.AnchorPoint = Vector2.new(0.5, 1)
    toggleBtn.Size = UDim2.fromOffset(160, 40)
    toggleBtn.Position = UDim2.new(0.5, 0, 0.93, 0)
    toggleBtn.BackgroundColor3 = Color3.fromRGB(38, 38, 38)
    toggleBtn.TextColor3 = Color3.new(1, 1, 1)
    toggleBtn.Font = Enum.Font.SourceSansBold
    toggleBtn.TextSize = 18
    toggleBtn.Parent = screenGui
    Instance.new("UICorner", toggleBtn).CornerRadius = UDim.new(0.25, 0)
    local moveBtn = toggleBtn:Clone()
    moveBtn.Name = "MoveButton"
    moveBtn.Text = "Move Blackhole (E)"
    moveBtn.Position = UDim2.new(0.5, 0, 0.99, 0)
    moveBtn.BackgroundColor3 = Color3.fromRGB(51, 51, 51)
    moveBtn.Parent = screenGui
    toggleBtn.MouseButton1Click:Connect(function()
        self.State.IsForceActive = not self.State.IsForceActive
        toggleBtn.Text = self.State.IsForceActive and "Disable Blackhole" or "Enable Blackhole"
        if self.State.IsForceActive then
            DoNotif("Blackhole force enabled", 2)
            for _,v in ipairs(self.Services.Workspace:GetDescendants()) do self:_applyForce(v) end
        else
            self:_cleanupForces()
            DoNotif("Blackhole force disabled", 2)
        end
    end)
    moveBtn.MouseButton1Click:Connect(function()
        self.State.TargetCFrame = mouse.Hit + Vector3.new(0, 5, 0)
    end)
    DoNotif("Blackhole created. Tap button or press E to move.", 3)
end
function Modules.Blackhole:Initialize()
    local module = self
    for _, service in ipairs(self.Dependencies) do
        module.Services[service] = game:GetService(service)
    end
    RegisterCommand({
        Name = "blackhole",
        Aliases = {"bhole"},
        Description = "Toggles a client-sided black hole that pulls all unanchored parts."
    }, function()
        if module.State.IsEnabled then
            module:Disable()
        else
            module:Enable()
        end
    end)
end
Modules.PathfinderFollow = {
    State = {
        IsEnabled = false,
        TargetPlayer = nil,
        FollowConnection = nil,
        Path = nil,
        CurrentWaypointIndex = 1,
        LastPathRecalculation = 0,
        LastSourcePos = Vector3.new(),
        LastTargetPos = Vector3.new()
    },
    Config = {
        RECALCULATION_INTERVAL = 0.5,
        RECALCULATION_DISTANCE = 3,
        WAYPOINT_PROXIMITY = 4,
        PATH_PARAMS = {
            AgentRadius = 3,
            AgentHeight = 6,
            AgentCanJump = true,
        }
    },
    Dependencies = {"PathfindingService", "RunService", "Players"},
    Services = {}
}
function Modules.PathfinderFollow:_onHeartbeat()
    if not (self.State.IsEnabled and self.State.TargetPlayer and self.State.TargetPlayer.Parent) then
        self:Disable()
        return
    end
    local localPlayer = self.Services.Players.LocalPlayer
    local localChar = localPlayer.Character
    local localHrp = localChar and localChar:FindFirstChild("HumanoidRootPart")
    local localHum = localChar and localChar:FindFirstChildOfClass("Humanoid")
    local targetChar = self.State.TargetPlayer.Character
    local targetHrp = targetChar and targetChar:FindFirstChild("HumanoidRootPart")
    if not (localHrp and localHum and targetHrp and localHum.Health > 0) then
        return
    end
    local sourcePos = localHrp.Position
    local targetPos = targetHrp.Position
    local timeSinceRecalc = os.clock() - self.State.LastPathRecalculation
    local sourceMoved = (sourcePos - self.State.LastSourcePos).Magnitude > self.Config.RECALCULATION_DISTANCE
    local targetMoved = (targetPos - self.State.LastTargetPos).Magnitude > self.Config.RECALCULATION_DISTANCE
    if timeSinceRecalc > self.Config.RECALCULATION_INTERVAL and (sourceMoved or targetMoved) then
        self.State.LastPathRecalculation = os.clock()
        self.State.LastSourcePos = sourcePos
        self.State.LastTargetPos = targetPos
        local success = pcall(function() self.State.Path:ComputeAsync(sourcePos, targetPos) end)
        if success and self.State.Path.Status == Enum.PathStatus.Success then
            self.State.CurrentWaypointIndex = 1
        end
    end
    if self.State.Path and self.State.Path.Status == Enum.PathStatus.Success then
        local waypoints = self.State.Path:GetWaypoints()
        if #waypoints == 0 or self.State.CurrentWaypointIndex > #waypoints then return end
        local currentWaypoint = waypoints[self.State.CurrentWaypointIndex]
        local distanceToWaypoint = (localHrp.Position - currentWaypoint.Position).Magnitude
        if distanceToWaypoint < self.Config.WAYPOINT_PROXIMITY then
            self.State.CurrentWaypointIndex = self.State.CurrentWaypointIndex + 1
        else
            if currentWaypoint.Action == Enum.PathWaypointAction.Jump then
                localHum.Jump = true
            end
            localHum:MoveTo(currentWaypoint.Position)
        end
    end
end
function Modules.PathfinderFollow:Disable()
    if not self.State.IsEnabled then return end
    if self.State.FollowConnection then
        self.State.FollowConnection:Disconnect()
        self.State.FollowConnection = nil
    end
    pcall(function()
        local char = self.Services.Players.LocalPlayer.Character
        local hum = char and char:FindFirstChildOfClass("Humanoid")
        if hum then hum:MoveTo(hum.RootPart.Position) end
    end)
    DoNotif("Pathfinder follow disabled.", 2)
    self.State.IsEnabled = false
    self.State.TargetPlayer = nil
    self.State.Path = nil
end
function Modules.PathfinderFollow:Enable(targetPlayer)
    if not targetPlayer or targetPlayer == self.Services.Players.LocalPlayer then
        DoNotif("Invalid target for pathfinding.", 3)
        return
    end
    self:Disable()
    self.State.IsEnabled = true
    self.State.TargetPlayer = targetPlayer
    self.State.Path = self.Services.PathfindingService:CreatePath(self.Config.PATH_PARAMS)
    self.State.LastPathRecalculation = 0
    self.State.FollowConnection = self.Services.RunService.Heartbeat:Connect(function() self:_onHeartbeat() end)
    DoNotif("Pathfinder following: " .. targetPlayer.Name, 2)
end
function Modules.PathfinderFollow:Initialize()
    local module = self
    for _, service in ipairs(self.Dependencies) do
        module.Services[service] = game:GetService(service)
    end
    RegisterCommand({
        Name = "pathfind",
        Aliases = {},
        Description = "Follow a player using PathfindingService."
    }, function(args)
        local argument = args[1]
        if not argument or (argument:lower() == "stop" or argument:lower() == "off") then
            module:Disable()
            return
        end
        local target = Utilities.findPlayer(argument)
        if target then
            module:Enable(target)
        else
            DoNotif("Player '" .. argument .. "' not found.", 3)
        end
    end)
end
Modules.GUICreator = {
    State = {
        IsEnabled = false,
        UI = nil,
        Connections = {},
        CreatedGUIs = {},
        SelectedElement = nil,
        PropertyPanel = nil,
        HierarchyPanel = nil,
        UndoStack = {},
        RedoStack = {},
        CurrentProject = {
            Name = "Untitled",
            Elements = {}
        }
    },
    Config = {
        GridSize = 20,
        SnapToGrid = false,
        ShowGrid = true,
        DefaultSize = UDim2.fromOffset(200, 100)
    }
}
local TweenService    = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local Players         = game:GetService("Players")
local LocalPlayer     = Players.LocalPlayer
function Modules.GUICreator:PushUndo(action)
    table.insert(self.State.UndoStack, action)
    self.State.RedoStack = {}
    if #self.State.UndoStack > 50 then
        table.remove(self.State.UndoStack, 1)
    end
end
function Modules.GUICreator:Undo()
    local action = table.remove(self.State.UndoStack)
    if not action then print("Nothing to undo") return end
    table.insert(self.State.RedoStack, action)
    action.Undo()
    self:RefreshHierarchy()
end
function Modules.GUICreator:Redo()
    local action = table.remove(self.State.RedoStack)
    if not action then print("Nothing to redo") return end
    table.insert(self.State.UndoStack, action)
    action.Do()
    self:RefreshHierarchy()
end
function Modules.GUICreator:SnapValue(v)
    if not self.Config.SnapToGrid then return v end
    local g = self.Config.GridSize
    return math.floor((v + g / 2) / g) * g
end
function Modules.GUICreator:CreateButton(text, color, parent)
    local btn = Instance.new("TextButton", parent)
    btn.Size = UDim2.fromOffset(110, 26)
    btn.BackgroundColor3 = color
    btn.BorderSizePixel = 0
    btn.Font = Enum.Font.GothamBold
    btn.Text = text
    btn.TextColor3 = Color3.new(1, 1, 1)
    btn.TextSize = 10
    btn.AutoButtonColor = false
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 4)
    btn.MouseEnter:Connect(function()
        local h, s, v = color:ToHSV()
        btn.BackgroundColor3 = Color3.fromHSV(h, s, math.min(v + 0.12, 1))
    end)
    btn.MouseLeave:Connect(function()
        btn.BackgroundColor3 = color end)
    return btn
end
function Modules.GUICreator:_createUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "GUICreator_Zuka"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    self.State.UI = screenGui
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.fromOffset(1200, 700)
    mainFrame.Position = UDim2.fromScale(0.5, 0.5)
    mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    mainFrame.BackgroundColor3 = Color3.fromRGB(22, 22, 32)
    mainFrame.BorderSizePixel = 0
    mainFrame.Parent = screenGui
    Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 12)
    local stroke = Instance.new("UIStroke", mainFrame)
    stroke.Color = Color3.fromRGB(90, 140, 255)
    stroke.Thickness = 2
    local titleBar = Instance.new("Frame", mainFrame)
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1, 0, 0, 40)
    titleBar.BackgroundColor3 = Color3.fromRGB(18, 18, 28)
    titleBar.BorderSizePixel = 0
    Instance.new("UICorner", titleBar).CornerRadius = UDim.new(0, 12)
    local title = Instance.new("TextLabel", titleBar)
    title.Size = UDim2.new(1, -110, 1, 0)
    title.Position = UDim2.fromOffset(15, 0)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.Code
    title.Text = "â–¸ GUI CREATOR  â€”  Ctrl+Z Undo  |  Ctrl+Y Redo"
    title.TextColor3 = Color3.fromRGB(90, 140, 255)
    title.TextSize = 14
    title.TextXAlignment = Enum.TextXAlignment.Left
    local closeBtn = Instance.new("TextButton", titleBar)
    closeBtn.Size = UDim2.fromOffset(30, 30)
    closeBtn.Position = UDim2.new(1, -35, 0, 5)
    closeBtn.BackgroundColor3 = Color3.fromRGB(255, 50, 100)
    closeBtn.BorderSizePixel = 0
    closeBtn.Text = "Ã—"
    closeBtn.TextColor3 = Color3.new(1, 1, 1)
    closeBtn.Font = Enum.Font.GothamBold
    closeBtn.TextSize = 20
    Instance.new("UICorner", closeBtn).CornerRadius = UDim.new(0, 8)
    closeBtn.MouseButton1Click:Connect(function() self:Disable() end)
    self:MakeDraggable(titleBar, mainFrame)
    local topBar = Instance.new("Frame", mainFrame)
    topBar.Name = "TopBar"
    topBar.Size = UDim2.new(1, -20, 0, 36)
    topBar.Position = UDim2.fromOffset(10, 44)
    topBar.BackgroundColor3 = Color3.fromRGB(32, 32, 44)
    topBar.BorderSizePixel = 0
    topBar.ZIndex = 10
    Instance.new("UICorner", topBar).CornerRadius = UDim.new(0, 6)
    local topLayout = Instance.new("UIListLayout", topBar)
    topLayout.FillDirection = Enum.FillDirection.Horizontal
    topLayout.Padding = UDim.new(0, 6)
    topLayout.VerticalAlignment = Enum.VerticalAlignment.Center
    Instance.new("UIPadding", topBar).PaddingLeft = UDim.new(0, 10)
    local exportBtn = self:CreateButton("â¬† EXPORT CODE", Color3.fromRGB(0, 190, 95), topBar)
    exportBtn.MouseButton1Click:Connect(function() self:ExportCode() end)
    local undoBtn = self:CreateButton("â†© UNDO", Color3.fromRGB(90, 140, 255), topBar)
    undoBtn.Size = UDim2.fromOffset(80, 26)
    undoBtn.MouseButton1Click:Connect(function() self:Undo() end)
    local redoBtn = self:CreateButton("â†ª REDO", Color3.fromRGB(90, 140, 255), topBar)
    redoBtn.Size = UDim2.fromOffset(80, 26)
    redoBtn.MouseButton1Click:Connect(function() self:Redo() end)
    local clearBtn = self:CreateButton("ðŸ—‘ CLEAR", Color3.fromRGB(230, 80, 50), topBar)
    clearBtn.Size = UDim2.fromOffset(80, 26)
    clearBtn.MouseButton1Click:Connect(function() self:ClearCanvas() end)
    local gridBtn = self:CreateButton("GRID: ON", Color3.fromRGB(80, 80, 180), topBar)
    gridBtn.Size = UDim2.fromOffset(90, 26)
    gridBtn.MouseButton1Click:Connect(function()
        self.Config.ShowGrid = not self.Config.ShowGrid
        gridBtn.Text = "GRID: " .. (self.Config.ShowGrid and "ON" or "OFF")
        self:DrawGrid()
    end)
    local snapBtn = self:CreateButton("SNAP: OFF", Color3.fromRGB(120, 80, 200), topBar)
    snapBtn.Size = UDim2.fromOffset(90, 26)
    snapBtn.MouseButton1Click:Connect(function()
        self.Config.SnapToGrid = not self.Config.SnapToGrid
        snapBtn.Text = "SNAP: " .. (self.Config.SnapToGrid and "ON" or "OFF")
        snapBtn.BackgroundColor3 = self.Config.SnapToGrid
            and Color3.fromRGB(180, 80, 255)
            or  Color3.fromRGB(120, 80, 200)
    end)
    local leftPanel = Instance.new("Frame", mainFrame)
    leftPanel.Name = "Toolbox"
    leftPanel.Size = UDim2.new(0, 165, 1, -90)
    leftPanel.Position = UDim2.fromOffset(10, 86)
    leftPanel.BackgroundColor3 = Color3.fromRGB(28, 28, 38)
    leftPanel.BorderSizePixel = 0
    Instance.new("UICorner", leftPanel).CornerRadius = UDim.new(0, 8)
    local toolboxLabel = Instance.new("TextLabel", leftPanel)
    toolboxLabel.Size = UDim2.new(1, 0, 0, 28)
    toolboxLabel.BackgroundTransparency = 1
    toolboxLabel.Font = Enum.Font.GothamBold
    toolboxLabel.Text = "ELEMENTS"
    toolboxLabel.TextColor3 = Color3.fromRGB(160, 160, 180)
    toolboxLabel.TextSize = 12
    local toolboxScroll = Instance.new("ScrollingFrame", leftPanel)
    toolboxScroll.Size = UDim2.new(1, -8, 1, -34)
    toolboxScroll.Position = UDim2.fromOffset(4, 30)
    toolboxScroll.BackgroundTransparency = 1
    toolboxScroll.BorderSizePixel = 0
    toolboxScroll.ScrollBarThickness = 3
    toolboxScroll.ScrollBarImageColor3 = Color3.fromRGB(90, 140, 255)
    toolboxScroll.CanvasSize = UDim2.fromOffset(0, 0)
    toolboxScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
    local toolboxLayout = Instance.new("UIListLayout", toolboxScroll)
    toolboxLayout.Padding = UDim.new(0, 4)
    toolboxLayout.SortOrder = Enum.SortOrder.LayoutOrder
    local canvasPanel = Instance.new("Frame", mainFrame)
    canvasPanel.Name = "Canvas"
    canvasPanel.Size = UDim2.new(1, -560, 1, -90)
    canvasPanel.Position = UDim2.fromOffset(183, 86)
    canvasPanel.BackgroundColor3 = Color3.fromRGB(36, 36, 48)
    canvasPanel.BorderSizePixel = 0
    Instance.new("UICorner", canvasPanel).CornerRadius = UDim.new(0, 8)
    canvasPanel.ClipsDescendants = true
    local canvasLabel = Instance.new("TextLabel", canvasPanel)
    canvasLabel.Size = UDim2.new(1, 0, 0, 24)
    canvasLabel.BackgroundTransparency = 1
    canvasLabel.Font = Enum.Font.GothamBold
    canvasLabel.Text = "CANVAS  (480 Ã— 360)"
    canvasLabel.TextColor3 = Color3.fromRGB(120, 120, 140)
    canvasLabel.TextSize = 11
    local workspace = Instance.new("Frame", canvasPanel)
    workspace.Name = "Workspace"
    workspace.Size = UDim2.fromOffset(480, 360)
    workspace.Position = UDim2.new(0.5, 0, 0.5, 0)
    workspace.AnchorPoint = Vector2.new(0.5, 0.5)
    workspace.BackgroundColor3 = Color3.fromRGB(46, 46, 58)
    workspace.BorderSizePixel = 0
    workspace.ClipsDescendants = true
    local wsStroke = Instance.new("UIStroke", workspace)
    wsStroke.Color = Color3.fromRGB(80, 80, 110)
    wsStroke.Thickness = 2
    local gridFrame = Instance.new("Frame", workspace)
    gridFrame.Name = "GridOverlay"
    gridFrame.Size = UDim2.new(1, 0, 1, 0)
    gridFrame.BackgroundTransparency = 1
    gridFrame.BorderSizePixel = 0
    gridFrame.ZIndex = 1
    self.State.GridFrame = gridFrame
    self:DrawGrid()
    local rightCol = Instance.new("Frame", mainFrame)
    rightCol.Name = "RightCol"
    rightCol.Size = UDim2.new(0, 240, 1, -90)
    rightCol.Position = UDim2.new(1, -250, 0, 86)
    rightCol.BackgroundTransparency = 1
    rightCol.BorderSizePixel = 0
    local rightPanel = Instance.new("Frame", rightCol)
    rightPanel.Name = "Properties"
    rightPanel.Size = UDim2.new(1, 0, 0.52, -4)
    rightPanel.BackgroundColor3 = Color3.fromRGB(28, 28, 38)
    rightPanel.BorderSizePixel = 0
    Instance.new("UICorner", rightPanel).CornerRadius = UDim.new(0, 8)
    local propertiesLabel = Instance.new("TextLabel", rightPanel)
    propertiesLabel.Size = UDim2.new(1, 0, 0, 28)
    propertiesLabel.BackgroundTransparency = 1
    propertiesLabel.Font = Enum.Font.GothamBold
    propertiesLabel.Text = "PROPERTIES"
    propertiesLabel.TextColor3 = Color3.fromRGB(160, 160, 180)
    propertiesLabel.TextSize = 12
    local propertiesScroll = Instance.new("ScrollingFrame", rightPanel)
    propertiesScroll.Name = "PropertiesScroll"
    propertiesScroll.Size = UDim2.new(1, -8, 1, -32)
    propertiesScroll.Position = UDim2.fromOffset(4, 30)
    propertiesScroll.BackgroundTransparency = 1
    propertiesScroll.BorderSizePixel = 0
    propertiesScroll.ScrollBarThickness = 3
    propertiesScroll.ScrollBarImageColor3 = Color3.fromRGB(90, 140, 255)
    propertiesScroll.CanvasSize = UDim2.fromOffset(0, 0)
    propertiesScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
    local propLayout = Instance.new("UIListLayout", propertiesScroll)
    propLayout.Padding = UDim.new(0, 6)
    propLayout.SortOrder = Enum.SortOrder.LayoutOrder
    self.State.PropertyPanel = propertiesScroll
    local hierPanel = Instance.new("Frame", rightCol)
    hierPanel.Name = "Hierarchy"
    hierPanel.Size = UDim2.new(1, 0, 0.48, -4)
    hierPanel.Position = UDim2.new(0, 0, 0.52, 4)
    hierPanel.BackgroundColor3 = Color3.fromRGB(28, 28, 38)
    hierPanel.BorderSizePixel = 0
    Instance.new("UICorner", hierPanel).CornerRadius = UDim.new(0, 8)
    local hierLabel = Instance.new("TextLabel", hierPanel)
    hierLabel.Size = UDim2.new(1, 0, 0, 28)
    hierLabel.BackgroundTransparency = 1
    hierLabel.Font = Enum.Font.GothamBold
    hierLabel.Text = "HIERARCHY"
    hierLabel.TextColor3 = Color3.fromRGB(160, 160, 180)
    hierLabel.TextSize = 12
    local hierScroll = Instance.new("ScrollingFrame", hierPanel)
    hierScroll.Name = "HierarchyScroll"
    hierScroll.Size = UDim2.new(1, -8, 1, -32)
    hierScroll.Position = UDim2.fromOffset(4, 30)
    hierScroll.BackgroundTransparency = 1
    hierScroll.BorderSizePixel = 0
    hierScroll.ScrollBarThickness = 3
    hierScroll.ScrollBarImageColor3 = Color3.fromRGB(90, 140, 255)
    hierScroll.CanvasSize = UDim2.fromOffset(0, 0)
    hierScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
    local hierLayout = Instance.new("UIListLayout", hierScroll)
    hierLayout.Padding = UDim.new(0, 3)
    hierLayout.SortOrder = Enum.SortOrder.LayoutOrder
    self.State.HierarchyPanel = hierScroll
    screenGui.Parent = CoreGui
    self:PopulateToolbox(toolboxScroll)
    self:_bindKeyboard()
    return workspace
end
function Modules.GUICreator:DrawGrid()
    local gf = self.State.GridFrame
    if not gf then return end
    for _, c in ipairs(gf:GetChildren()) do c:Destroy() end
    if not self.Config.ShowGrid then return end
    local W, H = 480, 360
    local g = self.Config.GridSize
    local lineColor = Color3.fromRGB(65, 65, 85)
    local function makeLine(x, y, w, h)
        local f = Instance.new("Frame", gf)
        f.BorderSizePixel = 0
        f.BackgroundColor3 = lineColor
        f.Size = UDim2.fromOffset(w, h)
        f.Position = UDim2.fromOffset(x, y)
        f.ZIndex = 1
    end
    local x = g
    while x < W do makeLine(x, 0, 1, H) ; x = x + g end
    local y = g
    while y < H do makeLine(0, y, W, 1) ; y = y + g end
end
function Modules.GUICreator:_bindKeyboard()
    local conn = UserInputService.InputBegan:Connect(function(input, gpe)
        if gpe then return end
        local ctrl = UserInputService:IsKeyDown(Enum.KeyCode.LeftControl)
            or UserInputService:IsKeyDown(Enum.KeyCode.RightControl)
        if ctrl and input.KeyCode == Enum.KeyCode.Z then self:Undo() end
        if ctrl and input.KeyCode == Enum.KeyCode.Y then self:Redo() end
        if ctrl and input.KeyCode == Enum.KeyCode.D then
            if self.State.SelectedElement then
                self:DuplicateElement(self.State.SelectedElement)
            end
        end
        if input.KeyCode == Enum.KeyCode.Delete then
            if self.State.SelectedElement then
                self:DeleteElement(self.State.SelectedElement)
            end
        end
    end)
    table.insert(self.State.Connections, conn)
end
function Modules.GUICreator:MakeDraggable(handle, object)
    local dragging, dragStart, startPos = false, nil, nil
    handle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = object.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local d = input.Position - dragStart
            object.Position = UDim2.new(
                startPos.X.Scale, startPos.X.Offset + d.X,
                startPos.Y.Scale, startPos.Y.Offset + d.Y
            )
        end
    end)
end
function Modules.GUICreator:PopulateToolbox(parent)
    local elements = {
        {Name = "Frame",          Color = Color3.fromRGB(100, 150, 220), Icon = "â–­"},
        {Name = "TextLabel",      Color = Color3.fromRGB(140, 210,  90), Icon = "T"},
        {Name = "TextButton",     Color = Color3.fromRGB(220, 150,  80), Icon = "B"},
        {Name = "TextBox",        Color = Color3.fromRGB(210,  90, 150), Icon = "I"},
        {Name = "ImageLabel",     Color = Color3.fromRGB(150,  90, 220), Icon = "ðŸ–¼"},
        {Name = "ScrollingFrame", Color = Color3.fromRGB(80,  200, 150), Icon = "â‡…"},
    }
    for _, elem in ipairs(elements) do
        local btn = Instance.new("TextButton", parent)
        btn.Size = UDim2.new(1, 0, 0, 38)
        btn.BackgroundColor3 = Color3.fromRGB(36, 36, 48)
        btn.BorderSizePixel = 0
        btn.Font = Enum.Font.GothamBold
        btn.Text = elem.Icon .. "  " .. elem.Name
        btn.TextColor3 = elem.Color
        btn.TextSize = 11
        btn.TextXAlignment = Enum.TextXAlignment.Left
        btn.AutoButtonColor = false
        Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 6)
        Instance.new("UIPadding", btn).PaddingLeft = UDim.new(0, 10)
        btn.MouseButton1Click:Connect(function() self:CreateElement(elem.Name) end)
        btn.MouseEnter:Connect(function() btn.BackgroundColor3 = Color3.fromRGB(50, 50, 66) end)
        btn.MouseLeave:Connect(function() btn.BackgroundColor3 = Color3.fromRGB(36, 36, 48) end)
    end
end
function Modules.GUICreator:CreateElement(elementType, snapshot)
    local workspace = self.State.UI.MainFrame.Canvas.Workspace
    local element = Instance.new(elementType)
    local idx = #self.State.CreatedGUIs + 1
    element.Name = elementType .. "_" .. idx
    element.Size = snapshot and snapshot.Size or self.Config.DefaultSize
    element.Position = snapshot and snapshot.Position or UDim2.fromOffset(
        self:SnapValue(math.random(40, 260)),
        self:SnapValue(math.random(40, 180))
    )
    element.BackgroundColor3 = snapshot and snapshot.BackgroundColor3
        or Color3.fromRGB(math.random(90, 200), math.random(90, 200), math.random(90, 200))
    element.BorderSizePixel = 0
    element.ZIndex = snapshot and snapshot.ZIndex or idx + 2
    if elementType == "TextLabel" or elementType == "TextButton" or elementType == "TextBox" then
        element.Text        = snapshot and snapshot.Text or element.Name
        element.TextColor3  = snapshot and snapshot.TextColor3 or Color3.new(1, 1, 1)
        element.Font        = Enum.Font.Gotham
        element.TextSize    = snapshot and snapshot.TextSize or 14
    end
    if elementType == "TextBox" then
        element.PlaceholderText  = "Enter textâ€¦"
        element.ClearTextOnFocus = false
    end
    if elementType == "ImageLabel" then
        element.Image = snapshot and snapshot.Image
            or "rbxasset://textures/ui/GuiImagePlaceholder.png"
    end
    if elementType == "ScrollingFrame" then
        element.ScrollBarThickness = 6
        element.CanvasSize         = UDim2.fromOffset(480, 720)
    end
    Instance.new("UICorner", element).CornerRadius = UDim.new(0, 8)
    element.Parent = workspace
    local data = {Element = element, Type = elementType}
    table.insert(self.State.CreatedGUIs, data)
    self:MakeElementInteractive(element)
    self:RefreshHierarchy()
    self:SelectElement(element)
    if not snapshot then
        self:PushUndo({
            Do = function()
                element.Parent = workspace
                table.insert(self.State.CreatedGUIs, data)
                self:RefreshHierarchy()
            end,
            Undo = function()
                element.Parent = nil
                for i, d in ipairs(self.State.CreatedGUIs) do
                    if d.Element == element then table.remove(self.State.CreatedGUIs, i) break end
                end
                self.State.SelectedElement = nil
                self:UpdatePropertiesPanel(nil)
                self:RefreshHierarchy()
            end
        })
    end
    print(string.format("âœ“ Created %s", element.Name))
    return element
end
function Modules.GUICreator:DuplicateElement(element)
    local snap = {
        Size             = UDim2.fromOffset(element.Size.X.Offset, element.Size.Y.Offset),
        Position         = UDim2.fromOffset(element.Position.X.Offset + 15, element.Position.Y.Offset + 15),
        BackgroundColor3 = element.BackgroundColor3,
        ZIndex           = element.ZIndex,
    }
    if element:IsA("TextLabel") or element:IsA("TextButton") or element:IsA("TextBox") then
        snap.Text       = element.Text
        snap.TextColor3 = element.TextColor3
        snap.TextSize   = element.TextSize
    end
    if element:IsA("ImageLabel") then
        snap.Image = element.Image
    end
    local elemType = "Frame"
    for _, d in ipairs(self.State.CreatedGUIs) do
        if d.Element == element then elemType = d.Type break end
    end
    self:CreateElement(elemType, snap)
    print("âœ“ Duplicated element (Ctrl+D)")
end
function Modules.GUICreator:MakeElementInteractive(element)
    local selBox = Instance.new("Frame", element)
    selBox.Name = "SelectionBox"
    selBox.Size = UDim2.new(1, 6, 1, 6)
    selBox.Position = UDim2.fromOffset(-3, -3)
    selBox.BackgroundTransparency = 1
    selBox.BorderSizePixel = 0
    selBox.Visible = false
    selBox.ZIndex = 200
    local selStroke = Instance.new("UIStroke", selBox)
    selStroke.Color = Color3.fromRGB(0, 230, 255)
    selStroke.Thickness = 2
    local handles = {
        {name="NW", ax=0,   ay=0,   cx=true,  cy=true},
        {name="N",  ax=0.5, ay=0,   cx=false, cy=true},
        {name="NE", ax=1,   ay=0,   cx=true,  cy=true},
        {name="W",  ax=0,   ay=0.5, cx=true,  cy=false},
        {name="E",  ax=1,   ay=0.5, cx=true,  cy=false},
        {name="SW", ax=0,   ay=1,   cx=true,  cy=true},
        {name="S",  ax=0.5, ay=1,   cx=false, cy=true},
        {name="SE", ax=1,   ay=1,   cx=true,  cy=true},
    }
    local handleInstances = {}
    for _, hd in ipairs(handles) do
        local h = Instance.new("Frame", selBox)
        h.Name = "Handle_" .. hd.name
        h.Size = UDim2.fromOffset(8, 8)
        h.AnchorPoint = Vector2.new(0.5, 0.5)
        h.Position = UDim2.new(hd.ax, 0, hd.ay, 0)
        h.BackgroundColor3 = Color3.fromRGB(0, 230, 255)
        h.BorderSizePixel = 0
        h.ZIndex = 201
        Instance.new("UICorner", h).CornerRadius = UDim.new(0, 2)
        handleInstances[hd.name] = {frame = h, meta = hd}
    end
    local dragging = false
    local dragStart, startPos, startSize
    local resizing = false
    local resizeHandle = nil
    for name, hdata in pairs(handleInstances) do
        hdata.frame.InputBegan:Connect(function(input)
            if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
            self:SelectElement(element)
            resizing = true
            resizeHandle = hdata.meta
            dragStart = input.Position
            startPos  = {X = element.Position.X.Offset, Y = element.Position.Y.Offset}
            startSize = {W = element.Size.X.Offset,     H = element.Size.Y.Offset}
        end)
    end
    element.InputBegan:Connect(function(input)
        if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
        self:SelectElement(element)
        if resizing then return end
        dragging  = true
        dragStart = input.Position
        startPos  = {X = element.Position.X.Offset, Y = element.Position.Y.Offset}
        startSize = {W = element.Size.X.Offset,     H = element.Size.Y.Offset}
    end)
    local prevPos, prevSize
    local moveConn = UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType ~= Enum.UserInputType.MouseMovement then return end
        local delta = input.Position - dragStart
        if dragging and not resizing then
            local nx = self:SnapValue(startPos.X + delta.X)
            local ny = self:SnapValue(startPos.Y + delta.Y)
            element.Position = UDim2.fromOffset(nx, ny)
        end
        if resizing and resizeHandle then
            local h = resizeHandle
            local dx = delta.X
            local dy = delta.Y
            local nx, ny = startPos.X, startPos.Y
            local nw, nh = startSize.W, startSize.H
            if h.cx then
                if h.ax == 0 then
                    nw = math.max(20, startSize.W - dx)
                    nx = startPos.X + (startSize.W - nw)
                else
                    nw = math.max(20, startSize.W + dx)
                end
            end
            if h.cy then
                if h.ay == 0 then
                    nh = math.max(20, startSize.H - dy)
                    ny = startPos.Y + (startSize.H - nh)
                else
                    nh = math.max(20, startSize.H + dy)
                end
            end
            nx = self:SnapValue(nx)
            ny = self:SnapValue(ny)
            nw = self:SnapValue(nw)
            nh = self:SnapValue(nh)
            element.Position = UDim2.fromOffset(nx, ny)
            element.Size     = UDim2.fromOffset(nw, nh)
            self:UpdatePropertiesPanel(element)
        end
    end)
    local releaseConn = UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
        if (dragging or resizing) and startPos then
            local oldPos  = UDim2.fromOffset(startPos.X, startPos.Y)
            local oldSize = UDim2.fromOffset(startSize.W, startSize.H)
            local newPos  = element.Position
            local newSize = element.Size
            if oldPos ~= newPos or oldSize ~= newSize then
                self:PushUndo({
                    Do = function()
                        element.Position = newPos
                        element.Size     = newSize
                        self:UpdatePropertiesPanel(element)
                    end,
                    Undo = function()
                        element.Position = oldPos
                        element.Size     = oldSize
                        self:UpdatePropertiesPanel(element)
                    end
                })
            end
        end
        dragging = false
        resizing = false
        resizeHandle = nil
    end)
    table.insert(self.State.Connections, moveConn)
    table.insert(self.State.Connections, releaseConn)
end
function Modules.GUICreator:SelectElement(element)
    if self.State.SelectedElement == element then return end
    if self.State.SelectedElement then
        local ob = self.State.SelectedElement:FindFirstChild("SelectionBox")
        if ob then ob.Visible = false end
    end
    self.State.SelectedElement = element
    local box = element:FindFirstChild("SelectionBox")
    if box then box.Visible = true end
    self:UpdatePropertiesPanel(element)
    self:RefreshHierarchy()
end
function Modules.GUICreator:RefreshHierarchy()
    local panel = self.State.HierarchyPanel
    if not panel then return end
    for _, c in ipairs(panel:GetChildren()) do
        if not c:IsA("UIListLayout") then c:Destroy() end
    end
    for _, data in ipairs(self.State.CreatedGUIs) do
        local elem = data.Element
        if not elem or not elem.Parent then continue end
        local row = Instance.new("TextButton", panel)
        row.Size = UDim2.new(1, -6, 0, 26)
        row.BorderSizePixel = 0
        row.Font = Enum.Font.Code
        row.TextSize = 11
        row.TextXAlignment = Enum.TextXAlignment.Left
        row.AutoButtonColor = false
        local isSelected = (self.State.SelectedElement == elem)
        row.BackgroundColor3 = isSelected
            and Color3.fromRGB(50, 80, 160)
            or  Color3.fromRGB(36, 36, 50)
        row.TextColor3 = isSelected
            and Color3.new(1, 1, 1)
            or  Color3.fromRGB(180, 180, 200)
        row.Text = "  [Z:" .. tostring(elem.ZIndex) .. "]  " .. elem.Name
        Instance.new("UICorner", row).CornerRadius = UDim.new(0, 4)
        row.MouseButton1Click:Connect(function()
            self:SelectElement(elem)
        end)
        local upBtn = Instance.new("TextButton", row)
        upBtn.Size = UDim2.fromOffset(18, 18)
        upBtn.Position = UDim2.new(1, -42, 0.5, -9)
        upBtn.BackgroundColor3 = Color3.fromRGB(70, 70, 100)
        upBtn.BorderSizePixel = 0
        upBtn.Font = Enum.Font.GothamBold
        upBtn.Text = "â–²"
        upBtn.TextSize = 9
        upBtn.TextColor3 = Color3.new(1, 1, 1)
        Instance.new("UICorner", upBtn).CornerRadius = UDim.new(0, 3)
        upBtn.MouseButton1Click:Connect(function()
            self:ChangeZIndex(elem, 1)
        end)
        local downBtn = Instance.new("TextButton", row)
        downBtn.Size = UDim2.fromOffset(18, 18)
        downBtn.Position = UDim2.new(1, -21, 0.5, -9)
        downBtn.BackgroundColor3 = Color3.fromRGB(70, 70, 100)
        downBtn.BorderSizePixel = 0
        downBtn.Font = Enum.Font.GothamBold
        downBtn.Text = "â–¼"
        downBtn.TextSize = 9
        downBtn.TextColor3 = Color3.new(1, 1, 1)
        Instance.new("UICorner", downBtn).CornerRadius = UDim.new(0, 3)
        downBtn.MouseButton1Click:Connect(function()
            self:ChangeZIndex(elem, -1)
        end)
    end
end
function Modules.GUICreator:ChangeZIndex(element, delta)
    local oldZ = element.ZIndex
    local newZ = math.max(3, oldZ + delta)
    element.ZIndex = newZ
    self:PushUndo({
        Do   = function() element.ZIndex = newZ ; self:RefreshHierarchy() end,
        Undo = function() element.ZIndex = oldZ ; self:RefreshHierarchy() end
    })
    self:RefreshHierarchy()
    self:UpdatePropertiesPanel(element)
    print(string.format("âœ“ ZIndex %s â†’ %d", element.Name, newZ))
end
function Modules.GUICreator:UpdatePropertiesPanel(element)
    local panel = self.State.PropertyPanel
    for _, child in ipairs(panel:GetChildren()) do
        if not child:IsA("UIListLayout") then child:Destroy() end
    end
    if not element then return end
    self:CreateProperty(panel, "Name", element.Name, function(v)
        local old = element.Name
        element.Name = v
        self:PushUndo({
            Do   = function() element.Name = v   ; self:RefreshHierarchy() end,
            Undo = function() element.Name = old ; self:RefreshHierarchy() end
        })
        self:RefreshHierarchy()
    end)
    self:CreateProperty(panel, "Size X", tostring(element.Size.X.Offset), function(v)
        element.Size = UDim2.fromOffset(tonumber(v) or 200, element.Size.Y.Offset)
    end)
    self:CreateProperty(panel, "Size Y", tostring(element.Size.Y.Offset), function(v)
        element.Size = UDim2.fromOffset(element.Size.X.Offset, tonumber(v) or 100)
    end)
    self:CreateProperty(panel, "Pos X", tostring(element.Position.X.Offset), function(v)
        element.Position = UDim2.fromOffset(tonumber(v) or 0, element.Position.Y.Offset)
    end)
    self:CreateProperty(panel, "Pos Y", tostring(element.Position.Y.Offset), function(v)
        element.Position = UDim2.fromOffset(element.Position.X.Offset, tonumber(v) or 0)
    end)
    self:CreateProperty(panel, "ZIndex", tostring(element.ZIndex), function(v)
        local old = element.ZIndex
        local nz = math.max(3, tonumber(v) or 3)
        element.ZIndex = nz
        self:PushUndo({
            Do   = function() element.ZIndex = nz  ; self:RefreshHierarchy() end,
            Undo = function() element.ZIndex = old ; self:RefreshHierarchy() end
        })
        self:RefreshHierarchy()
    end)
    self:CreateProperty(panel, "AnchorPoint X", tostring(element.AnchorPoint.X), function(v)
        element.AnchorPoint = Vector2.new(math.clamp(tonumber(v) or 0, 0, 1), element.AnchorPoint.Y)
    end)
    self:CreateProperty(panel, "AnchorPoint Y", tostring(element.AnchorPoint.Y), function(v)
        element.AnchorPoint = Vector2.new(element.AnchorPoint.X, math.clamp(tonumber(v) or 0, 0, 1))
    end)
    self:CreateColorProperty(panel, "BG Color", element.BackgroundColor3, function(c)
        element.BackgroundColor3 = c
    end)
    self:CreateProperty(panel, "Transparency", tostring(element.BackgroundTransparency), function(v)
        element.BackgroundTransparency = math.clamp(tonumber(v) or 0, 0, 1)
    end)
    if element:IsA("TextLabel") or element:IsA("TextButton") or element:IsA("TextBox") then
        self:CreateProperty(panel, "Text", element.Text, function(v) element.Text = v end)
        self:CreateProperty(panel, "TextSize", tostring(element.TextSize), function(v)
            element.TextSize = tonumber(v) or 14
        end)
        self:CreateColorProperty(panel, "Text Color", element.TextColor3, function(c)
            element.TextColor3 = c
        end)
    end
    local deleteBtn = Instance.new("TextButton", panel)
    deleteBtn.Size = UDim2.new(1, -6, 0, 32)
    deleteBtn.BackgroundColor3 = Color3.fromRGB(220, 45, 90)
    deleteBtn.BorderSizePixel = 0
    deleteBtn.Font = Enum.Font.GothamBold
    deleteBtn.Text = "ðŸ—‘  DELETE ELEMENT"
    deleteBtn.TextColor3 = Color3.new(1, 1, 1)
    deleteBtn.TextSize = 11
    Instance.new("UICorner", deleteBtn).CornerRadius = UDim.new(0, 6)
    deleteBtn.MouseButton1Click:Connect(function() self:DeleteElement(element) end)
    local dupBtn = Instance.new("TextButton", panel)
    dupBtn.Size = UDim2.new(1, -6, 0, 32)
    dupBtn.BackgroundColor3 = Color3.fromRGB(70, 130, 220)
    dupBtn.BorderSizePixel = 0
    dupBtn.Font = Enum.Font.GothamBold
    dupBtn.Text = "â§‰  DUPLICATE (Ctrl+D)"
    dupBtn.TextColor3 = Color3.new(1, 1, 1)
    dupBtn.TextSize = 11
    Instance.new("UICorner", dupBtn).CornerRadius = UDim.new(0, 6)
    dupBtn.MouseButton1Click:Connect(function() self:DuplicateElement(element) end)
end
function Modules.GUICreator:CreateProperty(panel, name, value, onChange)
    local container = Instance.new("Frame", panel)
    container.Size = UDim2.new(1, -6, 0, 48)
    container.BackgroundColor3 = Color3.fromRGB(36, 36, 50)
    container.BorderSizePixel = 0
    Instance.new("UICorner", container).CornerRadius = UDim.new(0, 5)
    local label = Instance.new("TextLabel", container)
    label.Size = UDim2.new(1, -10, 0, 18)
    label.Position = UDim2.fromOffset(6, 4)
    label.BackgroundTransparency = 1
    label.Font = Enum.Font.GothamBold
    label.Text = name
    label.TextColor3 = Color3.fromRGB(180, 180, 200)
    label.TextSize = 10
    label.TextXAlignment = Enum.TextXAlignment.Left
    local input = Instance.new("TextBox", container)
    input.Size = UDim2.new(1, -12, 0, 20)
    input.Position = UDim2.fromOffset(6, 24)
    input.BackgroundColor3 = Color3.fromRGB(26, 26, 38)
    input.BorderSizePixel = 0
    input.Font = Enum.Font.Code
    input.Text = tostring(value)
    input.TextColor3 = Color3.new(1, 1, 1)
    input.TextSize = 10
    input.ClearTextOnFocus = false
    Instance.new("UICorner", input).CornerRadius = UDim.new(0, 4)
    input.FocusLost:Connect(function() onChange(input.Text) end)
end
function Modules.GUICreator:CreateColorProperty(panel, name, color, onChange)
    local container = Instance.new("Frame", panel)
    container.Size = UDim2.new(1, -6, 0, 48)
    container.BackgroundColor3 = Color3.fromRGB(36, 36, 50)
    container.BorderSizePixel = 0
    Instance.new("UICorner", container).CornerRadius = UDim.new(0, 5)
    local label = Instance.new("TextLabel", container)
    label.Size = UDim2.new(1, -46, 0, 18)
    label.Position = UDim2.fromOffset(6, 4)
    label.BackgroundTransparency = 1
    label.Font = Enum.Font.GothamBold
    label.Text = name
    label.TextColor3 = Color3.fromRGB(180, 180, 200)
    label.TextSize = 10
    label.TextXAlignment = Enum.TextXAlignment.Left
    local preview = Instance.new("Frame", container)
    preview.Size = UDim2.fromOffset(22, 22)
    preview.Position = UDim2.new(1, -28, 0, 4)
    preview.BackgroundColor3 = color
    preview.BorderSizePixel = 0
    Instance.new("UICorner", preview).CornerRadius = UDim.new(0, 4)
    local input = Instance.new("TextBox", container)
    input.Size = UDim2.new(1, -12, 0, 20)
    input.Position = UDim2.fromOffset(6, 24)
    input.BackgroundColor3 = Color3.fromRGB(26, 26, 38)
    input.BorderSizePixel = 0
    input.Font = Enum.Font.Code
    input.Text = string.format("%d,%d,%d", color.R*255, color.G*255, color.B*255)
    input.TextColor3 = Color3.new(1, 1, 1)
    input.TextSize = 10
    input.PlaceholderText = "R,G,B"
    input.ClearTextOnFocus = false
    Instance.new("UICorner", input).CornerRadius = UDim.new(0, 4)
    input.FocusLost:Connect(function()
        local p = string.split(input.Text, ",")
        if #p == 3 then
            local r, g, b = tonumber(p[1]), tonumber(p[2]), tonumber(p[3])
            if r and g and b then
                local nc = Color3.fromRGB(r, g, b)
                preview.BackgroundColor3 = nc
                onChange(nc)
            end
        end
    end)
end
function Modules.GUICreator:DeleteElement(element)
    local savedType, savedData
    for i, data in ipairs(self.State.CreatedGUIs) do
        if data.Element == element then
            savedType = data.Type
            savedData = data
            table.remove(self.State.CreatedGUIs, i)
            break
        end
    end
    local snap = {
        Size             = element.Size,
        Position         = element.Position,
        BackgroundColor3 = element.BackgroundColor3,
        ZIndex           = element.ZIndex,
    }
    if element:IsA("TextLabel") or element:IsA("TextButton") or element:IsA("TextBox") then
        snap.Text       = element.Text
        snap.TextColor3 = element.TextColor3
        snap.TextSize   = element.TextSize
    end
    if element:IsA("ImageLabel") then snap.Image = element.Image end
    element:Destroy()
    self.State.SelectedElement = nil
    self:UpdatePropertiesPanel(nil)
    self:RefreshHierarchy()
    self:PushUndo({
        Undo = function()
            self:CreateElement(savedType, snap)
        end,
        Do = function()
        end
    })
    print("âœ“ Deleted element")
end
function Modules.GUICreator:ClearCanvas()
    for _, data in ipairs(self.State.CreatedGUIs) do
        if data.Element then data.Element:Destroy() end
    end
    self.State.CreatedGUIs = {}
    self.State.UndoStack   = {}
    self.State.RedoStack   = {}
    self.State.SelectedElement = nil
    self:UpdatePropertiesPanel(nil)
    self:RefreshHierarchy()
    print("âœ“ Cleared canvas")
end
function Modules.GUICreator:ExportCode()
    local lines = {}
    local function w(s) table.insert(lines, s) end
    w("-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    w("-- Generated by GUI Creator (Zuka)")
    w("-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    w("local Players    = game:GetService('Players')")
    w("local LocalPlayer = Players.LocalPlayer")
    w("")
    w("local ScreenGui = Instance.new('ScreenGui')")
    w("ScreenGui.Name = '" .. self.State.CurrentProject.Name .. "'")
    w("ScreenGui.ResetOnSpawn = false")
    w("ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling")
    w("ScreenGui.Parent = LocalPlayer:WaitForChild('PlayerGui')")
    w("")
    for _, data in ipairs(self.State.CreatedGUIs) do
        local e = data.Element
        if not e or not e.Parent then continue end
        w(string.format("-- %s", e.Name))
        w(string.format("local %s = Instance.new('%s')", e.Name, data.Type))
        w(string.format("%s.Name                 = '%s'",   e.Name, e.Name))
        w(string.format("%s.Size                 = UDim2.fromOffset(%d, %d)", e.Name, e.Size.X.Offset, e.Size.Y.Offset))
        w(string.format("%s.Position             = UDim2.fromOffset(%d, %d)", e.Name, e.Position.X.Offset, e.Position.Y.Offset))
        w(string.format("%s.AnchorPoint          = Vector2.new(%g, %g)",      e.Name, e.AnchorPoint.X, e.AnchorPoint.Y))
        w(string.format("%s.BackgroundColor3     = Color3.fromRGB(%d, %d, %d)",
            e.Name,
            math.round(e.BackgroundColor3.R * 255),
            math.round(e.BackgroundColor3.G * 255),
            math.round(e.BackgroundColor3.B * 255)))
        w(string.format("%s.BackgroundTransparency = %g",   e.Name, e.BackgroundTransparency))
        w(string.format("%s.BorderSizePixel       = 0",     e.Name))
        w(string.format("%s.ZIndex                = %d",    e.Name, e.ZIndex))
        if e:IsA("TextLabel") or e:IsA("TextButton") or e:IsA("TextBox") then
            local safeText = e.Text:gsub("'", "\\'")
            w(string.format("%s.Text                 = '%s'",  e.Name, safeText))
            w(string.format("%s.TextColor3           = Color3.fromRGB(%d, %d, %d)",
                e.Name,
                math.round(e.TextColor3.R * 255),
                math.round(e.TextColor3.G * 255),
                math.round(e.TextColor3.B * 255)))
            w(string.format("%s.TextSize             = %d",    e.Name, e.TextSize))
            w(string.format("%s.Font                 = Enum.Font.%s",
                e.Name, tostring(e.Font):gsub("Enum%.Font%.", "")))
            w(string.format("%s.TextXAlignment       = Enum.TextXAlignment.Left", e.Name))
        end
        if e:IsA("ImageLabel") or e:IsA("ImageButton") then
            w(string.format("%s.Image = '%s'", e.Name, e.Image))
            w(string.format("%s.ScaleType = Enum.ScaleType.Fit", e.Name))
        end
        if e:IsA("ScrollingFrame") then
            w(string.format("%s.ScrollBarThickness = %d", e.Name, e.ScrollBarThickness))
            w(string.format("%s.CanvasSize = UDim2.fromOffset(%d, %d)",
                e.Name, e.CanvasSize.X.Offset, e.CanvasSize.Y.Offset))
        end
        w(string.format("do local c = Instance.new('UICorner', %s) ; c.CornerRadius = UDim.new(0, 8) end", e.Name))
        w(string.format("%s.Parent = ScreenGui", e.Name))
        w("")
    end
    local code = table.concat(lines, "\n")
    if setclipboard then
        setclipboard(code)
        print("âœ“ Code copied to clipboard!")
    else
        print(code)
        print("âœ“ Code printed to console (F9)")
    end
end
function Modules.GUICreator:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    self:_createUI()
    print("âœ“ GUI Creator enabled")
    print("  Drag elements freely  |  Resize via handles  |  Ctrl+Z/Y undo/redo  |  Ctrl+D duplicate  |  Del to delete")
end
function Modules.GUICreator:Disable()
    if not self.State.IsEnabled then return end
    self.State.IsEnabled = false
    for _, conn in pairs(self.State.Connections) do
        if conn then conn:Disconnect() end
    end
    table.clear(self.State.Connections)
    if self.State.UI then
        self.State.UI:Destroy()
        self.State.UI = nil
    end
    self.State.CreatedGUIs     = {}
    self.State.UndoStack       = {}
    self.State.RedoStack       = {}
    self.State.SelectedElement = nil
    print("âœ“ GUI Creator disabled")
end
function Modules.GUICreator:Toggle()
    if self.State.IsEnabled then self:Disable() else self:Enable() end
end
RegisterCommand({
    Name = "guicreator",
    Aliases = {"guic", "guimaker", "guibuild"},
    Description = "Opens a visual GUI creator with drag-and-drop elements and code export."
}, function()
    Modules.GUICreator:Toggle()
end)
Modules.CharacterMorph = {
    State = {
        IsMorphed = false,
        OriginalDescription = nil,
        CharacterAddedConnection = nil
    },
    Dependencies = {"Players"},
    Services = {}
}
function Modules.CharacterMorph:_resolveDescription(target)
    local targetId = tonumber(target)
    if not targetId then
        local success, idFromName = pcall(function()
            return self.Services.Players:GetUserIdFromNameAsync(target)
        end)
        if not success or not idFromName then
            DoNotif("Could not find a user with the name: " .. tostring(target), 3)
            return nil
        end
        targetId = idFromName
    end
    DoNotif("Loading avatar for ID: " .. targetId, 1.5)
    local success, description = pcall(function()
        return self.Services.Players:GetHumanoidDescriptionFromUserId(targetId)
    end)
    if not success or not description then
        DoNotif("Unable to load avatar description for that user.", 3)
        return nil
    end
    return description
end
function Modules.CharacterMorph:_applyAndRespawn(description)
    local localPlayer = self.Services.Players.LocalPlayer
    if not description then return end
    if self.State.CharacterAddedConnection then
        self.State.CharacterAddedConnection:Disconnect()
        self.State.CharacterAddedConnection = nil
    end
    self.State.CharacterAddedConnection = localPlayer.CharacterAdded:Once(function(character)
        local humanoid = character:WaitForChild("Humanoid", 5)
        if humanoid then
            pcall(humanoid.ApplyDescription, humanoid, description)
        end
    end)
    localPlayer:LoadCharacter()
end
function Modules.CharacterMorph:Morph(target)
    if not target then
        DoNotif("Usage: ;char <username/userid>", 3)
        return
    end
    if not self.State.OriginalDescription then
        local success, originalDesc = pcall(function()
            return self.Services.Players:GetHumanoidDescriptionFromUserId(self.Services.Players.LocalPlayer.UserId)
        end)
        if success then
            self.State.OriginalDescription = originalDesc
        else
            warn("[CharacterMorph] Could not cache original character description.")
        end
    end
    task.spawn(function()
        local newDescription = self:_resolveDescription(target)
        if newDescription then
            self.State.IsMorphed = true
            self:_applyAndRespawn(newDescription)
            DoNotif("Applying character morph...", 2)
        end
    end)
end
function Modules.CharacterMorph:Revert()
    if not self.State.IsMorphed then
        DoNotif("You are not currently morphed.", 2)
        return
    end
    if not self.State.OriginalDescription then
        DoNotif("Could not find original avatar to revert to. Re-fetching...", 3)
        local success, originalDesc = pcall(function()
            return self.Services.Players:GetHumanoidDescriptionFromUserId(self.Services.Players.LocalPlayer.UserId)
        end)
        if success then self.State.OriginalDescription = originalDesc end
    end
    if self.State.OriginalDescription then
        self:_applyAndRespawn(self.State.OriginalDescription)
        self.State.IsMorphed = false
        DoNotif("Reverting to original character...", 2)
    else
        DoNotif("Failed to revert character: Original description is missing.", 4)
    end
end
function Modules.CharacterMorph:Initialize()
    local module = self
    for _, service in ipairs(self.Dependencies) do
        module.Services[service] = game:GetService(service)
    end
    RegisterCommand({
        Name = "char",
        Aliases = {"character", "morph"},
        Description = "Change your character's appearance to someone else's."
    }, function(args)
        module:Morph(args[1])
    end)
    RegisterCommand({
        Name = "unchar",
        Aliases = {},
        Description = "Reverts your character's appearance to your own."
    }, function()
        module:Revert()
    end)
end
Modules.InfoPanel = {
    State = {
        IsEnabled = false,
        UI = {},
        Connections = {},
        IsMinimized = false,
        IsMaximized = false,
        PreMaximizeSize = nil,
        PreMaximizePosition = nil
    },
    Theme = {
        Background = Color3.fromRGB(0, 0, 0),
        WindowGray = Color3.fromRGB(192, 192, 192),
        DarkGray = Color3.fromRGB(128, 128, 128),
        LightGray = Color3.fromRGB(223, 223, 223),
        White = Color3.fromRGB(255, 255, 255),
        Blue = Color3.fromRGB(0, 0, 128),
        Accent = Color3.fromRGB(0, 255, 0),
        Text = Color3.fromRGB(192, 192, 192),
        Font = Enum.Font.Code
    },
    Services = {
        Players = game:GetService("Players"),
        RunService = game:GetService("RunService"),
        CoreGui = game:GetService("CoreGui"),
        Workspace = game:GetService("Workspace"),
        TweenService = game:GetService("TweenService")
    }
}
function Modules.InfoPanel:Minimize()
    if self.State.IsMinimized then return end
    self.State.IsMinimized = true
    local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local tween = self.Services.TweenService:Create(self.State.UI.MainFrame, tweenInfo, {
        Position = UDim2.new(0.5, -self.State.UI.MainFrame.Size.X.Offset/2, 1, 50),
        Size = UDim2.new(0, self.State.UI.MainFrame.Size.X.Offset, 0, 30)
    })
    tween:Play()
end
function Modules.InfoPanel:Restore()
    if not self.State.IsMinimized then return end
    self.State.IsMinimized = false
    local targetSize = self.State.PreMaximizeSize or UDim2.new(0, 400, 0, 500)
    local targetPos = self.State.PreMaximizePosition or UDim2.new(0.5, -200, 0.5, -250)
    local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local tween = self.Services.TweenService:Create(self.State.UI.MainFrame, tweenInfo, {
        Position = targetPos,
        Size = targetSize
    })
    tween:Play()
end
function Modules.InfoPanel:Maximize()
    if self.State.IsMaximized then
        self.State.IsMaximized = false
        local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = self.Services.TweenService:Create(self.State.UI.MainFrame, tweenInfo, {
            Position = self.State.PreMaximizePosition,
            Size = self.State.PreMaximizeSize
        })
        tween:Play()
    else
        self.State.PreMaximizeSize = self.State.UI.MainFrame.Size
        self.State.PreMaximizePosition = self.State.UI.MainFrame.Position
        self.State.IsMaximized = true
        local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = self.Services.TweenService:Create(self.State.UI.MainFrame, tweenInfo, {
            Position = UDim2.new(0, 0, 0, 0),
            Size = UDim2.new(1, 0, 1, 0)
        })
        tween:Play()
    end
end
function Modules.InfoPanel:Toggle()
    if self.State.IsEnabled then
        if self.State.Connections.Updater then
            self.State.Connections.Updater:Disconnect()
        end
        if self.State.UI.ScreenGui then
            self.State.UI.ScreenGui:Destroy()
        end
        self.State = { 
            IsEnabled = false, 
            UI = {}, 
            Connections = {},
            IsMinimized = false,
            IsMaximized = false,
            PreMaximizeSize = nil,
            PreMaximizePosition = nil
        }
        DoNotif("System Information closed.", 2)
        return
    end
    self.State.IsEnabled = true
    DoNotif("System Information opened.", 2)
    local localPlayer = self.Services.Players.LocalPlayer
    local function CreateWin95Border(parent, isInset)
        local topColor = isInset and self.Theme.DarkGray or self.Theme.White
        local bottomColor = isInset and self.Theme.White or self.Theme.DarkGray
        local topBorder = Instance.new("Frame", parent)
        topBorder.Name = "TopBorder"
        topBorder.Size = UDim2.new(1, 0, 0, 2)
        topBorder.Position = UDim2.new(0, 0, 0, 0)
        topBorder.BackgroundColor3 = topColor
        topBorder.BorderSizePixel = 0
        topBorder.ZIndex = parent.ZIndex + 1
        local leftBorder = Instance.new("Frame", parent)
        leftBorder.Name = "LeftBorder"
        leftBorder.Size = UDim2.new(0, 2, 1, 0)
        leftBorder.Position = UDim2.new(0, 0, 0, 0)
        leftBorder.BackgroundColor3 = topColor
        leftBorder.BorderSizePixel = 0
        leftBorder.ZIndex = parent.ZIndex + 1
        local bottomBorder = Instance.new("Frame", parent)
        bottomBorder.Name = "BottomBorder"
        bottomBorder.Size = UDim2.new(1, 0, 0, 2)
        bottomBorder.Position = UDim2.new(0, 0, 1, -2)
        bottomBorder.BackgroundColor3 = bottomColor
        bottomBorder.BorderSizePixel = 0
        bottomBorder.ZIndex = parent.ZIndex + 1
        local rightBorder = Instance.new("Frame", parent)
        rightBorder.Name = "RightBorder"
        rightBorder.Size = UDim2.new(0, 2, 1, 0)
        rightBorder.Position = UDim2.new(1, -2, 0, 0)
        rightBorder.BackgroundColor3 = bottomColor
        rightBorder.BorderSizePixel = 0
        rightBorder.ZIndex = parent.ZIndex + 1
    end
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "SystemInformation_Win95"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
    self.State.UI.ScreenGui = screenGui
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "WindowFrame"
    mainFrame.Size = UDim2.fromOffset(400, 500)
    mainFrame.Position = UDim2.fromScale(0.5, 0.5)
    mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    mainFrame.BackgroundColor3 = self.Theme.WindowGray
    mainFrame.BorderSizePixel = 0
    mainFrame.Active = true
    mainFrame.ClipsDescendants = false
    mainFrame.Parent = screenGui
    self.State.UI.MainFrame = mainFrame
    CreateWin95Border(mainFrame, false)
    local titleBar = Instance.new("Frame", mainFrame)
    titleBar.Name = "TitleBar"
    titleBar.Position = UDim2.new(0, 3, 0, 3)
    titleBar.Size = UDim2.new(1, -6, 0, 22)
    titleBar.BackgroundColor3 = self.Theme.Blue
    titleBar.BorderSizePixel = 0
    titleBar.ZIndex = 2
    local titleGradient = Instance.new("UIGradient", titleBar)
    titleGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 0, 168)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(16, 132, 208))
    }
    titleGradient.Rotation = 90
    local titleLabel = Instance.new("TextLabel", titleBar)
    titleLabel.Name = "Title"
    titleLabel.Position = UDim2.new(0, 4, 0, 0)
    titleLabel.Size = UDim2.new(1, -70, 1, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Font = Enum.Font.SourceSansBold
    titleLabel.Text = "System Information"
    titleLabel.TextColor3 = self.Theme.White
    titleLabel.TextSize = 13
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.TextYAlignment = Enum.TextYAlignment.Center
    titleLabel.ZIndex = 3
    local minimizeButton = Instance.new("TextButton", titleBar)
    minimizeButton.Name = "MinimizeButton"
    minimizeButton.Position = UDim2.new(1, -54, 0, 2)
    minimizeButton.Size = UDim2.new(0, 16, 0, 16)
    minimizeButton.BackgroundColor3 = self.Theme.WindowGray
    minimizeButton.BorderSizePixel = 0
    minimizeButton.Font = Enum.Font.SourceSansBold
    minimizeButton.Text = "_"
    minimizeButton.TextColor3 = Color3.fromRGB(0, 0, 0)
    minimizeButton.TextSize = 14
    minimizeButton.TextYAlignment = Enum.TextYAlignment.Top
    minimizeButton.ZIndex = 4
    CreateWin95Border(minimizeButton, false)
    minimizeButton.MouseButton1Click:Connect(function()
        if self.State.IsMinimized then
            self:Restore()
        else
            self:Minimize()
        end
    end)
    local maximizeButton = Instance.new("TextButton", titleBar)
    maximizeButton.Name = "MaximizeButton"
    maximizeButton.Position = UDim2.new(1, -36, 0, 2)
    maximizeButton.Size = UDim2.new(0, 16, 0, 16)
    maximizeButton.BackgroundColor3 = self.Theme.WindowGray
    maximizeButton.BorderSizePixel = 0
    maximizeButton.Font = Enum.Font.SourceSansBold
    maximizeButton.Text = "â–¡"
    maximizeButton.TextColor3 = Color3.fromRGB(0, 0, 0)
    maximizeButton.TextSize = 14
    maximizeButton.ZIndex = 4
    CreateWin95Border(maximizeButton, false)
    maximizeButton.MouseButton1Click:Connect(function()
        self:Maximize()
    end)
    local closeButton = Instance.new("TextButton", titleBar)
    closeButton.Name = "CloseButton"
    closeButton.Position = UDim2.new(1, -18, 0, 2)
    closeButton.Size = UDim2.new(0, 16, 0, 16)
    closeButton.BackgroundColor3 = self.Theme.WindowGray
    closeButton.BorderSizePixel = 0
    closeButton.Font = Enum.Font.SourceSansBold
    closeButton.Text = "Ã—"
    closeButton.TextColor3 = Color3.fromRGB(0, 0, 0)
    closeButton.TextSize = 16
    closeButton.ZIndex = 4
    CreateWin95Border(closeButton, false)
    closeButton.MouseButton1Click:Connect(function()
        self:Toggle()
    end)
    local contentContainer = Instance.new("Frame", mainFrame)
    contentContainer.Name = "ContentContainer"
    contentContainer.Position = UDim2.new(0, 6, 0, 28)
    contentContainer.Size = UDim2.new(1, -12, 1, -34)
    contentContainer.BackgroundColor3 = self.Theme.WindowGray
    contentContainer.BorderSizePixel = 0
    contentContainer.ZIndex = 1
    CreateWin95Border(contentContainer, true)
    local scroll = Instance.new("ScrollingFrame", contentContainer)
    scroll.Size = UDim2.new(1, -8, 1, -8)
    scroll.Position = UDim2.new(0, 4, 0, 4)
    scroll.BackgroundTransparency = 1
    scroll.BorderSizePixel = 0
    scroll.ScrollBarThickness = 16
    scroll.ScrollBarImageColor3 = self.Theme.WindowGray
    scroll.ScrollingDirection = Enum.ScrollingDirection.Y
    scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
    scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
    local listLayout = Instance.new("UIListLayout", scroll)
    listLayout.Padding = UDim.new(0, 4)
    listLayout.SortOrder = Enum.SortOrder.LayoutOrder
    local padding = Instance.new("UIPadding", scroll)
    padding.PaddingLeft = UDim.new(0, 6)
    padding.PaddingRight = UDim.new(0, 6)
    padding.PaddingTop = UDim.new(0, 6)
    local function createHeader(text)
        local headerFrame = Instance.new("Frame")
        headerFrame.Size = UDim2.new(1, -12, 0, 20)
        headerFrame.BackgroundColor3 = self.Theme.Blue
        headerFrame.BorderSizePixel = 0
        headerFrame.Parent = scroll
        local headerLabel = Instance.new("TextLabel", headerFrame)
        headerLabel.Size = UDim2.new(1, -4, 1, 0)
        headerLabel.Position = UDim2.new(0, 2, 0, 0)
        headerLabel.BackgroundTransparency = 1
        headerLabel.Font = Enum.Font.SourceSansBold
        headerLabel.Text = text
        headerLabel.TextColor3 = self.Theme.White
        headerLabel.TextSize = 14
        headerLabel.TextXAlignment = Enum.TextXAlignment.Left
        CreateWin95Border(headerFrame, false)
    end
    local function createInfoEntry(key, value)
        local entry = Instance.new("Frame")
        entry.Size = UDim2.new(1, -12, 0, 18)
        entry.BackgroundColor3 = self.Theme.White
        entry.BorderSizePixel = 0
        entry.Parent = scroll
        CreateWin95Border(entry, true)
        local entryLabel = Instance.new("TextLabel", entry)
        entryLabel.Size = UDim2.new(1, -6, 1, 0)
        entryLabel.Position = UDim2.new(0, 3, 0, 0)
        entryLabel.BackgroundTransparency = 1
        entryLabel.Font = self.Theme.Font
        entryLabel.TextSize = 12
        entryLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
        entryLabel.TextXAlignment = Enum.TextXAlignment.Left
        entryLabel.RichText = true
        entryLabel.Text = string.format("<b>%s:</b> %s", key, tostring(value))
        return entryLabel
    end
    createHeader("â–¼ Client Information")
    createInfoEntry("Display Name", localPlayer.DisplayName)
    createInfoEntry("Username", localPlayer.Name)
    createInfoEntry("User ID", localPlayer.UserId)
    createInfoEntry("Account Age", localPlayer.AccountAge .. " days")
    local fpsLabel = createInfoEntry("Client FPS", "Calculating...")
    createHeader("â–¼ Game Information")
    createInfoEntry("Place ID", game.PlaceId)
    createInfoEntry("Job ID", game.JobId)
    createInfoEntry("Creator Type", game.CreatorType.Name)
    createInfoEntry("Creator ID", game.CreatorId)
    createHeader("â–¼ Server Players")
    local playerListFrame = Instance.new("Frame", scroll)
    playerListFrame.Size = UDim2.new(1, -12, 0, 0)
    playerListFrame.BackgroundTransparency = 1
    playerListFrame.AutomaticSize = Enum.AutomaticSize.Y
    local playerListLayout = Instance.new("UIListLayout", playerListFrame)
    playerListLayout.Padding = UDim.new(0, 2)
    local resizeHandle = Instance.new("Frame")
    resizeHandle.Name = "ResizeHandle"
    resizeHandle.Size = UDim2.fromOffset(16, 16)
    resizeHandle.Position = UDim2.new(1, -16, 1, -16)
    resizeHandle.BackgroundColor3 = self.Theme.WindowGray
    resizeHandle.BorderSizePixel = 0
    resizeHandle.ZIndex = 10
    resizeHandle.Parent = mainFrame
    for i = 0, 2 do
        local line = Instance.new("Frame", resizeHandle)
        line.Size = UDim2.new(0, 2, 1, -4 * i)
        line.Position = UDim2.new(0, 4 + (4 * i), 0, 4 * i)
        line.BackgroundColor3 = self.Theme.DarkGray
        line.BorderSizePixel = 0
        line.Rotation = 45
    end
    local dragging, resizing = false, false
    local dragStart, resizeStart, startPos, startSize
    local UserInputService = game:GetService("UserInputService")
    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = mainFrame.Position
            local conn; conn = input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                    conn:Disconnect()
                end
            end)
        end
    end)
    resizeHandle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            resizing = true
            resizeStart = input.Position
            startSize = mainFrame.Size
            local conn; conn = input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    resizing = false
                    conn:Disconnect()
                end
            end)
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            if dragging then
                local delta = input.Position - dragStart
                mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
            elseif resizing then
                local delta = Vector2.new(input.Position.X - resizeStart.X, input.Position.Y - resizeStart.Y)
                local newX = math.max(300, startSize.X.Offset + delta.X)
                local newY = math.max(250, startSize.Y.Offset + delta.Y)
                mainFrame.Size = UDim2.new(0, newX, 0, newY)
            end
        end
    end)
    local lastTick = 0
    self.State.Connections.Updater = self.Services.RunService.Heartbeat:Connect(function(step)
        if not screenGui.Parent then
            self:Toggle()
            return
        end
        local now = tick()
        if now - lastTick > 0.5 then
            lastTick = now
            fpsLabel.Text = string.format("<b>Client FPS:</b> %.1f", 1 / step)
            for _, child in ipairs(playerListFrame:GetChildren()) do
                if child:IsA("Frame") then
                    child:Destroy()
                end
            end
            local players = self.Services.Players:GetPlayers()
            for _, player in ipairs(players) do
                local playerEntry = Instance.new("Frame", playerListFrame)
                playerEntry.Size = UDim2.new(1, 0, 0, 16)
                playerEntry.BackgroundColor3 = self.Theme.White
                playerEntry.BorderSizePixel = 0
                CreateWin95Border(playerEntry, true)
                local playerLabel = Instance.new("TextLabel", playerEntry)
                playerLabel.Size = UDim2.new(1, -6, 1, 0)
                playerLabel.Position = UDim2.new(0, 3, 0, 0)
                playerLabel.BackgroundTransparency = 1
                playerLabel.Font = self.Theme.Font
                playerLabel.TextSize = 11
                playerLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
                playerLabel.Text = string.format("â€¢ %s (@%s)", player.DisplayName, player.Name)
                playerLabel.TextXAlignment = Enum.TextXAlignment.Left
            end
        end
    end)
    screenGui.Parent = self.Services.CoreGui
end
RegisterCommand({
    Name = "infopanel",
    Aliases = {"info", "gameinfo", "serverinfo"},
    Description = "Toggles a panel with information about the game, server, and players."
}, function(args)
    Modules.InfoPanel:Toggle()
end)
Modules.StalkerBot = {
    State = {
        IsEnabled = false,
        TargetPlayer = nil,
        Path = nil,
        CurrentWaypoints = {},
        CurrentWaypointIndex = 1,
        LastPathRecalculation = 0,
        HasLineOfSight = false,
        Connections = {},
        LastTargetPosition = nil
    },
    Config = {
        FollowDistance = 80,
        StopDistance = 15,
        RecalculationInterval = 0.5,
        WaypointReachedDistance = 4,
        DirectFollowDistance = 30,
        PATH_PARAMS = {
            AgentRadius = 2,
            AgentHeight = 5,
            AgentCanJump = true,
            AgentCanClimb = false,
            WaypointSpacing = 4,
            Costs = {
                Water = math.huge,
                DangerZone = math.huge
            }
        }
    },
    Services = {}
}
function Modules.StalkerBot:_onRenderStepped()
    if not (self.State.IsEnabled and self.State.TargetPlayer) then return end
    local success, myChar, targetChar = pcall(function()
        return self.Services.LocalPlayer.Character, self.State.TargetPlayer.Character
    end)
    if not (success and myChar and targetChar) then return end
    local myRoot = myChar:FindFirstChild("HumanoidRootPart")
    local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
    if not (myRoot and targetRoot) then return end
    local lookAtCFrame = CFrame.lookAt(myRoot.Position, targetRoot.Position)
    myRoot.CFrame = CFrame.new(myRoot.Position, myRoot.Position + lookAtCFrame.LookVector)
end
function Modules.StalkerBot:_computePath()
    local myChar = self.Services.LocalPlayer.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    local targetChar = self.State.TargetPlayer and self.State.TargetPlayer.Character
    local targetRoot = targetChar and targetChar:FindFirstChild("HumanoidRootPart")
    if not (myRoot and targetRoot) then return false end
    if not self.State.Path then
        self.State.Path = self.Services.PathfindingService:CreatePath(self.Config.PATH_PARAMS)
    end
    local success, errorMsg = pcall(function()
        self.State.Path:ComputeAsync(myRoot.Position, targetRoot.Position)
    end)
    if success and self.State.Path.Status == Enum.PathStatus.Success then
        self.State.CurrentWaypoints = self.State.Path:GetWaypoints()
        self.State.CurrentWaypointIndex = 1
        self.State.LastTargetPosition = targetRoot.Position
        return true
    else
        return false
    end
end
function Modules.StalkerBot:_hasLineOfSight(from, to)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {
        self.Services.LocalPlayer.Character,
        self.State.TargetPlayer.Character
    }
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    local direction = (to - from)
    local raycastResult = self.Services.Workspace:Raycast(from, direction, raycastParams)
    return raycastResult == nil
end
function Modules.StalkerBot:_onHeartbeat()
    if not self.State.IsEnabled then return end
    if not (self.State.TargetPlayer and self.State.TargetPlayer.Parent) then
        return self:Disable()
    end
    local myChar = self.Services.LocalPlayer.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    local myHumanoid = myChar and myChar:FindFirstChildOfClass("Humanoid")
    local targetChar = self.State.TargetPlayer.Character
    local targetRoot = targetChar and targetChar:FindFirstChild("HumanoidRootPart")
    if not (myRoot and myHumanoid and targetRoot and myHumanoid.Health > 0) then
        return
    end
    local distanceToTarget = (myRoot.Position - targetRoot.Position).Magnitude
    if distanceToTarget < self.Config.StopDistance then
        myHumanoid:MoveTo(myRoot.Position)
        return
    end
    local now = tick()
    local needsRecalculation = false
    if (now - self.State.LastPathRecalculation) > self.Config.RecalculationInterval then
        needsRecalculation = true
        self.State.LastPathRecalculation = now
    end
    if self.State.LastTargetPosition then
        local targetMovedDistance = (targetRoot.Position - self.State.LastTargetPosition).Magnitude
        if targetMovedDistance > 10 then
            needsRecalculation = true
        end
    end
    self.State.HasLineOfSight = self:_hasLineOfSight(myRoot.Position, targetRoot.Position)
    if distanceToTarget < self.Config.DirectFollowDistance and self.State.HasLineOfSight then
        myHumanoid:MoveTo(targetRoot.Position)
        return
    end
    if needsRecalculation or not self.State.CurrentWaypoints or #self.State.CurrentWaypoints == 0 then
        local success = self:_computePath()
        if not success then
            myHumanoid:MoveTo(targetRoot.Position)
            return
        end
    end
    if self.State.CurrentWaypoints and #self.State.CurrentWaypoints > 0 then
        if self.State.CurrentWaypointIndex > #self.State.CurrentWaypoints then
            self:_computePath()
            return
        end
        local currentWaypoint = self.State.CurrentWaypoints[self.State.CurrentWaypointIndex]
        if not currentWaypoint then
            self:_computePath()
            return
        end
        if currentWaypoint.Action == Enum.PathWaypointAction.Jump then
            myHumanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
        myHumanoid:MoveTo(currentWaypoint.Position)
        local distanceToWaypoint = (myRoot.Position - currentWaypoint.Position).Magnitude
        if distanceToWaypoint < self.Config.WaypointReachedDistance then
            self.State.CurrentWaypointIndex = self.State.CurrentWaypointIndex + 1
        end
    else
        myHumanoid:MoveTo(targetRoot.Position)
    end
end
function Modules.StalkerBot:Enable(targetPlayer)
    if not targetPlayer or targetPlayer == self.Services.LocalPlayer then
        return DoNotif("Invalid target for StalkerBot.", 3)
    end
    if self.State.IsEnabled then 
        self:Disable() 
    end
    pcall(function()
        self.Services.LocalPlayer.Character.Humanoid.AutoRotate = false
    end)
    self.State.IsEnabled = true
    self.State.TargetPlayer = targetPlayer
    self.State.Path = self.Services.PathfindingService:CreatePath(self.Config.PATH_PARAMS)
    self.State.CurrentWaypoints = {}
    self.State.CurrentWaypointIndex = 1
    self.State.LastPathRecalculation = 0
    self:_computePath()
    self.State.Connections.Heartbeat = self.Services.RunService.Heartbeat:Connect(function() 
        self:_onHeartbeat() 
    end)
    self.State.Connections.RenderStepped = self.Services.RunService.RenderStepped:Connect(function() 
        self:_onRenderStepped() 
    end)
    DoNotif("StalkerBot: Following " .. targetPlayer.Name, 3)
end
function Modules.StalkerBot:Disable()
    if not self.State.IsEnabled then return end
    for _, conn in pairs(self.State.Connections) do 
        conn:Disconnect() 
    end
    table.clear(self.State.Connections)
    pcall(function()
        local humanoid = self.Services.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.AutoRotate = true
            humanoid:MoveTo(humanoid.RootPart.Position)
        end
    end)
    self.State.IsEnabled = false
    self.State.TargetPlayer = nil
    self.State.Path = nil
    self.State.CurrentWaypoints = {}
    self.State.CurrentWaypointIndex = 1
    self.State.LastPathRecalculation = 0
    self.State.HasLineOfSight = false
    self.State.LastTargetPosition = nil
    DoNotif("StalkerBot: DISABLED", 2)
end
function Modules.StalkerBot:Initialize()
    local module = self
    module.Services = {
        LocalPlayer = game:GetService("Players").LocalPlayer,
        PathfindingService = game:GetService("PathfindingService"),
        RunService = game:GetService("RunService"),
        Workspace = game:GetService("Workspace")
    }
    RegisterCommand({
        Name = "stalkstare",
        Aliases = {},
        Description = "Follow and stare at a player."
    }, function(args)
        local argument = args[1]
        if not argument or (argument:lower() == "stop" or argument:lower() == "off") then
            module:Disable()
            return
        end
        local target = Utilities.findPlayer(argument)
        if target then
            module:Enable(target)
        else
            DoNotif("Player '" .. argument .. "' not found.", 3)
        end
    end)
    RegisterCommand({
        Name = "stalkdebug",
        Aliases = {},
        Description = "Shows stalker debug info."
    }, function()
        if not module.State.IsEnabled then
            DoNotif("StalkerBot is not active", 2)
            return
        end
        print("=== StalkerBot Debug ===")
        print("Target:", module.State.TargetPlayer and module.State.TargetPlayer.Name or "None")
        print("Has LOS:", module.State.HasLineOfSight)
        print("Waypoints:", #(module.State.CurrentWaypoints or {}))
        print("Current Waypoint Index:", module.State.CurrentWaypointIndex)
        print("Path Status:", module.State.Path and module.State.Path.Status or "No Path")
        DoNotif("Debug info printed to console (F9)", 2)
    end)
end
Modules.TimeStop = {
    State = {
        IsEnabled = false,
        Connections = {}
    },
    Dependencies = {"Players"},
    Services = {}
}
function Modules.TimeStop:_freezeCharacter(character)
    if not character then return end
    task.wait()
    local success, err = pcall(function()
        for _, descendant in ipairs(character:GetDescendants()) do
            if descendant:IsA("BasePart") then
                descendant.Anchored = true
            end
        end
    end)
    if not success then warn("[TimeStop] Failed to freeze character:", err) end
end
function Modules.TimeStop:_unfreezeCharacter(character)
    if not character then return end
    pcall(function()
        for _, descendant in ipairs(character:GetDescendants()) do
            if descendant:IsA("BasePart") then
                descendant.Anchored = false
            end
        end
    end)
end
function Modules.TimeStop:Disable()
    if not self.State.IsEnabled then return end
    for key, conn in pairs(self.State.Connections) do
        conn:Disconnect()
    end
    table.clear(self.State.Connections)
    for _, player in ipairs(self.Services.Players:GetPlayers()) do
        if player.Character then
            self:_unfreezeCharacter(player.Character)
        end
    end
    self.State.IsEnabled = false
    DoNotif("Time has resumed.", 2)
end
function Modules.TimeStop:Enable()
    if self.State.IsEnabled then return end
    self:Disable()
    self.State.IsEnabled = true
    local function setupPlayer(player)
        if player == self.Services.Players.LocalPlayer then return end
        if player.Character then
            self:_freezeCharacter(player.Character)
        end
        local conn = player.CharacterAdded:Connect(function(character)
            self:_freezeCharacter(character)
        end)
        self.State.Connections[player.UserId] = conn
    end
    for _, player in ipairs(self.Services.Players:GetPlayers()) do
        setupPlayer(player)
    end
    self.State.Connections.PlayerAdded = self.Services.Players.PlayerAdded:Connect(setupPlayer)
    DoNotif("ZA WARUDO! Time has been stopped.", 3)
end
function Modules.TimeStop:Initialize()
    local module = self
    for _, service in ipairs(self.Dependencies) do
        module.Services[service] = game:GetService(service)
    end
    RegisterCommand({
        Name = "timestop",
        Aliases = {"tstop"},
        Description = "Toggles a client-sided freeze for all other players."
    }, function()
        if module.State.IsEnabled then
            module:Disable()
        else
            module:Enable()
        end
    end)
    RegisterCommand({
        Name = "untimestop",
        Aliases = {"untstop"},
        Description = "Explicitly disables the time stop effect."
    }, function()
        module:Disable()
    end)
end
Modules.AnimationSpeed = {
    State = {
        IsEnabled = false,
        TargetSpeed = 1,
        LoopConnection = nil
    },
    Dependencies = {"RunService", "Players"},
    Services = {}
}
function Modules.AnimationSpeed:Disable()
    if not self.State.IsEnabled then return end
    if self.State.LoopConnection then
        self.State.LoopConnection:Disconnect()
        self.State.LoopConnection = nil
    end
    self.State.IsEnabled = false
    task.spawn(function()
        local char = self.Services.Players.LocalPlayer.Character
        if not char then return end
        local animator = char:FindFirstChildOfClass("Humanoid") or char:FindFirstChildOfClass("AnimationController")
        if not animator then return end
        pcall(function()
            for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
                track:AdjustSpeed(1)
            end
        end)
    end)
    DoNotif("Animation speed control disabled.", 2)
end
function Modules.AnimationSpeed:Enable(speed)
    local targetSpeed = tonumber(speed)
    if not targetSpeed or targetSpeed < 0 then
        DoNotif("Invalid speed. Must be a positive number.", 3)
        return
    end
    self.State.TargetSpeed = targetSpeed
    if self.State.IsEnabled then
        DoNotif("Animation speed updated to " .. targetSpeed, 2)
        return
    end
    self.State.IsEnabled = true
    self.State.LoopConnection = self.Services.RunService.Stepped:Connect(function()
        local char = self.Services.Players.LocalPlayer.Character
        if not char then return end
        local animator = char:FindFirstChildOfClass("Humanoid") or char:FindFirstChildOfClass("AnimationController")
        if not animator then return end
        local success, err = pcall(function()
            for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
                if track.Speed ~= self.State.TargetSpeed then
                    track:AdjustSpeed(self.State.TargetSpeed)
                end
            end
        end)
        if not success then
            warn("[AnimationSpeed] Error during loop:", err)
            self:Disable()
        end
    end)
    DoNotif("Animation speed set to " .. targetSpeed, 2)
end
function Modules.AnimationSpeed:Initialize()
    local module = self
    for _, service in ipairs(self.Dependencies) do
        module.Services[service] = game:GetService(service)
    end
    RegisterCommand({
        Name = "animspeed",
        Aliases = {},
        Description = "Adjusts local animation speed."
    }, function(args)
        local argument = args[1]
        if not argument or (argument:lower() == "off" or argument:lower() == "stop" or argument:lower() == "reset") then
            module:Disable()
        else
            module:Enable(argument)
        end
    end)
    RegisterCommand({
        Name = "unanimspeed",
        Aliases = {"unaspeed", "unanimationspeed"},
        Description = "Stops the animation speed adjustment loop."
    }, function()
        module:Disable()
    end)
end
Modules.Attacher = {
    State = {
        isGuiBuilt = false,
        followSpeed = 1,
        selectedPlayerName = "Nearest Player",
        isFollowing = false,
        isAttaching = false,
        isAutoAttacking = false,
        attackSpeed = 1,
        isChaosMode = false,
        flingStrength = 0.5,
        oscillationValue = 1,
        lastChaosTime = 0,
        chaosInterval = 0.1,
        UI = {},
        Connections = {}
    },
    Services = {}
}
function Modules.Attacher:Deactivate()
    if not self.State.isGuiBuilt then return end
    for _, conn in pairs(self.State.Connections) do
        conn:Disconnect()
    end
    table.clear(self.State.Connections)
    if self.State.UI.window and self.State.UI.window.Parent then
        self.State.UI.window:Destroy()
    end
    if self.State.UI.currentHighlight and self.State.UI.currentHighlight.Parent then
        self.State.UI.currentHighlight:Destroy()
    end
    table.clear(self.State.UI)
    self.State.isGuiBuilt = false
    DoNotif("Attacher module deactivated.", 2)
end
function Modules.Attacher:Activate()
    if self.State.isGuiBuilt then return end
    local self = self
    self.Services.Players = self.Services.Players or game:GetService("Players")
    self.Services.RunService = self.Services.RunService or game:GetService("RunService")
    self.Services.StarterGui = self.Services.StarterGui or game:GetService("StarterGui")
    local LocalPlayer = self.Services.Players.LocalPlayer
    local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/bloodball/-back-ups-for-libs/main/wall%20v3"))()
    local w = library:CreateWindow("Attacher")
    self.State.UI.window = w
    local function notify(title, text, duration)
        pcall(function()
            self.Services.StarterGui:SetCore("SendNotification", {
                Title = title; Text = text; Duration = duration or 3;
            })
        end)
    end
    local function clearHighlight()
        if self.State.UI.currentHighlight and self.State.UI.currentHighlight.Parent then
            self.State.UI.currentHighlight:Destroy()
            self.State.UI.currentHighlight = nil
        end
    end
    local function applyHighlight(targetPlayer)
        clearHighlight()
        if targetPlayer and targetPlayer.Character then
            local h = Instance.new("Highlight", targetPlayer.Character)
            h.Name = "TargetHighlight"
            h.FillColor = Color3.fromRGB(255, 0, 0)
            h.OutlineColor = Color3.fromRGB(255, 255, 255)
            h.FillTransparency = 0.45
            h.Adornee = targetPlayer.Character
            self.State.UI.currentHighlight = h
        end
    end
    local function findPlayerByPartialName(partialName)
        local localChar = LocalPlayer.Character
        if not localChar or not localChar:FindFirstChild("HumanoidRootPart") then return nil end
        local myPos = localChar.HumanoidRootPart.Position
        local lowerPartialName = partialName:lower()
        local matches = {}
        for _, p in ipairs(self.Services.Players:GetPlayers()) do
            if p ~= LocalPlayer then
                if p.Name:lower():find(lowerPartialName, 1, true) or p.DisplayName:lower():find(lowerPartialName, 1, true) then
                    table.insert(matches, p)
                end
            end
        end
        if #matches == 0 then return nil end
        if #matches == 1 then return matches[1] end
        local closestPlayer, closestDist = nil, math.huge
        for _, matchedPlayer in ipairs(matches) do
            if matchedPlayer.Character and matchedPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local dist = (matchedPlayer.Character.HumanoidRootPart.Position - myPos).Magnitude
                if dist < closestDist then
                    closestDist, closestPlayer = dist, matchedPlayer
                end
            end
        end
        return closestPlayer
    end
    local function updateNearestPlayerButton()
        if not self.State.UI.nearestPlayerButton then return end
        if self.State.selectedPlayerName == "Nearest Player" then
            self.State.UI.nearestPlayerButton.Name = "-> Nearest Player"
        else
            self.State.UI.nearestPlayerButton.Name = "Nearest Player"
        end
    end
    local mainFolder = w:CreateFolder("Follow Settings")
    mainFolder:Slider("Speed", {min = 0; max = 5; precise = true;}, function(value)
        self.State.followSpeed = value
    end)
    mainFolder:Box("Enter Username", "string", function(value)
        if value == "" then notify("Input Error", "Please type a valid username.", 3) return end
        local found = findPlayerByPartialName(value)
        if found and found ~= LocalPlayer then
            self.State.selectedPlayerName = found.Name
            applyHighlight(found)
            notify("Player Selected", "Targeting " .. found.Name, 2)
            updateNearestPlayerButton()
        else
            self.State.selectedPlayerName = "Nearest Player"
            updateNearestPlayerButton()
            notify("Player Not Found", "Could not find player: " .. value, 3)
        end
    end)
    self.State.UI.nearestPlayerButton = mainFolder:Button("-> Nearest Player", function()
        self.State.selectedPlayerName = "Nearest Player"
        clearHighlight()
        notify("Player Selected", "Nearest Player", 2)
        updateNearestPlayerButton()
    end)
    mainFolder:Toggle("Enable Following", function(bool)
        self.State.isFollowing = bool
        notify("Following", bool and "Enabled" or "Disabled")
    end)
    mainFolder:Toggle("Attach", function(bool)
        self.State.isAttaching = bool
        notify("Attach", bool and "Enabled" or "Disabled")
    end)
    local combatFolder = w:CreateFolder("Combat")
    combatFolder:Slider("Attack Speed", {min = 0.1; max = 5; precise = true;}, function(value)
        self.State.attackSpeed = value
    end)
    combatFolder:Toggle("Auto Attack (M1)", function(bool)
        self.State.isAutoAttacking = bool
        notify("Auto Attack", bool and "ENABLED - Spamming M1" or "Disabled")
    end)
    local chaosFolder = w:CreateFolder("Anti-Aimbot")
    chaosFolder:Slider("Fling Strength", {min = 0.1; max = 2; precise = true;}, function(value)
        self.State.flingStrength = value
    end)
    chaosFolder:Toggle("Chaos Movement", function(bool)
        self.State.isChaosMode = bool
        notify("Chaos Mode", bool and "ENABLED - Breaking Aimbots" or "Disabled")
    end)
    local function getNearestPlayer()
        local localChar = LocalPlayer.Character
        if not (localChar and localChar:FindFirstChild("HumanoidRootPart")) then return nil end
        local myPos = localChar.HumanoidRootPart.Position
        local closest, dist = nil, math.huge
        for _, p in ipairs(self.Services.Players:GetPlayers()) do
            if p ~= LocalPlayer and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
                local d = (p.Character.HumanoidRootPart.Position - myPos).Magnitude
                if d < dist then closest, dist = p, d end
            end
        end
        return closest
    end
    local function getSelectedPlayer()
        if self.State.selectedPlayerName == "Nearest Player" then
            local n = getNearestPlayer()
            if n then applyHighlight(n) else clearHighlight() end
            return n
        elseif self.State.selectedPlayerName and self.Services.Players:FindFirstChild(self.State.selectedPlayerName) then
            local p = self.Services.Players[self.State.selectedPlayerName]
            if p.Character and p.Character:FindFirstChild("HumanoidRootPart") and p.Character:FindFirstChildOfClass("Humanoid").Health > 0 then
                return p
            end
        end
        clearHighlight()
        return nil
    end
    local lastAttackTime = 0
    self.State.Connections.RenderStepped = self.Services.RunService.RenderStepped:Connect(function()
        local target = getSelectedPlayer()
        if (self.State.isFollowing or self.State.isAttaching) and target then
            local localChar, targetChar = LocalPlayer.Character, target.Character
            if localChar and targetChar then
                local part, targetPart = localChar:FindFirstChild("HumanoidRootPart"), targetChar:FindFirstChild("HumanoidRootPart")
                if part and targetPart then
                    local hum = localChar:FindFirstChildOfClass("Humanoid")
                    if hum then hum.AutoRotate = false end
                    if self.State.isAttaching then
                        part.CFrame = part.CFrame:Lerp(targetPart.CFrame, self.State.followSpeed)
                        local thum = targetChar:FindFirstChildOfClass("Humanoid")
                        if thum and thum.Jump then hum.Jump = true end
                    elseif self.State.isFollowing then
                        part.CFrame = part.CFrame:Lerp(CFrame.new(part.Position, targetPart.Position), self.State.followSpeed)
                        hum:MoveTo(targetPart.Position)
                    end
                end
            end
        else
            local c = LocalPlayer.Character
            if c and c:FindFirstChildOfClass("Humanoid") then c:FindFirstChildOfClass("Humanoid").AutoRotate = true end
        end
        if self.State.isChaosMode then
            local character = LocalPlayer.Character
            local rootPart = character and character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                local currentTime = tick()
                if currentTime - self.State.lastChaosTime >= self.State.chaosInterval then
                    self.State.lastChaosTime = currentTime
                    self.State.oscillationValue = -self.State.oscillationValue
                    local offsetX = math.sin(currentTime * 8) * self.State.flingStrength * 5
                    local offsetY = self.State.oscillationValue * self.State.flingStrength * 3
                    local offsetZ = math.cos(currentTime * 8) * self.State.flingStrength * 5
                    rootPart.CFrame = rootPart.CFrame * CFrame.new(offsetX, offsetY, offsetZ)
                    local oscillationVelocity = Vector3.new(
                        math.sin(currentTime * 5) * self.State.flingStrength * 30,
                        self.State.oscillationValue * self.State.flingStrength * 15,
                        math.cos(currentTime * 5) * self.State.flingStrength * 30
                    )
                    rootPart.Velocity = rootPart.Velocity + oscillationVelocity
                end
            end
        end
        if self.State.isAutoAttacking and target then
            local localChar = LocalPlayer.Character
            if localChar then
                local currentTime = tick()
                local attackDelay = 1 / self.State.attackSpeed
                if currentTime - lastAttackTime >= attackDelay then
                    lastAttackTime = currentTime
                    local backpack = LocalPlayer:FindFirstChild("Backpack")
                    local equippedTool = localChar:FindFirstChildOfClass("Tool")
                    if not equippedTool and backpack then
                        local tool = backpack:FindFirstChildOfClass("Tool")
                        if tool then
                            tool.Parent = localChar
                            equippedTool = tool
                        end
                    end
                    if equippedTool and equippedTool:FindFirstChild("Handle") then
                        local targetChar = target.Character
                        if targetChar and targetChar:FindFirstChild("HumanoidRootPart") then
                            local handle = equippedTool:FindFirstChild("Handle")
                            if handle then
                                handle.CFrame = CFrame.new(handle.Position, targetChar.HumanoidRootPart.Position)
                            end
                            equippedTool:Activate()
                        end
                    end
                end
            end
        end
    end)
    self.State.Connections.KeyDown = LocalPlayer:GetMouse().KeyDown:Connect(function(k)
        k = k:lower()
        if k == "x" then
            self.State.isFollowing = not self.State.isFollowing
            notify("Following", self.State.isFollowing and "Enabled" or "Disabled")
        elseif k == "z" then
            self.State.isAttaching = not self.State.isAttaching
            notify("Attach", self.State.isAttaching and "Enabled" or "Disabled")
        elseif k == "c" then
            self.State.isAutoAttacking = not self.State.isAutoAttacking
            notify("Auto Attack", self.State.isAutoAttacking and "ENABLED - Spamming M1" or "Disabled")
        elseif k == "v" then
            self.State.isChaosMode = not self.State.isChaosMode
            notify("Chaos Mode", self.State.isChaosMode and "ENABLED - Breaking Aimbots" or "Disabled")
        end
    end)
    self.State.isGuiBuilt = true
    DoNotif("Attacher module activated.", 2)
end
function Modules.Attacher:Toggle()
    if self.State.isGuiBuilt then
        self:Deactivate()
    else
        self:Activate()
    end
end
RegisterCommand({
    Name = "attacher",
    Aliases = {"attachui", "followui"},
    Description = "Toggles the Player Attacher/Follower UI."
}, function()
    if not Modules.Attacher.Toggle then
        local originalFunctions = loadfile("path/to/your/AttacherModule.lua")()
        Modules.Attacher.Activate = originalFunctions.Activate
        Modules.Attacher.Deactivate = originalFunctions.Deactivate
        Modules.Attacher.Toggle = originalFunctions.Toggle
    end
    Modules.Attacher:Toggle()
end)
Modules.StaffSentry = {
    State = {
        IsEnabled = false,
        AutoJoinConnection = nil,
        StaffGroups = {1200769, 2868472, 4199740}
    }
}
function Modules.StaffSentry:Scan()
    local found = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        local isStaff = false
        for _, groupId in ipairs(self.State.StaffGroups) do
            if player:GetRankInGroup(groupId) > 0 then
                isStaff = true
                break
            end
        end
        if isStaff or player:IsFriendsWith(LocalPlayer.UserId) == false and (player.AccountAge < 5) then
            table.insert(found, player.Name)
        end
    end
    if #found > 0 then
        DoNotif("Staff/Suspects Found: " .. table.concat(found, ", "), 5)
    else
        DoNotif("No staff members detected in current server.", 3)
    end
end
function Modules.StaffSentry:Initialize()
    RegisterCommand({
        Name = "staffcheck",
        Aliases = {"scheck", "admins"},
        Description = "Scans the server for players in common staff groups or with suspicious account ages."
    }, function()
        self:Scan()
    end)
end
Modules.KnockbackNullifier = {
    State = {
        IsEnabled = false,
        Connection = nil,
        LastPosition = nil,
        LastVelocity = Vector3.new(0, 0, 0),
        Mode = "aggressive"
    },
    Config = {
        VelocityThreshold = 20,
        YThreshold = 10,
        CheckInterval = 0,
        PreserveJumps = true,
        PreserveYVelocity = false,
        MaxVelocityClamp = 30
    }
}
function Modules.KnockbackNullifier:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    local lastCheck = tick()
    self.State.Connection = RunService.Heartbeat:Connect(function()
        if tick() - lastCheck < self.Config.CheckInterval then
            return
        end
        lastCheck = tick()
        local char = LocalPlayer.Character
        if not char then return end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if not hrp or not humanoid then return end
        local currentVel = hrp.AssemblyLinearVelocity
        local currentMag = currentVel.Magnitude
        if not self.State.LastPosition then
            self.State.LastPosition = hrp.Position
        end
        local isKnockback = false
        if self.State.Mode == "aggressive" then
            if currentMag > self.Config.VelocityThreshold then
                isKnockback = true
            end
            if currentVel.Y > self.Config.YThreshold and not (self.Config.PreserveJumps and humanoid:GetState() == Enum.HumanoidStateType.Jumping) then
                isKnockback = true
            end
        elseif self.State.Mode == "moderate" then
            local moveDir = humanoid.MoveDirection
            if currentMag > self.Config.VelocityThreshold and moveDir.Magnitude < 0.1 then
                isKnockback = true
            end
        elseif self.State.Mode == "subtle" then
            if currentMag > self.Config.MaxVelocityClamp then
                isKnockback = true
            end
        end
        if isKnockback then
            if self.Config.PreserveYVelocity then
                hrp.AssemblyLinearVelocity = Vector3.new(0, currentVel.Y, 0)
            else
                hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
            end
            hrp.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
            if self.State.Mode == "aggressive" then
                hrp.Anchored = true
                task.wait()
                hrp.Anchored = false
            end
        end
        self.State.LastVelocity = currentVel
        self.State.LastPosition = hrp.Position
    end)
    DoNotif("Knockback Nullifier: ENABLED (" .. self.State.Mode .. " mode)", 2)
end
function Modules.KnockbackNullifier:Disable()
    if not self.State.IsEnabled then return end
    self.State.IsEnabled = false
    if self.State.Connection then
        self.State.Connection:Disconnect()
        self.State.Connection = nil
    end
    self.State.LastPosition = nil
    self.State.LastVelocity = Vector3.new(0, 0, 0)
    DoNotif("Knockback Nullifier: DISABLED", 2)
end
function Modules.KnockbackNullifier:Toggle()
    if self.State.IsEnabled then
        self:Disable()
    else
        self:Enable()
    end
end
function Modules.KnockbackNullifier:SetMode(mode)
    mode = mode:lower()
    if mode == "aggressive" or mode == "agg" or mode == "a" then
        self.State.Mode = "aggressive"
    elseif mode == "moderate" or mode == "mod" or mode == "m" then
        self.State.Mode = "moderate"
    elseif mode == "subtle" or mode == "sub" or mode == "s" then
        self.State.Mode = "subtle"
    else
        DoNotif("Invalid mode. Use: aggressive, moderate, or subtle", 3)
        return
    end
    DoNotif("Knockback mode set to: " .. self.State.Mode, 2)
    if self.State.IsEnabled then
        self:Disable()
        self:Enable()
    end
end
function Modules.KnockbackNullifier:Initialize()
    local module = self
    RegisterCommand({
        Name = "noknockback",
        Aliases = {"nokb"},
        Description = "Negates knockback and external physics impulses."
    }, function(args)
        if args[1] then
            module:SetMode(args[1])
        else
            module:Toggle()
        end
    end)
    RegisterCommand({
        Name = "kbmode",
        Aliases = {"knockbackmode"},
        Description = "Set knockback nullifier mode: aggressive, moderate, or subtle."
    }, function(args)
        if not args[1] then
            DoNotif("Current mode: " .. module.State.Mode, 2)
            return
        end
        module:SetMode(args[1])
    end)
    RegisterCommand({
        Name = "kbthreshold",
        Aliases = {"knockbackthreshold"},
        Description = "Set velocity threshold for knockback detection."
    }, function(args)
        local threshold = tonumber(args[1])
        if not threshold then
            DoNotif("Current threshold: " .. module.Config.VelocityThreshold, 2)
            return
        end
        module.Config.VelocityThreshold = threshold
        DoNotif("Knockback threshold set to: " .. threshold, 2)
    end)
end
Modules.AntiVoid = {
    State = {
        IsEnabled = false,
        Connection = nil,
    },
    Config = {
        SafetyBuffer = 20,
    }
}
function Modules.AntiVoid:_getSafeCFrame()
    local spawns = {}
    for _, desc in ipairs(Workspace:GetDescendants()) do
        if desc:IsA("SpawnLocation") and desc.Enabled then
            table.insert(spawns, desc)
        end
    end
    if #spawns > 0 then
        return spawns[1].CFrame + Vector3.new(0, 5, 0)
    end
    return CFrame.new(0, 100, 0)
end
function Modules.AntiVoid:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    self.State.Connection = RunService.Heartbeat:Connect(function()
        local char = Players.LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        local killHeight = Workspace.FallenPartsDestroyHeight
        if hrp.Position.Y < (killHeight + self.Config.SafetyBuffer) then
            hrp.AssemblyLinearVelocity = Vector3.zero
            hrp.AssemblyAngularVelocity = Vector3.zero
            local targetCFrame = self:_getSafeCFrame()
            hrp.CFrame = targetCFrame
            DoNotif("Anti-Void: Saved from the abyss!", 2)
        end
    end)
    DoNotif("Anti-Void: SECURED", 2)
end
function Modules.AntiVoid:Disable()
    if not self.State.IsEnabled then return end
    self.State.IsEnabled = false
    if self.State.Connection then self.State.Connection:Disconnect() end
    DoNotif("Anti-Void: UNSECURED", 2)
end
function Modules.AntiVoid:Toggle()
    if self.State.IsEnabled then self:Disable() else self:Enable() end
end
RegisterCommand({
    Name = "antivoid",
    Aliases = {"av", "novoid", "safety"},
    Description = "Prevents you from dying to the void by teleporting you to safety."
}, function()
    Modules.AntiVoid:Toggle()
end)
Modules.codedoor = {
    State = {
        LastFoundCode = nil
    },
    Config = {
        Paths = {
            {Root = "CodeDoor", Target = "Code", Property = "Value"},
            {Root = "Staff_Code", Target = "Code.SurfaceGui.Desc", Property = "Text"}
        }
    }
}
function Modules.codedoor:GetCode()
    local foundCode = nil
    local workspaceService = game:GetService("Workspace")
    for _, config in ipairs(self.Config.Paths) do
        local rootObject = workspaceService:FindFirstChild(config.Root)
        if rootObject then
            local current = rootObject
            local segments = string.split(config.Target, ".")
            for _, segment in ipairs(segments) do
                current = current and current:FindFirstChild(segment)
            end
            if current then
                local success, val = pcall(function() return current[config.Property] end)
                if success and val ~= "" then
                    foundCode = tostring(val)
                    break
                end
            end
        end
    end
    if foundCode then
        self.State.LastFoundCode = foundCode
        DoNotif("Success: Code extracted.", 3)
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Door Unlocker",
            Text = "Code: " .. foundCode,
            Duration = 9
        })
        if Modules.CommandBar and Modules.CommandBar.AddOutput then
            Modules.CommandBar:AddOutput("[DECRYPTED]: Door Code is " .. foundCode, Modules.CommandBar.Theme.Accent)
        end
    else
        DoNotif("Error: No codedoor detected in Workspace.", 3)
    end
end
function Modules.codedoor:Initialize()
    local module = self
    RegisterCommand({
        Name = "codedoor",
        Aliases = {"unlock", "getcode", "doorcode"},
        Description = "Scans and extracts the PIN from common free-model codedoors."
    }, function()
        module:GetCode()
    end)
end
Modules.AdvancedShiftLock = {
    State = {
        IsEnabled = false,
        IsLocked = false,
        UI = {},
        Connections = {},
        Originals = {},
        CurrentOffset = Vector3.zero
    },
    Config = {
        Icons = {
            On = "rbxasset://textures/ui/mouseLock_on.png",
            Off = "rbxasset://textures/ui/mouseLock_off.png"
        },
        CameraOffset = Vector3.new(1.75, 0, 0),
        Smoothing = 0.25,
        ToggleKey = Enum.KeyCode.LeftShift
    },
    Dependencies = {"Players", "TweenService", "UserInputService", "RunService", "Workspace", "CoreGui"},
    Services = {}
}
function Modules.AdvancedShiftLock:_makeDraggable(guiObject, dragHandle)
    local UIS = self.Services.UserInputService
    local dragging = false
    local dragStart, startPos
    dragHandle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = guiObject.Position
            local changedConn; changedConn = input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                    changedConn:Disconnect()
                end
            end)
        end
    end)
    UIS.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - dragStart
            guiObject.Position = UDim2.new(
                startPos.X.Scale,
                startPos.X.Offset + delta.X,
                startPos.Y.Scale,
                startPos.Y.Offset + delta.Y
            )
        end
    end)
end
function Modules.AdvancedShiftLock:_updateLogic(deltaTime)
    local char = self.Services.Players.LocalPlayer.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    local camera = self.Services.Workspace.CurrentCamera
    if not (hum and hrp and camera and hum.Health > 0) then return end
    if self.State.IsLocked then
        local lookVector = camera.CFrame.LookVector
        local flatVector = Vector3.new(lookVector.X, 0, lookVector.Z)
        if flatVector.Magnitude > 1e-4 then
            hrp.CFrame = hrp.CFrame:Lerp(CFrame.lookAt(hrp.Position, hrp.Position + flatVector.Unit), 0.4)
        end
        hum.CameraOffset = hum.CameraOffset:Lerp(self.Config.CameraOffset, self.Config.Smoothing)
        self.Services.UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
    else
        if hum.CameraOffset.Magnitude > 0.01 then
            hum.CameraOffset = hum.CameraOffset:Lerp(Vector3.zero, self.Config.Smoothing)
        end
    end
end
function Modules.AdvancedShiftLock:_setLockState(newState)
    local char = self.Services.Players.LocalPlayer.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    if newState and hum and hum.Sit then return end
    self.State.IsLocked = newState
    if newState then
        if hum then
            self.State.Originals.AutoRotate = hum.AutoRotate
            hum.AutoRotate = false
        end
    else
        if hum and self.State.Originals.AutoRotate ~= nil then
            hum.AutoRotate = self.State.Originals.AutoRotate
        end
        self.Services.UserInputService.MouseBehavior = Enum.MouseBehavior.Default
    end
    local ui = self.State.UI
    if ui.Button then
        local targetColor = newState and Color3.fromRGB(0, 255, 200) or Color3.fromRGB(0, 140, 255)
        local targetBg = newState and Color3.fromRGB(20, 35, 30) or Color3.fromRGB(25, 25, 30)
        self.Services.TweenService:Create(ui.Stroke, TweenInfo.new(0.2), {Color = targetColor, Thickness = newState and 3 or 2}):Play()
        self.Services.TweenService:Create(ui.Button, TweenInfo.new(0.2), {BackgroundColor3 = targetBg}):Play()
        ui.Icon.Image = newState and self.Config.Icons.On or self.Config.Icons.Off
    end
end
function Modules.AdvancedShiftLock:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    local ui = self.State.UI
    ui.ScreenGui = Instance.new("ScreenGui", self.Services.CoreGui)
    ui.ScreenGui.Name = "ForensicShiftLock_V2"
    ui.ScreenGui.ResetOnSpawn = false
    ui.Button = Instance.new("ImageButton", ui.ScreenGui)
    ui.Button.Size = UDim2.fromOffset(55, 55)
    ui.Button.Position = UDim2.new(1, -75, 1, -150)
    ui.Button.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
    Instance.new("UICorner", ui.Button).CornerRadius = UDim.new(1, 0)
    ui.Stroke = Instance.new("UIStroke", ui.Button)
    ui.Stroke.Color = Color3.fromRGB(0, 140, 255)
    ui.Stroke.Thickness = 2
    ui.Icon = Instance.new("ImageLabel", ui.Button)
    ui.Icon.Size = UDim2.fromScale(0.6, 0.6)
    ui.Icon.Position = UDim2.fromScale(0.2, 0.2)
    ui.Icon.BackgroundTransparency = 1
    ui.Icon.Image = self.Config.Icons.Off
    self:_makeDraggable(ui.Button, ui.Button)
    self.State.Connections.Main = self.Services.RunService.RenderStepped:Connect(function(dt)
        self:_updateLogic(dt)
    end)
    self.State.Connections.Input = self.Services.UserInputService.InputBegan:Connect(function(input, gpe)
        if not gpe and input.KeyCode == self.Config.ToggleKey then
            self:_setLockState(not self.State.IsLocked)
        end
    end)
    ui.Button.Activated:Connect(function()
        self:_setLockState(not self.State.IsLocked)
    end)
    DoNotif("Advanced Shift-Lock V2 Enabled.", 3)
end
function Modules.AdvancedShiftLock:Disable()
    if not self.State.IsEnabled then return end
    self:_setLockState(false)
    for _, conn in pairs(self.State.Connections) do conn:Disconnect() end
    if self.State.UI.ScreenGui then self.State.UI.ScreenGui:Destroy() end
    self.State.IsEnabled = false
    table.clear(self.State.Connections)
    self.State.UI = {}
    DoNotif("Shift-Lock Disabled.", 2)
end
function Modules.AdvancedShiftLock:Initialize()
    local module = self
    module.Services = {}
    for _, serviceName in ipairs(module.Dependencies) do
        module.Services[serviceName] = game:GetService(serviceName)
    end
    RegisterCommand({
        Name = "shiftlock",
        Aliases = {"sl", "lockcam"},
        Description = "Toggles an advanced Over-The-Shoulder Shift Lock."
    }, function()
        if module.State.IsEnabled then
            module:Disable()
        else
            module:Enable()
        end
    end)
end
Modules.AntiTrip = {
    State = {
        IsEnabled = false,
        OriginalStateCache = setmetatable({}, {__mode = "k"}),
        Connections = {}
    },
    Config = {
        StatesToBlock = {
            Enum.HumanoidStateType.FallingDown,
            Enum.HumanoidStateType.Ragdoll,
            Enum.HumanoidStateType.PlatformStanding
        }
    },
    Dependencies = {"Players", "RunService", "ReplicatedService", "ReplicatedStorage"},
    Services = {}
}
function Modules.AntiTrip:_forceRecovery(humanoid)
    if not humanoid then return end
    pcall(function()
        local character = humanoid.Parent
        local rootPart = character and character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            rootPart.AssemblyLinearVelocity = Vector3.zero
        end
        humanoid.PlatformStand = false
        humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
    end)
end
function Modules.AntiTrip:_applyToCharacter(character)
    if not character then return end
    local humanoid = character:WaitForChild("Humanoid", 5)
    if not humanoid then return end
    local savedStates = {}
    for _, stateType in ipairs(self.Config.StatesToBlock) do
        local success, isEnabled = pcall(humanoid.GetStateEnabled, humanoid, stateType)
        if success then
            savedStates[stateType] = isEnabled
            pcall(humanoid.SetStateEnabled, humanoid, stateType, false)
        end
    end
    self.State.OriginalStateCache[humanoid] = savedStates
    local loopConnection = self.Services.RunService.Stepped:Connect(function()
        local currentState = humanoid:GetState()
        for _, blockedState in ipairs(self.Config.StatesToBlock) do
            if currentState == blockedState then
                self:_forceRecovery(humanoid)
                break
            end
        end
    end)
    self.State.Connections[character] = loopConnection
end
function Modules.AntiTrip:_revertForCharacter(character)
    if not character then return end
    if self.State.Connections[character] then
        self.State.Connections[character]:Disconnect()
        self.State.Connections[character] = nil
    end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid and self.State.OriginalStateCache[humanoid] then
        for stateType, wasEnabled in pairs(self.State.OriginalStateCache[humanoid]) do
            pcall(humanoid.SetStateEnabled, humanoid, stateType, wasEnabled)
        end
        self.State.OriginalStateCache[humanoid] = nil
    end
end
function Modules.AntiTrip:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    local localPlayer = self.Services.Players.LocalPlayer
    if localPlayer.Character then
        self:_applyToCharacter(localPlayer.Character)
    end
    self.State.Connections.CharacterAdded = localPlayer.CharacterAdded:Connect(function(char) self:_applyToCharacter(char) end)
    self.State.Connections.CharacterRemoving = localPlayer.CharacterRemoving:Connect(function(char) self:_revertForCharacter(char) end)
    DoNotif("Anti-Trip Enabled", 2)
end
function Modules.AntiTrip:Disable()
    if not self.State.IsEnabled then return end
    self.State.IsEnabled = false
    if self.State.Connections.CharacterAdded then self.State.Connections.CharacterAdded:Disconnect() end
    if self.State.Connections.CharacterRemoving then self.State.Connections.CharacterRemoving:Disconnect() end
    self.State.Connections.CharacterAdded, self.State.Connections.CharacterRemoving = nil, nil
    if self.Services.Players.LocalPlayer.Character then
        self:_revertForCharacter(self.Services.Players.LocalPlayer.Character)
    end
    DoNotif("Anti-Trip Disabled", 2)
end
function Modules.AntiTrip:Toggle()
    if self.State.IsEnabled then
        self:Disable()
    else
        self:Enable()
    end
end
function Modules.AntiTrip:Initialize()
    local module = self
    for _, service in ipairs(self.Dependencies) do
        module.Services[service] = game:GetService(service)
    end
    RegisterCommand({
        Name = "antitrip",
        Description = "Toggles a system to prevent your character from tripping or ragdolling."
    }, function()
        module:Toggle()
    end)
end
Modules.AdBlock = {
    State = {
        IsEnabled = false,
        Connections = {},
        RemovedAds = 0,
        Whitelist = {},
        ProcessedInstances = setmetatable({}, {__mode = "k"})
    },
    Dependencies = {"Workspace", "Players", "CoreGui"},
    Services = {},
    Config = {
        AggressiveMode = false,
        RemoveBillboards = true,
        RemoveSurfaceGuis = false,
        ProtectCoreGuis = true,
        DebugMode = false,
        WhitelistPatterns = {
            "^roblox",
            "^core",
            "^system",
            "health", "hotbar", "backpack", "chat",
            "leaderboard", "playerlist", "nametag",
            "menu", "settings", "inventory", "hud"
        },
        BlacklistPatterns = {
            "ad[sv]?$", "advert", "sponsor", "promo",
            "donation", "robux", "gamepass", "purchase",
            "vip", "premium", "buy", "shop"
        }
    }
}
local function debugLog(message)
    if Modules.AdBlock.Config.DebugMode then
        print("[AdBlock Debug]", message)
    end
end
local function isWhitelisted(name)
    name = name:lower()
    for instance in pairs(Modules.AdBlock.State.Whitelist) do
        if typeof(instance) == "Instance" and instance.Name:lower() == name then
            return true
        end
    end
    for _, pattern in ipairs(Modules.AdBlock.Config.WhitelistPatterns) do
        if name:match(pattern) then
            debugLog("Whitelisted by pattern: " .. name .. " (" .. pattern .. ")")
            return true
        end
    end
    return false
end
local function isBlacklisted(name)
    name = name:lower()
    for _, pattern in ipairs(Modules.AdBlock.Config.BlacklistPatterns) do
        if name:match(pattern) then
            debugLog("Blacklisted by pattern: " .. name .. " (" .. pattern .. ")")
            return true
        end
    end
    return false
end
local function hasAdCharacteristics(gui)
    local suspicionScore = 0
    local imageLabels = gui:GetDescendants()
    local imageCount = 0
    for _, obj in ipairs(imageLabels) do
        if obj:IsA("ImageLabel") then
            imageCount = imageCount + 1
        end
    end
    if imageCount > 3 then
        suspicionScore = suspicionScore + 2
    end
    for _, obj in ipairs(gui:GetDescendants()) do
        if obj:IsA("TextButton") or obj:IsA("TextLabel") then
            local text = obj.Text:lower()
            if text:match("buy") or text:match("purchase") or text:match("robux") 
                or text:match("vip") or text:match("premium") or text:match("gamepass") then
                suspicionScore = suspicionScore + 3
            end
        end
    end
    for _, obj in ipairs(gui:GetDescendants()) do
        if obj:IsA("ImageLabel") or obj:IsA("ImageButton") then
            local image = obj.Image
            if image and (image:match("rbxhttp") or image:match("http")) then
                suspicionScore = suspicionScore + 1
            end
        end
    end
    if gui:IsA("ScreenGui") then
        for _, frame in ipairs(gui:GetChildren()) do
            if frame:IsA("GuiObject") then
                local size = frame.AbsoluteSize
                local position = frame.AbsolutePosition
                if size.Y < 100 and size.X > 200 then
                    suspicionScore = suspicionScore + 1
                end
            end
        end
    end
    return suspicionScore >= (Modules.AdBlock.Config.AggressiveMode and 2 or 4)
end
local function isCoreGui(gui)
    if gui:IsDescendantOf(game:GetService("CoreGui")) then
        return true
    end
    local name = gui.Name:lower()
    if name:match("^roblox") or name:match("^core") then
        return true
    end
    return false
end
function Modules.AdBlock:_destroy(instance, reason)
    if not instance or not instance.Parent then return end
    if isWhitelisted(instance.Name) then
        debugLog("Skipped whitelisted: " .. instance.Name)
        return
    end
    if self.Config.ProtectCoreGuis and isCoreGui(instance) then
        debugLog("Protected core GUI: " .. instance.Name)
        return
    end
    local success = pcall(function()
        debugLog("Removing: " .. instance.Name .. " (" .. (reason or "unknown reason") .. ")")
        instance:Destroy()
        self.State.RemovedAds = self.State.RemovedAds + 1
    end)
    if not success then
        debugLog("Failed to remove: " .. instance.Name)
    end
end
function Modules.AdBlock:_processObject(obj)
    if not obj or not obj.Parent then return end
    if self.State.ProcessedInstances[obj] then
        return
    end
    self.State.ProcessedInstances[obj] = true
    if isWhitelisted(obj.Name) then
        return
    end
    if self.Config.RemoveBillboards and obj:IsA("BillboardGui") then
        local parent = obj.Parent
        if parent and parent:IsA("BasePart") then
            local humanoid = parent.Parent and parent.Parent:FindFirstChildOfClass("Humanoid")
            if humanoid then
                debugLog("Skipped character billboard: " .. obj.Name)
                return
            end
        end
        if isBlacklisted(obj.Name) then
            self:_destroy(obj, "blacklisted billboard")
            return
        end
    end
    if self.Config.RemoveSurfaceGuis and obj:IsA("SurfaceGui") then
        if isBlacklisted(obj.Name) or (self.Config.AggressiveMode and hasAdCharacteristics(obj)) then
            self:_destroy(obj, "suspicious surface GUI")
            return
        end
    end
    if obj:IsA("ScreenGui") then
        local shouldRemove = false
        local reason = ""
        if isBlacklisted(obj.Name) then
            shouldRemove = true
            reason = "blacklisted name"
        end
        if not shouldRemove and hasAdCharacteristics(obj) then
            shouldRemove = true
            reason = "ad characteristics detected"
        end
        if not shouldRemove and obj:FindFirstChild("AdGuiAdornee", true) then
            shouldRemove = true
            reason = "AdGuiAdornee marker"
        end
        if shouldRemove then
            self:_destroy(obj, reason)
            return
        end
    end
    if obj:IsA("BasePart") and self.Config.RemoveBillboards then
        local billboard = obj:FindFirstChildWhichIsA("BillboardGui")
        if billboard and (isBlacklisted(obj.Name) or isBlacklisted(billboard.Name)) then
            self:_destroy(obj, "part with ad billboard")
            return
        end
    end
    if self.Config.AggressiveMode and isBlacklisted(obj.Name) then
        if obj:IsA("GuiObject") or obj:IsA("LayerCollector") then
            self:_destroy(obj, "blacklisted name")
        end
    end
end
function Modules.AdBlock:Enable()
    if self.State.IsEnabled then
        DoNotif("AdBlock already enabled.", 2)
        return
    end
    self.State.IsEnabled = true
    self.State.RemovedAds = 0
    local function scan(container, containerName)
        debugLog("Scanning: " .. containerName)
        local count = 0
        for _, obj in ipairs(container:GetDescendants()) do
            self:_processObject(obj)
            count = count + 1
        end
        debugLog("Scanned " .. count .. " objects in " .. containerName)
    end
    scan(self.Services.Workspace, "Workspace")
    local player = self.Services.Players.LocalPlayer
    if player then
        local gui = player:FindFirstChild("PlayerGui")
        if not gui then
            gui = player:WaitForChild("PlayerGui", 5)
        end
        if gui then
            scan(gui, "PlayerGui")
        end
    end
    if not self.Config.ProtectCoreGuis then
        scan(self.Services.CoreGui, "CoreGui")
    end
    local function watch(container, containerName)
        local conn = container.DescendantAdded:Connect(function(obj)
            if self.State.IsEnabled then
                task.defer(function()
                    self:_processObject(obj)
                end)
            end
        end)
        table.insert(self.State.Connections, conn)
        debugLog("Watching: " .. containerName)
    end
    watch(self.Services.Workspace, "Workspace")
    if player and player:FindFirstChild("PlayerGui") then
        watch(player.PlayerGui, "PlayerGui")
    end
    if not self.Config.ProtectCoreGuis then
        watch(self.Services.CoreGui, "CoreGui")
    end
    DoNotif("AdBlock enabled. Removed " .. self.State.RemovedAds .. " ads.", 3)
end
function Modules.AdBlock:Disable()
    if not self.State.IsEnabled then
        DoNotif("AdBlock not active.", 2)
        return
    end
    self.State.IsEnabled = false
    for _, c in ipairs(self.State.Connections) do
        pcall(function() c:Disconnect() end)
    end
    table.clear(self.State.Connections)
    table.clear(self.State.ProcessedInstances)
    DoNotif("AdBlock disabled. Total ads removed: " .. self.State.RemovedAds, 3)
end
function Modules.AdBlock:Toggle()
    if self.State.IsEnabled then
        self:Disable()
    else
        self:Enable()
    end
end
function Modules.AdBlock:AddWhitelist(instance)
    if typeof(instance) == "Instance" then
        self.State.Whitelist[instance] = true
        debugLog("Added to whitelist: " .. instance.Name)
        return true
    end
    return false
end
function Modules.AdBlock:RemoveWhitelist(instance)
    if self.State.Whitelist[instance] then
        self.State.Whitelist[instance] = nil
        debugLog("Removed from whitelist: " .. instance.Name)
        return true
    end
    return false
end
function Modules.AdBlock:GetStats()
    return {
        Enabled = self.State.IsEnabled,
        RemovedAds = self.State.RemovedAds,
        WhitelistedCount = 0
    }
end
function Modules.AdBlock:Initialize()
    for _, serviceName in ipairs(self.Dependencies) do
        self.Services[serviceName] = game:GetService(serviceName)
    end
    RegisterCommand({
        Name = "adblock",
        Aliases = {"removeads", "blockads"},
        Description = "Toggles automatic ad removal."
    }, function()
        self:Toggle()
    end)
    RegisterCommand({
        Name = "adblockstats",
        Aliases = {"abstats"},
        Description = "Shows AdBlock statistics."
    }, function()
        local stats = self:GetStats()
        print("=== AdBlock Stats ===")
        print("Enabled:", stats.Enabled)
        print("Ads Removed:", stats.RemovedAds)
    end)
    RegisterCommand({
        Name = "adblockmode",
        Aliases = {"abmode"},
        Description = "Toggle aggressive mode."
    }, function(args)
        self.Config.AggressiveMode = not self.Config.AggressiveMode
        DoNotif("AdBlock Aggressive Mode: " .. tostring(self.Config.AggressiveMode), 2)
    end)
end
Modules.Fakeout = {
    State = {
        IsExecuting = false
    },
    Dependencies = {"Players", "Workspace"},
    Services = {}
}
function Modules.Fakeout:Execute()
    if self.State.IsExecuting then
        DoNotif("A fakeout is already in progress.", 1.5)
        return
    end
    local localPlayer = self.Services.Players.LocalPlayer
    local character = localPlayer.Character
    local rootPart = character and character:FindFirstChild("HumanoidRootPart")
    if not rootPart then
        DoNotif("Fakeout failed: Character root not found.", 2)
        return
    end
    self.State.IsExecuting = true
    task.spawn(function()
        local originalCFrame = rootPart.CFrame
        local originalDestroyHeight = self.Services.Workspace.FallenPartsDestroyHeight
        local wasAntiVoidEnabled = false
        if Modules.AntiVoid and Modules.AntiVoid.State.IsEnabled then
            wasAntiVoidEnabled = true
            Modules.AntiVoid:Disable()
        end
        local success, err = pcall(function()
            self.Services.Workspace.FallenPartsDestroyHeight = -1e9
            rootPart.CFrame = CFrame.new(originalCFrame.Position.X, originalDestroyHeight - 50, originalCFrame.Position.Z)
            task.wait(1)
            if rootPart and rootPart.Parent then
                rootPart.CFrame = originalCFrame
            end
        end)
        if not success then
            warn("[Fakeout] Sequence failed:", err)
        end
        self.Services.Workspace.FallenPartsDestroyHeight = originalDestroyHeight
        if wasAntiVoidEnabled and Modules.AntiVoid then
            Modules.AntiVoid:Enable()
        end
        self.State.IsExecuting = false
    end)
end
function Modules.Fakeout:Initialize()
    local module = self
    for _, serviceName in ipairs(self.Dependencies) do
        module.Services[serviceName] = game:GetService(serviceName)
    end
    RegisterCommand({
        Name = "fakeout",
        Description = "Teleports you to the void and back"
    }, function()
        module:Execute()
    end)
end
Modules.AntiPlayerPhysics = {
    State = {
        IsEnabled = false,
        SteppedConnection = nil,
        OriginalProperties = setmetatable({}, {__mode = "k"})
    },
    Services = {
        Players = game:GetService("Players"),
        RunService = game:GetService("RunService")
    }
}
function Modules.AntiPlayerPhysics:_revertCharacter(character)
    if not character then return end
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") and self.State.OriginalProperties[part] then
            part.CanCollide = self.State.OriginalProperties[part].CanCollide
            part.Massless = self.State.OriginalProperties[part].Massless
            self.State.OriginalProperties[part] = nil
        end
    end
end
function Modules.AntiPlayerPhysics:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    self.State.SteppedConnection = self.Services.RunService.Stepped:Connect(function()
        for _, player in ipairs(self.Services.Players:GetPlayers()) do
            if player ~= self.Services.Players.LocalPlayer and player.Character then
                pcall(function()
                    for _, part in ipairs(player.Character:GetChildren()) do
                        if part:IsA("BasePart") then
                            if not self.State.OriginalProperties[part] then
                                self.State.OriginalProperties[part] = {
                                    CanCollide = part.CanCollide,
                                    Massless = part.Massless
                                }
                            end
                            part.CanCollide = false
                            if part.Name == "Torso" then
                                part.Massless = true
                            end
                            part.Velocity = Vector3.new()
                            part.RotVelocity = Vector3.new()
                        end
                    end
                end)
            end
        end
    end)
    DoNotif("Anti-Player Physics: ENABLED.", 2)
end
function Modules.AntiPlayerPhysics:Disable()
    if not self.State.IsEnabled then return end
    self.State.IsEnabled = false
    if self.State.SteppedConnection then
        self.State.SteppedConnection:Disconnect()
        self.State.SteppedConnection = nil
    end
    for _, player in ipairs(self.Services.Players:GetPlayers()) do
        if player.Character then
            self:_revertCharacter(player.Character)
        end
    end
    table.clear(self.State.OriginalProperties)
    DoNotif("Anti-Player Physics: DISABLED.", 2)
end
function Modules.AntiPlayerPhysics:Toggle()
    if self.State.IsEnabled then
        self:Disable()
    else
        self:Enable()
    end
end
function Modules.AntiPlayerPhysics:Initialize()
    local module = self
    RegisterCommand({
        Name = "antifling",
        Aliases = {"nofling"},
        Description = "Toggles a simple anti-fling that makes other players non-collidable."
    }, function()
        module:Toggle()
    end)
end
Modules.AntiKill = {
    State = {
        IsEnabled = false,
        RenderConnection = nil,
        CameraConnection = nil
    },
    Services = {
        Players = game:GetService("Players"),
        RunService = game:GetService("RunService"),
        UserInputService = game:GetService("UserInputService"),
        Workspace = game:GetService("Workspace")
    }
}
function Modules.AntiKill:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    local Player = self.Services.Players.LocalPlayer
    local Camera = self.Services.Workspace.CurrentCamera
    local function onCameraChanged()
       Camera = self.Services.Workspace.CurrentCamera
    end
    self.State.CameraConnection = self.Services.Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(onCameraChanged)
    local function protectionLoop()
        local Character = Player.Character
        if not Character then return end
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        local RootPart = Character:FindFirstChild("HumanoidRootPart")
        if not (Humanoid and RootPart) then return end
        if self.Services.UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then
            local _, cameraY, _ = Camera.CFrame:ToEulerAnglesYXZ()
            RootPart.CFrame = CFrame.new(RootPart.Position) * CFrame.Angles(0, cameraY, 0)
        end
        Humanoid.Sit = true
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
    end
    self.State.RenderConnection = self.Services.RunService.RenderStepped:Connect(protectionLoop)
    DoNotif("Anti-Kill System: ENABLED.", 2)
end
function Modules.AntiKill:Disable()
    if not self.State.IsEnabled then return end
    self.State.IsEnabled = false
    if self.State.RenderConnection then
        self.State.RenderConnection:Disconnect()
        self.State.RenderConnection = nil
    end
    if self.State.CameraConnection then
        self.State.CameraConnection:Disconnect()
        self.State.CameraConnection = nil
    end
    pcall(function()
        local Humanoid = self.Services.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if Humanoid then
            Humanoid.Sit = false
            Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        end
    end)
    DoNotif("Anti-Kill System: DISABLED.", 2)
end
function Modules.AntiKill:Toggle()
    if self.State.IsEnabled then
        self:Disable()
    else
        self:Enable()
    end
end
function Modules.AntiKill:Initialize()
    local module = self
    RegisterCommand({
        Name = "antikill",
        Aliases = {},
        Description = "Toggles a client-sided system to resist death and character manipulation."
    }, function()
        module:Toggle()
    end)
end
Modules.SpectateController = {
    State = {
        IsEnabled = false,
        TargetPlayer = nil,
        Connections = {}
    },
    Services = {
        Players = game:GetService("Players"),
        Workspace = game:GetService("Workspace")
    }
}
function Modules.SpectateController:_cleanup()
    for _, conn in pairs(self.State.Connections) do
        if conn and conn.Connected then
            conn:Disconnect()
        end
    end
    table.clear(self.State.Connections)
    self.State.IsEnabled = false
    self.State.TargetPlayer = nil
end
function Modules.SpectateController:Disable()
    if not self.State.IsEnabled then return end
    local localPlayer = self.Services.Players.LocalPlayer
    self:_cleanup()
    if self.Services.Workspace.CurrentCamera and localPlayer.Character then
        self.Services.Workspace.CurrentCamera.CameraSubject = localPlayer.Character
    end
    DoNotif("Spectate disabled.", 2)
end
function Modules.SpectateController:Enable(targetPlayer: Player)
    self:Disable()
    if not targetPlayer or targetPlayer == self.Services.Players.LocalPlayer then
        return DoNotif("Invalid or self-targeted player.", 3)
    end
    if not targetPlayer.Character then
        return DoNotif("Target player does not have a character to spectate.", 3)
    end
    self.State.IsEnabled = true
    self.State.TargetPlayer = targetPlayer
    local camera = self.Services.Workspace.CurrentCamera
    camera.CameraSubject = targetPlayer.Character
    local function resetView()
        if self.State.IsEnabled and self.State.TargetPlayer and self.State.TargetPlayer.Character then
            if camera.CameraSubject ~= self.State.TargetPlayer.Character then
                camera.CameraSubject = self.State.TargetPlayer.Character
            end
        else
            self:Disable()
        end
    end
    self.State.Connections.TargetRespawn = targetPlayer.CharacterAdded:Connect(function(newCharacter)
        task.wait()
        resetView()
    end)
    self.State.Connections.CameraGuard = camera:GetPropertyChangedSignal("CameraSubject"):Connect(resetView)
    self.State.Connections.LocalPlayerRespawn = self.Services.Players.LocalPlayer.CharacterAdded:Connect(function()
        task.wait(0.1)
        resetView()
    end)
    DoNotif("Now spectating " .. targetPlayer.Name, 2)
end
function Modules.SpectateController:Initialize()
    RegisterCommand({
        Name = "view",
        Aliases = {"spectate"},
        Description = "Spectates a specified player."
    }, function(args)
        if not args[1] then
            return DoNotif("Usage: ;view <PlayerName>", 3)
        end
        local target = Utilities.findPlayer(args[1])
        if target then
            self:Enable(target)
        else
            DoNotif("Player '" .. args[1] .. "' not found.", 3)
        end
    end)
    RegisterCommand({
        Name = "unview",
        Aliases = {"unspectate"},
        Description = "Stops spectating and returns to your character."
    }, function()
        self:Disable()
    end)
end
Modules.AstralHead = {
State = {
IsEnabled = false,
OriginalProperties = {},
Connections = {}
}
}
function Modules.AstralHead:_getCharacterHeadParts(character)
    local parts = {}
    if not character then return parts end
        local head = character:FindFirstChild("Head")
        if head then table.insert(parts, head) end
            for _, accessory in ipairs(character:GetChildren()) do
                if accessory:IsA("Accessory") then
                    local handle = accessory:FindFirstChild("Handle")
                    if handle and handle:IsA("BasePart") then
                        table.insert(parts, handle)
                    end
                end
            end
            return parts
        end
        function Modules.AstralHead:_enableForCharacter(character)
            local self = Modules.AstralHead
            if not character then return end
                local partsToModify = self:_getCharacterHeadParts(character)
                for _, part in ipairs(partsToModify) do
                    if not self.State.OriginalProperties[part] then
                        self.State.OriginalProperties[part] = {
                        Transparency = part.Transparency,
                        CanQuery = part.CanQuery,
                        CanTouch = part.CanTouch
                        }
                    end
                    part.Transparency = 1
                    part.CanQuery = false
                    part.CanTouch = false
                end
            end
            function Modules.AstralHead:_disableForCharacter(character)
                local self = Modules.AstralHead
                for part, properties in pairs(self.State.OriginalProperties) do
                    pcall(function()
                    if part and part.Parent then
                        part.Transparency = properties.Transparency
                        part.CanQuery = properties.CanQuery
                        part.CanTouch = properties.CanTouch
                    end
                end)
            end
            table.clear(self.State.OriginalProperties)
        end
        function Modules.AstralHead:Toggle()
            local self = Modules.AstralHead
            self.State.IsEnabled = not self.State.IsEnabled
            if self.State.IsEnabled then
                DoNotif("Astral Head Enabled. Head is now untargetable.", 2)
                if LocalPlayer.Character then
                    self:_enableForCharacter(LocalPlayer.Character)
                end
            else
            DoNotif("Astral Head Disabled. Head restored.", 2)
            if LocalPlayer.Character then
                self:_disableForCharacter(LocalPlayer.Character)
            else
            table.clear(self.State.OriginalProperties)
        end
    end
end
function Modules.AstralHead:Initialize()
    local module = self
    module.State.Connections.CharacterAdded = LocalPlayer.CharacterAdded:Connect(function(character)
    task.wait(0.1)
    if module.State.IsEnabled then
        module:_enableForCharacter(character)
    end
end)
module.State.Connections.CharacterRemoving = LocalPlayer.CharacterRemoving:Connect(function(character)
if module.State.IsEnabled then
    module:_disableForCharacter(character)
end
end)
RegisterCommand({
Name = "astralhead",
Aliases = {"hidehead", "nohead"},
Description = "Toggles head invisibility to counter aimbots."
}, function()
module:Toggle()
end)
end
Modules.LocalAntiTeamChange = {
State = {
IsEnabled = false,
OriginalTeam = nil,
PropertyConnection = nil
},
Dependencies = {"Players"}
}
function Modules.LocalAntiTeamChange:Enable()
    if self.State.IsEnabled then return end
        local localPlayer = self.Services.Players.LocalPlayer
        if not localPlayer then
            warn("[LocalAntiTeamChange] Could not find LocalPlayer to monitor.")
            return
        end
        self.State.IsEnabled = true
        self.State.OriginalTeam = localPlayer.Team
        if self.State.PropertyConnection then self.State.PropertyConnection:Disconnect() end
            self.State.PropertyConnection = localPlayer:GetPropertyChangedSignal("Team"):Connect(function()
            if self.State.IsEnabled and localPlayer.Team ~= self.State.OriginalTeam then
                pcall(function()
                localPlayer.Team = self.State.OriginalTeam
                DoNotif("Reverted personal team change.", 2)
            end)
        end
    end)
    DoNotif("Personal Team Lock: [Enabled]", 3)
end
function Modules.LocalAntiTeamChange:Disable()
    if not self.State.IsEnabled then return end
        self.State.IsEnabled = false
        if self.State.PropertyConnection then
            self.State.PropertyConnection:Disconnect()
            self.State.PropertyConnection = nil
        end
        self.State.OriginalTeam = nil
        DoNotif("Personal Team Lock: [Disabled]", 3)
    end
    function Modules.LocalAntiTeamChange:Toggle()
        if self.State.IsEnabled then
            self:Disable()
        else
        self:Enable()
    end
end
function Modules.LocalAntiTeamChange:Initialize()
    local module = self
    module.Services = {}
    for _, serviceName in ipairs(module.Dependencies or {}) do
        module.Services[serviceName] = game:GetService(serviceName)
    end
    RegisterCommand({
    Name = "lockteam",
    Aliases = {"localantiteamchange", "latc"},
    Description = "Toggles a lock that prevents YOUR team from being changed."
    }, function(args)
    module:Toggle()
end)
end
Modules.HumanoidIntegrity = {
State = {
IsEnabled = false,
Connections = {}
},
Dependencies = {"Players"}
}
function Modules.HumanoidIntegrity:_protectCharacter(character)
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
        self:_cleanupCharacter(character)
        local charConnections = { Character = character }
        charConnections.StateChanged = humanoid.StateChanged:Connect(function(old, new)
        if not self.State.IsEnabled then return end
            if new == Enum.HumanoidStateType.Ragdoll or new == Enum.HumanoidStateType.Physics or new == Enum.HumanoidStateType.FallingDown then
                pcall(humanoid.ChangeState, humanoid, Enum.HumanoidStateType.GettingUp)
            end
        end)
        charConnections.JointRemoved = character.DescendantRemoving:Connect(function(descendant)
        if not self.State.IsEnabled then return end
            if descendant:IsA("Motor6D") then
                task.defer(humanoid.BuildRigFromAttachments, humanoid)
            end
        end)
        charConnections.PlatformStand = humanoid:GetPropertyChangedSignal("PlatformStand"):Connect(function()
        if not self.State.IsEnabled then return end
            if humanoid.PlatformStand then
                humanoid.PlatformStand = false
            end
        end)
        self.State.Connections[character] = charConnections
    end
    function Modules.HumanoidIntegrity:_cleanupCharacter(character)
        if self.State.Connections[character] then
            for _, conn in pairs(self.State.Connections[character]) do
                if typeof(conn) == "RBXScriptConnection" then
                    conn:Disconnect()
                end
            end
            self.State.Connections[character] = nil
        end
    end
    function Modules.HumanoidIntegrity:Enable()
        if self.State.IsEnabled then return end
            self.State.IsEnabled = true
            local localPlayer = self.Services.Players.LocalPlayer
            if localPlayer.Character then
                self:_protectCharacter(localPlayer.Character)
            end
            self.State.Connections.CharacterAdded = localPlayer.CharacterAdded:Connect(function(char)
            self:_protectCharacter(char)
        end)
        self.State.Connections.CharacterRemoving = localPlayer.CharacterRemoving:Connect(function(char)
        self:_cleanupCharacter(char)
    end)
    DoNotif("Humanoid Integrity System: [Enabled]", 3)
end
function Modules.HumanoidIntegrity:Disable()
    if not self.State.IsEnabled then return end
        self.State.IsEnabled = false
        for key, conn in pairs(self.State.Connections) do
            if typeof(conn) == "RBXScriptConnection" then
                conn:Disconnect()
            elseif type(conn) == "table" then
                self:_cleanupCharacter(key)
            end
        end
        table.clear(self.State.Connections)
        DoNotif("Humanoid Integrity System: [Disabled]", 3)
    end
    function Modules.HumanoidIntegrity:Toggle()
        if self.State.IsEnabled then
            self:Disable()
        else
        self:Enable()
    end
end
function Modules.HumanoidIntegrity:Initialize()
    local module = self
    module.Services = { Players = game:GetService("Players") }
    RegisterCommand({
    Name = "antiragdoll",
    Aliases = {"noragdoll", "integrity"},
    Description = "Toggles a system to aggressively counter character ragdolling and joint breaking."
    }, function()
    module:Toggle()
end)
end
Modules.UniversalExploitDetector = {
    State = {
        Enabled = false,
        TrackedPlayers = {},
        SuspicionScores = {},
        ConfirmedExploiters = {},
        Connections = {},
        HighlightCache = {},
        ConfidenceThreshold = 75,
        ScanInterval = 0.5,
        HistoryDuration = 10,
        EnableESP = true,
        EnableNotifications = true,
        AutoCounter = false,
    },
    Services = {
        Players = game:GetService("Players"),
        RunService = game:GetService("RunService"),
        Workspace = game:GetService("Workspace"),
    }
}
local DetectionPatterns = {
    MovementAnomaly = {
        weight = 20,
        check = function(player, data)
            if not player.Character then return 0 end
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then return 0 end
            local currentPos = hrp.Position
            local lastPos = data.LastPosition
            local lastTime = data.LastPosTime or tick()
            local currentTime = tick()
            if lastPos then
                local distance = (currentPos - lastPos).Magnitude
                local timeDelta = currentTime - lastTime
                if timeDelta > 0 then
                    local speed = distance / timeDelta
                    if speed > 100 then
                        return 95
                    elseif speed > 70 then
                        return 60
                    elseif speed > 50 then
                        return 30
                    end
                end
            end
            data.LastPosition = currentPos
            data.LastPosTime = currentTime
            return 0
        end
    },
    VerticalAnomaly = {
        weight = 15,
        check = function(player, data)
            if not player.Character then return 0 end
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then return 0 end
            local yPos = hrp.Position.Y
            if yPos > 200 then
                data.HighAltitudeTime = (data.HighAltitudeTime or 0) + 1
                if data.HighAltitudeTime > 5 then
                    return 80
                elseif data.HighAltitudeTime > 3 then
                    return 50
                end
            else
                data.HighAltitudeTime = 0
            end
            return 0
        end
    },
    SpawnAnomaly = {
        weight = 25,
        check = function(player, data)
            if not player.Character then return 0 end
            local currentChildCount = #player.Character:GetChildren()
            local lastCount = data.LastChildCount or currentChildCount
            local childDelta = currentChildCount - lastCount
            data.LastChildCount = currentChildCount
            if childDelta > 10 then
                return 90
            elseif childDelta > 5 then
                return 60
            end
            return 0
        end
    },
    HumanoidAnomaly = {
        weight = 30,
        check = function(player, data)
            if not player.Character then return 0 end
            local hum = player.Character:FindFirstChildOfClass("Humanoid")
            if not hum then return 0 end
            local suspicion = 0
            if hum.WalkSpeed > 100 then
                suspicion = suspicion + 70
            elseif hum.WalkSpeed > 50 then
                suspicion = suspicion + 30
            end
            if hum.JumpPower > 100 or hum.JumpHeight > 20 then
                suspicion = suspicion + 50
            end
            if hum.Health > hum.MaxHealth then
                suspicion = suspicion + 85
            end
            if hum.Health == hum.MaxHealth then
                data.MaxHealthTime = (data.MaxHealthTime or 0) + 1
                if data.MaxHealthTime > 20 then
                    suspicion = suspicion + 20
                end
            else
                data.MaxHealthTime = 0
            end
            return math.min(suspicion, 100)
        end
    },
    AnimationAnomaly = {
        weight = 15,
        check = function(player, data)
            if not player.Character then return 0 end
            local animator = player.Character:FindFirstChild("Humanoid")
                and player.Character.Humanoid:FindFirstChildOfClass("Animator")
            if not animator then return 0 end
            local suspicion = 0
            for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
                if track.Speed > 3 then
                    suspicion = suspicion + 70
                elseif track.Speed > 2 then
                    suspicion = suspicion + 40
                elseif track.Speed > 1.5 then
                    suspicion = suspicion + 20
                end
            end
            return math.min(suspicion, 100)
        end
    },
    WorkspacePollution = {
        weight = 25,
        check = function(player, data)
            local suspicion = 0
            local suspiciousPatterns = {
                "Acid",
                "Landmine",
                "Exploit",
                "Spam",
                "Clone"
            }
            local pollutionCount = 0
            for _, obj in ipairs(game.Workspace:GetDescendants()) do
                if obj:IsA("BasePart") then
                    for _, pattern in ipairs(suspiciousPatterns) do
                        if obj.Name:find(pattern) then
                            if obj:FindFirstChild("Creator") and obj.Creator.Value == player then
                                pollutionCount = pollutionCount + 1
                            end
                        end
                    end
                end
            end
            if pollutionCount > 50 then
                suspicion = 95
            elseif pollutionCount > 20 then
                suspicion = 70
            elseif pollutionCount > 10 then
                suspicion = 40
            end
            return suspicion
        end
    },
    RemoteSpam = {
        weight = 35,
        check = function(player, data)
            local remoteCallCount = data.RemoteCallCount or 0
            local timeSinceReset = (tick() - (data.RemoteResetTime or tick()))
            if timeSinceReset >= 1 then
                data.LastRemoteRate = remoteCallCount
                data.RemoteCallCount = 0
                data.RemoteResetTime = tick()
                remoteCallCount = 0
            end
            local rate = data.LastRemoteRate or 0
            if rate > 100 then
                return 95
            elseif rate > 50 then
                return 75
            elseif rate > 30 then
                return 40
            end
            return 0
        end
    },
    CharacterModification = {
        weight = 10,
        check = function(player, data)
            if not player.Character then return 0 end
            local suspicion = 0
            local criticalParts = {"Head", "HumanoidRootPart"}
            for _, partName in ipairs(criticalParts) do
                if not player.Character:FindFirstChild(partName) then
                    suspicion = suspicion + 40
                end
            end
            local partCount = 0
            for _, obj in ipairs(player.Character:GetDescendants()) do
                if obj:IsA("BasePart") then
                    partCount = partCount + 1
                end
            end
            if partCount > 100 then
                suspicion = suspicion + 30
            end
            return math.min(suspicion, 100)
        end
    },
}
function Modules.UniversalExploitDetector:InitializePlayerTracking(player)
    if self.State.TrackedPlayers[player] then return end
    self.State.TrackedPlayers[player] = {
        JoinTime = tick(),
        LastPosition = nil,
        LastPosTime = nil,
        LastChildCount = 0,
        HighAltitudeTime = 0,
        MaxHealthTime = 0,
        RemoteCallCount = 0,
        RemoteResetTime = tick(),
        LastRemoteRate = 0,
        DetectionHistory = {},
    }
    self.State.SuspicionScores[player] = 0
end
function Modules.UniversalExploitDetector:AnalyzePlayer(player)
    if not player.Character then return end
    local data = self.State.TrackedPlayers[player]
    if not data then
        self:InitializePlayerTracking(player)
        data = self.State.TrackedPlayers[player]
    end
    local totalSuspicion = 0
    local detections = {}
    for patternName, pattern in pairs(DetectionPatterns) do
        local score = pattern.check(player, data)
        if score > 0 then
            totalSuspicion = totalSuspicion + (score * pattern.weight / 100)
            table.insert(detections, {
                pattern = patternName,
                score = score,
                weight = pattern.weight
            })
        end
    end
    local currentScore = self.State.SuspicionScores[player] or 0
    local decayRate = 2
    if totalSuspicion > 0 then
        self.State.SuspicionScores[player] = math.min(currentScore + totalSuspicion, 100)
    else
        self.State.SuspicionScores[player] = math.max(currentScore - decayRate, 0)
    end
    if #detections > 0 then
        table.insert(data.DetectionHistory, {
            time = tick(),
            detections = detections,
            totalScore = totalSuspicion
        })
        while #data.DetectionHistory > 20 do
            table.remove(data.DetectionHistory, 1)
        end
    end
    local finalScore = self.State.SuspicionScores[player]
    local wasExploiter = self.State.ConfirmedExploiters[player]
    local isExploiter = finalScore >= self.State.ConfidenceThreshold
    if isExploiter and not wasExploiter then
        self:MarkAsExploiter(player, detections)
    elseif not isExploiter and wasExploiter then
        self:ClearExploiter(player)
    elseif isExploiter then
        self:UpdateExploiterESP(player, finalScore)
    end
end
function Modules.UniversalExploitDetector:MarkAsExploiter(player, detections)
    self.State.ConfirmedExploiters[player] = true
    if self.State.EnableESP then
        self:CreateExploiterHighlight(player)
    end
    if self.State.EnableNotifications then
        local patterns = {}
        for _, det in ipairs(detections) do
            table.insert(patterns, det.pattern)
        end
        local score = self.State.SuspicionScores[player]
        DoNotif(string.format(
            "ðŸŽ¯ EXPLOITER DETECTED: %s [%d%% confidence]",
            player.Name,
            math.floor(score)
        ), 5)
        if #patterns > 0 then
            DoNotif("Detected: " .. table.concat(patterns, ", "), 4)
        end
    end
    if self.State.AutoCounter then
        self:EnableCounterMeasures(player, detections)
    end
end
function Modules.UniversalExploitDetector:ClearExploiter(player)
    self.State.ConfirmedExploiters[player] = nil
    if self.State.HighlightCache[player] then
        self.State.HighlightCache[player]:Destroy()
        self.State.HighlightCache[player] = nil
    end
    if self.State.EnableNotifications then
        DoNotif(string.format("âœ“ %s no longer flagged", player.Name), 2)
    end
end
function Modules.UniversalExploitDetector:CreateExploiterHighlight(player)
    if not player.Character then return end
    if self.State.HighlightCache[player] then
        self.State.HighlightCache[player]:Destroy()
    end
    local highlight = Instance.new("Highlight")
    highlight.Name = "ExploiterESP"
    highlight.Adornee = player.Character
    highlight.FillColor = Color3.fromRGB(255, 0, 0)
    highlight.OutlineColor = Color3.fromRGB(255, 100, 100)
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = player.Character
    self.State.HighlightCache[player] = highlight
    player.CharacterAdded:Connect(function(char)
        task.wait(0.5)
        if self.State.ConfirmedExploiters[player] then
            self:CreateExploiterHighlight(player)
        end
    end)
end
function Modules.UniversalExploitDetector:UpdateExploiterESP(player, score)
    local highlight = self.State.HighlightCache[player]
    if not highlight or not highlight.Parent then
        self:CreateExploiterHighlight(player)
        return
    end
    local intensity = score / 100
    highlight.FillColor = Color3.fromRGB(255, 255 * (1 - intensity), 0)
end
function Modules.UniversalExploitDetector:EnableCounterMeasures(player, detections)
    for _, det in ipairs(detections) do
        if det.pattern == "RemoteSpam" and Modules.ApexCounter then
            Modules.ApexCounter:NullifySkidRemotes()
        elseif det.pattern == "SpawnAnomaly" and Modules.ApexCounter then
            Modules.ApexCounter:ToggleLagShield(true)
        end
    end
end
function Modules.UniversalExploitDetector:HookRemoteTracking()
    local mt = getrawmetatable(game)
    local oldNamecall = mt.__namecall
    setreadonly(mt, false)
    mt.__namecall = newcclosure(function(self, ...)
        local method = getnamecallmethod()
        if (method == "FireServer" or method == "InvokeServer") and self:IsA("RemoteEvent") or self:IsA("RemoteFunction") then
        end
        return oldNamecall(self, ...)
    end)
    setreadonly(mt, true)
end
function Modules.UniversalExploitDetector:StartScanning()
    if self.State.Connections.Scanner then return end
    self.State.Connections.Scanner = self.Services.RunService.Heartbeat:Connect(function()
        if not self.State.Enabled then return end
        for _, player in ipairs(self.Services.Players:GetPlayers()) do
            if player ~= self.Services.Players.LocalPlayer then
                pcall(function()
                    self:AnalyzePlayer(player)
                end)
            end
        end
        task.wait(self.State.ScanInterval)
    end)
end
function Modules.UniversalExploitDetector:StopScanning()
    if self.State.Connections.Scanner then
        self.State.Connections.Scanner:Disconnect()
        self.State.Connections.Scanner = nil
    end
end
function Modules.UniversalExploitDetector:Initialize()
    local module = self
    RegisterCommand({
        Name = "detectexploits",
        Aliases = {"exdet", "ed"},
        Description = "Toggle universal exploit detection"
    }, function(args)
        module.State.Enabled = not module.State.Enabled
        if module.State.Enabled then
            module:StartScanning()
            DoNotif("ðŸŽ¯ Exploit Detector: ACTIVE (Universal Mode)", 3)
            DoNotif("Confidence threshold: " .. module.State.ConfidenceThreshold .. "%", 2)
        else
            module:StopScanning()
            for player, highlight in pairs(module.State.HighlightCache) do
                highlight:Destroy()
            end
            module.State.HighlightCache = {}
            module.State.ConfirmedExploiters = {}
            DoNotif("Exploit Detector: DISABLED", 2)
        end
    end)
    RegisterCommand({
        Name = "detthreshold",
        Aliases = {"dth"},
        Description = "Set detection confidence threshold (0-100)"
    }, function(args)
        local threshold = tonumber(args[1])
        if not threshold then
            DoNotif("Current threshold: " .. module.State.ConfidenceThreshold .. "%", 2)
            return
        end
        threshold = math.clamp(threshold, 0, 100)
        module.State.ConfidenceThreshold = threshold
        DoNotif("Detection threshold set to: " .. threshold .. "%", 2)
    end)
    RegisterCommand({
        Name = "listexploiters",
        Aliases = {"lex"},
        Description = "Show all detected exploiters"
    }, function(args)
        local count = 0
        for player, _ in pairs(module.State.ConfirmedExploiters) do
            if player and player.Parent then
                local score = module.State.SuspicionScores[player] or 0
                DoNotif(string.format("%s - %d%% confidence", player.Name, math.floor(score)), 3)
                count = count + 1
            end
        end
        if count == 0 then
            DoNotif("No exploiters detected", 2)
        else
            DoNotif(string.format("Total exploiters: %d", count), 2)
        end
    end)
    RegisterCommand({
        Name = "checkplayer",
        Aliases = {"checkp"},
        Description = "Check a specific player for exploits"
    }, function(args)
        local target = Utilities.findPlayer(args[1])
        if not target then
            DoNotif("Player not found", 2)
            return
        end
        local score = module.State.SuspicionScores[target] or 0
        local data = module.State.TrackedPlayers[target]
        DoNotif(string.format("%s - Suspicion: %d%%", target.Name, math.floor(score)), 3)
        if data and #data.DetectionHistory > 0 then
            local recent = data.DetectionHistory[#data.DetectionHistory]
            for _, det in ipairs(recent.detections) do
                DoNotif(string.format("  â€¢ %s: %d%%", det.pattern, math.floor(det.score)), 2)
            end
        end
    end)
    RegisterCommand({
        Name = "autocounter",
        Aliases = {"acounter"},
        Description = "Toggle automatic counter activation"
    }, function(args)
        module.State.AutoCounter = not module.State.AutoCounter
        DoNotif("Auto-Counter: " .. (module.State.AutoCounter and "ENABLED" or "DISABLED"), 2)
    end)
    RegisterCommand({
        Name = "markexploiter",
        Aliases = {"mex"},
        Description = "Manually mark a player as exploiter"
    }, function(args)
        local target = Utilities.findPlayer(args[1])
        if not target then
            DoNotif("Player not found", 2)
            return
        end
        module.State.SuspicionScores[target] = 100
        module:MarkAsExploiter(target, {})
        DoNotif("Marked " .. target.Name .. " as exploiter", 2)
    end)
    RegisterCommand({
        Name = "unmarkexploiter",
        Aliases = {"uex"},
        Description = "Remove exploiter mark from player"
    }, function(args)
        local target = Utilities.findPlayer(args[1])
        if not target then
            DoNotif("Player not found", 2)
            return
        end
        module.State.SuspicionScores[target] = 0
        module:ClearExploiter(target)
        DoNotif("Unmarked " .. target.Name, 2)
    end)
    for _, player in ipairs(self.Services.Players:GetPlayers()) do
        if player ~= self.Services.Players.LocalPlayer then
            self:InitializePlayerTracking(player)
        end
    end
    self.Services.Players.PlayerAdded:Connect(function(player)
        self:InitializePlayerTracking(player)
    end)
    self.Services.Players.PlayerRemoving:Connect(function(player)
        self.State.TrackedPlayers[player] = nil
        self.State.SuspicionScores[player] = nil
        self.State.ConfirmedExploiters[player] = nil
        if self.State.HighlightCache[player] then
            self.State.HighlightCache[player]:Destroy()
            self.State.HighlightCache[player] = nil
        end
    end)
end
Modules.TeleporterScanner = {
	State = {
		UI = nil,
		IsScanning = false,
		Highlights = {},
		ScanCache = {},
		LastScan = 0,
		Stats = {
			TotalScanned = 0,
			PotentalFound = 0,
			LastScanTime = 0
		}
	},
	Config = {
		CacheExpiry = 60,
		YieldInterval = 250,
		MaxResults = 100,
		AutoScanOnOpen = false,
		HighlightDuration = 0,
		DeepScan = false,
		ScanHiddenObjects = true,
		DebugMode = false
	}
}
local function debugLog(message)
	if Modules.TeleporterScanner.Config.DebugMode then
		print("[TeleporterScanner Debug]", message)
	end
end
function Modules.TeleporterScanner:ToggleGUI()
	local self = Modules.TeleporterScanner
	if self.State.UI and self.State.UI.Parent then
		self:CleanupHighlights()
		self.State.UI:Destroy()
		self.State.UI = nil
		DoNotif("Teleporter Scanner closed.", 2)
		return
	end
	DoNotif("Forensic Teleporter Scanner opened.", 2)
	local Workspace = game:GetService("Workspace")
	local UserInputService = game:GetService("UserInputService")
	local TweenService = game:GetService("TweenService")
	local CoreGui = game:GetService("CoreGui")
	local Players = game:GetService("Players")
	local SCRIPT_KEYWORDS = {
		{pattern = "TeleportService", confidence = 1.0},
		{pattern = ":Teleport%(", confidence = 1.0},
		{pattern = ":TeleportToPlaceInstance%(", confidence = 1.0},
		{pattern = "TeleportAsync", confidence = 1.0},
		{pattern = "fireproximityprompt", confidence = 0.9},
		{pattern = "firetouchinterest", confidence = 0.85},
		{pattern = "game:GetService%([\"']TeleportService", confidence = 0.95},
		{pattern = "placeId%s*=%s*%d+", confidence = 0.7},
		{pattern = "JobId", confidence = 0.6},
		{pattern = "PrivateServerId", confidence = 0.6},
		{pattern = "CFrame%.new%(", confidence = 0.3},
		{pattern = "HumanoidRootPart%.CFrame", confidence = 0.4}
	}
	local NAME_KEYWORDS = {
		{pattern = "teleport", confidence = 0.6},
		{pattern = "portal", confidence = 0.6},
		{pattern = "warp", confidence = 0.5},
		{pattern = "transport", confidence = 0.5},
		{pattern = "gateway", confidence = 0.5},
		{pattern = "door", confidence = 0.3},
		{pattern = "exit", confidence = 0.4}
	}
	local DATA_PAYLOAD_NAMES = {
		{name = "placeid", confidence = 0.9},
		{name = "gameid", confidence = 0.9},
		{name = "targetplace", confidence = 0.9},
		{name = "destination", confidence = 0.7},
		{name = "teleportdata", confidence = 0.85},
		{name = "tpid", confidence = 0.8}
	}
	local screenGui = Instance.new("ScreenGui")
	self.State.UI = screenGui
	screenGui.Name = "TeleporterScannerGui"
	screenGui.ResetOnSpawn = false
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
	screenGui.IgnoreGuiInset = true
	local mainFrame = Instance.new("Frame")
	mainFrame.Name = "MainFrame"
	mainFrame.Size = UDim2.new(0, 380, 0, 500)
	mainFrame.Position = UDim2.new(0, 10, 0.5, -250)
	mainFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
	mainFrame.BorderSizePixel = 2
	mainFrame.BorderColor3 = Color3.fromRGB(85, 85, 125)
	mainFrame.ClipsDescendants = true
	mainFrame.Parent = screenGui
	local uiCorner = Instance.new("UICorner")
	uiCorner.CornerRadius = UDim.new(0, 8)
	uiCorner.Parent = mainFrame
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "TitleLabel"
	titleLabel.Size = UDim2.new(1, 0, 0, 35)
	titleLabel.BackgroundColor3 = Color3.fromRGB(45, 45, 55)
	titleLabel.Text = "ðŸ” Forensic Teleporter Scanner"
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.TextSize = 14
	titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	titleLabel.Parent = mainFrame
	local titleCorner = Instance.new("UICorner")
	titleCorner.CornerRadius = UDim.new(0, 8)
	titleCorner.Parent = titleLabel
	local closeButton = Instance.new("TextButton")
	closeButton.Name = "CloseButton"
	closeButton.Size = UDim2.new(0, 30, 0, 30)
	closeButton.Position = UDim2.new(1, -32, 0, 2.5)
	closeButton.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
	closeButton.Text = "âœ•"
	closeButton.Font = Enum.Font.GothamBold
	closeButton.TextSize = 16
	closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	closeButton.Parent = titleLabel
	local closeCorner = Instance.new("UICorner")
	closeCorner.CornerRadius = UDim.new(0, 4)
	closeCorner.Parent = closeButton
	local statsLabel = Instance.new("TextLabel")
	statsLabel.Name = "StatsLabel"
	statsLabel.Size = UDim2.new(1, -10, 0, 20)
	statsLabel.Position = UDim2.new(0, 5, 0, 40)
	statsLabel.BackgroundTransparency = 1
	statsLabel.Text = "Ready to scan | 0 objects scanned"
	statsLabel.Font = Enum.Font.Gotham
	statsLabel.TextSize = 11
	statsLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
	statsLabel.TextXAlignment = Enum.TextXAlignment.Left
	statsLabel.Parent = mainFrame
	local scanButton = Instance.new("TextButton")
	scanButton.Name = "ScanButton"
	scanButton.Size = UDim2.new(1, -10, 0, 32)
	scanButton.Position = UDim2.new(0.5, 0, 0, 65)
	scanButton.AnchorPoint = Vector2.new(0.5, 0)
	scanButton.BackgroundColor3 = Color3.fromRGB(80, 60, 200)
	scanButton.Font = Enum.Font.GothamBold
	scanButton.TextSize = 13
	scanButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	scanButton.Text = "ðŸ” Begin Workspace Scan"
	scanButton.Parent = mainFrame
	local scanCorner = Instance.new("UICorner")
	scanCorner.CornerRadius = UDim.new(0, 6)
	scanCorner.Parent = scanButton
	local deepScanToggle = Instance.new("TextButton")
	deepScanToggle.Name = "DeepScanToggle"
	deepScanToggle.Size = UDim2.new(0.48, 0, 0, 24)
	deepScanToggle.Position = UDim2.new(0, 5, 0, 102)
	deepScanToggle.BackgroundColor3 = self.Config.DeepScan and Color3.fromRGB(60, 180, 60) or Color3.fromRGB(80, 80, 90)
	deepScanToggle.Font = Enum.Font.Gotham
	deepScanToggle.TextSize = 11
	deepScanToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
	deepScanToggle.Text = "Deep Scan: " .. (self.Config.DeepScan and "ON" or "OFF")
	deepScanToggle.Parent = mainFrame
	local deepCorner = Instance.new("UICorner")
	deepCorner.CornerRadius = UDim.new(0, 4)
	deepCorner.Parent = deepScanToggle
	local clearButton = Instance.new("TextButton")
	clearButton.Name = "ClearButton"
	clearButton.Size = UDim2.new(0.48, 0, 0, 24)
	clearButton.Position = UDim2.new(0.52, 0, 0, 102)
	clearButton.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
	clearButton.Font = Enum.Font.Gotham
	clearButton.TextSize = 11
	clearButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	clearButton.Text = "ðŸ—‘ï¸ Clear Results"
	clearButton.Parent = mainFrame
	local clearCorner = Instance.new("UICorner")
	clearCorner.CornerRadius = UDim.new(0, 4)
	clearCorner.Parent = clearButton
	local filterLabel = Instance.new("TextLabel")
	filterLabel.Name = "FilterLabel"
	filterLabel.Size = UDim2.new(1, -10, 0, 18)
	filterLabel.Position = UDim2.new(0, 5, 0, 131)
	filterLabel.BackgroundTransparency = 1
	filterLabel.Text = "Min Confidence: 0%"
	filterLabel.Font = Enum.Font.Gotham
	filterLabel.TextSize = 10
	filterLabel.TextColor3 = Color3.fromRGB(180, 180, 180)
	filterLabel.TextXAlignment = Enum.TextXAlignment.Left
	filterLabel.Parent = mainFrame
	local filterSlider = Instance.new("Frame")
	filterSlider.Name = "FilterSlider"
	filterSlider.Size = UDim2.new(1, -10, 0, 6)
	filterSlider.Position = UDim2.new(0, 5, 0, 150)
	filterSlider.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
	filterSlider.BorderSizePixel = 0
	filterSlider.Parent = mainFrame
	local sliderCorner = Instance.new("UICorner")
	sliderCorner.CornerRadius = UDim.new(1, 0)
	sliderCorner.Parent = filterSlider
	local sliderFill = Instance.new("Frame")
	sliderFill.Name = "Fill"
	sliderFill.Size = UDim2.new(0, 0, 1, 0)
	sliderFill.BackgroundColor3 = Color3.fromRGB(80, 60, 200)
	sliderFill.BorderSizePixel = 0
	sliderFill.Parent = filterSlider
	local fillCorner = Instance.new("UICorner")
	fillCorner.CornerRadius = UDim.new(1, 0)
	fillCorner.Parent = sliderFill
	local resultsFrame = Instance.new("ScrollingFrame")
	resultsFrame.Name = "ResultsFrame"
	resultsFrame.Size = UDim2.new(1, -10, 1, -165)
	resultsFrame.Position = UDim2.new(0, 5, 0, 160)
	resultsFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	resultsFrame.BorderSizePixel = 0
	resultsFrame.ScrollBarThickness = 6
	resultsFrame.Parent = mainFrame
	local resultsCorner = Instance.new("UICorner")
	resultsCorner.CornerRadius = UDim.new(0, 6)
	resultsCorner.Parent = resultsFrame
	local listLayout = Instance.new("UIListLayout")
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.Padding = UDim.new(0, 3)
	listLayout.Parent = resultsFrame
	local listPadding = Instance.new("UIPadding")
	listPadding.PaddingLeft = UDim.new(0, 5)
	listPadding.PaddingRight = UDim.new(0, 5)
	listPadding.PaddingTop = UDim.new(0, 5)
	listPadding.PaddingBottom = UDim.new(0, 5)
	listPadding.Parent = resultsFrame
	local minConfidence = 0
	local function updateFilter()
		for _, child in ipairs(resultsFrame:GetChildren()) do
			if child:IsA("TextButton") then
				local conf = tonumber(child:GetAttribute("Confidence"))
				child.Visible = conf and (conf >= minConfidence)
			end
		end
	end
	filterSlider.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			local function updateSlider()
				local mouse = UserInputService:GetMouseLocation()
				local relativeX = math.clamp((mouse.X - filterSlider.AbsolutePosition.X) / filterSlider.AbsoluteSize.X, 0, 1)
				minConfidence = relativeX
				sliderFill.Size = UDim2.new(relativeX, 0, 1, 0)
				filterLabel.Text = string.format("Min Confidence: %.0f%%", minConfidence * 100)
				updateFilter()
			end
			local conn
			conn = UserInputService.InputEnded:Connect(function(endInput)
				if endInput.UserInputType == Enum.UserInputType.MouseButton1 then
					conn:Disconnect()
				end
			end)
			local moveConn
			moveConn = UserInputService.InputChanged:Connect(function(moveInput)
				if moveInput.UserInputType == Enum.UserInputType.MouseMovement then
					updateSlider()
				end
			end)
			UserInputService.InputEnded:Connect(function(endInput)
				if endInput.UserInputType == Enum.UserInputType.MouseButton1 then
					moveConn:Disconnect()
				end
			end)
			updateSlider()
		end
	end)
	local function highlightPart(part, confidence)
		if self.State.Highlights[part] then return end
		local highlight = Instance.new("Highlight")
		highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
		local hue = confidence * 0.33
		highlight.FillColor = Color3.fromHSV(hue, 0.8, 1)
		highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
		highlight.FillTransparency = 0.4
		highlight.OutlineTransparency = 0
		highlight.Parent = part
		self.State.Highlights[part] = highlight
		if self.Config.HighlightDuration > 0 then
			task.delay(self.Config.HighlightDuration, function()
				if highlight and highlight.Parent then
					highlight:Destroy()
				end
				self.State.Highlights[part] = nil
			end)
		end
		debugLog("Highlighted: " .. part:GetFullName() .. " (Confidence: " .. string.format("%.0f%%", confidence * 100) .. ")")
	end
	local function addResultToList(part, confidence, reasons)
		local resultButton = Instance.new("TextButton")
		resultButton.Name = part.Name
		local reasonText = table.concat(reasons, ", ")
		resultButton.Text = string.format("[%.0f%%] %s\n%s", confidence * 100, part.Name, reasonText)
		resultButton.Size = UDim2.new(1, -10, 0, 40)
		resultButton.BackgroundColor3 = Color3.fromHSV(confidence * 0.33, 0.4, 0.3)
		resultButton.Font = Enum.Font.Gotham
		resultButton.TextSize = 11
		resultButton.TextXAlignment = Enum.TextXAlignment.Left
		resultButton.TextYAlignment = Enum.TextYAlignment.Top
		resultButton.TextColor3 = Color3.fromRGB(255, 255, 255)
		resultButton.TextWrapped = true
		resultButton.LayoutOrder = math.floor(-confidence * 1000)
		resultButton:SetAttribute("Confidence", confidence)
		resultButton.Parent = resultsFrame
		local btnCorner = Instance.new("UICorner")
		btnCorner.CornerRadius = UDim.new(0, 4)
		btnCorner.Parent = resultButton
		local btnPadding = Instance.new("UIPadding")
		btnPadding.PaddingLeft = UDim.new(0, 8)
		btnPadding.PaddingTop = UDim.new(0, 4)
		btnPadding.Parent = resultButton
		resultButton.MouseButton1Click:Connect(function()
			if not part or not part.Parent then
				DoNotif("Target no longer exists", 2)
				return
			end
			local targetPart = part:IsA("Model") and part:FindFirstChildWhichIsA("BasePart", true) or part
			if not targetPart or not targetPart:IsA("BasePart") then
				DoNotif("Cannot teleport camera to this object", 2)
				return
			end
			local camera = Workspace.CurrentCamera
			local player = Players.LocalPlayer
			local originalCameraType = camera.CameraType
			camera.CameraType = Enum.CameraType.Scriptable
			local distance = 15
			local targetCFrame = CFrame.new(targetPart.Position + (targetPart.CFrame.LookVector * distance) + Vector3.new(0, 5, 0), targetPart.Position)
			local tween = TweenService:Create(camera, TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {CFrame = targetCFrame})
			tween:Play()
			task.delay(3, function()
				camera.CameraType = originalCameraType
			end)
		end)
		resultButton.MouseButton2Click:Connect(function()
			if setclipboard then
				setclipboard(part:GetFullName())
				DoNotif("Copied path to clipboard", 2)
			end
		end)
	end
	local function clearResults()
		self:CleanupHighlights()
		for _, child in ipairs(resultsFrame:GetChildren()) do
			if child:IsA("TextButton") then
				child:Destroy()
			end
		end
		scanButton.Text = "ðŸ” Begin Workspace Scan"
		scanButton.Active = true
		statsLabel.Text = "Results cleared | 0 objects scanned"
		debugLog("Results cleared")
	end
	local function analyzeScript(script)
		local success, source = pcall(function()
			return script.Source
		end)
		if not success or not source then
			return 0, {}
		end
		local lowerSource = source:lower()
		local maxConfidence = 0
		local reasons = {}
		for _, keyword in ipairs(SCRIPT_KEYWORDS) do
			local pattern = keyword.pattern:lower()
			if lowerSource:find(pattern, 1, true) or (self.Config.DeepScan and lowerSource:match(pattern)) then
				if keyword.confidence > maxConfidence then
					maxConfidence = keyword.confidence
				end
				table.insert(reasons, "Script: " .. keyword.pattern)
				if not self.Config.DeepScan then
					break
				end
			end
		end
		return maxConfidence, reasons
	end
	local function analyzeBasePart(part)
		local confidence = 0
		local reasons = {}
		for _, child in ipairs(part:GetChildren()) do
			if child:IsA("ValueBase") then
				local childName = child.Name:lower()
				for _, data in ipairs(DATA_PAYLOAD_NAMES) do
					if childName == data.name or childName:find(data.name, 1, true) then
						confidence = math.max(confidence, data.confidence)
						table.insert(reasons, "Data: " .. child.Name)
						break
					end
				end
			end
		end
		local partName = part.Name:lower()
		for _, keyword in ipairs(NAME_KEYWORDS) do
			if partName:find(keyword.pattern, 1, true) then
				confidence = math.max(confidence, keyword.confidence)
				table.insert(reasons, "Name: " .. keyword.pattern)
				if not self.Config.DeepScan then
					break
				end
			end
		end
		if part:FindFirstChildOfClass("ProximityPrompt") then
			confidence = math.max(confidence, 0.7)
			table.insert(reasons, "ProximityPrompt")
		end
		if part:FindFirstChildOfClass("ClickDetector") then
			confidence = math.max(confidence, 0.5)
			table.insert(reasons, "ClickDetector")
		end
		return confidence, reasons
	end
	local function scanWorkspace()
		self.State.IsScanning = true
		scanButton.Text = "â³ Scanning..."
		scanButton.Active = false
		local findings = {}
		local scannedCount = 0
		local startTime = tick()
		task.spawn(function()
			local descendants = Workspace:GetDescendants()
			local totalCount = #descendants
			debugLog("Starting scan of " .. totalCount .. " objects")
			for i, descendant in ipairs(descendants) do
				scannedCount = i
				if i % self.Config.YieldInterval == 0 then
					statsLabel.Text = string.format("Scanning... %d/%d (%.1f%%)", i, totalCount, (i / totalCount) * 100)
					task.wait()
				end
				if not descendant.Parent then
					continue
				end
				local part, confidence, reasons = nil, 0, {}
				if descendant:IsA("LuaSourceContainer") then
					local scriptConf, scriptReasons = analyzeScript(descendant)
					if scriptConf > 0 then
						part = descendant:FindFirstAncestorWhichIsA("Model") or descendant:FindFirstAncestorWhichIsA("BasePart") or descendant.Parent
						if part and (part:IsA("BasePart") or part:IsA("Model")) then
							confidence = scriptConf
							reasons = scriptReasons
						end
					end
				end
				if descendant:IsA("BasePart") and not part then
					local partConf, partReasons = analyzeBasePart(descendant)
					if partConf > 0 then
						part = descendant
						confidence = partConf
						reasons = partReasons
					end
				end
				if part and (not findings[part] or confidence > findings[part].confidence) then
					findings[part] = {
						confidence = confidence,
						reasons = reasons
					}
				end
			end
			local partsFound = 0
			local sortedFindings = {}
			for part, data in pairs(findings) do
				table.insert(sortedFindings, {part = part, data = data})
			end
			table.sort(sortedFindings, function(a, b)
				return a.data.confidence > b.data.confidence
			end)
			local maxResults = math.min(#sortedFindings, self.Config.MaxResults)
			for i = 1, maxResults do
				local finding = sortedFindings[i]
				partsFound = partsFound + 1
				highlightPart(finding.part, finding.data.confidence)
				addResultToList(finding.part, finding.data.confidence, finding.data.reasons)
			end
			local scanTime = tick() - startTime
			self.State.Stats.TotalScanned = scannedCount
			self.State.Stats.PotentalFound = partsFound
			self.State.Stats.LastScanTime = scanTime
			self.State.LastScan = tick()
			scanButton.Text = string.format("âœ“ Scan Complete! (%d found)", partsFound)
			statsLabel.Text = string.format("Found %d teleporters | Scanned %d objects in %.1fs", partsFound, scannedCount, scanTime)
			DoNotif(string.format("Scan complete: %d potential teleporters found", partsFound), 3)
			self.State.IsScanning = false
			debugLog(string.format("Scan complete: %d found in %.2fs", partsFound, scanTime))
		end)
	end
	scanButton.MouseButton1Click:Connect(function()
		if self.State.IsScanning then return end
		clearResults()
		scanWorkspace()
	end)
	clearButton.MouseButton1Click:Connect(clearResults)
	closeButton.MouseButton1Click:Connect(function()
		self:ToggleGUI()
	end)
	deepScanToggle.MouseButton1Click:Connect(function()
		self.Config.DeepScan = not self.Config.DeepScan
		deepScanToggle.Text = "Deep Scan: " .. (self.Config.DeepScan and "ON" or "OFF")
		deepScanToggle.BackgroundColor3 = self.Config.DeepScan and Color3.fromRGB(60, 180, 60) or Color3.fromRGB(80, 80, 90)
		DoNotif("Deep scan " .. (self.Config.DeepScan and "enabled" or "disabled"), 2)
	end)
	local isDragging, dragStart, startPosition = false, nil, nil
	titleLabel.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			isDragging = true
			dragStart = input.Position
			startPosition = mainFrame.Position
		end
	end)
	titleLabel.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement and isDragging then
			local delta = input.Position - dragStart
			mainFrame.Position = UDim2.new(
				startPosition.X.Scale,
				startPosition.X.Offset + delta.X,
				startPosition.Y.Scale,
				startPosition.Y.Offset + delta.Y
			)
		end
	end)
	UserInputService.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			isDragging = false
		end
	end)
	screenGui.Parent = CoreGui
	if self.Config.AutoScanOnOpen then
		task.wait(0.1)
		scanWorkspace()
	end
end
function Modules.TeleporterScanner:CleanupHighlights()
	for part, highlight in pairs(self.State.Highlights) do
		if highlight and highlight.Parent then
			pcall(function()
				highlight:Destroy()
			end)
		end
	end
	table.clear(self.State.Highlights)
end
function Modules.TeleporterScanner:GetStats()
	return {
		TotalScanned = self.State.Stats.TotalScanned,
		PotentialsFound = self.State.Stats.PotentalFound,
		LastScanTime = self.State.Stats.LastScanTime,
		IsScanning = self.State.IsScanning
	}
end
RegisterCommand({
	Name = "tpscan",
	Aliases = {"teleporterscan", "findtp", "scanteleports"},
	Description = "Opens a GUI that scans the workspace for potential teleporters."
}, function(args)
	Modules.TeleporterScanner:ToggleGUI()
end)
Modules.AuthorityHijacker = {
    State = {
        IsEnabled = false,
        UnlockedTables = {},
        OriginalNewIndex = nil,
        SpoofMap = {}
    }
}
function Modules.AuthorityHijacker:_deepUnlock(root, depth)
    if depth > 10 or self.State.UnlockedTables[root] then return end
    if type(root) ~= "table" then return end
    self.State.UnlockedTables[root] = true
    if setreadonly then
        pcall(setreadonly, root, false)
    elseif make_writeable then
        pcall(make_writeable, root)
    end
    for k, v in pairs(root) do
        if type(v) == "table" then
            self:_deepUnlock(v, depth + 1)
        end
    end
end
function Modules.AuthorityHijacker:ApplyKernelHook()
if key == "WalkSpeed" or key == "JumpPower" then
    if self.State.IsEnabled then
        return self.State.SpoofMap[t] and self.State.SpoofMap[t][key] or originalIndex(t, key)
    end
end
    if self.State.OriginalNewIndex then return end
    local success, mt = pcall(getrawmetatable, game)
    if not success then return end
    self.State.OriginalNewIndex = mt.__newindex
    local old = mt.__newindex
    setreadonly(mt, false)
    mt.__newindex = newcclosure(function(t, k, v)
        if Modules.AuthorityHijacker.State.IsEnabled then
            local ok = pcall(old, t, k, v)
            if not ok then
                if not Modules.AuthorityHijacker.State.SpoofMap[t] then
                    Modules.AuthorityHijacker.State.SpoofMap[t] = {}
                end
                Modules.AuthorityHijacker.State.SpoofMap[t][k] = v
                warn(string.format("--> [Hijacker] Seized property: %s.%s", t.Name, k))
                return nil
            end
        end
        return old(t, k, v)
    end)
    local oldIndex = mt.__index
    mt.__index = newcclosure(function(t, k)
        if Modules.AuthorityHijacker.State.IsEnabled and Modules.AuthorityHijacker.State.SpoofMap[t] then
            local fakeVal = Modules.AuthorityHijacker.State.SpoofMap[t][k]
            if fakeVal ~= nil then return fakeVal end
        end
        return oldIndex(t, k)
    end)
    setreadonly(mt, true)
end
function Modules.AuthorityHijacker:UnlockEnvironment()
    DoNotif("Unlocking Global Environment...", 2)
    self:_deepUnlock(getgenv(), 0)
    self:_deepUnlock(getrenv(), 0)
    self:_deepUnlock(getreg(), 0)
    DoNotif("Global Read-Only states dismantled.", 3)
end
RegisterCommand({
    Name = "unlockengine",
    Aliases = {"writeall"},
    Description = "Dismantles Read-Only protection on all Luau tables (getgenv/getreg)."
}, function()
    Modules.AuthorityHijacker:UnlockEnvironment()
end)
RegisterCommand({
    Name = "hijack",
    Aliases = {"forcewrite", "seize"},
    Description = "Toggles Kernel-level property hijacking. Allows 'writing' to read-only engine properties."
}, function()
    local state = Modules.AuthorityHijacker.State
    state.IsEnabled = not state.IsEnabled
    if state.IsEnabled then
        Modules.AuthorityHijacker:ApplyKernelHook()
        DoNotif("Kernel Hijack: ACTIVE. Engine constraints ignored.", 3)
    else
        DoNotif("Kernel Hijack: DISABLED.", 2)
    end
end)
Modules.InventoryVault = {
    State = {
        IsEnabled = false,
        Vault = {},
        Connections = {},
        HookActive = false,
        OriginalNewIndex = nil
    },
    Dependencies = {"Players", "CoreGui", "RunService"}
}
function Modules.InventoryVault:Snapshot()
    local backpack = Players.LocalPlayer:FindFirstChildOfClass("Backpack")
    local char = Players.LocalPlayer.Character
    if not (backpack or char) then return end
    table.clear(self.State.Vault)
    local count = 0
    local function save(tool)
        if tool:IsA("Tool") and not self.State.Vault[tool.Name] then
            self.State.Vault[tool.Name] = tool:Clone()
            count = count + 1
        end
    end
    for _, t in ipairs(backpack:GetChildren()) do save(t) end
    for _, t in ipairs(char:GetChildren()) do save(t) end
    DoNotif("Vault: Saved " .. count .. " tools to local memory.", 3)
end
function Modules.InventoryVault:Restore()
    local backpack = Players.LocalPlayer:FindFirstChildOfClass("Backpack")
    if not backpack then return end
    local restored = 0
    for name, toolTemplate in pairs(self.State.Vault) do
        if not backpack:FindFirstChild(name) and not (Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild(name)) then
            local clone = toolTemplate:Clone()
            clone.Parent = backpack
            restored = restored + 1
        end
    end
    DoNotif("Vault: Restored " .. restored .. " tools.", 2)
end
function Modules.InventoryVault:ApplyShield()
    if self.State.HookActive then return end
    local success, mt = pcall(getrawmetatable, game)
    if not success then return end
    self.State.OriginalNewIndex = mt.__newindex
    local old = mt.__newindex
    setreadonly(mt, false)
    mt.__newindex = newcclosure(function(t, k, v)
        if Modules.InventoryVault.State.IsEnabled and t:IsA("Tool") and k == "Parent" and v ~= Players.LocalPlayer:FindFirstChildOfClass("Backpack") and v ~= Players.LocalPlayer.Character then
            if not checkcaller() then
                warn("--> [Vault] Blocked attempt to remove tool: " .. t.Name)
                return nil
            end
        end
        return old(t, k, v)
    end)
    setreadonly(mt, true)
    self.State.HookActive = true
end
function Modules.InventoryVault:Toggle()
    self.State.IsEnabled = not self.State.IsEnabled
    if self.State.IsEnabled then
        self:ApplyShield()
        self:Snapshot()
        DoNotif("Inventory Shield: ACTIVE", 2)
    else
        DoNotif("Inventory Shield: DISABLED", 2)
    end
end
function Modules.InventoryVault:Initialize()
    local module = self
    module.Services = {}
    for _, s in ipairs(module.Dependencies) do module.Services[s] = game:GetService(s) end
    RegisterCommand({
        Name = "saveinv",
        Aliases = {"vaultsave"},
        Description = "Saves your current tools so you can restore them after death/stripping."
    }, function()
        module:Snapshot()
    end)
    RegisterCommand({
        Name = "restoreinv",
        Aliases = {"getvault"},
        Description = "Brings back all tools saved in your vault."
    }, function()
        module:Restore()
    end)
    RegisterCommand({
        Name = "antitoolremove",
        Aliases = {"atr"},
        Description = "Toggles a shield that blocks scripts from removing your tools."
    }, function()
        module:Toggle()
    end)
end
Modules.PropertyForensics = {
    State = {
        OriginalSizes = setmetatable({}, {__mode = "k"})
    }
}
function Modules.PropertyForensics:_resolvePath(path)
    local current = game
    local segments = string.split(path, ".")
    for i, name in ipairs(segments) do
        if i == 1 then
            if name:lower() == "workspace" then
                current = workspace
                continue
            elseif name:lower() == "game" then
                continue
            end
            local success, service = pcall(game.GetService, game, name)
            if success and service then
                current = service
            else
                current = current:FindFirstChild(name)
            end
        else
            current = current and current:FindFirstChild(name)
        end
        if not current then break end
    end
    return current
end
function Modules.PropertyForensics:Resize(path, x, y, z)
    local obj = self:_resolvePath(path)
    if not obj then
        return DoNotif("Resize Error: Path could not be resolved.", 3)
    end
    if obj:IsA("Model") then
        local scale = tonumber(x)
        if scale then
            local success, err = pcall(function() obj:ScaleTo(scale) end)
            if success then
                DoNotif("Model Scaled to: " .. scale, 2)
            else
                warn("Resize Error:", err)
            end
        else
            DoNotif("Usage for Models: ;size [path] [Multiplier]", 3)
        end
        return
    end
    if obj:IsA("BasePart") or obj:IsA("GuiObject") then
        local newSize
        if x and y and z then
            newSize = Vector3.new(tonumber(x), tonumber(y), tonumber(z))
        elseif x and not y then
            local factor = tonumber(x)
            newSize = obj.Size * factor
        end
        if newSize then
            if not self.State.OriginalSizes[obj] then
                self.State.OriginalSizes[obj] = obj.Size
            end
            pcall(function() obj.Size = newSize end)
            DoNotif("Resized: " .. obj.Name, 2)
        end
    else
        DoNotif("Error: Object type does not support Size.", 3)
    end
end
function Modules.PropertyForensics:Restore(path)
    local obj = self:_resolvePath(path)
    local original = self.State.OriginalSizes[obj]
    if obj and original then
        pcall(function() obj.Size = original end)
        self.State.OriginalSizes[obj] = nil
        DoNotif("Restored original size for: " .. obj.Name, 2)
    end
end
RegisterCommand({
    Name = "size",
    Aliases = {"resize", "scale"},
    Description = "Resizes an object by path. Usage: ;size [path] [multiplier] OR ;size [path] [x] [y] [z]"
}, function(args)
    if #args < 2 then
        return DoNotif("Usage: ;size workspace.Part 5", 3)
    end
    local path = args[1]
    local x = args[2]
    local y = args[3]
    local z = args[4]
    Modules.PropertyForensics:Resize(path, x, y, z)
end)
RegisterCommand({
    Name = "unsize",
    Aliases = {"revertsize"},
    Description = "Restores the original size of an object. Usage: ;unsize [path]"
}, function(args)
    if not args[1] then return end
    Modules.PropertyForensics:Restore(args[1])
end)
RegisterCommand({
    Name = "hsize",
    Aliases = {"hitboxsize", "ext"},
    Description = "Quick hitbox extender for players. Usage: ;hsize [Name] [Size]"
}, function(args)
    local target = Utilities.findPlayer(args[1])
    local size = args[2] or 10
    if target and target.Character then
        local hrp = target.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            Modules.PropertyForensics:Resize(hrp:GetFullName(), size)
            hrp.CanCollide = false
            hrp.Transparency = 0.7
        end
    else
        DoNotif("Target player character not found.", 3)
    end
end)
Modules.GrabTools = {
State = {
IsEnabled = false,
Connection = nil
}
}
function Modules.GrabTools:_onHeartbeat()
    local localPlayerBackpack = LocalPlayer and LocalPlayer:FindFirstChild("Backpack")
    if not localPlayerBackpack then return end
        for _, child in ipairs(Workspace:GetChildren()) do
            if child:IsA("Tool") and child:FindFirstChild("Handle") and not child.Handle.Anchored then
                child.Parent = localPlayerBackpack
                DoNotif("Grabbed Tool: " .. child.Name, 1.5)
            end
        end
    end
    function Modules.GrabTools:Toggle()
        local self = Modules.GrabTools
        self.State.IsEnabled = not self.State.IsEnabled
        if self.State.IsEnabled then
            if self.State.Connection then self.State.Connection:Disconnect() end
                self.State.Connection = RunService.Heartbeat:Connect(function() self:_onHeartbeat() end)
                DoNotif("Tool Grabber Enabled", 2)
            else
            if self.State.Connection then
                self.State.Connection:Disconnect()
                self.State.Connection = nil
            end
            DoNotif("Tool Grabber Disabled", 2)
        end
    end
    function Modules.GrabTools:Initialize()
        local module = self
        RegisterCommand({
        Name = "grabtools",
        Aliases = {"gt", "toolgrab"},
        Description = "Toggles an auto-grabber for all dropped tools in the workspace."
        }, function(args)
        module:Toggle()
    end)
end
Modules.AdminSpoofDemonstration = {
    State = {
        IsSpoofing = false,
        SpoofedId = -1,
        SpoofedName = nil,
        SpoofedDisplayName = nil,
        OriginalIndex = nil,
        OriginalNamecall = nil,
        PlayerMetatable = nil,
        GameMetatable = nil,
        HookEnabled = true,
        OriginalUserId = nil,
        OriginalName = nil,
        OriginalDisplayName = nil,
        Stats = {
            InterceptedCalls = 0,
            LastSpoof = 0
        }
    },
    Dependencies = {"Players"},
    Config = {
        SpoofName = true,
        SpoofDisplayName = true,
        InterceptRemoteCalls = true,
        StealthMode = true,
        DebugMode = false,
        AllowedProperties = {
            "UserId",
            "Name", 
            "DisplayName",
            "AccountAge"
        }
    }
}
local function debugLog(message)
    if Modules.AdminSpoofDemonstration.Config.DebugMode then
        print("[AdminSpoof Debug]", message)
    end
end
local function fetchUserInfo(userId)
    local success, result = pcall(function()
        local HttpService = game:GetService("HttpService")
        local url = "https://users.roblox.com/v1/users/" .. userId
        if request then
            local response = request({
                Url = url,
                Method = "GET"
            })
            if response.StatusCode == 200 then
                return HttpService:JSONDecode(response.Body)
            end
        end
        local data = game:HttpGet(url)
        return HttpService:JSONDecode(data)
    end)
    if success and result then
        return {
            name = result.name,
            displayName = result.displayName,
            id = result.id
        }
    end
    return nil
end
function Modules.AdminSpoofDemonstration:Enable(targetId, targetName, targetDisplayName)
    if self.State.IsSpoofing then
        DoNotif("Already spoofing. Reset first with ;spoofid reset", 3)
        return false
    end
    local localPlayer = self.Services.Players.LocalPlayer
    if not localPlayer then
        DoNotif("Error: LocalPlayer not found", 3)
        return false
    end
    self.State.OriginalUserId = localPlayer.UserId
    self.State.OriginalName = localPlayer.Name
    self.State.OriginalDisplayName = localPlayer.DisplayName
    self.State.SpoofedId = tonumber(targetId) or -1
    if self.State.SpoofedId <= 0 then
        DoNotif("Invalid UserId. Must be positive.", 3)
        return false
    end
    if not targetName or not targetDisplayName then
        DoNotif("Fetching user info...", 2)
        local userInfo = fetchUserInfo(self.State.SpoofedId)
        if userInfo then
            targetName = userInfo.name
            targetDisplayName = userInfo.displayName
            debugLog("Fetched info: " .. targetName .. " | " .. targetDisplayName)
        else
            debugLog("Failed to fetch user info, using defaults")
            targetName = targetName or "Player" .. self.State.SpoofedId
            targetDisplayName = targetDisplayName or targetName
        end
    end
    self.State.SpoofedName = targetName
    self.State.SpoofedDisplayName = targetDisplayName
    local success, playerMetatable = pcall(getrawmetatable, localPlayer)
    if not success or typeof(playerMetatable) ~= "table" then
        DoNotif("Error: Could not access player metatable", 4)
        return false
    end
    self.State.PlayerMetatable = playerMetatable
    self.State.OriginalIndex = playerMetatable.__index
    self.State.OriginalNamecall = playerMetatable.__namecall
    local originalIndexCache = self.State.OriginalIndex
    local originalNamecallCache = self.State.OriginalNamecall
    pcall(setreadonly, playerMetatable, false)
    playerMetatable.__index = newcclosure(function(self, key)
        if Modules.AdminSpoofDemonstration.State.IsSpoofing and 
           Modules.AdminSpoofDemonstration.State.HookEnabled and
           self == localPlayer then
            if key == "UserId" then
                Modules.AdminSpoofDemonstration.State.Stats.InterceptedCalls = Modules.AdminSpoofDemonstration.State.Stats.InterceptedCalls + 1
                debugLog("Intercepted UserId access for LocalPlayer")
                return Modules.AdminSpoofDemonstration.State.SpoofedId
            elseif key == "Name" and Modules.AdminSpoofDemonstration.Config.SpoofName then
                Modules.AdminSpoofDemonstration.State.Stats.InterceptedCalls = Modules.AdminSpoofDemonstration.State.Stats.InterceptedCalls + 1
                debugLog("Intercepted Name access for LocalPlayer")
                return Modules.AdminSpoofDemonstration.State.SpoofedName
            elseif key == "DisplayName" and Modules.AdminSpoofDemonstration.Config.SpoofDisplayName then
                Modules.AdminSpoofDemonstration.State.Stats.InterceptedCalls = Modules.AdminSpoofDemonstration.State.Stats.InterceptedCalls + 1
                debugLog("Intercepted DisplayName access for LocalPlayer")
                return Modules.AdminSpoofDemonstration.State.SpoofedDisplayName
            end
        end
        if typeof(originalIndexCache) == "function" then
            return originalIndexCache(self, key)
        else
            return originalIndexCache[key]
        end
    end)
    if self.Config.InterceptRemoteCalls then
        playerMetatable.__namecall = newcclosure(function(self, ...)
            local args = {...}
            local method = getnamecallmethod()
            if Modules.AdminSpoofDemonstration.State.IsSpoofing and 
               (method == "FireServer" or method == "InvokeServer") then
                for i, arg in ipairs(args) do
                    if arg == Modules.AdminSpoofDemonstration.State.OriginalUserId then
                        args[i] = Modules.AdminSpoofDemonstration.State.SpoofedId
                        debugLog("Spoofed UserId in remote call")
                    elseif arg == Modules.AdminSpoofDemonstration.State.OriginalName and 
                           Modules.AdminSpoofDemonstration.Config.SpoofName then
                        args[i] = Modules.AdminSpoofDemonstration.State.SpoofedName
                        debugLog("Spoofed Name in remote call")
                    elseif arg == Modules.AdminSpoofDemonstration.State.OriginalDisplayName and
                           Modules.AdminSpoofDemonstration.Config.SpoofDisplayName then
                        args[i] = Modules.AdminSpoofDemonstration.State.SpoofedDisplayName
                        debugLog("Spoofed DisplayName in remote call")
                    elseif arg == localPlayer then
                        debugLog("LocalPlayer instance passed in remote - hooks will handle properties")
                    end
                end
            end
            return originalNamecallCache(self, unpack(args))
        end)
    end
    pcall(setreadonly, playerMetatable, true)
    self.State.IsSpoofing = true
    self.State.Stats.LastSpoof = tick()
    DoNotif(string.format("Spoofing enabled:\nUserId: %d\nName: %s\nDisplay: %s", 
        self.State.SpoofedId, 
        self.State.SpoofedName, 
        self.State.SpoofedDisplayName
    ), 4)
    debugLog("Spoof enabled successfully for LocalPlayer only")
    return true
end
function Modules.AdminSpoofDemonstration:Disable()
    if not self.State.IsSpoofing then
        DoNotif("Not currently spoofing", 2)
        return false
    end
    if self.State.PlayerMetatable then
        pcall(setreadonly, self.State.PlayerMetatable, false)
        if self.State.OriginalIndex then
            self.State.PlayerMetatable.__index = self.State.OriginalIndex
        end
        if self.State.OriginalNamecall then
            self.State.PlayerMetatable.__namecall = self.State.OriginalNamecall
        end
        pcall(setreadonly, self.State.PlayerMetatable, true)
    end
    local interceptCount = self.State.Stats.InterceptedCalls
    self.State.IsSpoofing = false
    self.State.SpoofedId = -1
    self.State.SpoofedName = nil
    self.State.SpoofedDisplayName = nil
    self.State.OriginalIndex = nil
    self.State.OriginalNamecall = nil
    self.State.PlayerMetatable = nil
    self.State.OriginalUserId = nil
    self.State.OriginalName = nil
    self.State.OriginalDisplayName = nil
    self.State.Stats.InterceptedCalls = 0
    DoNotif(string.format("Spoof disabled. Intercepted %d calls.", interceptCount), 3)
    debugLog("Spoof disabled, cleaned up hooks")
    return true
end
function Modules.AdminSpoofDemonstration:Toggle()
    if self.State.IsSpoofing then
        self:Disable()
    else
        DoNotif("Usage: ;spoofid <userid> or ;spoofid <username>", 3)
    end
end
function Modules.AdminSpoofDemonstration:ToggleHook(enabled)
    self.State.HookEnabled = enabled
    DoNotif("Spoof hook " .. (enabled and "enabled" or "disabled"), 2)
end
function Modules.AdminSpoofDemonstration:GetStats()
    return {
        IsSpoofing = self.State.IsSpoofing,
        SpoofedId = self.State.SpoofedId,
        SpoofedName = self.State.SpoofedName,
        InterceptedCalls = self.State.Stats.InterceptedCalls,
        Uptime = self.State.IsSpoofing and (tick() - self.State.Stats.LastSpoof) or 0
    }
end
function Modules.AdminSpoofDemonstration:SpoofByUsername(username)
    local success, result = pcall(function()
        local Players = game:GetService("Players")
        return Players:GetUserIdFromNameAsync(username)
    end)
    if success and result then
        return self:Enable(result)
    else
        DoNotif("Failed to find user: " .. username, 3)
        return false
    end
end
function Modules.AdminSpoofDemonstration:Initialize()
    local module = self
    module.Services = {}
    for _, serviceName in ipairs(module.Dependencies or {}) do
        module.Services[serviceName] = game:GetService(serviceName)
    end
    RegisterCommand({
        Name = "spoofid",
        Aliases = {"setid", "fakeid", "adminspoof"},
        Description = "Spoofs your UserId/Name for vulnerable admin scripts."
    }, function(args)
        local argument = args[1]
        if not argument then
            return DoNotif("Usage: ;spoofid <userid|username|reset>", 3)
        end
        if argument:lower() == "reset" or argument:lower() == "clear" or argument:lower() == "off" then
            module:Disable()
        elseif argument:lower() == "stats" then
            local stats = module:GetStats()
            print("=== Admin Spoof Stats ===")
            print("Spoofing:", stats.IsSpoofing)
            print("Spoofed ID:", stats.SpoofedId)
            print("Spoofed Name:", stats.SpoofedName or "N/A")
            print("Intercepted Calls:", stats.InterceptedCalls)
            print("Uptime:", string.format("%.1f", stats.Uptime) .. "s")
        elseif argument:lower() == "toggle" then
            module:Toggle()
        else
            local targetId = tonumber(argument)
            if targetId and targetId > 0 then
                module:Enable(targetId)
            else
                module:SpoofByUsername(argument)
            end
        end
    end)
    RegisterCommand({
        Name = "spoofname",
        Aliases = {"fakename"},
        Description = "Toggle name spoofing on/off."
    }, function(args)
        module.Config.SpoofName = not module.Config.SpoofName
        DoNotif("Name spoofing: " .. (module.Config.SpoofName and "ON" or "OFF"), 2)
    end)
    RegisterCommand({
        Name = "spoofdisplay",
        Aliases = {"fakedisplay"},
        Description = "Toggle display name spoofing on/off."
    }, function(args)
        module.Config.SpoofDisplayName = not module.Config.SpoofDisplayName
        DoNotif("Display name spoofing: " .. (module.Config.SpoofDisplayName and "ON" or "OFF"), 2)
    end)
    RegisterCommand({
        Name = "spoofstats",
        Aliases = {"spoofinfo"},
        Description = "Shows spoofing statistics."
    }, function(args)
        local stats = module:GetStats()
        print("=== Admin Spoof Stats ===")
        print("Active:", stats.IsSpoofing)
        if stats.IsSpoofing then
            print("Spoofed ID:", stats.SpoofedId)
            print("Spoofed Name:", stats.SpoofedName)
            print("Intercepted:", stats.InterceptedCalls)
            print("Uptime:", string.format("%.1fs", stats.Uptime))
        end
    end)
end
Modules.CFrameEditor = {
    State = {
        IsEnabled = false,
        SelectedPart = nil,
        OriginalCFrame = nil,
        UI = nil,
        IsDragging = false,
        Mode = "position",
        Increment = 1,
        Connections = {}
    },
    Config = {
        HighlightColor = Color3.fromRGB(0, 255, 255),
        GridSnap = false,
        SnapSize = 1
    }
}
function Modules.CFrameEditor:_createUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "CFrameEditor_Zuka"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
    self.State.UI = screenGui
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.fromOffset(320, 480)
    mainFrame.Position = UDim2.new(1, -330, 0.5, -240)
    mainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
    mainFrame.BorderSizePixel = 0
    mainFrame.Parent = screenGui
    Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 8)
    local stroke = Instance.new("UIStroke", mainFrame)
    stroke.Color = Color3.fromRGB(0, 255, 255)
    stroke.Thickness = 2
    local titleBar = Instance.new("Frame", mainFrame)
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1, 0, 0, 35)
    titleBar.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
    titleBar.BorderSizePixel = 0
    Instance.new("UICorner", titleBar).CornerRadius = UDim.new(0, 8)
    local title = Instance.new("TextLabel", titleBar)
    title.Size = UDim2.new(1, -40, 1, 0)
    title.Position = UDim2.fromOffset(10, 0)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.GothamBold
    title.Text = "CFrame Editor"
    title.TextColor3 = Color3.fromRGB(0, 255, 255)
    title.TextSize = 16
    title.TextXAlignment = Enum.TextXAlignment.Left
    local closeBtn = Instance.new("TextButton", titleBar)
    closeBtn.Size = UDim2.fromOffset(30, 30)
    closeBtn.Position = UDim2.new(1, -32, 0, 2)
    closeBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    closeBtn.BorderSizePixel = 0
    closeBtn.Text = "Ã—"
    closeBtn.TextColor3 = Color3.new(1, 1, 1)
    closeBtn.Font = Enum.Font.GothamBold
    closeBtn.TextSize = 20
    Instance.new("UICorner", closeBtn).CornerRadius = UDim.new(0, 6)
    closeBtn.MouseButton1Click:Connect(function()
        self:Disable()
    end)
    local dragStart, startPos
    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragStart = input.Position
            startPos = mainFrame.Position
            local moveConn, endConn
            moveConn = UserInputService.InputChanged:Connect(function(moveInput)
                if moveInput.UserInputType == Enum.UserInputType.MouseMovement then
                    local delta = moveInput.Position - dragStart
                    mainFrame.Position = UDim2.new(
                        startPos.X.Scale, startPos.X.Offset + delta.X,
                        startPos.Y.Scale, startPos.Y.Offset + delta.Y
                    )
                end
            end)
            endConn = UserInputService.InputEnded:Connect(function(endInput)
                if endInput.UserInputType == Enum.UserInputType.MouseButton1 then
                    moveConn:Disconnect()
                    endConn:Disconnect()
                end
            end)
        end
    end)
    local content = Instance.new("Frame", mainFrame)
    content.Name = "Content"
    content.Size = UDim2.new(1, -20, 1, -45)
    content.Position = UDim2.fromOffset(10, 40)
    content.BackgroundTransparency = 1
    local selectionLabel = Instance.new("TextLabel", content)
    selectionLabel.Name = "SelectionLabel"
    selectionLabel.Size = UDim2.new(1, 0, 0, 30)
    selectionLabel.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    selectionLabel.BorderSizePixel = 0
    selectionLabel.Font = Enum.Font.GothamMedium
    selectionLabel.Text = "No part selected"
    selectionLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    selectionLabel.TextSize = 12
    Instance.new("UICorner", selectionLabel).CornerRadius = UDim.new(0, 6)
    local modeLabel = Instance.new("TextLabel", content)
    modeLabel.Size = UDim2.new(1, 0, 0, 20)
    modeLabel.Position = UDim2.fromOffset(0, 40)
    modeLabel.BackgroundTransparency = 1
    modeLabel.Font = Enum.Font.GothamBold
    modeLabel.Text = "Mode:"
    modeLabel.TextColor3 = Color3.new(1, 1, 1)
    modeLabel.TextSize = 13
    modeLabel.TextXAlignment = Enum.TextXAlignment.Left
    local modeButtons = {}
    local modes = {"position", "rotation", "scale"}
    for i, mode in ipairs(modes) do
        local btn = Instance.new("TextButton", content)
        btn.Name = mode .. "Btn"
        btn.Size = UDim2.fromOffset(90, 30)
        btn.Position = UDim2.fromOffset((i-1) * 95, 65)
        btn.BackgroundColor3 = mode == "position" and Color3.fromRGB(0, 200, 255) or Color3.fromRGB(50, 50, 65)
        btn.BorderSizePixel = 0
        btn.Font = Enum.Font.GothamSemibold
        btn.Text = mode:upper()
        btn.TextColor3 = Color3.new(1, 1, 1)
        btn.TextSize = 11
        Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 6)
        modeButtons[mode] = btn
        btn.MouseButton1Click:Connect(function()
            self.State.Mode = mode
            for m, b in pairs(modeButtons) do
                b.BackgroundColor3 = m == mode and Color3.fromRGB(0, 200, 255) or Color3.fromRGB(50, 50, 65)
            end
        end)
    end
    local incrementLabel = Instance.new("TextLabel", content)
    incrementLabel.Size = UDim2.new(1, 0, 0, 20)
    incrementLabel.Position = UDim2.fromOffset(0, 105)
    incrementLabel.BackgroundTransparency = 1
    incrementLabel.Font = Enum.Font.GothamBold
    incrementLabel.Text = "Increment: 1"
    incrementLabel.TextColor3 = Color3.new(1, 1, 1)
    incrementLabel.TextSize = 13
    incrementLabel.TextXAlignment = Enum.TextXAlignment.Left
    local incrementSlider = Instance.new("TextBox", content)
    incrementSlider.Size = UDim2.fromOffset(280, 30)
    incrementSlider.Position = UDim2.fromOffset(0, 130)
    incrementSlider.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    incrementSlider.BorderSizePixel = 0
    incrementSlider.Font = Enum.Font.Code
    incrementSlider.Text = "1"
    incrementSlider.TextColor3 = Color3.new(1, 1, 1)
    incrementSlider.TextSize = 14
    incrementSlider.PlaceholderText = "0.1 / 1 / 5 / 10"
    Instance.new("UICorner", incrementSlider).CornerRadius = UDim.new(0, 6)
    incrementSlider.FocusLost:Connect(function()
        local value = tonumber(incrementSlider.Text)
        if value and value > 0 then
            self.State.Increment = value
            incrementLabel.Text = "Increment: " .. value
        else
            incrementSlider.Text = tostring(self.State.Increment)
        end
    end)
    local controlsLabel = Instance.new("TextLabel", content)
    controlsLabel.Size = UDim2.new(1, 0, 0, 20)
    controlsLabel.Position = UDim2.fromOffset(0, 170)
    controlsLabel.BackgroundTransparency = 1
    controlsLabel.Font = Enum.Font.GothamBold
    controlsLabel.Text = "Controls:"
    controlsLabel.TextColor3 = Color3.new(1, 1, 1)
    controlsLabel.TextSize = 13
    controlsLabel.TextXAlignment = Enum.TextXAlignment.Left
    local controls = {
        {text = "+X", offset = Vector3.new(1, 0, 0), pos = {0, 195}},
        {text = "-X", offset = Vector3.new(-1, 0, 0), pos = {95, 195}},
        {text = "+Y", offset = Vector3.new(0, 1, 0), pos = {0, 230}},
        {text = "-Y", offset = Vector3.new(0, -1, 0), pos = {95, 230}},
        {text = "+Z", offset = Vector3.new(0, 0, 1), pos = {0, 265}},
        {text = "-Z", offset = Vector3.new(0, 0, -1), pos = {95, 265}},
    }
    for _, ctrl in ipairs(controls) do
        local btn = Instance.new("TextButton", content)
        btn.Size = UDim2.fromOffset(85, 30)
        btn.Position = UDim2.fromOffset(ctrl.pos[1], ctrl.pos[2])
        btn.BackgroundColor3 = Color3.fromRGB(60, 120, 200)
        btn.BorderSizePixel = 0
        btn.Font = Enum.Font.GothamBold
        btn.Text = ctrl.text
        btn.TextColor3 = Color3.new(1, 1, 1)
        btn.TextSize = 14
        Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 6)
        btn.MouseButton1Click:Connect(function()
            self:AdjustCFrame(ctrl.offset)
        end)
    end
    local actionsLabel = Instance.new("TextLabel", content)
    actionsLabel.Size = UDim2.new(1, 0, 0, 20)
    actionsLabel.Position = UDim2.fromOffset(0, 305)
    actionsLabel.BackgroundTransparency = 1
    actionsLabel.Font = Enum.Font.GothamBold
    actionsLabel.Text = "Quick Actions:"
    actionsLabel.TextColor3 = Color3.new(1, 1, 1)
    actionsLabel.TextSize = 13
    actionsLabel.TextXAlignment = Enum.TextXAlignment.Left
    local resetBtn = Instance.new("TextButton", content)
    resetBtn.Size = UDim2.new(0.48, 0, 0, 35)
    resetBtn.Position = UDim2.fromOffset(0, 330)
    resetBtn.BackgroundColor3 = Color3.fromRGB(200, 100, 50)
    resetBtn.BorderSizePixel = 0
    resetBtn.Font = Enum.Font.GothamBold
    resetBtn.Text = "RESET"
    resetBtn.TextColor3 = Color3.new(1, 1, 1)
    resetBtn.TextSize = 13
    Instance.new("UICorner", resetBtn).CornerRadius = UDim.new(0, 6)
    resetBtn.MouseButton1Click:Connect(function()
        self:ResetCFrame()
    end)
    local copyBtn = Instance.new("TextButton", content)
    copyBtn.Size = UDim2.new(0.48, 0, 0, 35)
    copyBtn.Position = UDim2.new(0.52, 0, 0, 330)
    copyBtn.BackgroundColor3 = Color3.fromRGB(100, 200, 100)
    copyBtn.BorderSizePixel = 0
    copyBtn.Font = Enum.Font.GothamBold
    copyBtn.Text = "COPY"
    copyBtn.TextColor3 = Color3.new(1, 1, 1)
    copyBtn.TextSize = 13
    Instance.new("UICorner", copyBtn).CornerRadius = UDim.new(0, 6)
    copyBtn.MouseButton1Click:Connect(function()
        self:CopyCFrame()
    end)
    local infoBox = Instance.new("TextLabel", content)
    infoBox.Name = "InfoBox"
    infoBox.Size = UDim2.new(1, 0, 0, 60)
    infoBox.Position = UDim2.fromOffset(0, 375)
    infoBox.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
    infoBox.BorderSizePixel = 0
    infoBox.Font = Enum.Font.Code
    infoBox.Text = "Position:\nX: 0, Y: 0, Z: 0"
    infoBox.TextColor3 = Color3.fromRGB(150, 255, 150)
    infoBox.TextSize = 11
    infoBox.TextWrapped = true
    infoBox.TextXAlignment = Enum.TextXAlignment.Left
    infoBox.TextYAlignment = Enum.TextYAlignment.Top
    Instance.new("UICorner", infoBox).CornerRadius = UDim.new(0, 6)
    local padding = Instance.new("UIPadding", infoBox)
    padding.PaddingLeft = UDim.new(0, 8)
    padding.PaddingTop = UDim.new(0, 8)
    screenGui.Parent = CoreGui
    return selectionLabel, infoBox
end
function Modules.CFrameEditor:SelectPart(part)
    if not part or not part:IsA("BasePart") then
        DoNotif("Invalid part selected", 3)
        return
    end
    if self.State.SelectedPart then
        local oldHighlight = self.State.SelectedPart:FindFirstChild("CFrameEditor_Highlight")
        if oldHighlight then oldHighlight:Destroy() end
    end
    self.State.SelectedPart = part
    self.State.OriginalCFrame = part.CFrame
    local highlight = Instance.new("SelectionBox")
    highlight.Name = "CFrameEditor_Highlight"
    highlight.Adornee = part
    highlight.LineThickness = 0.05
    highlight.Color3 = self.Config.HighlightColor
    highlight.Parent = part
    DoNotif("Selected: " .. part.Name, 2)
    self:UpdateDisplay()
end
function Modules.CFrameEditor:AdjustCFrame(offset)
    if not self.State.SelectedPart then
        return DoNotif("No part selected", 2)
    end
    local part = self.State.SelectedPart
    local increment = self.State.Increment
    if self.State.Mode == "position" then
        part.CFrame = part.CFrame + (offset * increment)
    elseif self.State.Mode == "rotation" then
        local angles = offset * math.rad(increment * 15)
        part.CFrame = part.CFrame * CFrame.Angles(angles.X, angles.Y, angles.Z)
    elseif self.State.Mode == "scale" then
        local newSize = part.Size + (offset * increment)
        if newSize.X > 0 and newSize.Y > 0 and newSize.Z > 0 then
            part.Size = newSize
        end
    end
    self:UpdateDisplay()
end
function Modules.CFrameEditor:ResetCFrame()
    if not self.State.SelectedPart or not self.State.OriginalCFrame then
        return DoNotif("No part to reset", 2)
    end
    self.State.SelectedPart.CFrame = self.State.OriginalCFrame
    DoNotif("Reset to original CFrame", 2)
    self:UpdateDisplay()
end
function Modules.CFrameEditor:CopyCFrame()
    if not self.State.SelectedPart then
        return DoNotif("No part selected", 2)
    end
    local cf = self.State.SelectedPart.CFrame
    local cfString = string.format("CFrame.new(%.2f, %.2f, %.2f)", cf.X, cf.Y, cf.Z)
    if setclipboard then
        setclipboard(cfString)
        DoNotif("CFrame copied to clipboard!", 2)
    else
        print("CFrame: " .. cfString)
        DoNotif("CFrame printed to console (F9)", 2)
    end
end
function Modules.CFrameEditor:UpdateDisplay()
    if not self.State.UI then return end
    local selectionLabel = self.State.UI:FindFirstChild("MainFrame"):FindFirstChild("Content"):FindFirstChild("SelectionLabel")
    local infoBox = self.State.UI:FindFirstChild("MainFrame"):FindFirstChild("Content"):FindFirstChild("InfoBox")
    if self.State.SelectedPart then
        selectionLabel.Text = "Selected: " .. self.State.SelectedPart.Name
        selectionLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
        local cf = self.State.SelectedPart.CFrame
        local pos = cf.Position
        local angles = {cf:ToEulerAnglesXYZ()}
        local size = self.State.SelectedPart.Size
        infoBox.Text = string.format(
            "Position:\nX: %.2f, Y: %.2f, Z: %.2f\n\nRotation:\nX: %.1fÂ°, Y: %.1fÂ°, Z: %.1fÂ°\n\nSize:\nX: %.2f, Y: %.2f, Z: %.2f",
            pos.X, pos.Y, pos.Z,
            math.deg(angles[1]), math.deg(angles[2]), math.deg(angles[3]),
            size.X, size.Y, size.Z
        )
    else
        selectionLabel.Text = "No part selected"
        selectionLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        infoBox.Text = "Click on a part to select it"
    end
end
function Modules.CFrameEditor:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    local selectionLabel, infoBox = self:_createUI()
    self.State.Connections.MouseClick = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            local mouse = LocalPlayer:GetMouse()
            local target = mouse.Target
            if target and target:IsA("BasePart") then
                self:SelectPart(target)
            end
        end
    end)
    DoNotif("CFrame Editor: ENABLED. Click parts to select.", 3)
end
function Modules.CFrameEditor:Disable()
    if not self.State.IsEnabled then return end
    self.State.IsEnabled = false
    if self.State.SelectedPart then
        local highlight = self.State.SelectedPart:FindFirstChild("CFrameEditor_Highlight")
        if highlight then highlight:Destroy() end
    end
    for _, conn in pairs(self.State.Connections) do
        conn:Disconnect()
    end
    table.clear(self.State.Connections)
    if self.State.UI then
        self.State.UI:Destroy()
        self.State.UI = nil
    end
    self.State.SelectedPart = nil
    self.State.OriginalCFrame = nil
    DoNotif("CFrame Editor: DISABLED", 2)
end
function Modules.CFrameEditor:Toggle()
    if self.State.IsEnabled then
        self:Disable()
    else
        self:Enable()
    end
end
RegisterCommand({
    Name = "cframe",
    Aliases = {"cfedit", "moveedit"},
    Description = "Opens CFrame editor to manipulate parts."
}, function()
    Modules.CFrameEditor:Toggle()
end)
Modules.CFrameDesync = {
    State = {
        IsEnabled = false,
        OriginalCFrame = nil,
        VisualCFrame = nil,
        ServerCFrame = nil,
        UI = nil,
        Mode = "position",
        Increment = 1,
        Connections = {},
        DesyncActive = false,
        FakeCharacter = nil
    },
    Config = {
        HighlightColor = Color3.fromRGB(255, 0, 200),
        ShowFakeCharacter = true,
        UpdateRate = 0.1
    }
}

local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

function Modules.CFrameDesync:_createUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "CFrameDesync_Zuka"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
    self.State.UI = screenGui
    
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.fromOffset(340, 520)
    mainFrame.Position = UDim2.new(1, -350, 0.5, -260)
    mainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
    mainFrame.BorderSizePixel = 0
    mainFrame.Parent = screenGui
    
    Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 8)
    
    local stroke = Instance.new("UIStroke", mainFrame)
    stroke.Color = Color3.fromRGB(255, 0, 200)
    stroke.Thickness = 2
    
    local glowTween = TweenService:Create(stroke, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {
        Thickness = 3
    })
    glowTween:Play()
    
    local titleBar = Instance.new("Frame", mainFrame)
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1, 0, 0, 35)
    titleBar.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
    titleBar.BorderSizePixel = 0
    Instance.new("UICorner", titleBar).CornerRadius = UDim.new(0, 8)
    
    local title = Instance.new("TextLabel", titleBar)
    title.Size = UDim2.new(1, -70, 1, 0)
    title.Position = UDim2.fromOffset(10, 0)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.Code
    title.Text = "â–¸ CFRAME DESYNC"
    title.TextColor3 = Color3.fromRGB(255, 0, 200)
    title.TextSize = 16
    title.TextXAlignment = Enum.TextXAlignment.Left
    
    local statusIndicator = Instance.new("TextLabel", titleBar)
    statusIndicator.Name = "StatusIndicator"
    statusIndicator.Size = UDim2.fromOffset(60, 20)
    statusIndicator.Position = UDim2.new(1, -130, 0.5, -10)
    statusIndicator.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    statusIndicator.BorderSizePixel = 0
    statusIndicator.Font = Enum.Font.GothamBold
    statusIndicator.Text = "OFF"
    statusIndicator.TextColor3 = Color3.fromRGB(200, 200, 200)
    statusIndicator.TextSize = 10
    Instance.new("UICorner", statusIndicator).CornerRadius = UDim.new(0, 4)
    
    local closeBtn = Instance.new("TextButton", titleBar)
    closeBtn.Size = UDim2.fromOffset(30, 30)
    closeBtn.Position = UDim2.new(1, -32, 0, 2)
    closeBtn.BackgroundColor3 = Color3.fromRGB(255, 50, 100)
    closeBtn.BorderSizePixel = 0
    closeBtn.Text = "Ã—"
    closeBtn.TextColor3 = Color3.new(1, 1, 1)
    closeBtn.Font = Enum.Font.GothamBold
    closeBtn.TextSize = 20
    Instance.new("UICorner", closeBtn).CornerRadius = UDim.new(0, 6)
    
    closeBtn.MouseButton1Click:Connect(function()
        self:Disable()
    end)
    
    -- Make draggable
    local dragStart, startPos
    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragStart = input.Position
            startPos = mainFrame.Position
            
            local moveConn, endConn
            moveConn = game:GetService("UserInputService").InputChanged:Connect(function(moveInput)
                if moveInput.UserInputType == Enum.UserInputType.MouseMovement then
                    local delta = moveInput.Position - dragStart
                    mainFrame.Position = UDim2.new(
                        startPos.X.Scale, startPos.X.Offset + delta.X,
                        startPos.Y.Scale, startPos.Y.Offset + delta.Y
                    )
                end
            end)
            
            endConn = game:GetService("UserInputService").InputEnded:Connect(function(endInput)
                if endInput.UserInputType == Enum.UserInputType.MouseButton1 then
                    moveConn:Disconnect()
                    endConn:Disconnect()
                end
            end)
        end
    end)
    
    local content = Instance.new("Frame", mainFrame)
    content.Name = "Content"
    content.Size = UDim2.new(1, -20, 1, -45)
    content.Position = UDim2.fromOffset(10, 40)
    content.BackgroundTransparency = 1
    
    -- Desync Toggle
    local desyncToggle = Instance.new("TextButton", content)
    desyncToggle.Name = "DesyncToggle"
    desyncToggle.Size = UDim2.new(1, 0, 0, 45)
    desyncToggle.BackgroundColor3 = Color3.fromRGB(50, 50, 65)
    desyncToggle.BorderSizePixel = 0
    desyncToggle.Font = Enum.Font.GothamBold
    desyncToggle.Text = "ACTIVATE DESYNC"
    desyncToggle.TextColor3 = Color3.new(1, 1, 1)
    desyncToggle.TextSize = 16
    Instance.new("UICorner", desyncToggle).CornerRadius = UDim.new(0, 6)
    
    desyncToggle.MouseButton1Click:Connect(function()
        self:ToggleDesync()
    end)
    
    -- Mode Selection
    local modeLabel = Instance.new("TextLabel", content)
    modeLabel.Size = UDim2.new(1, 0, 0, 20)
    modeLabel.Position = UDim2.fromOffset(0, 55)
    modeLabel.BackgroundTransparency = 1
    modeLabel.Font = Enum.Font.GothamBold
    modeLabel.Text = "Mode:"
    modeLabel.TextColor3 = Color3.new(1, 1, 1)
    modeLabel.TextSize = 13
    modeLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    local modeButtons = {}
    local modes = {"position", "rotation"}
    for i, mode in ipairs(modes) do
        local btn = Instance.new("TextButton", content)
        btn.Name = mode .. "Btn"
        btn.Size = UDim2.fromOffset(150, 30)
        btn.Position = UDim2.fromOffset((i-1) * 160, 80)
        btn.BackgroundColor3 = mode == "position" and Color3.fromRGB(255, 0, 200) or Color3.fromRGB(50, 50, 65)
        btn.BorderSizePixel = 0
        btn.Font = Enum.Font.GothamSemibold
        btn.Text = mode:upper()
        btn.TextColor3 = Color3.new(1, 1, 1)
        btn.TextSize = 11
        Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 6)
        
        modeButtons[mode] = btn
        
        btn.MouseButton1Click:Connect(function()
            self.State.Mode = mode
            for m, b in pairs(modeButtons) do
                b.BackgroundColor3 = m == mode and Color3.fromRGB(255, 0, 200) or Color3.fromRGB(50, 50, 65)
            end
        end)
    end
    
    -- Increment
    local incrementLabel = Instance.new("TextLabel", content)
    incrementLabel.Size = UDim2.new(1, 0, 0, 20)
    incrementLabel.Position = UDim2.fromOffset(0, 120)
    incrementLabel.BackgroundTransparency = 1
    incrementLabel.Font = Enum.Font.GothamBold
    incrementLabel.Text = "Increment: 1"
    incrementLabel.TextColor3 = Color3.new(1, 1, 1)
    incrementLabel.TextSize = 13
    incrementLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    local incrementSlider = Instance.new("TextBox", content)
    incrementSlider.Size = UDim2.new(1, 0, 0, 30)
    incrementSlider.Position = UDim2.fromOffset(0, 145)
    incrementSlider.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    incrementSlider.BorderSizePixel = 0
    incrementSlider.Font = Enum.Font.Code
    incrementSlider.Text = "1"
    incrementSlider.TextColor3 = Color3.new(1, 1, 1)
    incrementSlider.TextSize = 14
    incrementSlider.PlaceholderText = "0.1 / 1 / 5 / 10"
    Instance.new("UICorner", incrementSlider).CornerRadius = UDim.new(0, 6)
    
    incrementSlider.FocusLost:Connect(function()
        local value = tonumber(incrementSlider.Text)
        if value and value > 0 then
            self.State.Increment = value
            incrementLabel.Text = "Increment: " .. value
        else
            incrementSlider.Text = tostring(self.State.Increment)
        end
    end)
    
    -- Controls
    local controlsLabel = Instance.new("TextLabel", content)
    controlsLabel.Size = UDim2.new(1, 0, 0, 20)
    controlsLabel.Position = UDim2.fromOffset(0, 185)
    controlsLabel.BackgroundTransparency = 1
    controlsLabel.Font = Enum.Font.GothamBold
    controlsLabel.Text = "Visual Position Controls:"
    controlsLabel.TextColor3 = Color3.new(1, 1, 1)
    controlsLabel.TextSize = 13
    controlsLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    local controls = {
        {text = "+X", offset = Vector3.new(1, 0, 0), pos = {0, 210}},
        {text = "-X", offset = Vector3.new(-1, 0, 0), pos = {110, 210}},
        {text = "+Y", offset = Vector3.new(0, 1, 0), pos = {0, 245}},
        {text = "-Y", offset = Vector3.new(0, -1, 0), pos = {110, 245}},
        {text = "+Z", offset = Vector3.new(0, 0, 1), pos = {0, 280}},
        {text = "-Z", offset = Vector3.new(0, 0, -1), pos = {110, 280}},
    }
    
    for _, ctrl in ipairs(controls) do
        local btn = Instance.new("TextButton", content)
        btn.Size = UDim2.fromOffset(100, 30)
        btn.Position = UDim2.fromOffset(ctrl.pos[1], ctrl.pos[2])
        btn.BackgroundColor3 = Color3.fromRGB(200, 60, 120)
        btn.BorderSizePixel = 0
        btn.Font = Enum.Font.GothamBold
        btn.Text = ctrl.text
        btn.TextColor3 = Color3.new(1, 1, 1)
        btn.TextSize = 14
        Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 6)
        
        btn.MouseButton1Click:Connect(function()
            self:AdjustVisualCFrame(ctrl.offset)
        end)
    end
    
    -- Preset buttons
    local presetsLabel = Instance.new("TextLabel", content)
    presetsLabel.Size = UDim2.new(1, 0, 0, 20)
    presetsLabel.Position = UDim2.fromOffset(0, 320)
    presetsLabel.BackgroundTransparency = 1
    presetsLabel.Font = Enum.Font.GothamBold
    presetsLabel.Text = "Presets:"
    presetsLabel.TextColor3 = Color3.new(1, 1, 1)
    presetsLabel.TextSize = 13
    presetsLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    local undergroundBtn = Instance.new("TextButton", content)
    undergroundBtn.Size = UDim2.new(0.48, 0, 0, 30)
    undergroundBtn.Position = UDim2.fromOffset(0, 345)
    undergroundBtn.BackgroundColor3 = Color3.fromRGB(150, 100, 50)
    undergroundBtn.BorderSizePixel = 0
    undergroundBtn.Font = Enum.Font.GothamBold
    undergroundBtn.Text = "UNDERGROUND"
    undergroundBtn.TextColor3 = Color3.new(1, 1, 1)
    undergroundBtn.TextSize = 10
    Instance.new("UICorner", undergroundBtn).CornerRadius = UDim.new(0, 6)
    
    undergroundBtn.MouseButton1Click:Connect(function()
        self:PresetUnderground()
    end)
    
    local skyBtn = Instance.new("TextButton", content)
    skyBtn.Size = UDim2.new(0.48, 0, 0, 30)
    skyBtn.Position = UDim2.new(0.52, 0, 0, 345)
    skyBtn.BackgroundColor3 = Color3.fromRGB(100, 150, 255)
    skyBtn.BorderSizePixel = 0
    skyBtn.Font = Enum.Font.GothamBold
    skyBtn.Text = "SKY"
    skyBtn.TextColor3 = Color3.new(1, 1, 1)
    skyBtn.TextSize = 10
    Instance.new("UICorner", skyBtn).CornerRadius = UDim.new(0, 6)
    
    skyBtn.MouseButton1Click:Connect(function()
        self:PresetSky()
    end)
    
    -- Quick Actions
    local actionsLabel = Instance.new("TextLabel", content)
    actionsLabel.Size = UDim2.new(1, 0, 0, 20)
    actionsLabel.Position = UDim2.fromOffset(0, 385)
    actionsLabel.BackgroundTransparency = 1
    actionsLabel.Font = Enum.Font.GothamBold
    actionsLabel.Text = "Quick Actions:"
    actionsLabel.TextColor3 = Color3.new(1, 1, 1)
    actionsLabel.TextSize = 13
    actionsLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    local resetBtn = Instance.new("TextButton", content)
    resetBtn.Size = UDim2.new(0.48, 0, 0, 35)
    resetBtn.Position = UDim2.fromOffset(0, 410)
    resetBtn.BackgroundColor3 = Color3.fromRGB(200, 100, 50)
    resetBtn.BorderSizePixel = 0
    resetBtn.Font = Enum.Font.GothamBold
    resetBtn.Text = "RESET"
    resetBtn.TextColor3 = Color3.new(1, 1, 1)
    resetBtn.TextSize = 13
    Instance.new("UICorner", resetBtn).CornerRadius = UDim.new(0, 6)
    
    resetBtn.MouseButton1Click:Connect(function()
        self:ResetDesync()
    end)
    
    local syncBtn = Instance.new("TextButton", content)
    syncBtn.Size = UDim2.new(0.48, 0, 0, 35)
    syncBtn.Position = UDim2.new(0.52, 0, 0, 410)
    syncBtn.BackgroundColor3 = Color3.fromRGB(100, 200, 100)
    syncBtn.BorderSizePixel = 0
    syncBtn.Font = Enum.Font.GothamBold
    syncBtn.Text = "SYNC"
    syncBtn.TextColor3 = Color3.new(1, 1, 1)
    syncBtn.TextSize = 13
    Instance.new("UICorner", syncBtn).CornerRadius = UDim.new(0, 6)
    
    syncBtn.MouseButton1Click:Connect(function()
        self:SyncToServer()
    end)
    
    -- Info Box
    local infoBox = Instance.new("TextLabel", content)
    infoBox.Name = "InfoBox"
    infoBox.Size = UDim2.new(1, 0, 0, 60)
    infoBox.Position = UDim2.fromOffset(0, 455)
    infoBox.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
    infoBox.BorderSizePixel = 0
    infoBox.Font = Enum.Font.Code
    infoBox.Text = "Desync: OFF\nVisual Offset: 0, 0, 0"
    infoBox.TextColor3 = Color3.fromRGB(255, 150, 200)
    infoBox.TextSize = 10
    infoBox.TextWrapped = true
    infoBox.TextXAlignment = Enum.TextXAlignment.Left
    infoBox.TextYAlignment = Enum.TextYAlignment.Top
    Instance.new("UICorner", infoBox).CornerRadius = UDim.new(0, 6)
    
    local padding = Instance.new("UIPadding", infoBox)
    padding.PaddingLeft = UDim.new(0, 8)
    padding.PaddingTop = UDim.new(0, 8)
    
    screenGui.Parent = CoreGui
    
    return desyncToggle, statusIndicator, infoBox
end

function Modules.CFrameDesync:ToggleDesync()
    if not self.State.DesyncActive then
        self:ActivateDesync()
    else
        self:DeactivateDesync()
    end
end

function Modules.CFrameDesync:ActivateDesync()
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        print("âœ— Character not found")
        return
    end
    
    self.State.DesyncActive = true
    self.State.OriginalCFrame = character.HumanoidRootPart.CFrame
    self.State.ServerCFrame = self.State.OriginalCFrame
    self.State.VisualCFrame = self.State.OriginalCFrame
    
    -- Create fake character
    if self.Config.ShowFakeCharacter then
        self:CreateFakeCharacter()
    end
    
    -- Update UI
    local desyncToggle = self.State.UI.MainFrame.Content.DesyncToggle
    local statusIndicator = self.State.UI.MainFrame.TitleBar.StatusIndicator
    
    desyncToggle.Text = "DEACTIVATE DESYNC"
    desyncToggle.BackgroundColor3 = Color3.fromRGB(255, 50, 100)
    statusIndicator.Text = "ACTIVE"
    statusIndicator.BackgroundColor3 = Color3.fromRGB(255, 0, 200)
    statusIndicator.TextColor3 = Color3.new(1, 1, 1)
    
    -- Start desync loop
    self.State.Connections.DesyncLoop = RunService.Heartbeat:Connect(function()
        self:UpdateDesync()
    end)
    
    print("âœ“ Desync activated")
end

function Modules.CFrameDesync:DeactivateDesync()
    self.State.DesyncActive = false
    
    -- Sync back to server
    local character = LocalPlayer.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        character.HumanoidRootPart.CFrame = self.State.ServerCFrame
    end
    
    -- Remove fake character
    if self.State.FakeCharacter then
        self.State.FakeCharacter:Destroy()
        self.State.FakeCharacter = nil
    end
    
    -- Disconnect desync loop
    if self.State.Connections.DesyncLoop then
        self.State.Connections.DesyncLoop:Disconnect()
        self.State.Connections.DesyncLoop = nil
    end
    
    -- Update UI
    local desyncToggle = self.State.UI.MainFrame.Content.DesyncToggle
    local statusIndicator = self.State.UI.MainFrame.TitleBar.StatusIndicator
    
    desyncToggle.Text = "ACTIVATE DESYNC"
    desyncToggle.BackgroundColor3 = Color3.fromRGB(50, 50, 65)
    statusIndicator.Text = "OFF"
    statusIndicator.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    statusIndicator.TextColor3 = Color3.fromRGB(200, 200, 200)
    
    print("âœ“ Desync deactivated")
    self:UpdateDisplay()
end

function Modules.CFrameDesync:CreateFakeCharacter()
    local character = LocalPlayer.Character
    if not character then return end
    
    -- Clone character
    local fake = Instance.new("Model")
    fake.Name = "FakeCharacter_" .. LocalPlayer.Name
    
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            local clone = part:Clone()
            clone.CanCollide = false
            clone.Transparency = 0.5
            clone.Material = Enum.Material.ForceField
            clone.Color = Color3.fromRGB(255, 0, 200)
            clone.Parent = fake
        end
    end
    
    fake.Parent = workspace
    self.State.FakeCharacter = fake
end

function Modules.CFrameDesync:UpdateDesync()
    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
    
    local hrp = character.HumanoidRootPart
    
    -- Update server position (what the server sees)
    self.State.ServerCFrame = hrp.CFrame
    
    -- Apply visual offset
    hrp.CFrame = self.State.VisualCFrame
    
    -- Update fake character position
    if self.State.FakeCharacter then
        for _, part in pairs(self.State.FakeCharacter:GetChildren()) do
            if part:IsA("BasePart") then
                local realPart = character:FindFirstChild(part.Name)
                if realPart then
                    part.CFrame = realPart.CFrame
                end
            end
        end
    end
    
    self:UpdateDisplay()
end

function Modules.CFrameDesync:AdjustVisualCFrame(offset)
    if not self.State.DesyncActive then
        print("âš  Desync is not active")
        return
    end
    
    local increment = self.State.Increment
    
    if self.State.Mode == "position" then
        self.State.VisualCFrame = self.State.VisualCFrame + (offset * increment)
    elseif self.State.Mode == "rotation" then
        local angles = offset * math.rad(increment * 15)
        self.State.VisualCFrame = self.State.VisualCFrame * CFrame.Angles(angles.X, angles.Y, angles.Z)
    end
    
    self:UpdateDisplay()
end

function Modules.CFrameDesync:ResetDesync()
    if not self.State.DesyncActive then
        print("âš  Desync is not active")
        return
    end
    
    self.State.VisualCFrame = self.State.ServerCFrame
    print("âœ“ Reset visual position to server position")
    self:UpdateDisplay()
end

function Modules.CFrameDesync:SyncToServer()
    if not self.State.DesyncActive then
        print("âš  Desync is not active")
        return
    end
    
    -- Move server position to visual position
    self.State.ServerCFrame = self.State.VisualCFrame
    
    local character = LocalPlayer.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        character.HumanoidRootPart.CFrame = self.State.ServerCFrame
    end
    
    print("âœ“ Synced server position to visual position")
    self:UpdateDisplay()
end

function Modules.CFrameDesync:PresetUnderground()
    if not self.State.DesyncActive then
        print("âš  Desync is not active")
        return
    end
    
    self.State.VisualCFrame = self.State.ServerCFrame - Vector3.new(0, 50, 0)
    print("âœ“ Applied underground preset")
    self:UpdateDisplay()
end

function Modules.CFrameDesync:PresetSky()
    if not self.State.DesyncActive then
        print("âš  Desync is not active")
        return
    end
    
    self.State.VisualCFrame = self.State.ServerCFrame + Vector3.new(0, 200, 0)
    print("âœ“ Applied sky preset")
    self:UpdateDisplay()
end

function Modules.CFrameDesync:UpdateDisplay()
    if not self.State.UI then return end
    
    local infoBox = self.State.UI.MainFrame.Content.InfoBox
    
    if self.State.DesyncActive then
        local visualPos = self.State.VisualCFrame.Position
        local serverPos = self.State.ServerCFrame.Position
        local offset = visualPos - serverPos
        
        infoBox.Text = string.format(
            "Desync: ACTIVE\n\nVisual Pos:\nX: %.2f, Y: %.2f, Z: %.2f\n\nServer Pos:\nX: %.2f, Y: %.2f, Z: %.2f\n\nOffset:\nX: %.2f, Y: %.2f, Z: %.2f",
            visualPos.X, visualPos.Y, visualPos.Z,
            serverPos.X, serverPos.Y, serverPos.Z,
            offset.X, offset.Y, offset.Z
        )
        infoBox.TextColor3 = Color3.fromRGB(255, 100, 200)
    else
        infoBox.Text = "Desync: OFF\n\nActivate desync to start"
        infoBox.TextColor3 = Color3.fromRGB(150, 150, 150)
    end
end

function Modules.CFrameDesync:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    
    self:_createUI()
    
    print("âœ“ CFrame Desync enabled")
end

function Modules.CFrameDesync:Disable()
    if not self.State.IsEnabled then return end
    
    -- Deactivate desync if active
    if self.State.DesyncActive then
        self:DeactivateDesync()
    end
    
    self.State.IsEnabled = false
    
    -- Disconnect all connections
    for _, conn in pairs(self.State.Connections) do
        if conn then
            conn:Disconnect()
        end
    end
    table.clear(self.State.Connections)
    
    -- Destroy UI
    if self.State.UI then
        self.State.UI:Destroy()
        self.State.UI = nil
    end
    
    print("âœ“ CFrame Desync disabled")
end

function Modules.CFrameDesync:Toggle()
    if self.State.IsEnabled then
        self:Disable()
    else
        self:Enable()
    end
end

RegisterCommand({
    Name = "csync",
    Aliases = {"fakepos"},
    Description = "Opens CFrame desync editor to manipulate your character's visual position."
}, function()
    Modules.CFrameDesync:Toggle()
end)
Modules.OrbitController = {
    State = {
        IsEnabled = false,
        TargetPlayer = nil,
        Rotation = 0,
        Connections = {}
    },
    Config = {
        DefaultSpeed = 0.2,
        DefaultDistance = 6
    },
    Services = {
        Players = game:GetService("Players"),
        RunService = game:GetService("RunService")
    }
}
function Modules.OrbitController:Disable(shouldNotify: boolean)
    if not self.State.IsEnabled then return end
    for _, conn in pairs(self.State.Connections) do
        if conn and conn.Connected then
            conn:Disconnect()
        end
    end
    table.clear(self.State.Connections)
    local localPlayer = self.Services.Players.LocalPlayer
    if localPlayer.Character then
        local humanoid = localPlayer.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.AutoRotate = true
        end
    end
    self.State.IsEnabled = false
    self.State.TargetPlayer = nil
    if shouldNotify then
        DoNotif("Orbit stopped.", 2)
    end
end
function Modules.OrbitController:Enable(targetPlayer: Player, speed: number?, distance: number?)
    self:Disable(false)
    local localPlayer = self.Services.Players.LocalPlayer
    local myChar = localPlayer.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    local myHumanoid = myChar and myChar:FindFirstChildOfClass("Humanoid")
    local targetChar = targetPlayer and targetPlayer.Character
    local targetRoot = targetChar and targetChar:FindFirstChild("HumanoidRootPart")
    if not (myRoot and myHumanoid and targetRoot) then
        return DoNotif("Orbit failed: A character part could not be found.", 3)
    end
    self.State.IsEnabled = true
    self.State.TargetPlayer = targetPlayer
    self.State.Rotation = 0
    myHumanoid.AutoRotate = false
    local orbitSpeed = tonumber(speed) or self.Config.DefaultSpeed
    local orbitDistance = tonumber(distance) or self.Config.DefaultDistance
    self.State.Connections.Heartbeat = self.Services.RunService.Heartbeat:Connect(function()
        pcall(function()
            if not (self.State.IsEnabled and self.State.TargetPlayer and self.State.TargetPlayer.Character) then
                return self:Disable(true)
            end
            local currentTargetRoot = self.State.TargetPlayer.Character:FindFirstChild("HumanoidRootPart")
            if not currentTargetRoot then return self:Disable(true) end
            self.State.Rotation = self.State.Rotation + orbitSpeed
            myRoot.CFrame = CFrame.new(currentTargetRoot.Position) * CFrame.Angles(0, self.State.Rotation, 0) * CFrame.new(orbitDistance, 0, 0)
        end)
    end)
    self.State.Connections.RenderStepped = self.Services.RunService.RenderStepped:Connect(function()
        pcall(function()
            if not (self.State.IsEnabled and self.State.TargetPlayer and self.State.TargetPlayer.Character) then
                return self:Disable(true)
            end
            local currentTargetRoot = self.State.TargetPlayer.Character:FindFirstChild("HumanoidRootPart")
            if not currentTargetRoot then return self:Disable(true) end
            myRoot.CFrame = CFrame.new(myRoot.Position, currentTargetRoot.Position)
        end)
    end)
    self.State.Connections.Died = myHumanoid.Died:Connect(function() self:Disable(true) end)
    self.State.Connections.Seated = myHumanoid.Seated:Connect(function(isSeated)
        if isSeated then self:Disable(true) end
    end)
    DoNotif("Orbiting " .. targetPlayer.Name, 2)
end
function Modules.OrbitController:Initialize()
    RegisterCommand({
        Name = "orbit",
        Aliases = {},
        Description = "Orbits your character around a target player."
    }, function(args)
        if not args[1] then
            return DoNotif("Usage: ;orbit <PlayerName> [speed] [distance]", 3)
        end
        local target = Utilities.findPlayer(args[1])
        if target then
            self:Enable(target, args[2], args[3])
        else
            DoNotif("Player '" .. args[1] .. "' not found.", 3)
        end
    end)
    RegisterCommand({
        Name = "unorbit",
        Aliases = {},
        Description = "Stops orbiting the current target."
    }, function(args)
        local shouldNotify = not (args[1] and args[1]:lower() == "nonotify")
        self:Disable(shouldNotify)
    end)
end
local function readTable(tbl: table): string
    local function serialize(value: any, indent: number, visited: {[table]: boolean}): string
        local valueType: string = typeof(value)
        if valueType == "string" then
            return string.format("%q", value)
        elseif valueType == "number" or valueType == "boolean" or valueType == "nil" then
            return tostring(value)
        elseif valueType == "function" or valueType == "thread" or valueType == "userdata" then
            return string.format("\"<%s>\"", valueType)
        elseif valueType == "Instance" then
            return string.format("\"%s (%s)\"", value, value.ClassName)
        elseif valueType == "table" then
            if visited[value] then
                return "\"*Circular Reference*\""
            end
            visited[value] = true
            local str: string = "{\n"
            local indentation: string = string.rep("    ", indent + 1)
            local isNumeric: boolean = true
            local count: number = 0
            for i: number = 1, #value do
                str ..= indentation .. serialize(value[i], indent + 1, visited) .. ",\n"
                count += 1
            end
            for k: any, v: any in pairs(value) do
                if type(k) ~= "number" or k < 1 or k > #value or k % 1 ~= 0 then
                    isNumeric = false
                    break
                end
            end
            if not isNumeric then
                for k: any, v: any in pairs(value) do
                     local keyStr: string
                     if typeof(k) == "string" then
                         keyStr = string.format("[\"%s\"]", k)
                     else
                         keyStr = string.format("[%s]", tostring(k))
                     end
                     str ..= indentation .. keyStr .. " = " .. serialize(v, indent + 1, visited) .. ",\n"
                 end
            end
            str ..= string.rep("    ", indent) .. "}"
            visited[value] = false
            return str
        else
            return tostring(value)
        end
    end
    return serialize(tbl, 0, {})
end
Modules.RemoteInterceptor = {
    State = {
        IsEnabled = false,
        InterceptedRemotes = {}
    },
    Dependencies = {"CoreGui"},
    Services = {}
}
function Modules.RemoteInterceptor:_getInstanceFromPath(path: string): Instance?
    local current = game
    for component in string.gmatch(path, "[^%.]+") do
        if not current then return nil end
        if string.find(component, ":GetService") then
            local serviceName = component:match("'(.-)'") or component:match('"(.-)"')
            current = serviceName and current:GetService(serviceName) or nil
        else
            current = current:FindFirstChild(component)
        end
    end
    return current
end
function Modules.RemoteInterceptor:_logCall(remote: Instance, ...: any)
    local args = {...}
    local log = {"--> [Interceptor] Call detected on: " .. remote:GetFullName()}
    for i, arg in ipairs(args) do
        local argType = typeof(arg)
        local serializedValue
        if argType == "table" then
            serializedValue = readTable(arg)
        else
            serializedValue = tostring(arg)
        end
        table.insert(log, string.format("    - Arg #%d [%s]: %s", i, argType, serializedValue))
    end
    print(table.concat(log, "\n"))
end
function Modules.RemoteInterceptor:Intercept(remotePath: string)
    if self.State.InterceptedRemotes[remotePath] then
        return DoNotif("This remote is already being intercepted.", 3)
    end
    local originalRemote = self:_getInstanceFromPath(remotePath)
    if not (originalRemote and (originalRemote:IsA("RemoteEvent") or originalRemote:IsA("RemoteFunction"))) then
        return DoNotif("Remote not found or invalid type at path: " .. remotePath, 4)
    end
    local originalParent = originalRemote.Parent
    local originalName = originalRemote.Name
    local proxy = {}
    local metatable = {
        __index = function(_, key)
            if key == "FireServer" and originalRemote:IsA("RemoteEvent") then
                return function(_, ...)
                    self:_logCall(originalRemote, ...)
                    return originalRemote:FireServer(...)
                end
            elseif key == "InvokeServer" and originalRemote:IsA("RemoteFunction") then
                return function(_, ...)
                    self:_logCall(originalRemote, ...)
                    return originalRemote:InvokeServer(...)
                end
            end
            return originalRemote[key]
        end,
        __newindex = function(_, key, value)
            originalRemote[key] = value
        end
    }
    setmetatable(proxy, metatable)
    local proxyInstance = Instance.new("RemoteEvent")
    proxyInstance.Name = originalName
    local success, err = pcall(function()
        for i = 1, 20 do
            if originalParent:FindFirstChild(originalName) == originalRemote then
                break
            end
            task.wait()
        end
        originalRemote.Parent = self.Services.CoreGui
        proxyInstance.Parent = originalParent
    end)
    if not success then
        DoNotif("Failed to swap remote. It may be protected.", 4)
        if originalRemote.Parent ~= originalParent then
            originalRemote.Parent = originalParent
        end
        return
    end
    self.State.InterceptedRemotes[remotePath] = {
        Original = originalRemote,
        Proxy = proxy,
        ProxyInstance = proxyInstance,
        Parent = originalParent,
        Name = originalName
    }
    proxyInstance.OnServerEvent:Connect(function(_, ...)
        if originalRemote:IsA("RemoteEvent") then
            self:_logCall(originalRemote, ...)
            originalRemote:FireServer(...)
        end
    end)
    DoNotif("Successfully intercepted: " .. originalName, 3)
end
function Modules.RemoteInterceptor:Restore(remotePath: string)
    local data = self.State.InterceptedRemotes[remotePath]
    if not data then
        return DoNotif("Remote is not currently intercepted.", 3)
    end
    if data.ProxyInstance and data.ProxyInstance.Parent then
        data.ProxyInstance:Destroy()
    end
    data.Original.Parent = data.Parent
    self.State.InterceptedRemotes[remotePath] = nil
    DoNotif("Restored original remote: " .. data.Name, 2)
end
function Modules.RemoteInterceptor:Initialize()
    for _, serviceName in ipairs(self.Dependencies) do
        self.Services[serviceName] = game:GetService(serviceName)
    end
    RegisterCommand({
        Name = "intercept",
        Aliases = {"spy"},
        Description = "Intercepts a remote to spy on its arguments."
    }, function(args)
        if not args[1] then
            return DoNotif("Usage: ;intercept <path.to.remote>", 3)
        end
        self:Intercept(args[1])
    end)
    RegisterCommand({
        Name = "unintercept",
        Aliases = {"unspy"},
        Description = "Restores an intercepted remote."
    }, function(args)
        if not args[1] then
            return DoNotif("Usage: ;unintercept <path.to.remote>", 3)
        end
        self:Restore(args[1])
    end)
    RegisterCommand({
        Name = "intercepted",
        Description = "Lists all currently intercepted remotes."
    }, function()
        local count = 0
        print("--- [Active Interceptors] ---")
        for path, _ in pairs(self.State.InterceptedRemotes) do
            print("- " .. path)
            count = count + 1
        end
        DoNotif("Listed " .. count .. " intercepted remote(s) in the F9 console.", 2)
    end)
end
Modules.ClientCanary = {
    State = {
        IsEnabled = false,
        HeartbeatConnection = nil,
        ViolationData = {},
        HighlightedPlayers = {}
    },
    Config = {
        MAX_REASONABLE_SPEED = 75,
        VIOLATION_THRESHOLD = 8,
        VIOLATION_DECAY_TIME = 2.5,
        CHECK_INTERVAL_SECONDS = 0.25
    }
}
function Modules.ClientCanary:_onHeartbeat(deltaTime)
    local now = os.clock()
    for player, data in pairs(self.State.ViolationData) do
        if now - data.LastCheck > self.Config.VIOLATION_DECAY_TIME then
            data.Level = math.max(0, data.Level - 1)
            data.LastCheck = now
        end
        if not player.Parent then
            self.State.ViolationData[player] = nil
        end
    end
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and self.State.HighlightedPlayers[player] == nil then
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
            if humanoid and rootPart and humanoid.Health > 0 then
                local horizontalVelocity = Vector3.new(rootPart.AssemblyLinearVelocity.X, 0, rootPart.AssemblyLinearVelocity.Z)
                if horizontalVelocity.Magnitude > self.Config.MAX_REASONABLE_SPEED then
                    local data = self.State.ViolationData[player] or { Level = 0, LastCheck = now }
                    data.Level = data.Level + 1
                    data.LastCheck = now
                    self.State.ViolationData[player] = data
                    if data.Level >= self.Config.VIOLATION_THRESHOLD then
                        DoNotif(string.format("Exploiter Detected: %s (Reason: Sustained Speed)", player.Name), 4)
                        pcall(function()
                            Modules.HighlightPlayer:ApplyHighlight(player.Character)
                        end)
                        self.State.HighlightedPlayers[player] = true
                        self.State.ViolationData[player] = nil
                    end
                end
            end
        end
    end
end
function Modules.ClientCanary:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    local lastCheck = 0
    self.State.HeartbeatConnection = RunService.Heartbeat:Connect(function(deltaTime)
        if os.clock() - lastCheck > self.Config.CHECK_INTERVAL_SECONDS then
            self:_onHeartbeat(deltaTime)
            lastCheck = os.clock()
        end
    end)
    DoNotif("Client Canary: ENABLED. Automated exploiter detection is active.", 2)
end
function Modules.ClientCanary:Disable()
    if not self.State.IsEnabled then return end
    self.State.IsEnabled = false
    if self.State.HeartbeatConnection then
        self.State.HeartbeatConnection:Disconnect()
        self.State.HeartbeatConnection = nil
    end
    for player, _ in pairs(self.State.HighlightedPlayers) do
        if Modules.HighlightPlayer.State.TargetPlayer == player then
            Modules.HighlightPlayer:ClearHighlight()
        end
    end
    table.clear(self.State.ViolationData)
    table.clear(self.State.HighlightedPlayers)
    DoNotif("Client Canary: DISABLED.", 2)
end
function Modules.ClientCanary:Toggle()
    if self.State.IsEnabled then
        self:Disable()
    else
        self:Enable()
    end
end
function Modules.ClientCanary:Initialize()
    local module = self
    RegisterCommand({
        Name = "autodetect",
        Aliases = {"canary", "watchdog"},
        Description = "Toggles the automated client-side exploiter detection system."
    }, function()
        module:Toggle()
    end)
end
Modules.TweenClickTP = {
	State = {
		IsEnabled = false,
		Connection = nil,
		IsTweening = false
	},
	Config = {
		MODIFIER_KEY = Enum.KeyCode.LeftAlt,
		TWEEN_DURATION = 0.25,
		TWEEN_STYLE = Enum.EasingStyle.Quint
	}
}
function Modules.TweenClickTP:_executeTween(destination)
	if self.State.IsTweening then return end
	self.State.IsTweening = true
	local TweenService = game:GetService("TweenService")
	local RunService = game:GetService("RunService")
	local localPlayer = Players.LocalPlayer
	local character = localPlayer.Character
	local hrp = character and character:FindFirstChild("HumanoidRootPart")
	local camera = Workspace.CurrentCamera
	if not (hrp and camera) then
		self.State.IsTweening = false
		return
	end
	local cameraAnchor = Instance.new("Part")
	cameraAnchor.Size = Vector3.one
	cameraAnchor.Transparency = 1
	cameraAnchor.Anchored = true
	cameraAnchor.CanCollide = false
	cameraAnchor.CFrame = camera.CFrame
	cameraAnchor.Parent = Workspace
	local tweenInfo = TweenInfo.new(self.Config.TWEEN_DURATION, self.Config.TWEEN_STYLE)
	local targetCFrame = CFrame.lookAt(destination, destination + camera.CFrame.LookVector)
	local tween = TweenService:Create(cameraAnchor, tweenInfo, { CFrame = targetCFrame })
	camera.CameraType = Enum.CameraType.Scriptable
	local camConnection = RunService.RenderStepped:Connect(function()
		camera.CFrame = cameraAnchor.CFrame
	end)
	tween:Play()
	tween.Completed:Connect(function()
		camConnection:Disconnect()
		hrp.CFrame = CFrame.new(destination) + Vector3.new(0, 3, 0)
		camera.CameraType = Enum.CameraType.Custom
		cameraAnchor:Destroy()
		self.State.IsTweening = false
	end)
end
function Modules.TweenClickTP:Enable()
	if self.State.IsEnabled then return end
	self.State.IsEnabled = true
	self.State.Connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed or self.State.IsTweening then return end
		if UserInputService:IsKeyDown(self.Config.MODIFIER_KEY) and input.UserInputType == Enum.UserInputType.MouseButton1 then
			local mousePos = UserInputService:GetMouseLocation()
			local ray = Workspace.CurrentCamera:ViewportPointToRay(mousePos.X, mousePos.Y)
			local params = RaycastParams.new()
			params.FilterType = Enum.RaycastFilterType.Blacklist
			params.FilterDescendantsInstances = { Players.LocalPlayer.Character }
			local result = Workspace:Raycast(ray.Origin, ray.Direction * 2000, params)
			if result and result.Position then
				self:_executeTween(result.Position)
			end
		end
	end)
	DoNotif("Tween ClickTP: [Enabled]. Hold LeftAlt and click to teleport.", 3)
end
function Modules.TweenClickTP:Disable()
	if not self.State.IsEnabled then return end
	self.State.IsEnabled = false
	if self.State.Connection then
		self.State.Connection:Disconnect()
		self.State.Connection = nil
	end
	DoNotif("Tween ClickTP: [Disabled].", 2)
end
function Modules.TweenClickTP:Toggle()
	if self.State.IsEnabled then
		self:Disable()
	else
		self:Enable()
	end
end
RegisterCommand({
	Name = "tweenclicktp",
	Aliases = {"tctp", "smoothtp", "blinktp"},
	Description = "Toggles a smooth, camera-animated teleport. Hold Left Alt and click to use."
}, function(args)
	Modules.TweenClickTP:Toggle()
end)
Modules.UniversalESP = {
    State = {
        ActiveFolders = {} :: {[Instance]: ESPData}
    },
    Config = {
        FILL_COLOR = Color3.fromRGB(147, 112, 219),
        OUTLINE_COLOR = Color3.fromRGB(255, 255, 255),
        FILL_TRANSPARENCY = 0.5,
        OUTLINE_TRANSPARENCY = 0,
        HIGHLIGHT_LIMIT = 31
    }
}
function Modules.UniversalESP:_resolvePath(path: string): Instance?
    local success, result = pcall(function()
        local segments = string.split(path, ".")
        local current: any = game
        for i, name in ipairs(segments) do
            if i == 1 then
                if name:lower() == "game" then
                    continue
                elseif name:lower() == "workspace" then
                    current = workspace
                    continue
                else
                    current = game:GetService(name) or game:FindFirstChild(name)
                end
            else
                current = current:FindFirstChild(name)
            end
            if not current then break end
        end
        return current
    end)
    return success and result or nil
end
function Modules.UniversalESP:_highlight(instance: Instance, storage: {[Instance]: Highlight}): ()
    if not (instance:IsA("BasePart") or instance:IsA("Model")) then return end
    if storage[instance] then return end
    local highlight = Instance.new("Highlight")
    highlight.Name = "Universal_ESP_Layer"
    highlight.Adornee = instance
    highlight.FillColor = self.Config.FILL_COLOR
    highlight.OutlineColor = self.Config.OUTLINE_COLOR
    highlight.FillTransparency = self.Config.FILL_TRANSPARENCY
    highlight.OutlineTransparency = self.Config.OUTLINE_TRANSPARENCY
    highlight.Parent = CoreGui
    storage[instance] = highlight
end
function Modules.UniversalESP:Disable(folder: Instance): ()
    local data = self.State.ActiveFolders[folder]
    if not data then return end
    if data.Added then data.Added:Disconnect() end
    if data.Removed then data.Removed:Disconnect() end
    for item, highlight in pairs(data.Highlights) do
        pcall(function() highlight:Destroy() end)
    end
    self.State.ActiveFolders[folder] = nil
    DoNotif("Deactivated ESP for: " .. folder.Name, 2)
end
function Modules.UniversalESP:Enable(folder: Instance): ()
    if self.State.ActiveFolders[folder] then return end
    local data: ESPData = {
        Highlights = {},
        Added = nil,
        Removed = nil
    }
    local function process(child: Instance)
        if child:IsA("BasePart") or child:IsA("Model") then
            self:_highlight(child, data.Highlights)
        elseif child:IsA("Folder") or child:IsA("Configuration") then
            for _, subChild in ipairs(child:GetChildren()) do
                process(subChild)
            end
        end
    end
    data.Added = folder.DescendantAdded:Connect(function(descendant)
        task.defer(process, descendant)
    end)
    data.Removed = folder.DescendantRemoving:Connect(function(descendant)
        if data.Highlights[descendant] then
            pcall(function() data.Highlights[descendant]:Destroy() end)
            data.Highlights[descendant] = nil
        end
    end)
    self.State.ActiveFolders[folder] = data
    for _, child in ipairs(folder:GetChildren()) do
        process(child)
    end
    DoNotif("Activated ESP for: " .. folder.Name, 2)
end
function Modules.UniversalESP:Initialize(): ()
    local module = self
    RegisterCommand({
        Name = "espfolder",
        Aliases = {"fesp", "highf"},
        Description = "Recursive highlight for objects in a specified path."
    }, function(args: {string})
        local path = args[1]
        if not path then return DoNotif("Argument Required: Path", 3) end
        local folder = module:_resolvePath(path)
        if not folder then return DoNotif("Invalid Object Path: " .. path, 3) end
        if module.State.ActiveFolders[folder] then
            module:Disable(folder)
        else
            module:Enable(folder)
        end
    end)
end
Modules.FolderAimbot = {
    State = {
        IsEnabled = false,
        IsAiming = false,
        TargetFolder = nil,
        Connection = nil,
        InputBegan = nil,
        InputEnded = nil
    },
    Config = {
        FOV = 200,
        SMOOTHING = 0.25,
        AIM_KEY = Enum.UserInputType.MouseButton2
    }
}
function Modules.FolderAimbot:_resolvePath(path: string): Instance?
    local current: Instance = game
    for component in string.gmatch(path, "[^%.]+") do
        if string.find(component, ":GetService") then
            local serviceName = component:match("'(.-)'") or component:match('"(.-)"')
            current = serviceName and game:GetService(serviceName) or current
        else
            current = current and current:FindFirstChild(component)
        end
    end
    return current
end
function Modules.FolderAimbot:_getTargetPos(model: Model): Vector3?
    local priority = {"Head", "HumanoidRootPart", "Torso", "UpperTorso"}
    for _, name in ipairs(priority) do
        local part = model:FindFirstChild(name)
        if part and part:IsA("BasePart") then
            return part.Position
        end
    end
    return model.PrimaryPart and model.PrimaryPart.Position
end
function Modules.FolderAimbot:GetClosestTarget(): Model?
    local folder = self.State.TargetFolder
    if not folder then return nil end
    local closestTarget = nil
    local shortestDist = self.Config.FOV
    local mousePos = UserInputService:GetMouseLocation()
    for _, child in ipairs(folder:GetChildren()) do
        if child:IsA("Model") then
            local pos = self:_getTargetPos(child)
            if pos then
                local screenPos, onScreen = Camera:WorldToViewportPoint(pos)
                if onScreen then
                    local dist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                    if dist < shortestDist then
                        shortestDist = dist
                        closestTarget = child
                    end
                end
            end
        end
    end
    return closestTarget
end
function Modules.FolderAimbot:Enable(folder: Instance, fov: number?): ()
    self:Disable()
    self.State.IsEnabled = true
    self.State.TargetFolder = folder
    if fov then self.Config.FOV = fov end
    self.State.InputBegan = UserInputService.InputBegan:Connect(function(input, gpe)
        if not gpe and input.UserInputType == self.Config.AIM_KEY then
            self.State.IsAiming = true
        end
    end)
    self.State.InputEnded = UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == self.Config.AIM_KEY then
            self.State.IsAiming = false
        end
    end)
    self.State.Connection = RunService.RenderStepped:Connect(function()
        if not self.State.IsAiming then return end
        local target = self:GetClosestTarget()
        if target then
            local pos = self:_getTargetPos(target)
            if pos then
                local screenPos, onScreen = Camera:WorldToViewportPoint(pos)
                if onScreen then
                    local mousePos = UserInputService:GetMouseLocation()
                    local deltaX = (screenPos.X - mousePos.X) * self.Config.SMOOTHING
                    local deltaY = (screenPos.Y - mousePos.Y) * self.Config.SMOOTHING
                    if mousemoverel then
                        mousemoverel(deltaX, deltaY)
                    end
                end
            end
        end
    end)
    DoNotif("Folder Aimbot: ENABLED for " .. folder.Name, 2)
end
function Modules.FolderAimbot:Disable(): ()
    self.State.IsEnabled = false
    self.State.IsAiming = false
    if self.State.Connection then self.State.Connection:Disconnect() end
    if self.State.InputBegan then self.State.InputBegan:Disconnect() end
    if self.State.InputEnded then self.State.InputEnded:Disconnect() end
    self.State.Connection = nil
    self.State.InputBegan = nil
    self.State.InputEnded = nil
    self.State.TargetFolder = nil
end
function Modules.FolderAimbot:Initialize(): ()
    local module = self
    RegisterCommand({
        Name = "faim",
        Aliases = {"folderamt", "targetfolder"},
        Description = "Aimbot for all models in a folder. Usage: ;faim Workspace.Zombies 300"
    }, function(args: {string})
        local path = args[1]
        local fov = tonumber(args[2])
        if not path then
            if module.State.IsEnabled then
                module:Disable()
                return DoNotif("Folder Aimbot: DISABLED", 2)
            end
            return DoNotif("Usage: ;faim <Path> [FOV]", 3)
        end
        local folder = module:_resolvePath(path)
        if folder then
            module:Enable(folder, fov)
        else
            DoNotif("Error: Invalid path.", 3)
        end
    end)
end
Modules.RespawnOnPlayer = {
    State = {
        IsEnabled = false,
        TargetPlayer = nil,
        Connection = nil
    },
    Services = {
        Players = game:GetService("Players"),
        RunService = game:GetService("RunService")
    }
}
function Modules.RespawnOnPlayer:_onCharacterAdded(character)
    task.defer(function()
        if not self.State.IsEnabled or not self.State.TargetPlayer or not self.State.TargetPlayer.Parent then
            DoNotif("Respawn target lost. Disabling.", 3)
            self:Disable()
            return
        end
        local myRoot = character and character:FindFirstChild("HumanoidRootPart")
        if not myRoot then return end
        local targetCharacter = self.State.TargetPlayer.Character
        local targetRoot = nil
        if not targetCharacter then
            DoNotif("Waiting for " .. self.State.TargetPlayer.Name .. " to spawn...", 2)
            for i = 1, 10 do
                targetCharacter = self.State.TargetPlayer.Character
                if targetCharacter then break end
                task.wait(0.5)
            end
        end
        if targetCharacter then
            targetRoot = targetCharacter:FindFirstChild("HumanoidRootPart")
        end
        if targetRoot then
            myRoot.CFrame = targetRoot.CFrame + Vector3.new(0, 3, 0)
            DoNotif("Respawned on " .. self.State.TargetPlayer.Name, 2)
        else
            DoNotif("Could not respawn on target: Character not found (they may be respawning or have left).", 3)
        end
    end)
end
function Modules.RespawnOnPlayer:Enable(targetPlayer)
    if not targetPlayer or targetPlayer == self.Services.Players.LocalPlayer then
        return DoNotif("Invalid or self-targeted player.", 3)
    end
    self:Disable()
    self.State.IsEnabled = true
    self.State.TargetPlayer = targetPlayer
    local module = self
    self.State.Connection = self.Services.Players.LocalPlayer.CharacterAdded:Connect(function(char)
        module:_onCharacterAdded(char)
    end)
    DoNotif("Respawn on Target: ENABLED. Will respawn on " .. targetPlayer.Name, 3)
end
function Modules.RespawnOnPlayer:Disable()
    if not self.State.IsEnabled then return end
    if self.State.Connection then
        self.State.Connection:Disconnect()
        self.State.Connection = nil
    end
    self.State.TargetPlayer = nil
    self.State.IsEnabled = false
    DoNotif("Respawn on Target: DISABLED.", 2)
end
RegisterCommand({
    Name = "respawnontarget",
    Aliases = {"spon", "respawnon"},
    Description = "Sets your respawn point to a target player's location."
}, function(args)
    local argument = table.concat(args, " ")
    if not argument or argument == "" then
        return DoNotif("Usage: ;spon <PlayerName|clear>", 3)
    end
    if argument:lower() == "clear" or argument:lower() == "reset" or argument:lower() == "off" then
        Modules.RespawnOnPlayer:Disable()
        return
    end
    local targetPlayer = Utilities.findPlayer(argument)
    if targetPlayer then
        Modules.RespawnOnPlayer:Enable(targetPlayer)
    else
        DoNotif("Player not found: '" .. argument .. "'", 3)
    end
end)
Modules.VariableSniper = { State = { IsScanning = false } }
function Modules.VariableSniper:Search(varName, newValue)
    local foundCount = 0
    for _, obj in ipairs(getgc(true)) do
        if type(obj) == "table" and rawget(obj, varName) ~= nil then
            rawset(obj, varName, newValue)
            foundCount = foundCount + 1
        end
    end
    DoNotif("Sniper: Patched " .. foundCount .. " instances of '" .. varName .. "'", 3)
end
RegisterCommand({
    Name = "snipe",
    Aliases = {"patchvar", "memedit"},
    Description = "Scans memory for a variable name and overwrites its value. ;snipe isAdmin true"
}, function(args)
    local var = args[1]
    local val = args[2]
    if val == "true" then val = true elseif val == "false" then val = false end
    Modules.VariableSniper:Search(var, val)
end)
Modules.SignalRespawn = {
    State = {
        IsExecuting = false
    },
    Dependencies = {"Players", "Workspace", "ReplicateSignal"},
    Services = {}
}
function Modules.SignalRespawn:_getAllTools()
    local lp = self.Services.Players.LocalPlayer
    local tools = {}
    local backpack = lp:FindFirstChildOfClass("Backpack")
    local char = lp.Character
    if backpack then
        for _, tool in ipairs(backpack:GetChildren()) do
            if tool:IsA("Tool") then table.insert(tools, tool) end
        end
    end
    if char then
        for _, tool in ipairs(char:GetChildren()) do
            if tool:IsA("Tool") then table.insert(tools, tool) end
        end
    end
    return tools
end
function Modules.SignalRespawn:Execute()
    if self.State.IsExecuting then return end
    if not replicatesignal then
        return DoNotif("SignalRespawn: Your executor lacks 'replicatesignal'.", 4)
    end
    local lp = self.Services.Players.LocalPlayer
    local players = self.Services.Players
    local char = lp.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    local cam = self.Services.Workspace.CurrentCamera
    if not hum or not root then
        return DoNotif("SignalRespawn: Character root not found.", 3)
    end
    self.State.IsExecuting = true
    DoNotif("Initiating signal-based respawn...", 1.5)
    pcall(function()
        replicatesignal(lp.ConnectDiedSignalBackend)
    end)
    local savedCFrame = root.CFrame
    local savedTools = self:_getAllTools()
    task.wait(players.RespawnTime - 0.165)
    pcall(function()
        hum:ChangeState(Enum.HumanoidStateType.Dead)
    end)
    local newChar = lp.CharacterAdded:Wait()
    local newRoot = newChar:WaitForChild("HumanoidRootPart", 5)
    if newRoot then
        task.wait(0.1)
        newRoot.CFrame = savedCFrame
        self.Services.Workspace.CurrentCamera = cam
        DoNotif("Respawn complete. Position restored.", 2)
    end
    self.State.IsExecuting = false
end
function Modules.SignalRespawn:Initialize()
    local module = self
    for _, serviceName in ipairs(module.Dependencies) do
        module.Services[serviceName] = game:GetService(serviceName)
    end
    RegisterCommand({
        Name = "signalrespawn",
        Aliases = {"instaspawn"},
        Description = "Advanced instant respawn using signal replication. Restores position."
    }, function()
        module:Execute()
    end)
end
Modules.ExternalChatter = {
    State = {
        IsEnabled = true
    },
    Dependencies = {"TextChatService", "ReplicatedStorage", "Players"},
    Services = {}
}
function Modules.ExternalChatter:Say(args)
    local message = table.concat(args, " ")
    if not message or message == "" then
        return DoNotif("External Chatter: No message provided.", 2)
    end
    local textChatService = self.Services.TextChatService
    local replicatedStorage = self.Services.ReplicatedStorage
    if textChatService and textChatService.ChatVersion == Enum.ChatVersion.TextChatService then
        local generalChannel = textChatService.TextChannels:FindFirstChild("RBXGeneral")
        if generalChannel then
            pcall(function()
                generalChannel:SendAsync(message)
            end)
            return
        end
    end
    local chatEvents = replicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
    local sayMessageRequest = chatEvents and chatEvents:FindFirstChild("SayMessageRequest")
    if sayMessageRequest and sayMessageRequest:IsA("RemoteEvent") then
        pcall(function()
            sayMessageRequest:FireServer(message, "All")
        end)
    else
        local lp = self.Services.Players.LocalPlayer
        if lp then
            pcall(lp.Chat, lp, message)
        end
    end
end
function Modules.ExternalChatter:Initialize()
    local module = self
    for _, serviceName in ipairs(module.Dependencies) do
        module.Services[serviceName] = game:GetService(serviceName)
    end
    RegisterCommand({
        Name = "chat",
        Aliases = {"message"},
        Description = "Forces your character to chat. Bypasses some UI mutes."
    }, function(args)
        module:Say(args)
    end)
end
Modules.StareController = {
    State = {
        IsEnabled = false,
        TargetPlayer = nil,
        Mode = nil,
        Connection = nil,
        PrevAutoRotate = true
    },
    Dependencies = {"Players", "RunService"},
    Services = {}
}
function Modules.StareController:_facePosition(targetPos)
    local lp = self.Services.Players.LocalPlayer
    local char = lp.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if root then
        local targetLook = Vector3.new(targetPos.X, root.Position.Y, targetPos.Z)
        if (targetLook - root.Position).Magnitude > 0.01 then
            root.CFrame = CFrame.lookAt(root.Position, targetLook)
        end
    end
end
function Modules.StareController:_getClosestPlayer()
    local lp = self.Services.Players.LocalPlayer
    local char = lp.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not root then return nil end
    local closest, dist = nil, math.huge
    for _, p in ipairs(self.Services.Players:GetPlayers()) do
        if p ~= lp and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
            local d = (p.Character.HumanoidRootPart.Position - root.Position).Magnitude
            if d < dist then
                dist = d
                closest = p
            end
        end
    end
    return closest
end
function Modules.StareController:Disable()
    if self.State.Connection then
        self.State.Connection:Disconnect()
        self.State.Connection = nil
    end
    local lp = self.Services.Players.LocalPlayer
    local hum = lp.Character and lp.Character:FindFirstChildOfClass("Humanoid")
    if hum then
        hum.AutoRotate = self.State.PrevAutoRotate
    end
    self.State.IsEnabled = false
    self.State.TargetPlayer = nil
    self.State.Mode = nil
end
function Modules.StareController:Enable(target, mode)
    self:Disable()
    local lp = self.Services.Players.LocalPlayer
    local hum = lp.Character and lp.Character:FindFirstChildOfClass("Humanoid")
    if not hum then return end
    self.State.PrevAutoRotate = hum.AutoRotate
    hum.AutoRotate = false
    self.State.IsEnabled = true
    self.State.Mode = mode
    if mode == "Direct" then
        self.State.TargetPlayer = target
        self.State.Connection = self.Services.RunService.RenderStepped:Connect(function()
            if target and target.Parent and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
                self:_facePosition(target.Character.HumanoidRootPart.Position)
            else
                self:Disable()
                DoNotif("Stare: Target lost. Disabling.", 2)
            end
        end)
        DoNotif("Staring at: " .. target.Name, 2)
    elseif mode == "Nearest" then
        self.State.Connection = self.Services.RunService.RenderStepped:Connect(function()
            local closest = self:_getClosestPlayer()
            if closest and closest.Character and closest.Character:FindFirstChild("HumanoidRootPart") then
                self:_facePosition(closest.Character.HumanoidRootPart.Position)
            end
        end)
        DoNotif("Staring at nearest player.", 2)
    end
end
function Modules.StareController:Initialize()
    local module = self
    for _, s in ipairs(module.Dependencies) do module.Services[s] = game:GetService(s) end
    RegisterCommand({
        Name = "lookat",
        Aliases = {"stare", "face"},
        Description = "Forces your character to persistently face a player."
    }, function(args)
        local target = Utilities.findPlayer(args[1] or "")
        if target then
            module:Enable(target, "Direct")
        else
            DoNotif("Stare: Player not found.", 3)
        end
    end)
    RegisterCommand({
        Name = "unlookat",
        Aliases = {"unstare", "unface"},
        Description = "Stops the stare effect and restores movement rotation."
    }, function()
        module:Disable()
        DoNotif("Stare disabled.", 2)
    end)
    RegisterCommand({
        Name = "starenear",
        Aliases = {"stareclosest", "snear"},
        Description = "Persistently stare at whoever is closest to you."
    }, function()
        module:Enable(nil, "Nearest")
    end)
    RegisterCommand({
        Name = "unstarenear",
        Aliases = {"unstareclosest"},
        Description = "Stops staring at the closest player."
    }, function()
        module:Disable()
        DoNotif("Nearest Stare disabled.", 2)
    end)
end
Modules.ProximityPromptTP = {
    State = {
        IsEnabled = false,
        FoundPrompts = {},
        SelectedPrompt = nil,
        OriginalPosition = nil,
        UI = nil,
        Connections = {},
        AutoTeleport = false,
        IsExecuting = false
    },
    Config = {
        MaxDistance = 1000,
        ShowHighlight = true,
        HighlightColor = Color3.fromRGB(255, 200, 0),
        ReturnDelay = 0.5,
        AutoScan = true,
        ScanInterval = 2
    }
}
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local ProximityPromptService = game:GetService("ProximityPromptService")
function Modules.ProximityPromptTP:_createUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "ProximityPromptTP_Zuka"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
    self.State.UI = screenGui
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.fromOffset(400, 620)
    mainFrame.Position = UDim2.new(1, -410, 0.5, -310)
    mainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
    mainFrame.BorderSizePixel = 0
    mainFrame.Parent = screenGui
    Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 8)
    local stroke = Instance.new("UIStroke", mainFrame)
    stroke.Color = Color3.fromRGB(255, 200, 0)
    stroke.Thickness = 2
    local glowTween = TweenService:Create(stroke, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {
        Thickness = 3
    })
    glowTween:Play()
    local titleBar = Instance.new("Frame", mainFrame)
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1, 0, 0, 35)
    titleBar.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
    titleBar.BorderSizePixel = 0
    Instance.new("UICorner", titleBar).CornerRadius = UDim.new(0, 8)
    local title = Instance.new("TextLabel", titleBar)
    title.Size = UDim2.new(1, -100, 1, 0)
    title.Position = UDim2.fromOffset(10, 0)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.Code
    title.Text = "â–¸ PROXIMITY TP"
    title.TextColor3 = Color3.fromRGB(255, 200, 0)
    title.TextSize = 16
    title.TextXAlignment = Enum.TextXAlignment.Left
    local statusIndicator = Instance.new("TextLabel", titleBar)
    statusIndicator.Name = "StatusIndicator"
    statusIndicator.Size = UDim2.fromOffset(100, 20)
    statusIndicator.Position = UDim2.new(1, -170, 0.5, -10)
    statusIndicator.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    statusIndicator.BorderSizePixel = 0
    statusIndicator.Font = Enum.Font.GothamBold
    statusIndicator.Text = "0 PROMPTS"
    statusIndicator.TextColor3 = Color3.fromRGB(200, 200, 200)
    statusIndicator.TextSize = 10
    Instance.new("UICorner", statusIndicator).CornerRadius = UDim.new(0, 4)
    local closeBtn = Instance.new("TextButton", titleBar)
    closeBtn.Size = UDim2.fromOffset(30, 30)
    closeBtn.Position = UDim2.new(1, -32, 0, 2)
    closeBtn.BackgroundColor3 = Color3.fromRGB(255, 50, 100)
    closeBtn.BorderSizePixel = 0
    closeBtn.Text = "Ã—"
    closeBtn.TextColor3 = Color3.new(1, 1, 1)
    closeBtn.Font = Enum.Font.GothamBold
    closeBtn.TextSize = 20
    Instance.new("UICorner", closeBtn).CornerRadius = UDim.new(0, 6)
    closeBtn.MouseButton1Click:Connect(function()
        self:Disable()
    end)
    local dragStart, startPos
    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragStart = input.Position
            startPos = mainFrame.Position
            local moveConn, endConn
            moveConn = game:GetService("UserInputService").InputChanged:Connect(function(moveInput)
                if moveInput.UserInputType == Enum.UserInputType.MouseMovement then
                    local delta = moveInput.Position - dragStart
                    mainFrame.Position = UDim2.new(
                        startPos.X.Scale, startPos.X.Offset + delta.X,
                        startPos.Y.Scale, startPos.Y.Offset + delta.Y
                    )
                end
            end)
            endConn = game:GetService("UserInputService").InputEnded:Connect(function(endInput)
                if endInput.UserInputType == Enum.UserInputType.MouseButton1 then
                    moveConn:Disconnect()
                    endConn:Disconnect()
                end
            end)
        end
    end)
    local content = Instance.new("Frame", mainFrame)
    content.Name = "Content"
    content.Size = UDim2.new(1, -20, 1, -45)
    content.Position = UDim2.fromOffset(10, 40)
    content.BackgroundTransparency = 1
    local selectionLabel = Instance.new("TextLabel", content)
    selectionLabel.Name = "SelectionLabel"
    selectionLabel.Size = UDim2.new(1, 0, 0, 35)
    selectionLabel.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    selectionLabel.BorderSizePixel = 0
    selectionLabel.Font = Enum.Font.GothamMedium
    selectionLabel.Text = "No prompt selected"
    selectionLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    selectionLabel.TextSize = 12
    Instance.new("UICorner", selectionLabel).CornerRadius = UDim.new(0, 6)
    local settingsLabel = Instance.new("TextLabel", content)
    settingsLabel.Size = UDim2.new(1, 0, 0, 20)
    settingsLabel.Position = UDim2.fromOffset(0, 45)
    settingsLabel.BackgroundTransparency = 1
    settingsLabel.Font = Enum.Font.GothamBold
    settingsLabel.Text = "Settings:"
    settingsLabel.TextColor3 = Color3.new(1, 1, 1)
    settingsLabel.TextSize = 13
    settingsLabel.TextXAlignment = Enum.TextXAlignment.Left
    local distanceLabel = Instance.new("TextLabel", content)
    distanceLabel.Size = UDim2.new(1, 0, 0, 18)
    distanceLabel.Position = UDim2.fromOffset(0, 70)
    distanceLabel.BackgroundTransparency = 1
    distanceLabel.Font = Enum.Font.Gotham
    distanceLabel.Text = "Max Distance: 1000"
    distanceLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    distanceLabel.TextSize = 11
    distanceLabel.TextXAlignment = Enum.TextXAlignment.Left
    local distanceInput = Instance.new("TextBox", content)
    distanceInput.Size = UDim2.new(1, 0, 0, 30)
    distanceInput.Position = UDim2.fromOffset(0, 92)
    distanceInput.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    distanceInput.BorderSizePixel = 0
    distanceInput.Font = Enum.Font.Code
    distanceInput.Text = "1000"
    distanceInput.TextColor3 = Color3.new(1, 1, 1)
    distanceInput.TextSize = 12
    distanceInput.PlaceholderText = "Scan radius..."
    Instance.new("UICorner", distanceInput).CornerRadius = UDim.new(0, 6)
    distanceInput.FocusLost:Connect(function()
        local value = tonumber(distanceInput.Text)
        if value and value > 0 then
            self.Config.MaxDistance = value
            distanceLabel.Text = "Max Distance: " .. value
        else
            distanceInput.Text = tostring(self.Config.MaxDistance)
        end
    end)
    local delayLabel = Instance.new("TextLabel", content)
    delayLabel.Size = UDim2.new(1, 0, 0, 18)
    delayLabel.Position = UDim2.fromOffset(0, 130)
    delayLabel.BackgroundTransparency = 1
    delayLabel.Font = Enum.Font.Gotham
    delayLabel.Text = "Return Delay: 0.5s"
    delayLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    delayLabel.TextSize = 11
    delayLabel.TextXAlignment = Enum.TextXAlignment.Left
    local delayInput = Instance.new("TextBox", content)
    delayInput.Size = UDim2.new(1, 0, 0, 30)
    delayInput.Position = UDim2.fromOffset(0, 152)
    delayInput.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    delayInput.BorderSizePixel = 0
    delayInput.Font = Enum.Font.Code
    delayInput.Text = "0.5"
    delayInput.TextColor3 = Color3.new(1, 1, 1)
    delayInput.TextSize = 12
    delayInput.PlaceholderText = "Delay before returning..."
    Instance.new("UICorner", delayInput).CornerRadius = UDim.new(0, 6)
    delayInput.FocusLost:Connect(function()
        local value = tonumber(delayInput.Text)
        if value and value >= 0 then
            self.Config.ReturnDelay = value
            delayLabel.Text = "Return Delay: " .. value .. "s"
        else
            delayInput.Text = tostring(self.Config.ReturnDelay)
        end
    end)
    local autoScanToggle = Instance.new("TextButton", content)
    autoScanToggle.Name = "AutoScanToggle"
    autoScanToggle.Size = UDim2.new(1, 0, 0, 30)
    autoScanToggle.Position = UDim2.fromOffset(0, 192)
    autoScanToggle.BackgroundColor3 = Color3.fromRGB(0, 200, 100)
    autoScanToggle.BorderSizePixel = 0
    autoScanToggle.Font = Enum.Font.GothamBold
    autoScanToggle.Text = "AUTO-SCAN: ON"
    autoScanToggle.TextColor3 = Color3.new(1, 1, 1)
    autoScanToggle.TextSize = 11
    Instance.new("UICorner", autoScanToggle).CornerRadius = UDim.new(0, 6)
    autoScanToggle.MouseButton1Click:Connect(function()
        self.Config.AutoScan = not self.Config.AutoScan
        autoScanToggle.Text = "AUTO-SCAN: " .. (self.Config.AutoScan and "ON" or "OFF")
        autoScanToggle.BackgroundColor3 = self.Config.AutoScan and Color3.fromRGB(0, 200, 100) or Color3.fromRGB(50, 50, 65)
    end)
    local scanBtn = Instance.new("TextButton", content)
    scanBtn.Name = "ScanButton"
    scanBtn.Size = UDim2.new(1, 0, 0, 35)
    scanBtn.Position = UDim2.fromOffset(0, 232)
    scanBtn.BackgroundColor3 = Color3.fromRGB(0, 150, 255)
    scanBtn.BorderSizePixel = 0
    scanBtn.Font = Enum.Font.GothamBold
    scanBtn.Text = "SCAN FOR PROMPTS"
    scanBtn.TextColor3 = Color3.new(1, 1, 1)
    scanBtn.TextSize = 12
    Instance.new("UICorner", scanBtn).CornerRadius = UDim.new(0, 6)
    scanBtn.MouseButton1Click:Connect(function()
        self:ScanForPrompts()
    end)
    local actionsLabel = Instance.new("TextLabel", content)
    actionsLabel.Size = UDim2.new(1, 0, 0, 20)
    actionsLabel.Position = UDim2.fromOffset(0, 277)
    actionsLabel.BackgroundTransparency = 1
    actionsLabel.Font = Enum.Font.GothamBold
    actionsLabel.Text = "Actions:"
    actionsLabel.TextColor3 = Color3.new(1, 1, 1)
    actionsLabel.TextSize = 13
    actionsLabel.TextXAlignment = Enum.TextXAlignment.Left
    local executeBtn = Instance.new("TextButton", content)
    executeBtn.Name = "ExecuteButton"
    executeBtn.Size = UDim2.new(1, 0, 0, 45)
    executeBtn.Position = UDim2.fromOffset(0, 302)
    executeBtn.BackgroundColor3 = Color3.fromRGB(255, 200, 0)
    executeBtn.BorderSizePixel = 0
    executeBtn.Font = Enum.Font.GothamBold
    executeBtn.Text = "EXECUTE PROMPT"
    executeBtn.TextColor3 = Color3.new(1, 1, 1)
    executeBtn.TextSize = 14
    Instance.new("UICorner", executeBtn).CornerRadius = UDim.new(0, 6)
    executeBtn.MouseButton1Click:Connect(function()
        self:ExecutePrompt()
    end)
    local tpBtn = Instance.new("TextButton", content)
    tpBtn.Size = UDim2.new(0.48, 0, 0, 35)
    tpBtn.Position = UDim2.fromOffset(0, 357)
    tpBtn.BackgroundColor3 = Color3.fromRGB(150, 100, 255)
    tpBtn.BorderSizePixel = 0
    tpBtn.Font = Enum.Font.GothamBold
    tpBtn.Text = "TP ONLY"
    tpBtn.TextColor3 = Color3.new(1, 1, 1)
    tpBtn.TextSize = 11
    Instance.new("UICorner", tpBtn).CornerRadius = UDim.new(0, 6)
    tpBtn.MouseButton1Click:Connect(function()
        self:TeleportToPrompt()
    end)
    local returnBtn = Instance.new("TextButton", content)
    returnBtn.Size = UDim2.new(0.48, 0, 0, 35)
    returnBtn.Position = UDim2.new(0.52, 0, 0, 357)
    returnBtn.BackgroundColor3 = Color3.fromRGB(100, 200, 100)
    returnBtn.BorderSizePixel = 0
    returnBtn.Font = Enum.Font.GothamBold
    returnBtn.Text = "RETURN"
    returnBtn.TextColor3 = Color3.new(1, 1, 1)
    returnBtn.TextSize = 11
    Instance.new("UICorner", returnBtn).CornerRadius = UDim.new(0, 6)
    returnBtn.MouseButton1Click:Connect(function()
        self:ReturnToOriginal()
    end)
    local listLabel = Instance.new("TextLabel", content)
    listLabel.Size = UDim2.new(1, 0, 0, 20)
    listLabel.Position = UDim2.fromOffset(0, 402)
    listLabel.BackgroundTransparency = 1
    listLabel.Font = Enum.Font.GothamBold
    listLabel.Text = "Found Prompts:"
    listLabel.TextColor3 = Color3.new(1, 1, 1)
    listLabel.TextSize = 13
    listLabel.TextXAlignment = Enum.TextXAlignment.Left
    local promptList = Instance.new("ScrollingFrame", content)
    promptList.Name = "PromptList"
    promptList.Size = UDim2.new(1, 0, 0, 173)
    promptList.Position = UDim2.fromOffset(0, 427)
    promptList.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
    promptList.BorderSizePixel = 0
    promptList.ScrollBarThickness = 4
    promptList.ScrollBarImageColor3 = Color3.fromRGB(255, 200, 0)
    promptList.CanvasSize = UDim2.fromOffset(0, 0)
    promptList.AutomaticCanvasSize = Enum.AutomaticSize.Y
    Instance.new("UICorner", promptList).CornerRadius = UDim.new(0, 6)
    local listLayout = Instance.new("UIListLayout", promptList)
    listLayout.Padding = UDim.new(0, 3)
    listLayout.SortOrder = Enum.SortOrder.LayoutOrder
    screenGui.Parent = CoreGui
    return selectionLabel, statusIndicator, promptList
end
function Modules.ProximityPromptTP:ScanForPrompts()
    local myChar = LocalPlayer.Character
    if not myChar or not myChar:FindFirstChild("HumanoidRootPart") then
        print("âœ— Character not found")
        return
    end
    local myPos = myChar.HumanoidRootPart.Position
    self.State.FoundPrompts = {}
    for _, obj in pairs(workspace:GetDescendants()) do
        if obj:IsA("ProximityPrompt") then
            local promptPart = obj.Parent
            if promptPart and promptPart:IsA("BasePart") then
                local distance = (promptPart.Position - myPos).Magnitude
                if distance <= self.Config.MaxDistance then
                    table.insert(self.State.FoundPrompts, {
                        Prompt = obj,
                        Part = promptPart,
                        Distance = distance,
                        Name = obj.ObjectText ~= "" and obj.ObjectText or promptPart.Name,
                        ActionText = obj.ActionText
                    })
                end
            end
        end
    end
    table.sort(self.State.FoundPrompts, function(a, b)
        return a.Distance < b.Distance
    end)
    print(string.format("âœ“ Found %d prompts", #self.State.FoundPrompts))
    self:UpdateDisplay()
end
function Modules.ProximityPromptTP:SelectPrompt(promptData)
    if not promptData then return end
    if self.State.SelectedPrompt and self.State.SelectedPrompt.Part then
        local oldHighlight = self.State.SelectedPrompt.Part:FindFirstChild("ProximityTP_Highlight")
        if oldHighlight then
            oldHighlight:Destroy()
        end
    end
    self.State.SelectedPrompt = promptData
    if self.Config.ShowHighlight and promptData.Part then
        local highlight = Instance.new("SelectionBox")
        highlight.Name = "ProximityTP_Highlight"
        highlight.Adornee = promptData.Part
        highlight.LineThickness = 0.05
        highlight.Color3 = self.Config.HighlightColor
        highlight.Parent = promptData.Part
    end
    print(string.format("âœ“ Selected: %s", promptData.Name))
    self:UpdateDisplay()
end
function Modules.ProximityPromptTP:TeleportToPrompt()
    if not self.State.SelectedPrompt then
        print("âš  No prompt selected")
        return
    end
    local myChar = LocalPlayer.Character
    if not myChar or not myChar:FindFirstChild("HumanoidRootPart") then
        print("âœ— Character not found")
        return
    end
    local promptPart = self.State.SelectedPrompt.Part
    if not promptPart or not promptPart.Parent then
        print("âœ— Prompt no longer exists")
        return
    end
    self.State.OriginalPosition = myChar.HumanoidRootPart.CFrame
    local offset = Vector3.new(0, 3, 0)
    myChar.HumanoidRootPart.CFrame = CFrame.new(promptPart.Position + offset)
    print(string.format("âœ“ Teleported to: %s", self.State.SelectedPrompt.Name))
end
function Modules.ProximityPromptTP:ReturnToOriginal()
    if not self.State.OriginalPosition then
        print("âš  No saved position")
        return
    end
    local myChar = LocalPlayer.Character
    if not myChar or not myChar:FindFirstChild("HumanoidRootPart") then
        print("âœ— Character not found")
        return
    end
    myChar.HumanoidRootPart.CFrame = self.State.OriginalPosition
    print("âœ“ Returned to original position")
end
function Modules.ProximityPromptTP:ExecutePrompt()
    if not self.State.SelectedPrompt then
        print("âš  No prompt selected")
        return
    end
    if self.State.IsExecuting then
        print("âš  Already executing a prompt")
        return
    end
    local myChar = LocalPlayer.Character
    if not myChar or not myChar:FindFirstChild("HumanoidRootPart") then
        print("âœ— Character not found")
        return
    end
    local prompt = self.State.SelectedPrompt.Prompt
    local promptPart = self.State.SelectedPrompt.Part
    if not prompt or not prompt.Parent or not promptPart or not promptPart.Parent then
        print("âœ— Prompt no longer exists")
        return
    end
    self.State.IsExecuting = true
    self.State.OriginalPosition = myChar.HumanoidRootPart.CFrame
    print(string.format("ðŸ’¾ Saved position: %.1f, %.1f, %.1f", self.State.OriginalPosition.X, self.State.OriginalPosition.Y, self.State.OriginalPosition.Z))
    local offset = Vector3.new(0, 3, 0)
    myChar.HumanoidRootPart.CFrame = CFrame.new(promptPart.Position + offset)
    print(string.format("ðŸ“ Teleported to: %s", self.State.SelectedPrompt.Name))
    task.wait(0.1)
    local success = pcall(function()
        fireproximityprompt(prompt)
    end)
    if success then
        print(string.format("âœ“ Triggered prompt: %s", self.State.SelectedPrompt.ActionText))
    else
        print("âš  Failed to trigger prompt")
    end
    task.wait(self.Config.ReturnDelay)
    if myChar and myChar:FindFirstChild("HumanoidRootPart") then
        myChar.HumanoidRootPart.CFrame = self.State.OriginalPosition
        print("â†© Returned to original position")
    end
    self.State.IsExecuting = false
end
function Modules.ProximityPromptTP:UpdateDisplay()
    if not self.State.UI then return end
    local selectionLabel = self.State.UI.MainFrame.Content.SelectionLabel
    local statusIndicator = self.State.UI.MainFrame.TitleBar.StatusIndicator
    local promptList = self.State.UI.MainFrame.Content.PromptList
    if self.State.SelectedPrompt then
        selectionLabel.Text = string.format("Selected: %s (%.1fm)", 
            self.State.SelectedPrompt.Name, 
            self.State.SelectedPrompt.Distance
        )
        selectionLabel.TextColor3 = Color3.fromRGB(255, 255, 100)
    else
        selectionLabel.Text = "No prompt selected"
        selectionLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    end
    local count = #self.State.FoundPrompts
    statusIndicator.Text = count .. " PROMPTS"
    statusIndicator.BackgroundColor3 = count > 0 and Color3.fromRGB(255, 200, 0) or Color3.fromRGB(50, 50, 50)
    statusIndicator.TextColor3 = count > 0 and Color3.new(1, 1, 1) or Color3.fromRGB(200, 200, 200)
    for _, child in pairs(promptList:GetChildren()) do
        if not child:IsA("UIListLayout") then
            child:Destroy()
        end
    end
    for i, promptData in ipairs(self.State.FoundPrompts) do
        local entry = Instance.new("TextButton")
        entry.Size = UDim2.new(1, -5, 0, 40)
        entry.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
        entry.BorderSizePixel = 0
        entry.Font = Enum.Font.Code
        entry.Text = ""
        entry.TextColor3 = Color3.fromRGB(255, 200, 0)
        entry.TextSize = 10
        entry.TextXAlignment = Enum.TextXAlignment.Left
        entry.AutoButtonColor = false
        entry.Parent = promptList
        Instance.new("UICorner", entry).CornerRadius = UDim.new(0, 4)
        local nameLabel = Instance.new("TextLabel", entry)
        nameLabel.Size = UDim2.new(1, -10, 0, 18)
        nameLabel.Position = UDim2.fromOffset(8, 3)
        nameLabel.BackgroundTransparency = 1
        nameLabel.Font = Enum.Font.GothamBold
        nameLabel.Text = string.format("[%d] %s", i, promptData.Name)
        nameLabel.TextColor3 = Color3.fromRGB(255, 200, 0)
        nameLabel.TextSize = 11
        nameLabel.TextXAlignment = Enum.TextXAlignment.Left
        nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
        local actionLabel = Instance.new("TextLabel", entry)
        actionLabel.Size = UDim2.new(1, -10, 0, 15)
        actionLabel.Position = UDim2.fromOffset(8, 21)
        actionLabel.BackgroundTransparency = 1
        actionLabel.Font = Enum.Font.Gotham
        actionLabel.Text = string.format("%.1fm - %s", promptData.Distance, promptData.ActionText)
        actionLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
        actionLabel.TextSize = 9
        actionLabel.TextXAlignment = Enum.TextXAlignment.Left
        actionLabel.TextTruncate = Enum.TextTruncate.AtEnd
        entry.MouseButton1Click:Connect(function()
            self:SelectPrompt(promptData)
            for _, child in pairs(promptList:GetChildren()) do
                if child:IsA("TextButton") then
                    child.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
                end
            end
            entry.BackgroundColor3 = Color3.fromRGB(200, 150, 0)
        end)
        entry.MouseEnter:Connect(function()
            if entry.BackgroundColor3 ~= Color3.fromRGB(200, 150, 0) then
                entry.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
            end
        end)
        entry.MouseLeave:Connect(function()
            if entry.BackgroundColor3 ~= Color3.fromRGB(200, 150, 0) then
                entry.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
            end
        end)
    end
end
function Modules.ProximityPromptTP:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    self:_createUI()
    self:ScanForPrompts()
    self.State.Connections.AutoScan = RunService.Heartbeat:Connect(function()
        if self.Config.AutoScan then
            task.wait(self.Config.ScanInterval)
            self:ScanForPrompts()
        end
    end)
    print("âœ“ Proximity Prompt TP enabled")
end
function Modules.ProximityPromptTP:Disable()
    if not self.State.IsEnabled then return end
    self.State.IsEnabled = false
    if self.State.SelectedPrompt and self.State.SelectedPrompt.Part then
        local highlight = self.State.SelectedPrompt.Part:FindFirstChild("ProximityTP_Highlight")
        if highlight then
            highlight:Destroy()
        end
    end
    for _, conn in pairs(self.State.Connections) do
        if conn then
            conn:Disconnect()
        end
    end
    table.clear(self.State.Connections)
    if self.State.UI then
        self.State.UI:Destroy()
        self.State.UI = nil
    end
    self.State.FoundPrompts = {}
    self.State.SelectedPrompt = nil
    print("âœ“ Proximity Prompt TP disabled")
end
function Modules.ProximityPromptTP:Toggle()
    if self.State.IsEnabled then
        self:Disable()
    else
        self:Enable()
    end
end
RegisterCommand({
    Name = "proximitytp",
    Aliases = {"ptp", "prompttp", "proxtp"},
    Description = "Teleports to proximity prompts from any distance and returns you to original position."
}, function()
    Modules.ProximityPromptTP:Toggle()
end)
Modules.ProximityStalker = {
    State = {
        IsEnabled = false,
        IsFollowing = false,
        TargetPlayer = nil,
        LastDistances = {},
        Connections = {}
    },
    Config = {
        ProximityRadius = 25,
        StopDistance = 5
    },
    Dependencies = {"RunService", "Players"},
    Services = {}
}
function Modules.ProximityStalker:_cleanup()
    for key, conn in pairs(self.State.Connections) do
        conn:Disconnect()
    end
    table.clear(self.State.Connections)
    local lp = self.Services.Players.LocalPlayer
    local hum = lp.Character and lp.Character:FindFirstChildOfClass("Humanoid")
    if hum then
        hum:MoveTo(lp.Character.PrimaryPart and lp.Character.PrimaryPart.Position or Vector3.zero)
    end
    self.State.LastDistances = {}
    self.State.IsFollowing = false
    self.State.TargetPlayer = nil
    self.State.IsEnabled = false
end
function Modules.ProximityStalker:_setupFollowLogic(target)
    local lp = self.Services.Players.LocalPlayer
    local myHum = lp.Character and lp.Character:FindFirstChildOfClass("Humanoid")
    if not myHum then return end
    self.State.Connections.FollowLoop = self.Services.RunService.Heartbeat:Connect(function()
        local tChar = target.Character
        local tRoot = tChar and tChar:FindFirstChild("HumanoidRootPart")
        local myChar = lp.Character
        if myChar and tRoot and tChar.Parent then
            local dist = (tRoot.Position - myChar.PrimaryPart.Position).Magnitude
            if dist > self.Config.StopDistance then
                myHum:MoveTo(tRoot.Position)
            end
        else
            if self.State.Connections.FollowLoop then
                self.State.Connections.FollowLoop:Disconnect()
            end
            self.State.IsFollowing = false
            self.State.TargetPlayer = nil
            DoNotif("Proximity Stalker: Target lost. Resuming scan.", 2)
        end
    end)
    local tHum = target.Character:FindFirstChildOfClass("Humanoid")
    if tHum then
        self.State.Connections.TargetDied = tHum.Died:Connect(function()
            if self.State.Connections.FollowLoop then self.State.Connections.FollowLoop:Disconnect() end
            self.State.IsFollowing = false
            self.State.TargetPlayer = nil
        end)
    end
end
function Modules.ProximityStalker:Start()
    self:_cleanup()
    self.State.IsEnabled = true
    local lp = self.Services.Players.LocalPlayer
    DoNotif("Proximity Stalker: ACTIVE (Radius: " .. self.Config.ProximityRadius .. ")", 2)
    self.State.Connections.Scanner = self.Services.RunService.Heartbeat:Connect(function()
        if self.State.IsFollowing or not self.State.IsEnabled then return end
        local myChar = lp.Character
        local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
        if not myRoot then return end
        for _, plr in ipairs(self.Services.Players:GetPlayers()) do
            if plr ~= lp and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                local tRoot = plr.Character.HumanoidRootPart
                local currentDist = (myRoot.Position - tRoot.Position).Magnitude
                local lastDist = self.State.LastDistances[plr]
                if lastDist and lastDist > self.Config.ProximityRadius and currentDist <= self.Config.ProximityRadius then
                    self.State.IsFollowing = true
                    self.State.TargetPlayer = plr
                    DoNotif("Stalker: Locked onto " .. plr.Name, 2)
                    self:_setupFollowLogic(plr)
                    self.State.Connections.TargetRespawn = plr.CharacterAdded:Connect(function(newChar)
                        task.wait(0.5)
                        if self.State.IsEnabled and self.State.TargetPlayer == plr then
                            self:_setupFollowLogic(plr)
                        end
                    end)
                    break
                end
                self.State.LastDistances[plr] = currentDist
            end
        end
    end)
end
function Modules.ProximityStalker:Initialize()
    local module = self
    for _, s in ipairs(module.Dependencies) do module.Services[s] = game:GetService(s) end
    RegisterCommand({
        Name = "autofollow",
        Aliases = {"autostalk", "proxfollow", "stalkonapproach"},
        Description = "Automatically follows any player who walks into your proximity radius."
    }, function()
        module:Start()
    end)
    RegisterCommand({
        Name = "unautofollow",
        Aliases = {"stopautostalk", "unproxfollow"},
        Description = "Disables the proximity stalker and stops current movement."
    }, function()
        module:_cleanup()
        DoNotif("Proximity Stalker: DISABLED", 2)
    end)
end
Modules.ForceRespawn = {
}
function Modules.ForceRespawn:Execute()
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    if not LocalPlayer then
        DoNotif("Cannot respawn: LocalPlayer not found.", 3)
        return
    end
    DoNotif("Attempting to force respawn...", 2)
    local success, err = pcall(function()
        LocalPlayer:LoadCharacter()
    end)
    if not success then
        warn("[ForceRespawn] LoadCharacter failed:", err)
        DoNotif("Respawn request failed. The server may have rejected it.", 4)
    end
end
function Modules.ForceRespawn:Initialize()
    RegisterCommand({
        Name = "respawn",
        Aliases = {"rr"},
        Description = "Forces your character to respawn. Useful if you are stuck or punished."
    }, function()
        Modules.ForceRespawn:Execute()
    end)
end
RegisterCommand({
    Name = "gclog",
    Aliases = {"memcheck", "gcinfo"},
    Description = "Dumps current Garbage Collector stats to the console."
}, function()
    local current = collectgarbage("count")
    local objects = #getgc()
    local diff = current - _GC_START
    print("--- [GC] ---")
    print(string.format("Baseline Memory: %.2f KB", _GC_START))
    print(string.format("Current Memory: %.2f KB", current))
    print(string.format("Memory Delta: %.2f KB", diff))
    print(string.format("Live Lua Objects: %d", objects))
    print("----------------------------")
    DoNotif(string.format("Memory Usage: %.2f KB", current), 2)
end)
Modules.AntiAim = {
    State = {
        IsEnabled = false,
        Connection = nil,
        CharacterConnection = nil,
        HealthConnection = nil,
        CameraConnection = nil,
        CounterAttachConnection = nil,
        RealVisualizer = nil,
        DesyncVisualizer = nil,
        CurrentPattern = nil,
        PatternStartTime = 0,
        LastHitTime = 0,
        HitCount = 0,
        AdaptiveMode = false,
        OriginalNeckC0 = nil,
        InversionActive = false,
        AttachedPlayers = {},
        CurrentAttachTarget = nil
    },
    Config = {
        VelocityStrength = 9000,
        SnapBack = true,
        Visuals = true,
        StrengthVariation = true,
        MinStrength = 5000,
        MaxStrength = 15000,
        SnapBackMode = "random",
        SnapBackDelay = 0.05,
        MultiPartDesync = false,
        AdaptiveDetection = true,
        JitterEnabled = true,
        JitterStrength = 500,
        InversionEnabled = false,
        InversionOffset = -3.5,
        RandomInversion = false,
        CameraCorrection = true,
        CounterAttachEnabled = false,
        CounterAttachMode = "reverse",
        CounterAttachDistance = 5,
        CounterAttachNotify = true
    }
}
function Modules.AntiAim:_getDynamicStrength()
    if self.Config.StrengthVariation then
        return math.random(self.Config.MinStrength, self.Config.MaxStrength)
    end
    return self.Config.VelocityStrength
end
function Modules.AntiAim:_generateDesyncVector()
    local strength = self:_getDynamicStrength()
    local patterns = {
        function(t)
            return Vector3.new(
                math.cos(t * 10) * strength,
                math.sin(t * 5) * strength,
                math.sin(t * 10) * strength
            )
        end,
        function(t)
            return Vector3.new(
                math.sin(t * 8) * strength,
                math.cos(t * 4) * strength * 0.5,
                math.sin(t * 4) * math.cos(t * 4) * strength
            )
        end,
        function(t)
            local noise = math.noise(t * 20, t * 15, t * 10) or 0.5
            return Vector3.new(
                math.random(-100, 100) * noise,
                math.random(-100, 100) * noise,
                math.random(-100, 100) * noise
            ).Unit * strength
        end,
        function(t)
            local burstIndex = math.floor(t * 30) % 6
            local directions = {
                Vector3.new(1, 0, 0),
                Vector3.new(-1, 0, 0),
                Vector3.new(0, 1, 0),
                Vector3.new(0, -1, 0),
                Vector3.new(0, 0, 1),
                Vector3.new(0, 0, -1)
            }
            return directions[burstIndex + 1] * strength
        end,
        function(t)
            local angle = t * 15
            return Vector3.new(
                math.cos(angle) * strength,
                math.random(-1, 1) * strength * 0.3,
                math.sin(angle) * strength
            )
        end
    }
    if not self.State.CurrentPattern or math.random() < 0.15 then
        self.State.CurrentPattern = patterns[math.random(1, #patterns)]
        self.State.PatternStartTime = tick()
    end
    local baseVector = self.State.CurrentPattern(tick() - self.State.PatternStartTime)
    if self.Config.JitterEnabled then
        local jitter = Vector3.new(
            math.random(-self.Config.JitterStrength, self.Config.JitterStrength),
            math.random(-self.Config.JitterStrength, self.Config.JitterStrength),
            math.random(-self.Config.JitterStrength, self.Config.JitterStrength)
        )
        baseVector = baseVector + jitter
    end
    return baseVector
end
function Modules.AntiAim:_applyPartDesync()
    local character = LocalPlayer.Character
    if not character then return end
    local parts = {
        character:FindFirstChild("Head"),
        character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso"),
        character:FindFirstChild("LeftUpperArm"),
        character:FindFirstChild("RightUpperArm"),
        character:FindFirstChild("LeftLowerArm"),
        character:FindFirstChild("RightLowerArm")
    }
    for i, part in ipairs(parts) do
        if part and part:IsA("BasePart") then
            local offset = Vector3.new(
                math.random(-1, 1),
                math.random(-1, 1),
                math.random(-1, 1)
            ).Unit * (self:_getDynamicStrength() * (i * 0.25))
            part.AssemblyLinearVelocity = self:_generateDesyncVector() + offset
        end
    end
end
function Modules.AntiAim:_detectAttachers()
    local myChar = LocalPlayer.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end
    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local theirRoot = player.Character:FindFirstChild("HumanoidRootPart")
            local theirHumanoid = player.Character:FindFirstChildOfClass("Humanoid")
            if theirRoot and theirHumanoid and theirHumanoid.Health > 0 then
                local distance = (myRoot.Position - theirRoot.Position).Magnitude
                if distance < 8 and distance > 0.1 then
                    local relativeVel = (theirRoot.AssemblyLinearVelocity - myRoot.AssemblyLinearVelocity).Magnitude
                    if relativeVel < 50 then
                        if not self.State.AttachedPlayers[player.UserId] then
                            self.State.AttachedPlayers[player.UserId] = {
                                Player = player,
                                DetectedTime = tick(),
                                Confirmed = false
                            }
                        else
                            if tick() - self.State.AttachedPlayers[player.UserId].DetectedTime > 0.5 then
                                self.State.AttachedPlayers[player.UserId].Confirmed = true
                                if self.Config.CounterAttachNotify and not self.State.CurrentAttachTarget then
                                    DoNotif("ðŸŽ¯ ATTACHER DETECTED: " .. player.Name, 2)
                                end
                                self.State.CurrentAttachTarget = player
                            end
                        end
                    else
                        self.State.AttachedPlayers[player.UserId] = nil
                    end
                else
                    self.State.AttachedPlayers[player.UserId] = nil
                    if self.State.CurrentAttachTarget == player then
                        self.State.CurrentAttachTarget = nil
                    end
                end
            end
        end
    end
end
function Modules.AntiAim:_applyCounterAttach()
    if not self.State.CurrentAttachTarget then return end
    local target = self.State.CurrentAttachTarget
    if not target.Character then
        self.State.CurrentAttachTarget = nil
        return
    end
    local targetRoot = target.Character:FindFirstChild("HumanoidRootPart")
    local myChar = LocalPlayer.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not targetRoot or not myRoot then
        self.State.CurrentAttachTarget = nil
        return
    end
    local mode = self.Config.CounterAttachMode
    local distance = self.Config.CounterAttachDistance
    if mode == "reverse" then
        local offset = Vector3.new(0, 2, distance)
        myRoot.CFrame = targetRoot.CFrame * CFrame.new(offset)
        myRoot.AssemblyLinearVelocity = targetRoot.AssemblyLinearVelocity
    elseif mode == "orbit" then
        local angle = tick() * 5
        local offset = Vector3.new(
            math.cos(angle) * distance,
            2,
            math.sin(angle) * distance
        )
        myRoot.CFrame = targetRoot.CFrame * CFrame.new(offset)
        myRoot.AssemblyLinearVelocity = Vector3.zero
    elseif mode == "spinattack" then
        local angle = tick() * 10
        local offset = Vector3.new(
            math.cos(angle) * 3,
            math.sin(angle * 2) * 2,
            math.sin(angle) * 3
        )
        myRoot.CFrame = targetRoot.CFrame * CFrame.new(offset)
        myRoot.AssemblyLinearVelocity = Vector3.new(
            math.random(-100, 100),
            math.random(-100, 100),
            math.random(-100, 100)
        )
    end
end
function Modules.AntiAim:_setupCounterAttach()
    if self.State.CounterAttachConnection then
        self.State.CounterAttachConnection:Disconnect()
        self.State.CounterAttachConnection = nil
    end
    if not self.Config.CounterAttachEnabled then return end
    self.State.CounterAttachConnection = RunService.Heartbeat:Connect(function()
        if not self.State.IsEnabled then return end
        self:_detectAttachers()
        if self.State.CurrentAttachTarget then
            self:_applyCounterAttach()
        end
    end)
end
function Modules.AntiAim:_setupCameraCorrection()
    if self.State.CameraConnection then
        self.State.CameraConnection:Disconnect()
        self.State.CameraConnection = nil
    end
    if not self.Config.CameraCorrection then return end
    self.State.CameraConnection = RunService.RenderStepped:Connect(function()
        if not self.State.IsEnabled or not self.Config.InversionEnabled then return end
        local camera = workspace.CurrentCamera
        local character = LocalPlayer.Character
        local humanoid = character and character:FindFirstChildOfClass("Humanoid")
        if not camera or not humanoid then return end
        if self.State.InversionActive then
            local currentCF = camera.CFrame
            local pos = currentCF.Position
            local lookVector = currentCF.LookVector
            local upVector = Vector3.new(0, 1, 0)
            local rightVector = lookVector:Cross(upVector).Unit
            upVector = rightVector:Cross(lookVector).Unit
            camera.CFrame = CFrame.fromMatrix(pos, rightVector, upVector, -lookVector)
        end
    end)
end
function Modules.AntiAim:_applyInversion()
    local character = LocalPlayer.Character
    if not character then return end
    local root = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not root or not humanoid then return end
    if self.Config.RandomInversion and math.random() < 0.05 then
        self.State.InversionActive = not self.State.InversionActive
    end
    if self.State.InversionActive then
        local currentCF = root.CFrame
        local invertedCF = currentCF * CFrame.Angles(math.pi, 0, 0)
        invertedCF = invertedCF + Vector3.new(0, self.Config.InversionOffset, 0)
        root.CFrame = invertedCF
        if humanoid.Sit then
            humanoid.Sit = false
        end
    end
end
function Modules.AntiAim:_setupAdaptiveDetection()
    if not self.Config.AdaptiveDetection then return end
    local character = LocalPlayer.Character
    local humanoid = character and character:FindFirstChildOfClass("Humanoid")
    if humanoid and not self.State.HealthConnection then
        self.State.HealthConnection = humanoid.HealthChanged:Connect(function(health)
            if not self.State.IsEnabled then return end
            local now = tick()
            if now - self.State.LastHitTime < 2 then
                self.State.HitCount += 1
                if self.State.HitCount >= 3 and not self.State.AdaptiveMode then
                    self.State.AdaptiveMode = true
                    local oldStrength = self.Config.VelocityStrength
                    self.Config.VelocityStrength = math.min(oldStrength * 2.5, 25000)
                    if self.Config.InversionEnabled and not self.State.InversionActive then
                        self.State.InversionActive = true
                    end
                    DoNotif("âš ï¸ TRACKING DETECTED - ADAPTIVE AA ENGAGED", 2)
                    task.delay(5, function()
                        if self.State.IsEnabled then
                            self.State.AdaptiveMode = false
                            self.Config.VelocityStrength = oldStrength
                            self.State.HitCount = 0
                            DoNotif("Adaptive AA: [RESET]", 1.5)
                        end
                    end)
                end
            else
                self.State.HitCount = 1
            end
            self.State.LastHitTime = now
        end)
    end
end
function Modules.AntiAim:_updateVisualizer()
    local character = LocalPlayer.Character
    local root = character and character:FindFirstChild("HumanoidRootPart")
    if self.State.IsEnabled and self.Config.Visuals and root then
        if not self.State.RealVisualizer then
            local sb = Instance.new("SelectionBox")
            sb.Name = "AA_Real_Visualizer"
            sb.Color3 = Color3.fromRGB(0, 255, 0)
            sb.LineThickness = 0.05
            sb.Adornee = root
            sb.Parent = root
            self.State.RealVisualizer = sb
        else
            self.State.RealVisualizer.Adornee = root
            self.State.RealVisualizer.Parent = root
        end
        if not self.State.DesyncVisualizer then
            local ghost = Instance.new("Part")
            ghost.Name = "AA_Desync_Ghost"
            ghost.CanCollide = false
            ghost.CanTouch = false
            ghost.CanQuery = false
            ghost.Anchored = true
            ghost.Size = root.Size
            ghost.Color = Color3.fromRGB(255, 0, 0)
            ghost.Material = Enum.Material.Neon
            ghost.Transparency = 0.6
            ghost.Parent = workspace.Terrain
            local outline = Instance.new("SelectionBox")
            outline.Color3 = Color3.fromRGB(255, 255, 255)
            outline.LineThickness = 0.03
            outline.Adornee = ghost
            outline.Parent = ghost
            self.State.DesyncVisualizer = ghost
        end
    else
        if self.State.RealVisualizer then
            self.State.RealVisualizer:Destroy()
            self.State.RealVisualizer = nil
        end
        if self.State.DesyncVisualizer then
            self.State.DesyncVisualizer:Destroy()
            self.State.DesyncVisualizer = nil
        end
    end
end
function Modules.AntiAim:_onHeartbeat()
    local character = LocalPlayer.Character
    local root = character and character:FindFirstChild("HumanoidRootPart")
    if not root or not self.State.IsEnabled then return end
    if self.Config.CounterAttachEnabled and self.State.CurrentAttachTarget then
        return
    end
    local oldCFrame = root.CFrame
    local oldVelocity = root.AssemblyLinearVelocity
    if self.Config.InversionEnabled then
        self:_applyInversion()
        oldCFrame = root.CFrame
    end
    if self.Config.MultiPartDesync then
        self:_applyPartDesync()
    else
        root.AssemblyLinearVelocity = self:_generateDesyncVector()
    end
    local snapMode = self.Config.SnapBackMode
    if snapMode == "random" then
        local modes = {"instant", "delayed", "partial"}
        snapMode = modes[math.random(1, #modes)]
    end
    if snapMode == "instant" then
        RunService.RenderStepped:Wait()
        if root and root.Parent and self.State.IsEnabled then
            if self.Config.Visuals and self.State.DesyncVisualizer then
                self.State.DesyncVisualizer.CFrame = root.CFrame
            end
            if self.Config.SnapBack then
                root.CFrame = oldCFrame
            end
            root.AssemblyLinearVelocity = oldVelocity
        end
    elseif snapMode == "delayed" then
        RunService.RenderStepped:Wait()
        local desyncedCFrame = root.CFrame
        task.wait(self.Config.SnapBackDelay)
        if root and root.Parent and self.State.IsEnabled then
            if self.Config.Visuals and self.State.DesyncVisualizer then
                self.State.DesyncVisualizer.CFrame = desyncedCFrame
            end
            if self.Config.SnapBack then
                root.CFrame = oldCFrame
            end
            root.AssemblyLinearVelocity = oldVelocity
        end
    elseif snapMode == "partial" then
        RunService.RenderStepped:Wait()
        if root and root.Parent and self.State.IsEnabled then
            local desyncedCFrame = root.CFrame
            if self.Config.Visuals and self.State.DesyncVisualizer then
                self.State.DesyncVisualizer.CFrame = desyncedCFrame
            end
            if self.Config.SnapBack then
                root.CFrame = oldCFrame:Lerp(desyncedCFrame, 0.3)
            end
            root.AssemblyLinearVelocity = oldVelocity
        end
    end
end
function Modules.AntiAim:Enable()
    if self.State.IsEnabled then return end
    self:Disable(true)
    self.State.IsEnabled = true
    self.State.Connection = RunService.Heartbeat:Connect(function()
        self:_onHeartbeat()
    end)
    self.State.CharacterConnection = LocalPlayer.CharacterAdded:Connect(function()
        task.wait(1)
        if self.State.IsEnabled then
            self:_updateVisualizer()
            self:_setupAdaptiveDetection()
            self:_setupCameraCorrection()
            self:_setupCounterAttach()
            self.State.OriginalNeckC0 = nil
        end
    end)
    self:_updateVisualizer()
    self:_setupAdaptiveDetection()
    self:_setupCameraCorrection()
    self:_setupCounterAttach()
    local mode = self.Config.SnapBackMode == "random" and "RANDOM" or self.Config.SnapBackMode:upper()
    local invStatus = self.Config.InversionEnabled and " | INVERTED" or ""
    local caStatus = self.Config.CounterAttachEnabled and " | CA" or ""
    DoNotif("Anti-Aim: [ENABLED] | Mode: " .. mode .. invStatus .. caStatus, 2)
end
function Modules.AntiAim:Disable(silent)
    self.State.IsEnabled = false
    if self.State.Connection then
        self.State.Connection:Disconnect()
        self.State.Connection = nil
    end
    if self.State.CharacterConnection then
        self.State.CharacterConnection:Disconnect()
        self.State.CharacterConnection = nil
    end
    if self.State.HealthConnection then
        self.State.HealthConnection:Disconnect()
        self.State.HealthConnection = nil
    end
    if self.State.CameraConnection then
        self.State.CameraConnection:Disconnect()
        self.State.CameraConnection = nil
    end
    if self.State.CounterAttachConnection then
        self.State.CounterAttachConnection:Disconnect()
        self.State.CounterAttachConnection = nil
    end
    workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
    self.State.InversionActive = false
    self.State.OriginalNeckC0 = nil
    self.State.AttachedPlayers = {}
    self.State.CurrentAttachTarget = nil
    self:_updateVisualizer()
    if not silent then
        DoNotif("Anti-Aim: [DISABLED]", 2)
    end
end
function Modules.AntiAim:Toggle()
    if self.State.IsEnabled then
        self:Disable()
    else
        self:Enable()
    end
end
function Modules.AntiAim:Initialize()
    local module = self
    RegisterCommand({
        Name = "antiaim",
        Aliases = {"aa"},
        Description = "Toggles velocity-based Anti-Aim."
    }, function(args)
        local strength = tonumber(args[1])
        if strength then
            module.Config.VelocityStrength = strength
            DoNotif("Anti-Aim Strength: " .. strength, 2)
        end
        module:Toggle()
    end)
    RegisterCommand({
        Name = "aasnap",
        Aliases = {"snapback"},
        Description = "Toggles CFrame snapback."
    }, function()
        module.Config.SnapBack = not module.Config.SnapBack
        DoNotif("Snapback: " .. (module.Config.SnapBack and "ON" or "OFF"), 2)
    end)
    RegisterCommand({
        Name = "aavis",
        Description = "Toggles Anti-Aim Hitbox Visuals."
    }, function()
        module.Config.Visuals = not module.Config.Visuals
        module:_updateVisualizer()
        DoNotif("AA Visuals: " .. (module.Config.Visuals and "ON" or "OFF"), 2)
    end)
    RegisterCommand({
        Name = "aamode",
        Description = "Sets snapback mode: instant, delayed, partial, random"
    }, function(args)
        local modes = {instant = true, delayed = true, partial = true, random = true}
        local mode = string.lower(args[1] or "")
        if modes[mode] then
            module.Config.SnapBackMode = mode
            DoNotif("AA Mode: " .. mode:upper(), 2)
        else
            DoNotif("Valid modes: instant, delayed, partial, random", 2)
        end
    end)
    RegisterCommand({
        Name = "aavary",
        Aliases = {"aavariation"},
        Description = "Toggles strength variation"
    }, function()
        module.Config.StrengthVariation = not module.Config.StrengthVariation
        DoNotif("Strength Variation: " .. (module.Config.StrengthVariation and "ON" or "OFF"), 2)
    end)
    RegisterCommand({
        Name = "aamulti",
        Description = "Toggles multi-part desync"
    }, function()
        module.Config.MultiPartDesync = not module.Config.MultiPartDesync
        DoNotif("Multi-Part Desync: " .. (module.Config.MultiPartDesync and "ON" or "OFF"), 2)
    end)
    RegisterCommand({
        Name = "aajitter",
        Description = "Toggles micro-jitter"
    }, function()
        module.Config.JitterEnabled = not module.Config.JitterEnabled
        DoNotif("Jitter: " .. (module.Config.JitterEnabled and "ON" or "OFF"), 2)
    end)
    RegisterCommand({
        Name = "aaadaptive",
        Description = "Toggles adaptive tracking detection"
    }, function()
        module.Config.AdaptiveDetection = not module.Config.AdaptiveDetection
        DoNotif("Adaptive Detection: " .. (module.Config.AdaptiveDetection and "ON" or "OFF"), 2)
    end)
    RegisterCommand({
        Name = "aainvert",
        Aliases = {"aaflip"},
        Description = "Toggles character inversion (upside down)"
    }, function()
        module.Config.InversionEnabled = not module.Config.InversionEnabled
        if module.Config.InversionEnabled then
            module.State.InversionActive = true
            module:_setupCameraCorrection()
        else
            module.State.InversionActive = false
        end
        DoNotif("Inversion: " .. (module.Config.InversionEnabled and "ON ðŸ™ƒ" or "OFF"), 2)
    end)
    RegisterCommand({
        Name = "aaoffset",
        Description = "Sets inversion ground offset (negative = lower)"
    }, function(args)
        local offset = tonumber(args[1])
        if offset then
            module.Config.InversionOffset = offset
            DoNotif("Inversion Offset: " .. offset, 2)
        else
            DoNotif("Current Offset: " .. module.Config.InversionOffset, 2)
        end
    end)
    RegisterCommand({
        Name = "aarandom",
        Description = "Toggles random inversion flipping"
    }, function()
        module.Config.RandomInversion = not module.Config.RandomInversion
        DoNotif("Random Inversion: " .. (module.Config.RandomInversion and "ON" or "OFF"), 2)
    end)
    RegisterCommand({
        Name = "aacamera",
        Description = "Toggles camera correction for inversion"
    }, function()
        module.Config.CameraCorrection = not module.Config.CameraCorrection
        if module.Config.CameraCorrection then
            module:_setupCameraCorrection()
        else
            if module.State.CameraConnection then
                module.State.CameraConnection:Disconnect()
                module.State.CameraConnection = nil
            end
        end
        DoNotif("Camera Correction: " .. (module.Config.CameraCorrection and "ON" or "OFF"), 2)
    end)
    RegisterCommand({
        Name = "aacounter",
        Aliases = {"aaca"},
        Description = "Toggles counter-attach system"
    }, function()
        module.Config.CounterAttachEnabled = not module.Config.CounterAttachEnabled
        if module.Config.CounterAttachEnabled then
            module:_setupCounterAttach()
        else
            if module.State.CounterAttachConnection then
                module.State.CounterAttachConnection:Disconnect()
                module.State.CounterAttachConnection = nil
            end
            module.State.AttachedPlayers = {}
            module.State.CurrentAttachTarget = nil
        end
        DoNotif("Counter-Attach: " .. (module.Config.CounterAttachEnabled and "ON ðŸŽ¯" or "OFF"), 2)
    end)
    RegisterCommand({
        Name = "aacamode",
        Description = "Sets counter-attach mode: reverse, orbit, spinattack"
    }, function(args)
        local modes = {reverse = true, orbit = true, spinattack = true}
        local mode = string.lower(args[1] or "")
        if modes[mode] then
            module.Config.CounterAttachMode = mode
            DoNotif("Counter-Attach Mode: " .. mode:upper(), 2)
        else
            DoNotif("Valid modes: reverse, orbit, spinattack", 2)
        end
    end)
    RegisterCommand({
        Name = "aacadist",
        Description = "Sets counter-attach distance"
    }, function(args)
        local dist = tonumber(args[1])
        if dist then
            module.Config.CounterAttachDistance = dist
            DoNotif("Counter-Attach Distance: " .. dist, 2)
        else
            DoNotif("Current Distance: " .. module.Config.CounterAttachDistance, 2)
        end
    end)
    RegisterCommand({
        Name = "aacatarget",
        Description = "Shows current counter-attach target"
    }, function()
        if module.State.CurrentAttachTarget then
            DoNotif("Current Target: " .. module.State.CurrentAttachTarget.Name, 2)
        else
            DoNotif("No active counter-attach target", 2)
        end
    end)
    RegisterCommand({
        Name = "aaconfig",
        Aliases = {"aastatus"},
        Description = "Shows current AA configuration"
    }, function()
        local config = string.format(
            "AA CONFIG:\nStrength: %d\nMode: %s\nVariation: %s\nMulti-Part: %s\nJitter: %s\nAdaptive: %s\nInversion: %s\nCamera Fix: %s\nCounter-Attach: %s (%s)",
            module.Config.VelocityStrength,
            module.Config.SnapBackMode:upper(),
            module.Config.StrengthVariation and "ON" or "OFF",
            module.Config.MultiPartDesync and "ON" or "OFF",
            module.Config.JitterEnabled and "ON" or "OFF",
            module.Config.AdaptiveDetection and "ON" or "OFF",
            module.Config.InversionEnabled and "ON" or "OFF",
            module.Config.CameraCorrection and "ON" or "OFF",
            module.Config.CounterAttachEnabled and "ON" or "OFF",
            module.Config.CounterAttachMode:upper()
        )
        DoNotif(config, 6)
    end)
end
Modules.Overseer = {
    State = {
        IsEnabled = false,
        ActivePatches = {},
        SelectedModule = nil,
        CurrentTable = nil,
        PathStack = {},
        Minimized = false,
        ViewingCode = false,
        CurrentMode = "modules",
        ExplorerPath = {},
        ExplorerInstance = nil,
        UI = nil,
        SidebarButtons = {},
        ValueHooks = {},
        HookedConnections = {},
        PropertyHooks = {},
        RemoteSpyData = {},
        CallFrequency = {},
        CurrentTypeFilter = nil,
        FilteredResults = {},
        SpyCallLog = {},
        IsSpying = false,
        SelectedRemote = nil,
        DisabledModules = {}
    },
    Config = {
        ACCENT_COLOR = Color3.fromRGB(0, 255, 170),
        BG_COLOR = Color3.fromRGB(10, 10, 12),
        HEADER_COLOR = Color3.fromRGB(15, 15, 18),
        SECONDARY_COLOR = Color3.fromRGB(18, 18, 22),
        HOOK_COLOR = Color3.fromRGB(0, 200, 150),
        DANGER_COLOR = Color3.fromRGB(200, 50, 50),
        BUTTON_HEIGHT = 24,
        ROW_HEIGHT = 35,
        FILTER_HEIGHT = 40,
        PADDING = 4,
        CORNER_RADIUS = 2,
        CODE_BUTTON_HEIGHT = 30
    },
    RemoteSpy = {
        MaxLogSize = 500,
        RecordingTypes = { "FireServer", "FireClient", "InvokeServer" }
    }
}
function Modules.Overseer:_applyStyle(obj, radius)
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, radius or 4)
    corner.Parent = obj
end
function Modules.Overseer:_setClipboard(txt)
    if setclipboard then setclipboard(txt) end
end
function Modules.Overseer:_showErrorInGrid(errorText)
    local ui = self.State.UI
    if not ui or not ui.Grid then return end
    for _, v in ipairs(ui.Grid:GetChildren()) do
        if not v:IsA("UIListLayout") then v:Destroy() end
    end
    local errorLabel = Instance.new("TextLabel", ui.Grid)
    errorLabel.Size = UDim2.new(1, 0, 0, 40)
    errorLabel.Text = errorText
    errorLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
    errorLabel.BackgroundColor3 = Color3.fromRGB(40, 20, 20)
    errorLabel.BackgroundTransparency = 0.3
    errorLabel.Font = Enum.Font.Code
    errorLabel.TextSize = 10
    errorLabel.TextWrapped = true
    self:_applyStyle(errorLabel, 2)
end
function Modules.Overseer:_cleanupModuleHooks(mod)
    if self.State.ActivePatches[mod] then
        self.State.ActivePatches[mod] = nil
    end
    for hookKey, hook in pairs(self.State.ValueHooks) do
        if hook.table == mod then
            self.State.ValueHooks[hookKey] = nil
        end
    end
    for propKey, hook in pairs(self.State.PropertyHooks) do
        if hook.instance and hook.instance:IsDescendantOf(mod) then
            if self.State.HookedConnections[propKey] then
                pcall(function() self.State.HookedConnections[propKey]:Disconnect() end)
                self.State.HookedConnections[propKey] = nil
            end
            self.State.PropertyHooks[propKey] = nil
        end
    end
end
function Modules.Overseer:_validatePatches()
    for tbl, keys in pairs(self.State.ActivePatches) do
        if type(tbl) ~= "table" then
            return false
        end
        for key, data in pairs(keys) do
            if data.Value == nil then
                return false
            end
        end
    end
    return true
end
function Modules.Overseer:_validateHooks()
    for hookKey, hook in pairs(self.State.ValueHooks) do
        if hook.enabled and hook.value == nil then
            return false
        end
    end
    for propKey, hook in pairs(self.State.PropertyHooks) do
        if hook.enabled and hook.value == nil then
            return false
        end
    end
    return true
end
function Modules.Overseer:_generateObfuscatedName()
    local charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    local length = math.random(10, 20)
    local result = ""
    for i = 1, length do
        local rand = math.random(1, #charset)
        result = result .. charset:sub(rand, rand)
    end
    return result
end
function Modules.Overseer:_applyEnvironment(func, scriptInstance)
    local fenv = {}
    local realFenv = {script = scriptInstance}
    local fenvMt = {}
    fenvMt.__index = function(_, key)
        return realFenv[key] or getfenv()[key]
    end
    fenvMt.__newindex = function(_, key, value)
        if realFenv[key] == nil then
            getfenv()[key] = value
        else
            realFenv[key] = value
        end
    end
    setmetatable(fenv, fenvMt)
    setfenv(func, fenv)
    return func
end
function Modules.Overseer:_createButton(parent, text, size, position, bgColor, callback)
    local btn = Instance.new("TextButton", parent)
    btn.Size = size
    btn.Position = position
    btn.BackgroundColor3 = bgColor or self.Config.HOOK_COLOR
    btn.Text = text
    btn.TextColor3 = Color3.new(1, 1, 1)
    btn.Font = Enum.Font.Code
    btn.TextSize = 9
    self:_applyStyle(btn, self.Config.CORNER_RADIUS)
    if callback then
        btn.MouseButton1Click:Connect(callback)
    end
    return btn
end
function Modules.Overseer:_createLabel(parent, text, size, position, textColor, bgColor)
    local lbl = Instance.new("TextLabel", parent)
    lbl.Size = size
    lbl.Position = position
    lbl.Text = text
    lbl.TextColor3 = textColor or Color3.fromRGB(150, 150, 150)
    lbl.BackgroundColor3 = bgColor or Color3.new(0, 0, 0)
    lbl.BackgroundTransparency = (bgColor == nil and 1 or 0.3)
    lbl.Font = Enum.Font.Code
    lbl.TextSize = 9
    lbl.TextXAlignment = Enum.TextXAlignment.Left
    lbl.TextYAlignment = Enum.TextYAlignment.Center
    return lbl
end
function Modules.Overseer:_createRow(parent, labelText, labelSize, labelColor)
    local row = Instance.new("Frame", parent)
    row.Size = UDim2.new(1, -10, 0, self.Config.ROW_HEIGHT)
    row.BackgroundTransparency = 1
    local label = Instance.new("TextLabel", row)
    label.Size = labelSize or UDim2.new(0.6, 0, 1, 0)
    label.Text = labelText
    label.TextColor3 = labelColor or Color3.fromRGB(150, 150, 150)
    label.BackgroundTransparency = 1
    label.Font = Enum.Font.Code
    label.TextSize = 9
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.ClipsDescendants = true
    return row, label
end
function Modules.Overseer:_initRemoteSpy()
    if self.State.IsSpying then return end
    self.State.IsSpying = true
    local function hookRemotes(parent)
        for _, child in ipairs(parent:GetDescendants()) do
            if child:IsA("RemoteEvent") then
                pcall(function()
                    if child.FireServer and not child:GetAttribute("_OverseerHooked") then
                        local original = child.FireServer
                        if setreadonly then setreadonly(child, false) end
                        child.FireServer = function(remoteself, ...)
                            local args = {...}
                            local parentName = remoteself.Parent and remoteself.Parent.Name or "Unknown"
                            table.insert(Modules.Overseer.State.SpyCallLog, {
                                Type = "FireServer",
                                Remote = remoteself.Name or "Unknown",
                                Parent = parentName,
                                Args = args,
                                Time = tick()
                            })
                            if #Modules.Overseer.State.SpyCallLog > Modules.Overseer.RemoteSpy.MaxLogSize then
                                table.remove(Modules.Overseer.State.SpyCallLog, 1)
                            end
                            return original(remoteself, ...)
                        end
                        child:SetAttribute("_OverseerHooked", true)
                        if setreadonly then setreadonly(child, true) end
                    end
                end)
            elseif child:IsA("RemoteFunction") then
                pcall(function()
                    if child.InvokeServer and not child:GetAttribute("_OverseerHooked") then
                        local original = child.InvokeServer
                        if setreadonly then setreadonly(child, false) end
                        child.InvokeServer = function(remoteself, ...)
                            local args = {...}
                            local parentName = remoteself.Parent and remoteself.Parent.Name or "Unknown"
                            table.insert(Modules.Overseer.State.SpyCallLog, {
                                Type = "InvokeServer",
                                Remote = remoteself.Name or "Unknown",
                                Parent = parentName,
                                Args = args,
                                Time = tick()
                            })
                            if #Modules.Overseer.State.SpyCallLog > Modules.Overseer.RemoteSpy.MaxLogSize then
                                table.remove(Modules.Overseer.State.SpyCallLog, 1)
                            end
                            return original(remoteself, ...)
                        end
                        child:SetAttribute("_OverseerHooked", true)
                        if setreadonly then setreadonly(child, true) end
                    end
                end)
            end
        end
    end
    hookRemotes(ReplicatedStorage)
    hookRemotes(game)
    local hookConnection; hookConnection = game.DescendantAdded:Connect(function(child)
        if self.State.IsSpying then
            if child:IsA("RemoteEvent") or child:IsA("RemoteFunction") then
                task.wait(0.1)
                pcall(function()
                    if child:IsA("RemoteEvent") and child.FireServer and not child:GetAttribute("_OverseerHooked") then
                        local original = child.FireServer
                        if setreadonly then setreadonly(child, false) end
                        child.FireServer = function(remoteself, ...)
                            local args = {...}
                            local parentName = remoteself.Parent and remoteself.Parent.Name or "Unknown"
                            table.insert(Modules.Overseer.State.SpyCallLog, {
                                Type = "FireServer",
                                Remote = remoteself.Name or "Unknown",
                                Parent = parentName,
                                Args = args,
                                Time = tick()
                            })
                            if #Modules.Overseer.State.SpyCallLog > Modules.Overseer.RemoteSpy.MaxLogSize then
                                table.remove(Modules.Overseer.State.SpyCallLog, 1)
                            end
                            return original(remoteself, ...)
                        end
                        child:SetAttribute("_OverseerHooked", true)
                        if setreadonly then setreadonly(child, true) end
                    elseif child:IsA("RemoteFunction") and child.InvokeServer and not child:GetAttribute("_OverseerHooked") then
                        local original = child.InvokeServer
                        if setreadonly then setreadonly(child, false) end
                        child.InvokeServer = function(remoteself, ...)
                            local args = {...}
                            local parentName = remoteself.Parent and remoteself.Parent.Name or "Unknown"
                            table.insert(Modules.Overseer.State.SpyCallLog, {
                                Type = "InvokeServer",
                                Remote = remoteself.Name or "Unknown",
                                Parent = parentName,
                                Args = args,
                                Time = tick()
                            })
                            if #Modules.Overseer.State.SpyCallLog > Modules.Overseer.RemoteSpy.MaxLogSize then
                                table.remove(Modules.Overseer.State.SpyCallLog, 1)
                            end
                            return original(remoteself, ...)
                        end
                        child:SetAttribute("_OverseerHooked", true)
                        if setreadonly then setreadonly(child, true) end
                    end
                end)
            end
        end
    end)
    table.insert(self.State.HookedConnections, hookConnection)
end
function Modules.Overseer:_showRemoteSpy()
    local ui = self.State.UI
    ui.Grid.Visible = true
    ui.CodeFrame.Visible = false
    ui.Title.Text = "REMOTE SPY - " .. #self.State.SpyCallLog .. " CALLS"
    for _, v in ipairs(ui.Grid:GetChildren()) do
        if not v:IsA("UIListLayout") then v:Destroy() end
    end
    local spyStatusLabel = Instance.new("TextLabel", ui.Grid)
    spyStatusLabel.Size = UDim2.new(1, -10, 0, 30)
    spyStatusLabel.BackgroundColor3 = self.State.IsSpying and Color3.fromRGB(20, 40, 20) or Color3.fromRGB(40, 20, 20)
    spyStatusLabel.Text = "SPY STATUS: " .. (self.State.IsSpying and "ACTIVE" or "INACTIVE")
    spyStatusLabel.TextColor3 = self.State.IsSpying and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(255, 100, 100)
    spyStatusLabel.Font = Enum.Font.Code
    spyStatusLabel.TextSize = 10
    self:_applyStyle(spyStatusLabel, 2)
    if not self.State.IsSpying then
        local startBtn = Instance.new("TextButton", ui.Grid)
        startBtn.Size = UDim2.new(0.9, 0, 0, 35)
        startBtn.BackgroundColor3 = Color3.fromRGB(40, 100, 40)
        startBtn.Text = "START SPYING ON ALL REMOTES"
        startBtn.TextColor3 = Color3.fromRGB(100, 255, 100)
        startBtn.Font = Enum.Font.Code
        startBtn.TextSize = 10
        self:_applyStyle(startBtn, 2)
        startBtn.MouseButton1Click:Connect(function()
            self:_initRemoteSpy()
            self:_showRemoteSpy()
        end)
    end
    if #self.State.SpyCallLog > 0 then
        local logLabel = Instance.new("TextLabel", ui.Grid)
        logLabel.Size = UDim2.new(1, 0, 0, 20)
        logLabel.Text = " CALL HISTORY (Most Recent First)"
        logLabel.TextColor3 = Color3.fromRGB(200, 200, 100)
        logLabel.BackgroundTransparency = 1
        logLabel.Font = Enum.Font.Code
        logLabel.TextSize = 9
        for i = math.min(30, #self.State.SpyCallLog), 1, -1 do
            local call = self.State.SpyCallLog[i]
            if call and call.Remote then
                local row, label = self:_createRow(ui.Grid, "", UDim2.new(0.7, 0, 1, 0))
                local parentName = call.Parent or "Unknown"
                local callText = "[" .. call.Type .. "] " .. call.Remote .. " | Parent: " .. parentName
                label.Text = callText
                label.TextColor3 = (call.Type == "FireServer" and Color3.fromRGB(100, 150, 255) or Color3.fromRGB(150, 100, 255))
                local argsBtn = Instance.new("TextButton", row)
                argsBtn.Size = UDim2.new(0, 60, 0, 24)
                argsBtn.Position = UDim2.fromScale(0.72, 0.15)
                argsBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 100)
                argsBtn.Text = "ARGS (" .. (#call.Args or 0) .. ")"
                argsBtn.TextColor3 = Color3.fromRGB(200, 200, 255)
                argsBtn.Font = Enum.Font.Code
                argsBtn.TextSize = 7
                self:_applyStyle(argsBtn, 2)
                argsBtn.MouseButton1Click:Connect(function()
                    self:_showRemoteArgs(call)
                end)
            end
        end
    end
end
function Modules.Overseer:_showRemoteArgs(callInfo)
    local ui = self.State.UI
    ui.Grid.Visible = false
    ui.CodeFrame.Visible = true
    ui.Title.Text = "REMOTE ARGS: " .. callInfo.Remote
    local argText = "[" .. callInfo.Type .. "] " .. callInfo.Remote .. "\n\n"
    for i, arg in ipairs(callInfo.Args) do
        local argType = type(arg)
        if argType == "table" then
            argText = argText .. "Arg[" .. i .. "]: TABLE\n"
            for k, v in pairs(arg) do
                argText = argText .. "  [" .. tostring(k) .. "] = " .. tostring(v) .. "\n"
            end
        else
            argText = argText .. "Arg[" .. i .. "]: " .. argType:upper() .. " = " .. tostring(arg) .. "\n"
        end
    end
    ui.CodeBox.Text = argText
    ui.CodeBox.TextEditable = false
end
local c_check = clonefunction(checkcaller)
local c_rawset = clonefunction(rawset)
local c_getmt = clonefunction(getrawmetatable)
function Modules.Overseer:_hookValue(tbl, key, value, valueType)
    local hookKey = tostring(tbl) .. ":" .. tostring(key)
    if self.State.ValueHooks[hookKey] then
        self.State.ValueHooks[hookKey].enabled = true
        return
    end
    self.State.ValueHooks[hookKey] = {
        table = tbl,
        key = key,
        value = value,
        type = valueType,
        enabled = true,
        originalMt = getrawmetatable and getrawmetatable(tbl)
    }
    pcall(function()
        if setreadonly then setreadonly(tbl, false) elseif make_writeable then make_writeable(tbl) end
        rawset(tbl, key, value)
        if setreadonly then setreadonly(tbl, true) end
    end)
    if getrawmetatable then
        local mt = getrawmetatable(tbl)
        if mt then
            pcall(function()
                if setreadonly then setreadonly(mt, false) elseif make_writeable then make_writeable(mt) end
                local originalNewindex = rawget(mt, "__newindex")
                rawset(mt, "__newindex", function(t, k, v)
                    if k == key then
                        rawset(tbl, key, value)
                    elseif type(originalNewindex) == "function" then
                        originalNewindex(t, k, v)
                    else
                        rawset(t, k, v)
                    end
                end)
                if setreadonly then setreadonly(mt, true) end
            end)
        end
    end
end
function Modules.Overseer:_unhookValue(tbl, key)
    local hookKey = tostring(tbl) .. ":" .. tostring(key)
    self.State.ValueHooks[hookKey] = nil
end
function Modules.Overseer:_hookProperty(instance, property, value)
    if not instance or not instance:IsA("Instance") then return end
    local propKey = tostring(instance) .. ":" .. property
    self.State.PropertyHooks[propKey] = {
        instance = instance,
        property = property,
        value = value,
        enabled = true
    }
    pcall(function()
        instance[property] = value
    end)
    if self.State.HookedConnections[propKey] then
        pcall(function() self.State.HookedConnections[propKey]:Disconnect() end)
    end
    self.State.HookedConnections[propKey] = RunService.Heartbeat:Connect(function()
        if self.State.PropertyHooks[propKey] and self.State.PropertyHooks[propKey].enabled then
            pcall(function()
                if instance and instance.Parent and instance[property] ~= value then
                    instance[property] = value
                elseif not instance or not instance.Parent then
                    self:_unhookProperty(instance, property)
                end
            end)
        end
    end)
end
function Modules.Overseer:_unhookProperty(instance, property)
    local propKey = tostring(instance) .. ":" .. property
    if self.State.HookedConnections[propKey] then
        self.State.HookedConnections[propKey]:Disconnect()
        self.State.HookedConnections[propKey] = nil
    end
    self.State.PropertyHooks[propKey] = nil
end
function Modules.Overseer:_getPatchStatus()
    local active = 0
    local valueHooks = 0
    local propHooks = 0
    for _, _ in pairs(self.State.ActivePatches) do active = active + 1 end
    for _, hook in pairs(self.State.ValueHooks) do if hook.enabled then valueHooks = valueHooks + 1 end end
    for _, hook in pairs(self.State.PropertyHooks) do if hook.enabled then propHooks = propHooks + 1 end end
    return active, valueHooks, propHooks
end
function Modules.Overseer:_filterTableByType(tbl, typeFilter)
    if not tbl or type(tbl) ~= "table" then return {} end
    local results = {}
    for k, v in pairs(tbl) do
        local vType = type(v)
        if typeFilter == "all" or vType == typeFilter then
            table.insert(results, {key = k, value = v, type = vType})
        end
    end
    return results
end
function Modules.Overseer:_searchInTable(tbl, searchTerm)
    local results = {}
    searchTerm = searchTerm:lower()
    for k, v in pairs(tbl) do
        local keyStr = tostring(k):lower()
        local valStr = tostring(v):lower()
        if keyStr:find(searchTerm) or valStr:find(searchTerm) then
            table.insert(results, {key = k, value = v, type = type(v)})
        end
    end
    return results
end
function Modules.Overseer:_getAllValuesOfType(typeFilter, searchDepth)
    searchDepth = searchDepth or 2
    local results = {}
    local scanned = {}
    local maxResults = 100
    local function scanTable(tbl, depth, path)
        if scanned[tbl] or depth <= 0 or #results >= maxResults then return end
        if type(tbl) ~= "table" then return end
        scanned[tbl] = true
        local success, pairs_result = pcall(function()
            local count = 0
            for k, v in pairs(tbl) do
                if count > 50 then break end
                count = count + 1
                if type(v) == typeFilter then
                    table.insert(results, {
                        path = path .. "." .. tostring(k),
                        key = k,
                        value = v,
                        type = typeFilter,
                        table = tbl
                    })
                elseif type(v) == "table" and depth > 0 and not scanned[v] then
                    local tableSafe, _ = pcall(function() return pairs(v) end)
                    if tableSafe then
                        scanTable(v, depth - 1, path .. "." .. tostring(k))
                    end
                end
                if #results >= maxResults then break end
            end
        end)
        if not success then
            return
        end
    end
    pcall(function()
        if _G then scanTable(_G, searchDepth, "_G") end
    end)
    return results
end
function Modules.Overseer:_applyPatch(tbl, key, val, isFunc)
    if not tbl or type(tbl) ~= "table" then return false end
    if not self.State.ActivePatches[tbl] then
        self.State.ActivePatches[tbl] = {}
    end
    self.State.ActivePatches[tbl][key] = {Value = val, Locked = true, IsFunction = isFunc}
    pcall(function()
        if setreadonly then setreadonly(tbl, false) elseif make_writeable then make_writeable(tbl) end
        if isFunc then
            if val == "TRUE" then
                rawset(tbl, key, function() return true end)
            elseif val == "FALSE" then
                rawset(tbl, key, function() return false end)
            else
                rawset(tbl, key, val)
            end
        else
            rawset(tbl, key, val)
        end
        if setreadonly then setreadonly(tbl, true) end
    end)
    if getrawmetatable then
        pcall(function()
            local mt = getrawmetatable(tbl)
            if mt then
                if setreadonly then setreadonly(mt, false) end
                local oldIndex = rawget(mt, "__index")
                rawset(mt, "__index", function(t, k)
                    if k == key then
                        return val
                    elseif type(oldIndex) == "function" then
                        return oldIndex(t, k)
                    elseif type(oldIndex) == "table" then
                        return oldIndex[k]
                    end
                end)
                if setreadonly then setreadonly(mt, true) end
            end
        end)
    end
    return true
end
function Modules.Overseer:_getUpvalues(func, depth, maxDepth)
    depth = depth or 0
    maxDepth = maxDepth or 5
    if depth > maxDepth then return {} end
    local upvalues = {}
    local success, result = pcall(debug.getupvalues, func)
    if success and result then
        for i, uv in ipairs(result) do
            local uvType = type(uv)
            upvalues[i] = {
                Index = i,
                Value = uv,
                Type = uvType,
                IsFunction = uvType == "function",
                IsTable = uvType == "table",
                ChildUpvalues = uvType == "function" and self:_getUpvalues(uv, depth + 1, maxDepth) or {}
            }
        end
    end
    return upvalues
end
function Modules.Overseer:_patchEnvironment(func, varName, varValue)
    if type(func) ~= "function" then return false end
    return pcall(function()
        local env = getfenv(func)
        if not env then env = {} end
        if setreadonly then setreadonly(env, false) end
        env[varName] = varValue
        if setreadonly then setreadonly(env, true) end
        setfenv(func, env)
    end)
end
function Modules.Overseer:_batchPatch(tbl, patches)
    if type(patches) ~= "table" then return 0 end
    local count = 0
    for key, value in pairs(patches) do
        if self:_applyPatch(tbl, key, value, false) then
            count = count + 1
        end
    end
    return count
end
function Modules.Overseer:_clearPatches(tbl)
    if not tbl or type(tbl) ~= "table" then return false end
    pcall(function()
        if setreadonly then setreadonly(tbl, false) end
        if self.State.ActivePatches[tbl] then
            for key, _ in pairs(self.State.ActivePatches[tbl]) do
                if not key:find("^__") then
                    pcall(function() rawset(tbl, key, nil) end)
                end
            end
        end
        if setreadonly then setreadonly(tbl, true) end
    end)
    self.State.ActivePatches[tbl] = nil
    return true
end
function Modules.Overseer:_scanMetatable(tbl)
    if not getrawmetatable then return nil end
    local mt = c_getmt(tbl)
    if not mt then return nil end
    if setreadonly then setreadonly(mt, false) elseif make_writeable then make_writeable(mt) end
    local metamethods = {}
    for k, v in pairs(mt) do
        if type(v) == "function" then
            metamethods[k] = {
                Value = v,
                Type = "function",
                Upvalues = self:_getUpvalues(v),
                OriginalUpvalues = self:_getUpvalues(v)
            }
        else
            metamethods[k] = {Value = v, Type = type(v)}
        end
    end
    return {
        Metatable = mt,
        Methods = metamethods
    }
end
function Modules.Overseer:_patchMetamethod(tbl, metamethod, newFunc)
    if not getrawmetatable then return false end
    if not tbl or type(tbl) ~= "table" then return false end
    return pcall(function()
        local mt = getrawmetatable(tbl)
        if not mt then
            mt = {}
            setmetatable(tbl, mt)
        end
        if setreadonly then setreadonly(mt, false) end
        rawset(mt, metamethod, newFunc)
        if setreadonly then setreadonly(mt, true) end
        if not self.State.ActivePatches[tbl] then
            self.State.ActivePatches[tbl] = {}
        end
        self.State.ActivePatches[tbl][metamethod] = {
            Value = newFunc,
            Locked = true,
            IsFunction = true,
            IsMetamethod = true
        }
    end)
end
function Modules.Overseer:_createUpvalueRow(uvIndex, uvData, parentFunc, ui)
    local row = Instance.new("Frame", ui.Grid)
    row.Size = UDim2.new(1, -10, 0, 35)
    row.BackgroundTransparency = 1
    local label = Instance.new("TextLabel", row)
    label.Size = UDim2.new(0.4, 0, 1, 0)
    label.Text = "  [" .. uvIndex .. "] " .. uvData.Type
    label.TextColor3 = Color3.fromRGB(100, 200, 255)
    label.Font = Enum.Font.Code
    label.TextSize = 9
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.BackgroundTransparency = 1
    label.ClipsDescendants = true
    if uvData.IsTable then
        local diveBtn = Instance.new("TextButton", row)
        diveBtn.Size = UDim2.new(0, 100, 0, 24)
        diveBtn.Position = UDim2.fromScale(0.42, 0.15)
        diveBtn.BackgroundColor3 = Color3.fromRGB(30, 60, 80)
        diveBtn.Text = "DIVE UV >"
        diveBtn.TextColor3 = Color3.fromRGB(0, 200, 255)
        diveBtn.Font = Enum.Font.Code
        diveBtn.TextSize = 8
        self:_applyStyle(diveBtn, 2)
        diveBtn.MouseButton1Click:Connect(function()
            table.insert(self.State.PathStack, self.State.CurrentTable)
            self.State.CurrentTable = uvData.Value
            self:PopulateGrid(uvData.Value, "[UV:" .. uvIndex .. "]")
        end)
    elseif uvData.IsFunction then
        local uvBtn = Instance.new("TextButton", row)
        uvBtn.Size = UDim2.new(0, 80, 0, 24)
        uvBtn.Position = UDim2.fromScale(0.42, 0.15)
        uvBtn.BackgroundColor3 = Color3.fromRGB(60, 40, 100)
        uvBtn.Text = "UVALS"
        uvBtn.TextColor3 = Color3.fromRGB(150, 100, 255)
        uvBtn.Font = Enum.Font.Code
        uvBtn.TextSize = 8
        self:_applyStyle(uvBtn, 2)
        uvBtn.MouseButton1Click:Connect(function()
            self:_showUpvaluesUI(uvData.Value, "[UV:" .. uvIndex .. "] Function")
        end)
        local viewBtn = Instance.new("TextButton", row)
        viewBtn.Size = UDim2.new(0, 60, 0, 24)
        viewBtn.Position = UDim2.fromScale(0.55, 0.15)
        viewBtn.BackgroundColor3 = Color3.fromRGB(60, 40, 60)
        viewBtn.Text = "VIEW"
        viewBtn.TextColor3 = Color3.fromRGB(255, 100, 255)
        viewBtn.Font = Enum.Font.Code
        viewBtn.TextSize = 8
        self:_applyStyle(viewBtn, 2)
        viewBtn.MouseButton1Click:Connect(function() self:_showSource(uvData.Value) end)
    else
        local box = Instance.new("TextBox", row)
        box.Size = UDim2.new(0, 100, 0, 24)
        box.Position = UDim2.fromScale(0.42, 0.15)
        box.BackgroundColor3 = Color3.fromRGB(10, 10, 12)
        box.Text = tostring(uvData.Value)
        box.TextColor3 = Color3.fromRGB(100, 200, 255)
        box.Font = Enum.Font.Code
        box.TextSize = 9
        self:_applyStyle(box, 2)
        box.FocusLost:Connect(function(enter)
            if enter and parentFunc then
                local newVal = tonumber(box.Text) or box.Text
                self:_patchUpvalue(parentFunc, uvIndex, newVal)
                box.Text = tostring(newVal)
            end
        end)
    end
end
function Modules.Overseer:_showUpvaluesUI(func, funcName)
    local ui = self.State.UI
    self.State.ViewingCode = true
    ui.Grid.Visible = false
    ui.CodeFrame.Visible = true
    ui.Title.Text = "UPVALUES: " .. funcName
    ui.CodeBox.Text = "-- Scanning upvalues..."
    task.spawn(function()
        for _, v in ipairs(ui.Grid:GetChildren()) do
            if not v:IsA("UIListLayout") then v:Destroy() end
        end
        ui.CodeFrame.Visible = false
        ui.Grid.Visible = true
        local upvalues = self:_getUpvalues(func)
        if #upvalues == 0 then
            local noUvLabel = Instance.new("TextLabel", ui.Grid)
            noUvLabel.Size = UDim2.new(1, 0, 0, 20)
            noUvLabel.Text = "  -- NO UPVALUES FOUND -- "
            noUvLabel.TextColor3 = Color3.fromRGB(200, 100, 100)
            noUvLabel.BackgroundTransparency = 1
            noUvLabel.Font = Enum.Font.Code
            noUvLabel.TextSize = 9
        else
            for _, uvData in ipairs(upvalues) do
                self:_createUpvalueRow(uvData.Index, uvData, func, ui)
                if uvData.IsFunction and #uvData.ChildUpvalues > 0 then
                    for _, childUv in ipairs(uvData.ChildUpvalues) do
                        local childRow = Instance.new("Frame", ui.Grid)
                        childRow.Size = UDim2.new(1, -30, 0, 35)
                        childRow.BackgroundTransparency = 1
                        childRow.Position = UDim2.new(0, 20, 0, 0)
                        local childLabel = Instance.new("TextLabel", childRow)
                        childLabel.Size = UDim2.new(1, 0, 1, 0)
                        childLabel.Text = "    â””â”€[" .. childUv.Index .. "] " .. childUv.Type
                        childLabel.TextColor3 = Color3.fromRGB(150, 150, 100)
                        childLabel.Font = Enum.Font.Code
                        childLabel.TextSize = 8
                        childLabel.TextXAlignment = Enum.TextXAlignment.Left
                        childLabel.BackgroundTransparency = 1
                    end
                end
            end
        end
    end)
end
function Modules.Overseer:_showSource(target)
    if not target or not self.State.UI then return end
    local decompiler = (decompile or decompile_script)
    local ui = self.State.UI
    self.State.ViewingCode = true
    ui.Grid.Visible = false
    ui.CodeFrame.Visible = true
    ui.CodeFrame.Name = "ViewMode"
    local targetName = "Closure"
    if type(target) == "table" and target.Name then
        targetName = target.Name
    elseif type(target) == "function" then
        targetName = "Function"
    end
    ui.Title.Text = "DECOMPILING: " .. targetName
    ui.CodeBox.Text = "-- Generating Source, please wait..."
    task.spawn(function()
        local success, src
        if decompiler then
            success, src = pcall(decompiler, target)
        else
            success, src = false, "-- [ERROR] Decompiler not available (decompile/decompile_script required)"
        end
        if self.State.UI and self.State.UI.CodeBox then
            ui.CodeBox.Text = success and src or "-- [FAILURE] Decompilation error: " .. tostring(src)
        end
    end)
end
function Modules.Overseer:_showEditUI(target, targetName)
    if not target or not self.State.UI then return end
    local decompiler = (decompile or decompile_script)
    local ui = self.State.UI
    self.State.ViewingCode = true
    ui.Grid.Visible = false
    ui.CodeFrame.Visible = true
    ui.CodeFrame.Name = "EditMode"
    ui.Title.Text = "EDIT: " .. targetName
    ui.CodeBox.Text = "-- Loading source..."
    ui.CodeBox.TextEditable = true
    ui.CodeBox.ClearTextOnFocus = false
    task.spawn(function()
        local success, src
        if decompiler then
            success, src = pcall(decompiler, target)
        else
            success, src = false, "-- [ERROR] Decompiler not available (decompile/decompile_script required)\n-- Module source editing not supported"
        end
        if self.State.UI and self.State.UI.CodeBox then
            ui.CodeBox.Text = success and src or "-- [ERROR] Failed to decompile source\n" .. tostring(src)
        end
    end)
end
function Modules.Overseer:_createTableRow(k, v, src)
    local ui = self.State.UI
    local row = Instance.new("Frame", ui.Grid)
    row.Size = UDim2.new(1, -10, 0, 35)
    row.BackgroundTransparency = 1
    local label = Instance.new("TextLabel", row)
    label.Size = UDim2.new(0.35, 0, 1, 0)
    label.Text = " " .. tostring(k)
    label.TextColor3 = Color3.fromRGB(150, 150, 150)
    label.Font = Enum.Font.Code
    label.TextSize = 9
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.BackgroundTransparency = 1
    label.ClipsDescendants = true
    if type(v) == "table" then
        local diveBtn = Instance.new("TextButton", row)
        diveBtn.Size = UDim2.new(0, 100, 0, 24)
        diveBtn.Position = UDim2.fromScale(0.37, 0.15)
        diveBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
        diveBtn.Text = "DIVE >"
        diveBtn.TextColor3 = self.Config.ACCENT_COLOR
        diveBtn.Font = Enum.Font.Code
        diveBtn.TextSize = 8
        self:_applyStyle(diveBtn, 2)
        diveBtn.MouseButton1Click:Connect(function()
            table.insert(self.State.PathStack, src)
            self:PopulateGrid(v, tostring(k))
        end)
    elseif type(v) == "function" then
        local spoofBtn = Instance.new("TextButton", row)
        spoofBtn.Size = UDim2.new(0, 40, 0, 24)
        spoofBtn.Position = UDim2.fromScale(0.37, 0.15)
        spoofBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 70)
        spoofBtn.Text = "SPOOF"
        spoofBtn.TextColor3 = Color3.new(1, 1, 1)
        spoofBtn.Font = Enum.Font.Code
        spoofBtn.TextSize = 7
        self:_applyStyle(spoofBtn, 2)
        local uvBtn = Instance.new("TextButton", row)
        uvBtn.Size = UDim2.new(0, 40, 0, 24)
        uvBtn.Position = UDim2.fromScale(0.45, 0.15)
        uvBtn.BackgroundColor3 = Color3.fromRGB(60, 40, 100)
        uvBtn.Text = "UVALS"
        uvBtn.TextColor3 = Color3.fromRGB(150, 100, 255)
        uvBtn.Font = Enum.Font.Code
        uvBtn.TextSize = 7
        self:_applyStyle(uvBtn, 2)
        uvBtn.MouseButton1Click:Connect(function()
            self:_showUpvaluesUI(v, tostring(k))
        end)
        local viewBtn = Instance.new("TextButton", row)
        viewBtn.Size = UDim2.new(0, 35, 0, 24)
        viewBtn.Position = UDim2.fromScale(0.54, 0.15)
        viewBtn.BackgroundColor3 = Color3.fromRGB(60, 40, 60)
        viewBtn.Text = "V"
        viewBtn.TextColor3 = Color3.fromRGB(255, 100, 255)
        viewBtn.Font = Enum.Font.Code
        viewBtn.TextSize = 7
        self:_applyStyle(viewBtn, 2)
        viewBtn.MouseButton1Click:Connect(function()
            self.State.EditTarget = src
            self:_showSource(v)
        end)
        local editBtn = Instance.new("TextButton", row)
        editBtn.Size = UDim2.new(0, 35, 0, 24)
        editBtn.Position = UDim2.fromScale(0.615, 0.15)
        editBtn.BackgroundColor3 = Color3.fromRGB(100, 70, 50)
        editBtn.Text = "E"
        editBtn.TextColor3 = Color3.fromRGB(255, 180, 100)
        editBtn.Font = Enum.Font.Code
        editBtn.TextSize = 7
        self:_applyStyle(editBtn, 2)
        editBtn.MouseButton1Click:Connect(function()
            self.State.EditTarget = src
            self:_showEditUI(v, tostring(k) .. "()")
        end)
        local modes = {"NORMAL", "TRUE", "FALSE"}
        local cur = 1
        spoofBtn.MouseButton1Click:Connect(function()
            cur = (cur % 3) + 1
            local mode = modes[cur]
            spoofBtn.Text = "F" .. string.sub(mode, 1, 1)
            spoofBtn.BackgroundColor3 = (mode == "TRUE" and Color3.fromRGB(0, 200, 100)) or (mode == "FALSE" and Color3.fromRGB(200, 50, 50)) or Color3.fromRGB(50, 50, 70)
            if mode == "NORMAL" then
                if self.State.ActivePatches[src] then self.State.ActivePatches[src][k] = nil end
            else
                self:_applyPatch(src, k, mode, true)
            end
        end)
    else
        local valueType = type(v)
        local box = Instance.new("TextBox", row)
        box.Size = UDim2.new(0, 90, 0, 24)
        box.Position = UDim2.fromScale(0.37, 0.15)
        box.BackgroundColor3 = Color3.fromRGB(10, 10, 12)
        box.Text = tostring(v)
        box.TextColor3 = self.Config.ACCENT_COLOR
        box.Font = Enum.Font.Code
        box.TextSize = 9
        self:_applyStyle(box, 2)
        box.FocusLost:Connect(function(enter)
            if enter then
                self:_applyPatch(src, k, tonumber(box.Text) or box.Text, false)
            end
        end)
        if valueType == "number" then
            local hookBtn = Instance.new("TextButton", row)
            hookBtn.Size = UDim2.new(0, 45, 0, 24)
            hookBtn.Position = UDim2.fromScale(0.545, 0.15)
            hookBtn.BackgroundColor3 = Color3.fromRGB(40, 60, 40)
            hookBtn.Text = "HOOK"
            hookBtn.TextColor3 = self.Config.HOOK_COLOR
            hookBtn.Font = Enum.Font.Code
            hookBtn.TextSize = 7
            self:_applyStyle(hookBtn, 2)
            hookBtn.MouseButton1Click:Connect(function()
                local newVal = tonumber(box.Text) or v
                self:_hookValue(src, k, newVal, valueType)
                hookBtn.BackgroundColor3 = Color3.fromRGB(0, 150, 100)
                hookBtn.Text = "HOOKED"
                task.wait(0.5)
                hookBtn.BackgroundColor3 = Color3.fromRGB(40, 60, 40)
                hookBtn.Text = "HOOK"
            end)
        end
    end
end
function Modules.Overseer:PopulateGrid(targetTable, name)
    local ui = self.State.UI
    self.State.CurrentTable = targetTable
    self.State.CurrentTypeFilter = nil
    local active, valueHooks, propHooks = self:_getPatchStatus()
    ui.Title.Text = "PATH: " .. (name or "Main") .. " [" .. active .. " patches | " .. valueHooks .. " value hooks]"
    for _, v in ipairs(ui.Grid:GetChildren()) do
        if not v:IsA("UIListLayout") then v:Destroy() end
    end
    local filterFrame = Instance.new("Frame", ui.Grid)
    filterFrame.Size = UDim2.new(1, -10, 0, 40)
    filterFrame.BackgroundTransparency = 0.8
    filterFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
    self:_applyStyle(filterFrame, 2)
    local types = {"number", "string", "boolean", "function", "table"}
    local typeButtons = {}
    for i, typeStr in ipairs(types) do
        local typeBtn = Instance.new("TextButton", filterFrame)
        typeBtn.Size = UDim2.new(0, 80, 0, 25)
        typeBtn.Position = UDim2.new(0, 10 + (i-1) * 90, 0.5, -12.5)
        typeBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
        typeBtn.Text = typeStr:upper()
        typeBtn.TextColor3 = Color3.fromRGB(150, 150, 150)
        typeBtn.Font = Enum.Font.Code
        typeBtn.TextSize = 8
        self:_applyStyle(typeBtn, 2)
        typeBtn.MouseButton1Click:Connect(function()
            self:_applyTypeFilter(targetTable, typeStr, name)
            for _, btn in ipairs(typeButtons) do
                btn.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
                btn.TextColor3 = Color3.fromRGB(150, 150, 150)
            end
            typeBtn.BackgroundColor3 = Color3.fromRGB(60, 80, 100)
            typeBtn.TextColor3 = Color3.fromRGB(100, 200, 255)
        end)
        table.insert(typeButtons, typeBtn)
    end
    local clearBtn = Instance.new("TextButton", filterFrame)
    clearBtn.Size = UDim2.new(0, 60, 0, 25)
    clearBtn.Position = UDim2.new(0, 10 + 5 * 90, 0.5, -12.5)
    clearBtn.BackgroundColor3 = Color3.fromRGB(60, 40, 40)
    clearBtn.Text = "ALL"
    clearBtn.TextColor3 = Color3.new(1, 1, 1)
    clearBtn.Font = Enum.Font.Code
    clearBtn.TextSize = 8
    self:_applyStyle(clearBtn, 2)
    clearBtn.MouseButton1Click:Connect(function()
        for _, btn in ipairs(typeButtons) do
            btn.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
            btn.TextColor3 = Color3.fromRGB(150, 150, 150)
        end
        clearBtn.BackgroundColor3 = Color3.fromRGB(100, 80, 40)
        clearBtn.TextColor3 = Color3.fromRGB(255, 200, 100)
        self.State.CurrentTypeFilter = nil
        self:_populateGridRows(targetTable)
    end)
    clearBtn.BackgroundColor3 = Color3.fromRGB(100, 80, 40)
    clearBtn.TextColor3 = Color3.fromRGB(255, 200, 100)
    self:_populateGridRows(targetTable)
end
function Modules.Overseer:_populateGridRows(targetTable)
    if not self.State.UI or not self.State.UI.Grid then return end
    local ui = self.State.UI
    if type(targetTable) ~= "table" then
        local errorLabel = Instance.new("TextLabel", ui.Grid)
        errorLabel.Size = UDim2.new(1, 0, 0, 30)
        errorLabel.Text = "-- ERROR: Cannot display non-table value --"
        errorLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
        errorLabel.BackgroundTransparency = 1
        errorLabel.Font = Enum.Font.Code
        errorLabel.TextSize = 10
        return
    end
    local children = ui.Grid:GetChildren()
    for i = #children, 1, -1 do
        local v = children[i]
        if v and v.Parent and not v:IsA("UIListLayout") and v.Name ~= "FilterFrame" then
            v:Destroy()
        end
    end
    local rowsToDisplay = targetTable
    local isFiltered = false
    if self.State.CurrentTypeFilter then
        rowsToDisplay = self:_filterTableByType(targetTable, self.State.CurrentTypeFilter)
        isFiltered = true
    end
    if isFiltered then
        for _, item in ipairs(rowsToDisplay) do
            if item and item.key then
                self:_createTableRow(item.key, item.value, targetTable)
            end
        end
    else
        for k, v in pairs(rowsToDisplay) do
            self:_createTableRow(k, v, targetTable)
        end
    end
    local mt = getrawmetatable and getrawmetatable(targetTable)
    if mt then
        if setreadonly then setreadonly(mt, false) elseif make_writeable then make_writeable(mt) end
        if mt.__index and type(mt.__index) == "table" then
            local ghostLabel = Instance.new("TextLabel", ui.Grid)
            ghostLabel.Size = UDim2.new(1, 0, 0, 20)
            ghostLabel.Text = " -- GHOST INDEX (__index) -- "
            ghostLabel.TextColor3 = Color3.fromRGB(255, 0, 255)
            ghostLabel.BackgroundTransparency = 1
            ghostLabel.Font = Enum.Font.Code
            ghostLabel.TextSize = 9
            for k, v in pairs(mt.__index) do
                self:_createTableRow(k, v, mt.__index)
            end
        end
        local metamethods = {}
        for mmKey, mmVal in pairs(mt) do
            if mmKey ~= "__index" and type(mmVal) == "function" then
                table.insert(metamethods, {Key = mmKey, Value = mmVal})
            end
        end
        if #metamethods > 0 then
            local mmLabel = Instance.new("TextLabel", ui.Grid)
            mmLabel.Size = UDim2.new(1, 0, 0, 20)
            mmLabel.Text = " -- METAMETHODS -- "
            mmLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
            mmLabel.BackgroundTransparency = 1
            mmLabel.Font = Enum.Font.Code
            mmLabel.TextSize = 9
            for _, mmData in ipairs(metamethods) do
                local mmRow = Instance.new("Frame", ui.Grid)
                mmRow.Size = UDim2.new(1, -10, 0, 35)
                mmRow.BackgroundTransparency = 1
                local mmLabel2 = Instance.new("TextLabel", mmRow)
                mmLabel2.Size = UDim2.new(0.4, 0, 1, 0)
                mmLabel2.Text = " " .. mmData.Key .. "()"
                mmLabel2.TextColor3 = Color3.fromRGB(255, 200, 100)
                mmLabel2.Font = Enum.Font.Code
                mmLabel2.TextSize = 9
                mmLabel2.TextXAlignment = Enum.TextXAlignment.Left
                mmLabel2.BackgroundTransparency = 1
                mmLabel2.ClipsDescendants = true
                local uvBtn = Instance.new("TextButton", mmRow)
                uvBtn.Size = UDim2.new(0, 65, 0, 24)
                uvBtn.Position = UDim2.fromScale(0.42, 0.15)
                uvBtn.BackgroundColor3 = Color3.fromRGB(60, 40, 100)
                uvBtn.Text = "UVALS"
                uvBtn.TextColor3 = Color3.fromRGB(150, 100, 255)
                uvBtn.Font = Enum.Font.Code
                uvBtn.TextSize = 8
                self:_applyStyle(uvBtn, 2)
                uvBtn.MouseButton1Click:Connect(function()
                    self:_showUpvaluesUI(mmData.Value, mmData.Key .. "() metamethod")
                end)
                local viewBtn = Instance.new("TextButton", mmRow)
                viewBtn.Size = UDim2.new(0, 65, 0, 24)
                viewBtn.Position = UDim2.fromScale(0.54, 0.15)
                viewBtn.BackgroundColor3 = Color3.fromRGB(60, 40, 60)
                viewBtn.Text = "VIEW"
                viewBtn.TextColor3 = Color3.fromRGB(255, 100, 255)
                viewBtn.Font = Enum.Font.Code
                viewBtn.TextSize = 8
                self:_applyStyle(viewBtn, 2)
                viewBtn.MouseButton1Click:Connect(function()
                    self:_showSource(mmData.Value)
                end)
            end
        end
    end
end
function Modules.Overseer:_applyTypeFilter(targetTable, typeFilter, name)
    self.State.CurrentTypeFilter = typeFilter
    local ui = self.State.UI
    ui.Title.Text = "FILTERED BY: " .. typeFilter:upper() .. " in " .. (name or "Main")
    self:_populateGridRows(targetTable)
end
function Modules.Overseer:AddModuleToList(mod)
    local n = mod.Name:lower()
    if n:find("chat") or n:find("roblox") then return end
    local ui = self.State.UI
    local container = Instance.new("Frame", ui.Sidebar)
    container.Size = UDim2.new(1, -5, 0, 25)
    container.BackgroundTransparency = 1
    local isScript = mod:IsA("LocalScript") or mod:IsA("Script")
    local displayName = " [" .. mod.ClassName .. "] " .. mod.Name
    local isDisabled = self.State.DisabledModules[mod]
    local b = Instance.new("TextButton", container)
    b.Size = UDim2.new(0.55, 0, 1, 0)
    b.Text = displayName
    b.BackgroundColor3 = isDisabled and Color3.fromRGB(40, 20, 20) or (isScript and Color3.fromRGB(25, 20, 20) or Color3.fromRGB(20, 20, 25))
    b.TextColor3 = isDisabled and Color3.fromRGB(100, 50, 50) or Color3.new(0.8, 0.8, 0.8)
    b.Font = Enum.Font.Code
    b.TextXAlignment = Enum.TextXAlignment.Left
    b.ClipsDescendants = true
    self:_applyStyle(b, 2)
    local disB = Instance.new("TextButton", container)
    disB.Size = UDim2.new(0.12, 0, 1, 0)
    disB.Position = UDim2.fromScale(0.55, 0)
    disB.BackgroundColor3 = isDisabled and Color3.fromRGB(80, 40, 40) or Color3.fromRGB(40, 80, 40)
    disB.Text = isDisabled and "âœ—" or "âœ“"
    disB.TextColor3 = Color3.new(1, 1, 1)
    disB.Font = Enum.Font.Code
    disB.TextSize = 10
    self:_applyStyle(disB, 2)
    local srcB = Instance.new("TextButton", container)
    srcB.Size = UDim2.new(0.12, 0, 1, 0)
    srcB.Position = UDim2.fromScale(0.67, 0)
    srcB.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
    srcB.Text = "V"
    srcB.TextColor3 = Color3.fromRGB(100, 200, 255)
    srcB.Font = Enum.Font.Code
    srcB.TextSize = 8
    self:_applyStyle(srcB, 2)
    local editB = Instance.new("TextButton", container)
    editB.Size = UDim2.new(0.16, 0, 1, 0)
    editB.Position = UDim2.fromScale(0.79, 0)
    editB.BackgroundColor3 = Color3.fromRGB(50, 40, 30)
    editB.Text = "E"
    editB.TextColor3 = Color3.fromRGB(255, 180, 100)
    editB.Font = Enum.Font.Code
    editB.TextSize = 8
    self:_applyStyle(editB, 2)
    self.State.SidebarButtons[container] = mod.Name
    disB.MouseButton1Click:Connect(function()
        local isCurrentlyDisabled = self.State.DisabledModules[mod]
        self.State.DisabledModules[mod] = not isCurrentlyDisabled
        if self.State.DisabledModules[mod] then
            disB.BackgroundColor3 = Color3.fromRGB(80, 40, 40)
            disB.Text = "âœ—"
            b.BackgroundColor3 = Color3.fromRGB(40, 20, 20)
            b.TextColor3 = Color3.fromRGB(100, 50, 50)
            self:_cleanupModuleHooks(mod)
        else
            disB.BackgroundColor3 = Color3.fromRGB(40, 80, 40)
            disB.Text = "âœ“"
            b.BackgroundColor3 = isScript and Color3.fromRGB(25, 20, 20) or Color3.fromRGB(20, 20, 25)
            b.TextColor3 = Color3.new(0.8, 0.8, 0.8)
        end
    end)
    b.MouseButton1Click:Connect(function()
        if self.State.DisabledModules[mod] then
            self:_showErrorInGrid("-- ERROR: Module is disabled --")
            return
        end
        if not mod or not mod.Parent then
            self:_showErrorInGrid("-- ERROR: Module has been destroyed --")
            return
        end
        self.State.SelectedModule = mod
        self.State.PathStack = {}
        if isScript then
            self:_showSource(mod)
        else
            local success, result = pcall(function()
                if not mod or not mod.Parent then
                    error("Module has been destroyed")
                end
                return require(mod)
            end)
            if success and type(result) == "table" then
                self:PopulateGrid(result, mod.Name)
            else
                self:_showSource(mod)
            end
        end
    end)
    srcB.MouseButton1Click:Connect(function()
        if self.State.DisabledModules[mod] then
            self.State.UI.CodeBox.Text = "-- ERROR: Module is disabled --"
            return
        end
        if not mod or not mod.Parent then
            self.State.UI.CodeBox.Text = "-- ERROR: Module has been destroyed --"
            return
        end
        self.State.EditTarget = mod
        self:_showSource(mod)
    end)
    editB.MouseButton1Click:Connect(function()
        if self.State.DisabledModules[mod] then
            self.State.UI.CodeBox.Text = "-- ERROR: Module is disabled --"
            return
        end
        if not mod or not mod.Parent then
            self.State.UI.CodeBox.Text = "-- ERROR: Module has been destroyed --"
            return
        end
        self.State.EditTarget = mod
        self:_showEditUI(mod, displayName)
    end)
end
function Modules.Overseer:_createInstanceRow(inst, parent)
    local ui = self.State.UI
    local row = Instance.new("Frame", ui.Grid)
    row.Size = UDim2.new(1, -10, 0, 35)
    row.BackgroundTransparency = 1
    local label = Instance.new("TextLabel", row)
    label.Size = UDim2.new(0.55, 0, 1, 0)
    label.Text = " " .. inst.Name .. " (" .. inst.ClassName .. ")"
    label.TextColor3 = Color3.fromRGB(150, 200, 255)
    label.Font = Enum.Font.Code
    label.TextSize = 9
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.BackgroundTransparency = 1
    label.ClipsDescendants = true
    if #inst:GetChildren() > 0 then
        local expandBtn = Instance.new("TextButton", row)
        expandBtn.Size = UDim2.new(0, 50, 0, 24)
        expandBtn.Position = UDim2.fromScale(0.57, 0.15)
        expandBtn.BackgroundColor3 = Color3.fromRGB(40, 60, 80)
        expandBtn.Text = "EXPAND"
        expandBtn.TextColor3 = Color3.fromRGB(0, 200, 255)
        expandBtn.Font = Enum.Font.Code
        expandBtn.TextSize = 7
        self:_applyStyle(expandBtn, 2)
        expandBtn.MouseButton1Click:Connect(function()
            table.insert(self.State.ExplorerPath, inst)
            self:PopulateExplorer(inst)
        end)
    end
    if inst:IsA("ModuleScript") or inst:IsA("Script") or inst:IsA("LocalScript") then
        local poisonBtn = Instance.new("TextButton", row)
        poisonBtn.Size = UDim2.new(0, 50, 0, 24)
        poisonBtn.Position = UDim2.fromScale(0.72, 0.15)
        poisonBtn.BackgroundColor3 = Color3.fromRGB(80, 40, 60)
        poisonBtn.Text = "POISON"
        poisonBtn.TextColor3 = Color3.fromRGB(255, 100, 255)
        poisonBtn.Font = Enum.Font.Code
        poisonBtn.TextSize = 7
        self:_applyStyle(poisonBtn, 2)
        poisonBtn.MouseButton1Click:Connect(function()
            self.State.SelectedModule = inst
            self.State.PathStack = {}
            self.State.CurrentMode = "modules"
            if inst:IsA("ModuleScript") then
                local success, result = pcall(require, inst)
                if success then
                    self:PopulateGrid(result, inst.Name)
                end
            else
                self:_showSource(inst)
            end
        end)
    elseif inst:IsA("GuiObject") or inst:IsA("Part") or inst:IsA("BasePart") then
        local propBtn = Instance.new("TextButton", row)
        propBtn.Size = UDim2.new(0, 50, 0, 24)
        propBtn.Position = UDim2.fromScale(0.72, 0.15)
        propBtn.BackgroundColor3 = Color3.fromRGB(60, 50, 40)
        propBtn.Text = "PROPS"
        propBtn.TextColor3 = Color3.fromRGB(255, 180, 100)
        propBtn.Font = Enum.Font.Code
        propBtn.TextSize = 7
        self:_applyStyle(propBtn, 2)
        propBtn.MouseButton1Click:Connect(function()
            self:_showInstanceProperties(inst)
        end)
    end
end
function Modules.Overseer:PopulateExplorer(instance)
    local ui = self.State.UI
    self.State.ExplorerInstance = instance
    local pathStr = ""
    for i, inst in ipairs(self.State.ExplorerPath) do
        pathStr = pathStr .. inst.Name .. "/"
    end
    pathStr = pathStr .. instance.Name
    ui.Title.Text = "EXPLORER: " .. pathStr
    for _, v in ipairs(ui.Grid:GetChildren()) do
        if not v:IsA("UIListLayout") then v:Destroy() end
    end
    local children = instance:GetChildren()
    if #children == 0 then
        local emptyLabel = Instance.new("TextLabel", ui.Grid)
        emptyLabel.Size = UDim2.new(1, 0, 0, 20)
        emptyLabel.Text = "  -- NO CHILDREN -- "
        emptyLabel.TextColor3 = Color3.fromRGB(200, 100, 100)
        emptyLabel.BackgroundTransparency = 1
        emptyLabel.Font = Enum.Font.Code
        emptyLabel.TextSize = 9
    else
        for _, child in ipairs(children) do
            self:_createInstanceRow(child, instance)
        end
    end
end
function Modules.Overseer:_showGlobalTypeSearch()
    local ui = self.State.UI
    self.State.ViewingCode = true
    ui.Grid.Visible = false
    ui.CodeFrame.Visible = true
    ui.Title.Text = "GLOBAL TYPE SEARCH"
    ui.CodeBox.TextEditable = false
    for _, v in ipairs(ui.Grid:GetChildren()) do
        if not v:IsA("UIListLayout") then v:Destroy() end
    end
    local searchLabel = Instance.new("TextLabel", ui.Grid)
    searchLabel.Size = UDim2.new(1, -10, 0, 30)
    searchLabel.Text = "Select a type to search globally..."
    searchLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    searchLabel.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
    searchLabel.Font = Enum.Font.Code
    searchLabel.TextSize = 10
    self:_applyStyle(searchLabel, 2)
    local types = {"number", "string", "boolean", "function", "table"}
    for i, typeStr in ipairs(types) do
        local typeBtn = Instance.new("TextButton", ui.Grid)
        typeBtn.Size = UDim2.new(0.9, 0, 0, 35)
        typeBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
        typeBtn.Text = "SEARCH: " .. typeStr:upper() .. " (Click to start)"
        typeBtn.TextColor3 = Color3.fromRGB(100, 200, 255)
        typeBtn.Font = Enum.Font.Code
        typeBtn.TextSize = 9
        self:_applyStyle(typeBtn, 2)
        typeBtn.MouseButton1Click:Connect(function()
            self:_displayGlobalSearchResults(typeStr)
        end)
    end
end
function Modules.Overseer:_displayGlobalSearchResults(typeFilter)
    local ui = self.State.UI
    for _, v in ipairs(ui.Grid:GetChildren()) do
        if not v:IsA("UIListLayout") then v:Destroy() end
    end
    ui.CodeBox.Text = "Searching for all " .. typeFilter .. " values...\nThis may take a moment...\n\n"
    local results = self:_getAllValuesOfType(typeFilter, 3)
    ui.CodeBox.Text = "Found " .. #results .. " " .. typeFilter .. " values:\n\n"
    local headerLabel = Instance.new("TextLabel", ui.Grid)
    headerLabel.Size = UDim2.new(1, -10, 0, 25)
    headerLabel.Text = "FOUND " .. #results .. " RESULTS - Click to dive into"
    headerLabel.TextColor3 = self.Config.HOOK_COLOR
    headerLabel.BackgroundColor3 = Color3.fromRGB(20, 30, 20)
    headerLabel.Font = Enum.Font.Code
    headerLabel.TextSize = 10
    self:_applyStyle(headerLabel, 2)
    for i, result in ipairs(results) do
        if i > 50 then
            local moreLabel = Instance.new("TextLabel", ui.Grid)
            moreLabel.Size = UDim2.new(1, -10, 0, 20)
            moreLabel.Text = "... and " .. (#results - 50) .. " more"
            moreLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
            moreLabel.BackgroundTransparency = 1
            moreLabel.Font = Enum.Font.Code
            moreLabel.TextSize = 9
            break
        end
        local resultRow = Instance.new("Frame", ui.Grid)
        resultRow.Size = UDim2.new(1, -10, 0, 35)
        resultRow.BackgroundTransparency = 1
        local resultLabel = Instance.new("TextLabel", resultRow)
        resultLabel.Size = UDim2.new(0.7, 0, 1, 0)
        resultLabel.Text = " " .. result.path
        resultLabel.TextColor3 = Color3.fromRGB(100, 200, 255)
        resultLabel.Font = Enum.Font.Code
        resultLabel.TextSize = 8
        resultLabel.TextXAlignment = Enum.TextXAlignment.Left
        resultLabel.BackgroundTransparency = 1
        resultLabel.ClipsDescendants = true
        local diveBtn = Instance.new("TextButton", resultRow)
        diveBtn.Size = UDim2.new(0, 55, 0, 24)
        diveBtn.Position = UDim2.fromScale(0.72, 0.15)
        diveBtn.BackgroundColor3 = Color3.fromRGB(40, 60, 80)
        diveBtn.Text = "DIVE"
        diveBtn.TextColor3 = Color3.fromRGB(0, 200, 255)
        diveBtn.Font = Enum.Font.Code
        diveBtn.TextSize = 8
        self:_applyStyle(diveBtn, 2)
        diveBtn.MouseButton1Click:Connect(function()
            if type(result.value) == "table" then
                table.insert(self.State.PathStack, self.State.CurrentTable)
                self.State.CurrentTable = result.value
                self:PopulateGrid(result.value, result.path)
            end
        end)
    end
end
function Modules.Overseer:_showInstanceProperties(inst)
    local ui = self.State.UI
    self.State.ViewingCode = true
    ui.Grid.Visible = false
    ui.CodeFrame.Visible = true
    ui.Title.Text = "PROPERTIES: " .. inst.Name
    ui.CodeBox.TextEditable = false
    for _, v in ipairs(ui.Grid:GetChildren()) do
        if not v:IsA("UIListLayout") then v:Destroy() end
    end
    local properties = {}
    pcall(function()
        properties = inst:GetProperties()
    end)
    if #properties == 0 then
        ui.CodeBox.Text = "-- No properties accessible"
        return
    end
    for _, prop in ipairs(properties) do
        local success, val = pcall(function() return inst[prop] end)
        if success then
            local propRow = Instance.new("Frame", ui.Grid)
            propRow.Size = UDim2.new(1, -10, 0, 35)
            propRow.BackgroundTransparency = 1
            local label = Instance.new("TextLabel", propRow)
            label.Size = UDim2.new(0.4, 0, 1, 0)
            label.Text = " " .. prop
            label.TextColor3 = Color3.fromRGB(150, 200, 255)
            label.Font = Enum.Font.Code
            label.TextSize = 8
            label.TextXAlignment = Enum.TextXAlignment.Left
            label.BackgroundTransparency = 1
            label.ClipsDescendants = true
            if type(val) == "number" then
                local box = Instance.new("TextBox", propRow)
                box.Size = UDim2.new(0, 80, 0, 24)
                box.Position = UDim2.fromScale(0.42, 0.15)
                box.BackgroundColor3 = Color3.fromRGB(10, 10, 12)
                box.Text = tostring(val)
                box.TextColor3 = Color3.fromRGB(100, 200, 255)
                box.Font = Enum.Font.Code
                box.TextSize = 8
                self:_applyStyle(box, 2)
                box.FocusLost:Connect(function(enter)
                    if enter then
                        pcall(function()
                            inst[prop] = tonumber(box.Text) or val
                        end)
                    end
                end)
                local hookBtn = Instance.new("TextButton", propRow)
                hookBtn.Size = UDim2.new(0, 45, 0, 24)
                hookBtn.Position = UDim2.fromScale(0.545, 0.15)
                hookBtn.BackgroundColor3 = Color3.fromRGB(40, 60, 40)
                hookBtn.Text = "HOOK"
                hookBtn.TextColor3 = self.Config.HOOK_COLOR
                hookBtn.Font = Enum.Font.Code
                hookBtn.TextSize = 7
                self:_applyStyle(hookBtn, 2)
                hookBtn.MouseButton1Click:Connect(function()
                    local newVal = tonumber(box.Text) or val
                    self:_hookProperty(inst, prop, newVal)
                    hookBtn.BackgroundColor3 = Color3.fromRGB(0, 150, 100)
                    hookBtn.Text = "HOOKED"
                    task.wait(0.5)
                    hookBtn.BackgroundColor3 = Color3.fromRGB(40, 60, 40)
                    hookBtn.Text = "HOOK"
                end)
            else
                local label2 = Instance.new("TextLabel", propRow)
                label2.Size = UDim2.new(0.5, 0, 1, 0)
                label2.Position = UDim2.fromScale(0.42, 0)
                label2.Text = tostring(val)
                label2.TextColor3 = Color3.fromRGB(150, 150, 150)
                label2.Font = Enum.Font.Code
                label2.TextSize = 8
                label2.TextXAlignment = Enum.TextXAlignment.Left
                label2.BackgroundTransparency = 1
                label2.ClipsDescendants = true
            end
        end
    end
end
function Modules.Overseer:_generatePoisonedVersion(originalCode)
    local poisonedCode = "local ORIGINAL_SCRIPT = [[\n" .. originalCode .. "\n]]\n\n"
    poisonedCode = poisonedCode .. "-- Poison execution environment\n"
    poisonedCode = poisonedCode .. "local function applyPoison()\n"
    poisonedCode = poisonedCode .. "    local success, result = pcall(function()\n"
    poisonedCode = poisonedCode .. "        local func, err = loadstring(ORIGINAL_SCRIPT, 'PoisonedScript')\n"
    poisonedCode = poisonedCode .. "        if func then\n"
    poisonedCode = poisonedCode .. "            return func()\n"
    poisonedCode = poisonedCode .. "        else\n"
    poisonedCode = poisonedCode .. "            error('Compilation failed: ' .. tostring(err))\n"
    poisonedCode = poisonedCode .. "        end\n"
    poisonedCode = poisonedCode .. "    end)\n"
    poisonedCode = poisonedCode .. "    return success, result\n"
    poisonedCode = poisonedCode .. "end\n\n"
    poisonedCode = poisonedCode .. "local success, result = applyPoison()\n"
    poisonedCode = poisonedCode .. "if not success then warn('Poisoned execution error: ' .. tostring(result)) end\n"
    return poisonedCode
end
function Modules.Overseer:_generateAdvancedPoisonVersion(originalCode, options)
    options = options or {}
    local poisonedCode = "-- ============================================================================\n"
    poisonedCode = poisonedCode .. "-- POISONED SCRIPT - OVERSEER INJECTION\n"
    poisonedCode = poisonedCode .. "-- Patches: " .. (options.includePatches and "ACTIVE" or "NONE") .. " | Hooks: " .. (options.includeHooks and "ACTIVE" or "NONE") .. "\n"
    poisonedCode = poisonedCode .. "-- ============================================================================\n\n"
    poisonedCode = poisonedCode .. "local PATCHES_ENABLED = " .. (options.patchesEnabled and "true" or "false") .. "\n"
    poisonedCode = poisonedCode .. "local HOOKS_ENABLED = " .. (options.includeHooks and "true" or "false") .. "\n\n"
    poisonedCode = poisonedCode .. "local ORIGINAL_SCRIPT = [[\n"
    poisonedCode = poisonedCode .. originalCode .. "\n]]\n\n"
    if options.includePatches then
        poisonedCode = poisonedCode .. "local ACTIVE_PATCHES = {\n"
        for tbl, keys in pairs(self.State.ActivePatches) do
            for key, data in pairs(keys) do
                local valStr = tostring(data.Value)
                if type(data.Value) == "string" then
                    valStr = "\"" .. data.Value:gsub("\"", "\\\"") .. "\""
                elseif type(data.Value) == "boolean" then
                    valStr = data.Value and "true" or "false"
                end
                poisonedCode = poisonedCode .. "    [" .. tostring(key) .. "] = {value = " .. valStr .. ", locked = " .. (data.Locked and "true" or "false") .. "},\n"
            end
        end
        poisonedCode = poisonedCode .. "}\n\n"
    else
        poisonedCode = poisonedCode .. "local ACTIVE_PATCHES = {}\n\n"
    end
    if options.includeHooks then
        poisonedCode = poisonedCode .. "local HOOKED_VALUES = {\n"
        for hookKey, hook in pairs(self.State.ValueHooks) do
            if hook.enabled then
                poisonedCode = poisonedCode .. "    [" .. hookKey .. "] = {value = " .. tostring(hook.value) .. ", enabled = true},\n"
            end
        end
        poisonedCode = poisonedCode .. "}\n\n"
    else
        poisonedCode = poisonedCode .. "local HOOKED_VALUES = {}\n\n"
    end
    poisonedCode = poisonedCode .. "-- Apply patches and hooks before execution\n"
    poisonedCode = poisonedCode .. "local function applyPoisonLogic()\n"
    poisonedCode = poisonedCode .. "    if PATCHES_ENABLED then\n"
    poisonedCode = poisonedCode .. "        for key, patchData in pairs(ACTIVE_PATCHES) do\n"
    poisonedCode = poisonedCode .. "            if patchData.locked then\n"
    poisonedCode = poisonedCode .. "                _G[key] = patchData.value\n"
    poisonedCode = poisonedCode .. "            end\n"
    poisonedCode = poisonedCode .. "        end\n"
    poisonedCode = poisonedCode .. "    end\n"
    poisonedCode = poisonedCode .. "    if HOOKS_ENABLED then\n"
    poisonedCode = poisonedCode .. "        for hookKey, hookData in pairs(HOOKED_VALUES) do\n"
    poisonedCode = poisonedCode .. "            if hookData.enabled then\n"
    poisonedCode = poisonedCode .. "                _G[hookKey] = hookData.value\n"
    poisonedCode = poisonedCode .. "            end\n"
    poisonedCode = poisonedCode .. "        end\n"
    poisonedCode = poisonedCode .. "    end\n"
    poisonedCode = poisonedCode .. "end\n\n"
    poisonedCode = poisonedCode .. "-- Execute with poison applied\n"
    poisonedCode = poisonedCode .. "local success, result = pcall(function()\n"
    poisonedCode = poisonedCode .. "    applyPoisonLogic()\n"
    poisonedCode = poisonedCode .. "    local func, err = loadstring(ORIGINAL_SCRIPT, 'PoisonedExecution')\n"
    poisonedCode = poisonedCode .. "    if func then\n"
    poisonedCode = poisonedCode .. "        return func()\n"
    poisonedCode = poisonedCode .. "    else\n"
    poisonedCode = poisonedCode .. "        error('Compilation: ' .. tostring(err))\n"
    poisonedCode = poisonedCode .. "    end\n"
    poisonedCode = poisonedCode .. "end)\n\n"
    poisonedCode = poisonedCode .. "if success then\n"
    poisonedCode = poisonedCode .. "    print('[POISON] Script executed with ' .. (PATCHES_ENABLED and 'patches' or 'no patches') .. ' & ' .. (HOOKS_ENABLED and 'hooks' or 'no hooks'))\n"
    poisonedCode = poisonedCode .. "else\n"
    poisonedCode = poisonedCode .. "    warn('[POISON] Execution failed: ' .. tostring(result))\n"
    poisonedCode = poisonedCode .. "end\n"
    return poisonedCode
end
function Modules.Overseer:_showPoisonOptions()
    local ui = self.State.UI
    for _, v in ipairs(ui.Grid:GetChildren()) do
        if not v:IsA("UIListLayout") then v:Destroy() end
    end
    ui.CodeFrame.Visible = false
    ui.Grid.Visible = true
    ui.Title.Text = "POISON OPTIONS"
    local titleLabel = Instance.new("TextLabel", ui.Grid)
    titleLabel.Size = UDim2.new(1, -10, 0, 30)
    titleLabel.Text = "Generate Poisoned Version - Select Options:"
    titleLabel.TextColor3 = Color3.fromRGB(200, 100, 255)
    titleLabel.BackgroundColor3 = Color3.fromRGB(40, 20, 60)
    titleLabel.Font = Enum.Font.Code
    titleLabel.TextSize = 10
    self:_applyStyle(titleLabel, 2)
    local options = {
        {name = "Simple Wrapper", desc = "Wrap in basic execution", value = "simple"},
        {name = "Include Patches", desc = "Include active patches", value = "patches"},
        {name = "Include Hooks", desc = "Include value hooks", value = "hooks"},
        {name = "Advanced (All)", desc = "Patches + Hooks + Comments", value = "advanced"}
    }
    for _, option in ipairs(options) do
        local optRow = Instance.new("Frame", ui.Grid)
        optRow.Size = UDim2.new(1, -10, 0, 35)
        optRow.BackgroundTransparency = 1
        local optLabel = Instance.new("TextLabel", optRow)
        optLabel.Size = UDim2.new(0.6, 0, 1, 0)
        optLabel.Text = " " .. option.name .. "\n " .. option.desc
        optLabel.TextColor3 = Color3.fromRGB(150, 200, 255)
        optLabel.Font = Enum.Font.Code
        optLabel.TextSize = 9
        optLabel.TextXAlignment = Enum.TextXAlignment.Left
        optLabel.TextYAlignment = Enum.TextYAlignment.Center
        optLabel.BackgroundTransparency = 1
        local execBtn = Instance.new("TextButton", optRow)
        execBtn.Size = UDim2.new(0, 70, 0, 24)
        execBtn.Position = UDim2.fromScale(0.62, 0.25)
        execBtn.BackgroundColor3 = Color3.fromRGB(60, 80, 100)
        execBtn.Text = "GENERATE"
        execBtn.TextColor3 = Color3.fromRGB(100, 200, 255)
        execBtn.Font = Enum.Font.Code
        execBtn.TextSize = 8
        self:_applyStyle(execBtn, 2)
        execBtn.MouseButton1Click:Connect(function()
            local codeBox = ui.CodeBox
            local originalCode = codeBox.Text
            if (option.value == "patches" or option.value == "advanced") and not self:_validatePatches() then
                self:_showErrorInGrid("-- ERROR: Invalid patches detected --")
                return
            end
            if (option.value == "hooks" or option.value == "advanced") and not self:_validateHooks() then
                self:_showErrorInGrid("-- ERROR: Invalid hooks detected --")
                return
            end
            local poisonedCode = ""
            if option.value == "simple" then
                poisonedCode = self:_generatePoisonedVersion(originalCode)
            else
                local opts = {
                    patchesEnabled = true,
                    includePatches = (option.value == "patches" or option.value == "advanced"),
                    includeHooks = (option.value == "hooks" or option.value == "advanced")
                }
                poisonedCode = self:_generateAdvancedPoisonVersion(originalCode, opts)
            end
            self:_showPoisonedCode(poisonedCode, option.name)
        end)
    end
end
function Modules.Overseer:_showPoisonedCode(poisonedCode, optionName)
    local ui = self.State.UI
    ui.Grid.Visible = false
    ui.CodeFrame.Visible = true
    ui.Title.Text = "POISONED VERSION (" .. optionName .. ")"
    ui.CodeBox.Text = poisonedCode
    ui.CodeBox.TextEditable = false
    local children = ui.CodeFrame:GetChildren()
    for _, btn in ipairs(children) do
        if btn:IsA("TextButton") then
            if btn.Text == "COPY" then
                btn.Visible = true
            elseif btn.Text == "EDIT" then
                btn.Visible = true
            elseif btn.Text == "APPLY" then
                btn.Visible = true
                btn.Text = "EXECUTE"
                btn.BackgroundColor3 = Color3.fromRGB(150, 80, 20)
                btn.TextColor3 = Color3.new(1, 1, 1)
            end
        end
    end
end
function Modules.Overseer:_showPatchManager()
    local ui = self.State.UI
    self.State.ViewingCode = true
    ui.Grid.Visible = false
    ui.CodeFrame.Visible = true
    ui.Title.Text = "PATCH MANAGER"
    ui.CodeBox.TextEditable = false
    for _, v in ipairs(ui.Grid:GetChildren()) do
        if not v:IsA("UIListLayout") then v:Destroy() end
    end
    local active, valueHooks, propHooks = self:_getPatchStatus()
    local headerLabel = Instance.new("TextLabel", ui.Grid)
    headerLabel.Size = UDim2.new(1, 0, 0, 30)
    headerLabel.Text = "ACTIVE PATCHES: " .. active .. " | VALUE HOOKS: " .. valueHooks .. " | PROPERTY HOOKS: " .. propHooks
    headerLabel.TextColor3 = self.Config.HOOK_COLOR
    headerLabel.BackgroundColor3 = Color3.fromRGB(20, 30, 20)
    headerLabel.Font = Enum.Font.Code
    headerLabel.TextSize = 10
    self:_applyStyle(headerLabel, 2)
    if valueHooks > 0 then
        local vhLabel = Instance.new("TextLabel", ui.Grid)
        vhLabel.Size = UDim2.new(1, 0, 0, 20)
        vhLabel.Text = " -- VALUE HOOKS --"
        vhLabel.TextColor3 = Color3.fromRGB(100, 200, 255)
        vhLabel.BackgroundTransparency = 1
        vhLabel.Font = Enum.Font.Code
        vhLabel.TextSize = 9
        for hookKey, hook in pairs(self.State.ValueHooks) do
            if hook.enabled then
                local hookRow = Instance.new("Frame", ui.Grid)
                hookRow.Size = UDim2.new(1, -10, 0, 35)
                hookRow.BackgroundTransparency = 1
                local hookLabel = Instance.new("TextLabel", hookRow)
                hookLabel.Size = UDim2.new(0.7, 0, 1, 0)
                hookLabel.Text = " " .. hookKey .. " = " .. tostring(hook.value)
                hookLabel.TextColor3 = Color3.fromRGB(100, 200, 255)
                hookLabel.Font = Enum.Font.Code
                hookLabel.TextSize = 8
                hookLabel.TextXAlignment = Enum.TextXAlignment.Left
                hookLabel.BackgroundTransparency = 1
                hookLabel.ClipsDescendants = true
                local toggleBtn = Instance.new("TextButton", hookRow)
                toggleBtn.Size = UDim2.new(0, 50, 0, 24)
                toggleBtn.Position = UDim2.fromScale(0.72, 0.15)
                toggleBtn.BackgroundColor3 = Color3.fromRGB(0, 150, 100)
                toggleBtn.Text = "DISABLE"
                toggleBtn.TextColor3 = Color3.new(1, 1, 1)
                toggleBtn.Font = Enum.Font.Code
                toggleBtn.TextSize = 7
                self:_applyStyle(toggleBtn, 2)
                toggleBtn.MouseButton1Click:Connect(function()
                    hook.enabled = false
                    hookRow:Destroy()
                end)
            end
        end
    end
    if propHooks > 0 then
        local phLabel = Instance.new("TextLabel", ui.Grid)
        phLabel.Size = UDim2.new(1, 0, 0, 20)
        phLabel.Text = " -- PROPERTY HOOKS --"
        phLabel.TextColor3 = Color3.fromRGB(255, 180, 100)
        phLabel.BackgroundTransparency = 1
        phLabel.Font = Enum.Font.Code
        phLabel.TextSize = 9
        for propKey, hook in pairs(self.State.PropertyHooks) do
            if hook.enabled then
                local hookRow = Instance.new("Frame", ui.Grid)
                hookRow.Size = UDim2.new(1, -10, 0, 35)
                hookRow.BackgroundTransparency = 1
                local hookLabel = Instance.new("TextLabel", hookRow)
                hookLabel.Size = UDim2.new(0.7, 0, 1, 0)
                hookLabel.Text = " " .. hook.property .. " = " .. tostring(hook.value)
                hookLabel.TextColor3 = Color3.fromRGB(255, 180, 100)
                hookLabel.Font = Enum.Font.Code
                hookLabel.TextSize = 8
                hookLabel.TextXAlignment = Enum.TextXAlignment.Left
                hookLabel.BackgroundTransparency = 1
                hookLabel.ClipsDescendants = true
                local toggleBtn = Instance.new("TextButton", hookRow)
                toggleBtn.Size = UDim2.new(0, 50, 0, 24)
                toggleBtn.Position = UDim2.fromScale(0.72, 0.15)
                toggleBtn.BackgroundColor3 = Color3.fromRGB(0, 150, 100)
                toggleBtn.Text = "DISABLE"
                toggleBtn.TextColor3 = Color3.new(1, 1, 1)
                toggleBtn.Font = Enum.Font.Code
                toggleBtn.TextSize = 7
                self:_applyStyle(toggleBtn, 2)
                toggleBtn.MouseButton1Click:Connect(function()
                    self:_unhookProperty(hook.instance, hook.property)
                    hookRow:Destroy()
                end)
            end
        end
    end
    if active > 0 then
        local patchLabel = Instance.new("TextLabel", ui.Grid)
        patchLabel.Size = UDim2.new(1, 0, 0, 20)
        patchLabel.Text = " -- TABLE PATCHES --"
        patchLabel.TextColor3 = Color3.fromRGB(150, 100, 255)
        patchLabel.BackgroundTransparency = 1
        patchLabel.Font = Enum.Font.Code
        patchLabel.TextSize = 9
        for tbl, keys in pairs(self.State.ActivePatches) do
            for key, data in pairs(keys) do
                local patchRow = Instance.new("Frame", ui.Grid)
                patchRow.Size = UDim2.new(1, -10, 0, 35)
                patchRow.BackgroundTransparency = 1
                local patchLabel2 = Instance.new("TextLabel", patchRow)
                patchLabel2.Size = UDim2.new(0.7, 0, 1, 0)
                patchLabel2.Text = " [" .. key .. "] = " .. tostring(data.Value)
                patchLabel2.TextColor3 = Color3.fromRGB(150, 100, 255)
                patchLabel2.Font = Enum.Font.Code
                patchLabel2.TextSize = 8
                patchLabel2.TextXAlignment = Enum.TextXAlignment.Left
                patchLabel2.BackgroundTransparency = 1
                patchLabel2.ClipsDescendants = true
                local clearBtn = Instance.new("TextButton", patchRow)
                clearBtn.Size = UDim2.new(0, 50, 0, 24)
                clearBtn.Position = UDim2.fromScale(0.72, 0.15)
                clearBtn.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
                clearBtn.Text = "CLEAR"
                clearBtn.TextColor3 = Color3.new(1, 1, 1)
                clearBtn.Font = Enum.Font.Code
                clearBtn.TextSize = 7
                self:_applyStyle(clearBtn, 2)
                clearBtn.MouseButton1Click:Connect(function()
                    if self.State.ActivePatches[tbl] then
                        self.State.ActivePatches[tbl][key] = nil
                    end
                    patchRow:Destroy()
                end)
            end
        end
    end
end
function Modules.Overseer:_initFunctionTracer()
    if self.State.TracerActive then return end
    self.State.TracerActive = true
    self.State.CallTrace = {}
    self.State.CallFrequency = {}
    local function traceCall(func, name, args, returns)
        local call = {
            Function = name or "Unknown",
            Args = args,
            Returns = returns,
            Time = tick()
        }
        table.insert(self.State.CallTrace, call)
        if #self.State.CallTrace > self.State.MaxTraceSize then
            table.remove(self.State.CallTrace, 1)
        end
        if not self.State.CallFrequency[name] then
            self.State.CallFrequency[name] = 0
        end
        self.State.CallFrequency[name] = self.State.CallFrequency[name] + 1
    end
    self.State.TracerCallback = traceCall
end
function Modules.Overseer:_showFunctionTracer()
    local ui = self.State.UI
    ui.Grid.Visible = true
    ui.CodeFrame.Visible = false
    ui.Title.Text = "FUNCTION CALL TRACER - " .. #self.State.CallTrace .. " CALLS"
    for _, v in ipairs(ui.Grid:GetChildren()) do
        if not v:IsA("UIListLayout") then v:Destroy() end
    end
    local tracerStatusLabel = Instance.new("TextLabel", ui.Grid)
    tracerStatusLabel.Size = UDim2.new(1, -10, 0, 30)
    tracerStatusLabel.BackgroundColor3 = self.State.TracerActive and Color3.fromRGB(20, 40, 20) or Color3.fromRGB(40, 20, 20)
    tracerStatusLabel.Text = "TRACER STATUS: " .. (self.State.TracerActive and "ACTIVE" or "INACTIVE")
    tracerStatusLabel.TextColor3 = self.State.TracerActive and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(255, 100, 100)
    tracerStatusLabel.Font = Enum.Font.Code
    tracerStatusLabel.TextSize = 10
    self:_applyStyle(tracerStatusLabel, 2)
    if not self.State.TracerActive then
        local startBtn = Instance.new("TextButton", ui.Grid)
        startBtn.Size = UDim2.new(0.9, 0, 0, 35)
        startBtn.BackgroundColor3 = Color3.fromRGB(40, 100, 40)
        startBtn.Text = "START TRACING FUNCTIONS"
        startBtn.TextColor3 = Color3.fromRGB(100, 255, 100)
        startBtn.Font = Enum.Font.Code
        startBtn.TextSize = 10
        self:_applyStyle(startBtn, 2)
        startBtn.MouseButton1Click:Connect(function()
            self:_initFunctionTracer()
            self:_showFunctionTracer()
        end)
    else
        local clearBtn = Instance.new("TextButton", ui.Grid)
        clearBtn.Size = UDim2.new(0.9, 0, 0, 35)
        clearBtn.BackgroundColor3 = Color3.fromRGB(100, 40, 40)
        clearBtn.Text = "CLEAR TRACE LOG"
        clearBtn.TextColor3 = Color3.fromRGB(255, 100, 100)
        clearBtn.Font = Enum.Font.Code
        clearBtn.TextSize = 10
        self:_applyStyle(clearBtn, 2)
        clearBtn.MouseButton1Click:Connect(function()
            self.State.CallTrace = {}
            self.State.CallFrequency = {}
            self:_showFunctionTracer()
        end)
    end
    if #self.State.CallTrace > 0 then
        local freqLabel = Instance.new("TextLabel", ui.Grid)
        freqLabel.Size = UDim2.new(1, 0, 0, 20)
        freqLabel.Text = " CALL FREQUENCY (Top 10)"
        freqLabel.TextColor3 = Color3.fromRGB(200, 200, 100)
        freqLabel.BackgroundTransparency = 1
        freqLabel.Font = Enum.Font.Code
        freqLabel.TextSize = 9
        local sorted = {}
        for func, count in pairs(self.State.CallFrequency) do
            table.insert(sorted, {name = func, count = count})
        end
        table.sort(sorted, function(a, b) return a.count > b.count end)
        for i = 1, math.min(10, #sorted) do
            local data = sorted[i]
            local row, label = self:_createRow(ui.Grid, "", UDim2.new(0.7, 0, 1, 0))
            label.Text = "[" .. i .. "] " .. data.name .. " (" .. data.count .. " calls)"
            label.TextColor3 = Color3.fromRGB(100, 150, 255)
        end
    end
    if #self.State.CallTrace > 0 then
        local callLabel = Instance.new("TextLabel", ui.Grid)
        callLabel.Size = UDim2.new(1, 0, 0, 20)
        callLabel.Text = " RECENT CALLS"
        callLabel.TextColor3 = Color3.fromRGB(200, 200, 100)
        callLabel.BackgroundTransparency = 1
        callLabel.Font = Enum.Font.Code
        callLabel.TextSize = 9
        for i = math.min(20, #self.State.CallTrace), 1, -1 do
            local call = self.State.CallTrace[i]
            if call then
                local row, label = self:_createRow(ui.Grid, "", UDim2.new(0.8, 0, 1, 0))
                local argCount = call.Args and #call.Args or 0
                local status = call.Returns and call.Returns[1] and "OK" or "ERR"
                label.Text = call.Function .. " [" .. argCount .. " args] - " .. status
                label.TextColor3 = (call.Returns and call.Returns[1]) and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(255, 100, 100)
            end
        end
    end
end
function Modules.Overseer:_initEventSpy()
    if self.State.EventSpyActive then return end
    self.State.EventSpyActive = true
    self.State.EventLog = {}
    local function hookEvent(bindable, eventName)
        if not bindable or bindable:GetAttribute("_OverseerEventHooked") then return end
        pcall(function()
            bindable.Event:Connect(function(...)
                local args = {...}
                table.insert(Modules.Overseer.State.EventLog, {
                    Event = eventName,
                    Parent = bindable.Parent and bindable.Parent.Name or "Unknown",
                    Args = args,
                    Time = tick(),
                    Type = bindable.ClassName
                })
                if #Modules.Overseer.State.EventLog > Modules.Overseer.State.MaxEventLogSize then
                    table.remove(Modules.Overseer.State.EventLog, 1)
                end
            end)
            bindable:SetAttribute("_OverseerEventHooked", true)
        end)
    end
    local function scanEvents(parent)
        for _, child in ipairs(parent:GetDescendants()) do
            if child:IsA("BindableEvent") or child:IsA("BindableFunction") then
                hookEvent(child, child.Name)
            end
        end
    end
    scanEvents(ReplicatedStorage)
    scanEvents(game)
    table.insert(self.State.HookedConnections, game.DescendantAdded:Connect(function(child)
        if self.State.EventSpyActive and (child:IsA("BindableEvent") or child:IsA("BindableFunction")) then
            task.wait(0.05)
            hookEvent(child, child.Name)
        end
    end))
end
function Modules.Overseer:_showEventSpy()
    local ui = self.State.UI
    ui.Grid.Visible = true
    ui.CodeFrame.Visible = false
    ui.Title.Text = "EVENT/SIGNAL SPY - " .. #self.State.EventLog .. " FIRES"
    for _, v in ipairs(ui.Grid:GetChildren()) do
        if not v:IsA("UIListLayout") then v:Destroy() end
    end
    local spyStatusLabel = Instance.new("TextLabel", ui.Grid)
    spyStatusLabel.Size = UDim2.new(1, -10, 0, 30)
    spyStatusLabel.BackgroundColor3 = self.State.EventSpyActive and Color3.fromRGB(20, 40, 20) or Color3.fromRGB(40, 20, 20)
    spyStatusLabel.Text = "EVENT SPY STATUS: " .. (self.State.EventSpyActive and "ACTIVE" or "INACTIVE")
    spyStatusLabel.TextColor3 = self.State.EventSpyActive and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(255, 100, 100)
    spyStatusLabel.Font = Enum.Font.Code
    spyStatusLabel.TextSize = 10
    self:_applyStyle(spyStatusLabel, 2)
    if not self.State.EventSpyActive then
        local startBtn = Instance.new("TextButton", ui.Grid)
        startBtn.Size = UDim2.new(0.9, 0, 0, 35)
        startBtn.BackgroundColor3 = Color3.fromRGB(40, 100, 40)
        startBtn.Text = "START SPYING ON EVENTS"
        startBtn.TextColor3 = Color3.fromRGB(100, 255, 100)
        startBtn.Font = Enum.Font.Code
        startBtn.TextSize = 10
        self:_applyStyle(startBtn, 2)
        startBtn.MouseButton1Click:Connect(function()
            self:_initEventSpy()
            self:_showEventSpy()
        end)
    end
    if #self.State.EventLog > 0 then
        local logLabel = Instance.new("TextLabel", ui.Grid)
        logLabel.Size = UDim2.new(1, 0, 0, 20)
        logLabel.Text = " SIGNAL FIRE HISTORY"
        logLabel.TextColor3 = Color3.fromRGB(200, 200, 100)
        logLabel.BackgroundTransparency = 1
        logLabel.Font = Enum.Font.Code
        logLabel.TextSize = 9
        for i = math.min(30, #self.State.EventLog), 1, -1 do
            local event = self.State.EventLog[i]
            if event then
                local row, label = self:_createRow(ui.Grid, "", UDim2.new(0.8, 0, 1, 0))
                local parentName = event.Parent or "Unknown"
                local argCount = #event.Args
                local eventText = "[" .. event.Type .. "] " .. event.Event .. " (" .. argCount .. " args)"
                label.Text = eventText
                label.TextColor3 = (event.Type == "BindableEvent" and Color3.fromRGB(100, 200, 255) or Color3.fromRGB(150, 150, 255))
            end
        end
    end
end
function Modules.Overseer:_inspectScriptEnvironment(script)
    if not script or not script:IsA("LuaSourceContainer") then return false end
    self.State.ViewingCode = true
    local ui = self.State.UI
    ui.Grid.Visible = false
    ui.CodeFrame.Visible = true
    ui.Title.Text = "SCRIPT STATE: " .. script.Name
    local envInfo = "SCRIPT: " .. script:GetFullName() .. "\n"
    envInfo = envInfo .. "CLASS: " .. script.ClassName .. "\n"
    envInfo = envInfo .. "ENABLED: " .. tostring(script.Enabled) .. "\n\n"
    envInfo = envInfo .. "--- SOURCE CODE ---\n"
    envInfo = envInfo .. script.Source .. "\n"
    ui.CodeBox.Text = envInfo
    ui.CodeBox.TextEditable = false
end
function Modules.Overseer:_showScriptStateInspector()
    local ui = self.State.UI
    self.State.ViewingCode = false
    ui.Grid.Visible = true
    ui.CodeFrame.Visible = false
    ui.Title.Text = "SCRIPT STATE INSPECTOR"
    for _, v in ipairs(ui.Grid:GetChildren()) do
        if not v:IsA("UIListLayout") then v:Destroy() end
    end
    local infoLabel = Instance.new("TextLabel", ui.Grid)
    infoLabel.Size = UDim2.new(1, -10, 0, 40)
    infoLabel.Text = "Browse scripts in workspace and ReplicatedStorage"
    infoLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    infoLabel.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
    infoLabel.Font = Enum.Font.Code
    infoLabel.TextSize = 10
    infoLabel.TextWrapped = true
    self:_applyStyle(infoLabel, 2)
    local scanLabel = Instance.new("TextLabel", ui.Grid)
    scanLabel.Size = UDim2.new(1, -10, 0, 20)
    scanLabel.Text = " AVAILABLE SCRIPTS"
    scanLabel.TextColor3 = Color3.fromRGB(200, 200, 100)
    scanLabel.BackgroundTransparency = 1
    scanLabel.Font = Enum.Font.Code
    scanLabel.TextSize = 9
    local scripts = {}
    local function scanScripts(parent)
        for _, child in ipairs(parent:GetDescendants()) do
            if child:IsA("LocalScript") or child:IsA("Script") or child:IsA("ModuleScript") then
                table.insert(scripts, child)
            end
        end
    end
    scanScripts(Workspace)
    scanScripts(ReplicatedStorage)
    for i, script in ipairs(scripts) do
        if i > 30 then break end
        local row = Instance.new("Frame", ui.Grid)
        row.Size = UDim2.new(1, -10, 0, 35)
        row.BackgroundTransparency = 1
        local label = Instance.new("TextLabel", row)
        label.Size = UDim2.new(0.6, 0, 1, 0)
        label.Text = " " .. script.Name .. " [" .. script.ClassName .. "]"
        label.TextColor3 = Color3.fromRGB(150, 200, 255)
        label.Font = Enum.Font.Code
        label.TextSize = 9
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.BackgroundTransparency = 1
        label.ClipsDescendants = true
        local inspectBtn = Instance.new("TextButton", row)
        inspectBtn.Size = UDim2.new(0, 70, 0, 24)
        inspectBtn.Position = UDim2.fromScale(0.62, 0.15)
        inspectBtn.BackgroundColor3 = Color3.fromRGB(40, 60, 80)
        inspectBtn.Text = "INSPECT"
        inspectBtn.TextColor3 = Color3.fromRGB(0, 200, 255)
        inspectBtn.Font = Enum.Font.Code
        inspectBtn.TextSize = 8
        self:_applyStyle(inspectBtn, 2)
        inspectBtn.MouseButton1Click:Connect(function()
            self:_inspectScriptEnvironment(script)
        end)
    end
end
function Modules.Overseer:CreateUI()
    if self.State.UI then self.State.UI.Main.Visible = true return end
    local screenGui = Instance.new("ScreenGui", CoreGui)
    screenGui.Name = "Overseer_Merged_V1"
    screenGui.ResetOnSpawn = false
    local main = Instance.new("Frame", screenGui)
    main.Size = UDim2.fromOffset(850, 570)
    main.Position = UDim2.new(0.5, -425, 0.5, -285)
    main.BackgroundColor3 = self.Config.BG_COLOR
    main.BackgroundTransparency = 0.4
    main.BorderSizePixel = 0
    main.ClipsDescendants = true
    self:_applyStyle(main, 6)
    local toolbar = Instance.new("Frame", main)
    toolbar.Size = UDim2.new(1, 0, 0, 30)
    toolbar.Position = UDim2.fromOffset(0, 0)
    toolbar.BackgroundColor3 = self.Config.SECONDARY_COLOR
    local header = Instance.new("Frame", main)
    header.Size = UDim2.new(1, 0, 0, 35)
    header.Position = UDim2.fromOffset(0, 30)
    header.BackgroundColor3 = self.Config.HEADER_COLOR
    local title = Instance.new("TextLabel", header)
    title.Size = UDim2.new(1, -280, 1, 0)
    title.Position = UDim2.fromOffset(10, 0)
    title.Text = "Overseer - Unified Module & Instance Explorer"
    title.TextColor3 = self.Config.ACCENT_COLOR
    title.Font = Enum.Font.Code
    title.TextSize = 11
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.BackgroundTransparency = 1
    local modeBtn = Instance.new("TextButton", header)
    modeBtn.Size = UDim2.new(0, 70, 0, 24)
    modeBtn.Position = UDim2.new(1, -210, 0.5, -11)
    modeBtn.BackgroundColor3 = Color3.fromRGB(60, 40, 100)
    modeBtn.Text = "EXPLORER"
    modeBtn.TextColor3 = Color3.new(1, 1, 1)
    modeBtn.Font = Enum.Font.Code
    modeBtn.TextSize = 9
    self:_applyStyle(modeBtn, 2)
    local patchBtn = Instance.new("TextButton", header)
    patchBtn.Size = UDim2.new(0, 70, 0, 24)
    patchBtn.Position = UDim2.new(1, -285, 0.5, -11)
    patchBtn.BackgroundColor3 = Color3.fromRGB(80, 60, 40)
    patchBtn.Text = "PATCHES"
    patchBtn.TextColor3 = Color3.fromRGB(255, 180, 100)
    patchBtn.Font = Enum.Font.Code
    patchBtn.TextSize = 9
    self:_applyStyle(patchBtn, 2)
    local searchBtn = Instance.new("TextButton", header)
    searchBtn.Size = UDim2.new(0, 70, 0, 24)
    searchBtn.Position = UDim2.new(1, -360, 0.5, -11)
    searchBtn.BackgroundColor3 = Color3.fromRGB(60, 80, 60)
    searchBtn.Text = "SEARCH"
    searchBtn.TextColor3 = Color3.fromRGB(100, 255, 100)
    searchBtn.Font = Enum.Font.Code
    searchBtn.TextSize = 9
    self:_applyStyle(searchBtn, 2)
    local spyBtn = Instance.new("TextButton", header)
    spyBtn.Size = UDim2.new(0, 70, 0, 24)
    spyBtn.Position = UDim2.new(1, -435, 0.5, -11)
    spyBtn.BackgroundColor3 = Color3.fromRGB(100, 60, 100)
    spyBtn.Text = "SPY"
    spyBtn.TextColor3 = Color3.fromRGB(255, 100, 255)
    spyBtn.Font = Enum.Font.Code
    spyBtn.TextSize = 9
    self:_applyStyle(spyBtn, 2)
    local backBtn = Instance.new("TextButton", header)
    backBtn.Size = UDim2.new(0, 60, 0, 24)
    backBtn.Position = UDim2.new(1, -510, 0.5, -11)
    backBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
    backBtn.Text = "< BACK"
    backBtn.TextColor3 = Color3.new(1, 1, 1)
    backBtn.Font = Enum.Font.Code
    backBtn.TextSize = 10
    self:_applyStyle(backBtn, 2)
    local closeBtn = Instance.new("TextButton", header)
    closeBtn.Size = UDim2.new(0, 30, 0, 30)
    closeBtn.Position = UDim2.new(1, -35, 0, 0)
    closeBtn.Text = "X"
    closeBtn.TextColor3 = Color3.new(1, 1, 1)
    closeBtn.BackgroundTransparency = 1
    closeBtn.Font = Enum.Font.Code
    local content = Instance.new("Frame", main)
    content.Size = UDim2.new(1, 0, 1, -65)
    content.Position = UDim2.fromOffset(0, 65)
    content.BackgroundTransparency = 1
    local searchInput = Instance.new("TextBox", content)
    searchInput.Size = UDim2.new(0, 230, 0, 30)
    searchInput.Position = UDim2.fromOffset(10, 10)
    searchInput.BackgroundColor3 = self.Config.SECONDARY_COLOR
    searchInput.PlaceholderText = "SEARCH..."
    searchInput.Text = ""
    searchInput.TextColor3 = self.Config.ACCENT_COLOR
    searchInput.Font = Enum.Font.Code
    searchInput.TextSize = 10
    self:_applyStyle(searchInput, 4)
    local sidebar = Instance.new("ScrollingFrame", content)
    sidebar.Size = UDim2.new(0, 230, 1, -60)
    sidebar.Position = UDim2.fromOffset(10, 50)
    sidebar.BackgroundTransparency = 1
    sidebar.AutomaticCanvasSize = Enum.AutomaticSize.Y
    sidebar.ScrollBarThickness = 2
    local sidebarList = Instance.new("UIListLayout", sidebar)
    sidebarList.Padding = UDim.new(0, 4)
    local grid = Instance.new("ScrollingFrame", content)
    grid.Size = UDim2.new(1, -270, 1, -20)
    grid.Position = UDim2.fromOffset(260, 10)
    grid.BackgroundColor3 = self.Config.SECONDARY_COLOR
    grid.BackgroundTransparency = 0.3
    grid.AutomaticCanvasSize = Enum.AutomaticSize.Y
    grid.ScrollBarThickness = 2
    self:_applyStyle(grid, 4)
    local gridList = Instance.new("UIListLayout", grid)
    gridList.SortOrder = Enum.SortOrder.LayoutOrder
    local codeFrame = Instance.new("Frame", content)
    codeFrame.Size = grid.Size
    codeFrame.Position = grid.Position
    codeFrame.BackgroundColor3 = Color3.fromRGB(12, 12, 15)
    codeFrame.Visible = false
    self:_applyStyle(codeFrame, 4)
    local codeScroller = Instance.new("ScrollingFrame", codeFrame)
    codeScroller.Size = UDim2.new(1, -20, 1, -60)
    codeScroller.Position = UDim2.fromOffset(10, 10)
    codeScroller.BackgroundTransparency = 1
    codeScroller.ScrollBarThickness = 2
    codeScroller.AutomaticCanvasSize = Enum.AutomaticSize.XY
    local codeBox = Instance.new("TextBox", codeScroller)
    codeBox.Size = UDim2.new(1, 0, 1, 0)
    codeBox.BackgroundColor3 = Color3.fromRGB(5, 5, 7)
    codeBox.TextColor3 = Color3.fromRGB(200, 200, 200)
    codeBox.Font = Enum.Font.Code
    codeBox.TextSize = 10
    codeBox.TextXAlignment = Enum.TextXAlignment.Left
    codeBox.TextYAlignment = Enum.TextYAlignment.Top
    codeBox.ClearTextOnFocus = false
    codeBox.TextEditable = false
    codeBox.MultiLine = true
    codeBox.AutomaticSize = Enum.AutomaticSize.XY
    self:_applyStyle(codeBox, 4)
    local copyBtn = Instance.new("TextButton", codeFrame)
    copyBtn.Size = UDim2.new(0, 90, 0, 30)
    copyBtn.Position = UDim2.new(1, -280, 1, -40)
    copyBtn.BackgroundColor3 = self.Config.ACCENT_COLOR
    copyBtn.Text = "COPY"
    copyBtn.TextColor3 = Color3.new(0, 0, 0)
    copyBtn.Font = Enum.Font.Code
    copyBtn.TextSize = 10
    self:_applyStyle(copyBtn, 4)
    local editBtn = Instance.new("TextButton", codeFrame)
    editBtn.Size = UDim2.new(0, 90, 0, 30)
    editBtn.Position = UDim2.new(1, -185, 1, -40)
    editBtn.BackgroundColor3 = Color3.fromRGB(100, 70, 50)
    editBtn.Text = "EDIT"
    editBtn.TextColor3 = Color3.fromRGB(255, 180, 100)
    editBtn.Font = Enum.Font.Code
    editBtn.TextSize = 10
    self:_applyStyle(editBtn, 4)
    local applyBtn = Instance.new("TextButton", codeFrame)
    applyBtn.Size = UDim2.new(0, 90, 0, 30)
    applyBtn.Position = UDim2.new(1, -280, 1, -40)
    applyBtn.BackgroundColor3 = Color3.fromRGB(0, 150, 100)
    applyBtn.Text = "APPLY"
    applyBtn.TextColor3 = Color3.new(1, 1, 1)
    applyBtn.Font = Enum.Font.Code
    applyBtn.TextSize = 10
    applyBtn.Visible = false
    self:_applyStyle(applyBtn, 4)
    local discardBtn = Instance.new("TextButton", codeFrame)
    discardBtn.Size = UDim2.new(0, 90, 0, 30)
    discardBtn.Position = UDim2.new(1, -185, 1, -40)
    discardBtn.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
    discardBtn.Text = "DISCARD"
    discardBtn.TextColor3 = Color3.new(1, 1, 1)
    discardBtn.Font = Enum.Font.Code
    discardBtn.TextSize = 10
    discardBtn.Visible = false
    self:_applyStyle(discardBtn, 4)
    local closeCode = Instance.new("TextButton", codeFrame)
    closeCode.Size = UDim2.new(0, 90, 0, 30)
    closeCode.Position = UDim2.new(0, 10, 1, -40)
    closeCode.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
    closeCode.Text = "EXIT"
    closeCode.TextColor3 = Color3.new(1, 1, 1)
    closeCode.Font = Enum.Font.Code
    closeCode.TextSize = 10
    self:_applyStyle(closeCode, 4)
    local poisonBtn = Instance.new("TextButton", codeFrame)
    poisonBtn.Size = UDim2.new(0, 90, 0, 30)
    poisonBtn.Position = UDim2.new(1, -90, 1, -40)
    poisonBtn.BackgroundColor3 = Color3.fromRGB(80, 40, 100)
    poisonBtn.Text = "POISON"
    poisonBtn.TextColor3 = Color3.fromRGB(200, 100, 255)
    poisonBtn.Font = Enum.Font.Code
    poisonBtn.TextSize = 10
    self:_applyStyle(poisonBtn, 4)
    self.State.UI = {
        ScreenGui = screenGui,
        Main = main,
        Title = title,
        Grid = grid,
        Sidebar = sidebar,
        CodeFrame = codeFrame,
        CodeBox = codeBox,
        Search = searchInput,
        EditMode = false,
        EditTarget = nil,
        OriginalCode = ""
    }
    local scannedModules = {}
    local function RescanModules()
        for btn, _ in pairs(self.State.SidebarButtons) do
            if btn and btn.Parent then
                btn:Destroy()
            end
        end
        self.State.SidebarButtons = {}
        scannedModules = {}
        for _, v in ipairs(grid:GetChildren()) do
            if not v:IsA("UIListLayout") then
                v:Destroy()
            end
        end
        grid.Visible = true
        codeFrame.Visible = false
        title.Text = "Overseer - Unified Module & Instance Explorer"
        self.State.CurrentTable = nil
        self.State.PathStack = {}
        self.State.SelectedModule = nil
        sidebar.CanvasPosition = Vector2.new(0, 0)
        grid.CanvasPosition = Vector2.new(0, 0)
        local function scan(root)
            for _, m in ipairs(root:GetDescendants()) do
                if (m:IsA("ModuleScript") or m:IsA("LocalScript") or m:IsA("Script")) and not scannedModules[m] then
                    scannedModules[m] = true
                    self:AddModuleToList(m)
                end
            end
        end
        if ReplicatedFirst then scan(ReplicatedFirst) end
        if ReplicatedStorage then scan(ReplicatedStorage) end
        if Players.LocalPlayer then scan(Players.LocalPlayer) end
        if Workspace then scan(Workspace) end
        if getloadedmodules then
            for _, m in ipairs(getloadedmodules()) do
                if not scannedModules[m] then
                    scannedModules[m] = true
                    self:AddModuleToList(m)
                end
            end
        end
    end
    local rescanBtn = Instance.new("TextButton", toolbar)
    rescanBtn.Size = UDim2.new(0, 80, 0, 22)
    rescanBtn.Position = UDim2.new(0, 10, 0.5, -11)
    rescanBtn.BackgroundColor3 = Color3.fromRGB(30, 50, 40)
    rescanBtn.Text = "RESCAN"
    rescanBtn.TextColor3 = Color3.fromRGB(0, 255, 170)
    rescanBtn.Font = Enum.Font.Code
    rescanBtn.TextSize = 10
    self:_applyStyle(rescanBtn, 3)
    modeBtn.MouseButton1Click:Connect(function()
        if self.State.CurrentMode == "modules" then
            self.State.CurrentMode = "explorer"
            self.State.ExplorerPath = {}
            modeBtn.Text = "MODULES"
            modeBtn.BackgroundColor3 = Color3.fromRGB(40, 100, 60)
            self:PopulateExplorer(game)
        else
            self.State.CurrentMode = "modules"
            modeBtn.Text = "EXPLORER"
            modeBtn.BackgroundColor3 = Color3.fromRGB(60, 40, 100)
            RescanModules()
        end
    end)
    patchBtn.MouseButton1Click:Connect(function()
        self:_showPatchManager()
    end)
    searchBtn.MouseButton1Click:Connect(function()
        self:_showGlobalTypeSearch()
    end)
    spyBtn.MouseButton1Click:Connect(function()
        self:_showRemoteSpy()
    end)
    local tracerBtn = Instance.new("TextButton", header)
    tracerBtn.Size = UDim2.new(0, 70, 0, 24)
    tracerBtn.Position = UDim2.new(1, -510, 0.5, -11)
    tracerBtn.BackgroundColor3 = Color3.fromRGB(100, 80, 60)
    tracerBtn.Text = "TRACE"
    tracerBtn.TextColor3 = Color3.fromRGB(255, 200, 100)
    tracerBtn.Font = Enum.Font.Code
    tracerBtn.TextSize = 9
    self:_applyStyle(tracerBtn, 2)
    local eventBtn = Instance.new("TextButton", header)
    eventBtn.Size = UDim2.new(0, 70, 0, 24)
    eventBtn.Position = UDim2.new(1, -585, 0.5, -11)
    eventBtn.BackgroundColor3 = Color3.fromRGB(80, 100, 60)
    eventBtn.Text = "EVENT"
    eventBtn.TextColor3 = Color3.fromRGB(200, 255, 100)
    eventBtn.Font = Enum.Font.Code
    eventBtn.TextSize = 9
    self:_applyStyle(eventBtn, 2)
    local stateBtn = Instance.new("TextButton", header)
    stateBtn.Size = UDim2.new(0, 70, 0, 24)
    stateBtn.Position = UDim2.new(1, -660, 0.5, -11)
    stateBtn.BackgroundColor3 = Color3.fromRGB(60, 80, 100)
    stateBtn.Text = "STATE"
    stateBtn.TextColor3 = Color3.fromRGB(100, 200, 255)
    stateBtn.Font = Enum.Font.Code
    stateBtn.TextSize = 9
    self:_applyStyle(stateBtn, 2)
    tracerBtn.MouseButton1Click:Connect(function()
        self:_showFunctionTracer()
    end)
    eventBtn.MouseButton1Click:Connect(function()
        self:_initEventSpy()
        self:_showEventSpy()
    end)
    stateBtn.MouseButton1Click:Connect(function()
        self:_showScriptStateInspector()
    end)
    backBtn.Position = UDim2.new(1, -735, 0.5, -11)
    rescanBtn.MouseButton1Click:Connect(RescanModules)
    backBtn.MouseButton1Click:Connect(function()
        if self.State.CurrentMode == "modules" then
            if #self.State.PathStack > 0 then
                local prev = table.remove(self.State.PathStack)
                if type(prev) == "table" then
                    self:PopulateGrid(prev, "Parent")
                else
                    self:_showErrorInGrid("-- ERROR: Parent reference is invalid --")
                end
            end
        else
            if #self.State.ExplorerPath > 0 then
                local prev = table.remove(self.State.ExplorerPath)
                if prev and prev:IsA("Instance") and prev.Parent then
                    self:PopulateExplorer(prev)
                else
                    self:_showErrorInGrid("-- ERROR: Instance was destroyed --")
                end
            end
        end
    end)
    closeBtn.MouseButton1Click:Connect(function()
        main.Visible = false
    end)
    closeCode.MouseButton1Click:Connect(function()
        self.State.ViewingCode = false
        self.State.UI.EditMode = false
        codeFrame.Visible = false
        grid.Visible = true
        codeBox.Text = ""
        codeBox.TextEditable = false
        codeBox.ClearTextOnFocus = false
        copyBtn.Visible = true
        editBtn.Visible = true
        applyBtn.Visible = false
        discardBtn.Visible = false
        poisonBtn.Visible = false
        self.State.EditTarget = nil
        self.State.UI.OriginalCode = ""
        title.Text = "PATH: " .. (self.State.SelectedModule and self.State.SelectedModule.Name or "Main")
    end)
    poisonBtn.MouseButton1Click:Connect(function()
        self:_showPoisonOptions()
    end)
    copyBtn.MouseButton1Click:Connect(function()
        self:_setClipboard(codeBox.Text)
        copyBtn.Text = "COPIED!"
        task.wait(1)
        copyBtn.Text = "COPY"
    end)
    editBtn.MouseButton1Click:Connect(function()
        self.State.UI.EditMode = true
        self.State.UI.OriginalCode = codeBox.Text
        codeBox.TextEditable = true
        copyBtn.Visible = false
        editBtn.Visible = false
        applyBtn.Visible = true
        discardBtn.Visible = true
        title.Text = title.Text .. " [EDITING]"
    end)
    applyBtn.MouseButton1Click:Connect(function()
        local editedCode = codeBox.Text
        local success, result = pcall(function()
            local compiled = loadstring(editedCode, "EditedModule")
            if compiled then
                compiled()
                return true
            end
            return false
        end)
        if success and result then
            applyBtn.Text = "APPLIED!"
            applyBtn.BackgroundColor3 = Color3.fromRGB(0, 200, 100)
            task.wait(1.5)
            applyBtn.Text = "APPLY"
            applyBtn.BackgroundColor3 = Color3.fromRGB(0, 150, 100)
            if self.State.EditTarget then
                self.State.ActivePatches[self.State.EditTarget] = self.State.ActivePatches[self.State.EditTarget] or {}
                self.State.ActivePatches[self.State.EditTarget]["_EditedCode"] = {
                    Value = editedCode,
                    Locked = false,
                    IsFunction = false,
                    IsEdit = true
                }
            end
        else
            applyBtn.Text = "ERROR!"
            applyBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
            codeBox.Text = "-- [ERROR] " .. tostring(result) .. "\n\n" .. editedCode
            task.wait(2)
            applyBtn.Text = "APPLY"
            applyBtn.BackgroundColor3 = Color3.fromRGB(0, 150, 100)
        end
    end)
    discardBtn.MouseButton1Click:Connect(function()
        self.State.UI.EditMode = false
        codeBox.Text = self.State.UI.OriginalCode
        codeBox.TextEditable = false
        copyBtn.Visible = true
        editBtn.Visible = true
        applyBtn.Visible = false
        discardBtn.Visible = false
        title.Text = title.Text:gsub(" %[EDITING%]", "")
    end)
    searchInput:GetPropertyChangedSignal("Text"):Connect(function()
        local filter = searchInput.Text:lower()
        local visibleCount = 0
        for container, name in pairs(self.State.SidebarButtons) do
            local isVisible = filter == "" or name:lower():find(filter, 1, true) ~= nil
            container.Visible = isVisible
            if isVisible then visibleCount = visibleCount + 1 end
        end
        if filter ~= "" and visibleCount == 0 then
            local noResultsMsg = sidebar:FindFirstChild("NoResults")
            if not noResultsMsg then
                noResultsMsg = Instance.new("TextLabel", sidebar)
                noResultsMsg.Name = "NoResults"
                noResultsMsg.Size = UDim2.new(1, 0, 0, 30)
                noResultsMsg.Text = "No matching modules found"
                noResultsMsg.TextColor3 = Color3.fromRGB(150, 100, 100)
                noResultsMsg.BackgroundTransparency = 1
                noResultsMsg.Font = Enum.Font.Code
                noResultsMsg.TextSize = 9
            end
            noResultsMsg.Visible = true
        else
            local noResultsMsg = sidebar:FindFirstChild("NoResults")
            if noResultsMsg then noResultsMsg.Visible = false end
        end
    end)
    local dragging, dragStart, startPos
    local inputBegan; inputBegan = header.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = main.Position
        end
    end)
    local inputChanged; inputChanged = UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local delta = input.Position - dragStart
            main.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
    local inputEnded; inputEnded = UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)
    table.insert(self.State.HookedConnections, inputBegan)
    table.insert(self.State.HookedConnections, inputChanged)
    table.insert(self.State.HookedConnections, inputEnded)
    table.insert(self.State.HookedConnections, screenGui.Destroying:Connect(function()
        for _, conn in ipairs(self.State.HookedConnections) do
            if conn and typeof(conn) == "RBXScriptConnection" then
                pcall(function() conn:Disconnect() end)
            end
        end
        self.State.HookedConnections = {}
        self.State.UI = nil
    end))
    task.spawn(function()
        local paths = {ReplicatedStorage, Players.LocalPlayer, Workspace}
        for _, p in ipairs(paths) do
            if p then
                for _, m in ipairs(p:GetDescendants()) do
                    if m and (m:IsA("ModuleScript") or m:IsA("LocalScript") or m:IsA("Script")) and m.Parent then
                        self:AddModuleToList(m)
                    end
                end
                task.wait()
            end
        end
    end)
end
function Modules.Overseer:Initialize()
    local module = self
    RunService.Heartbeat:Connect(function()
        for tbl, keys in pairs(module.State.ActivePatches) do
            for key, data in pairs(keys) do
                if data.Locked then
                    pcall(function()
                        if setreadonly then setreadonly(tbl, false) elseif make_writeable then make_writeable(tbl) end
                        if data.IsFunction then
                            if data.Value == "TRUE" then
                                rawset(tbl, key, function() return true end)
                            elseif data.Value == "FALSE" then
                                rawset(tbl, key, function() return false end)
                            end
                        else
                            rawset(tbl, key, data.Value)
                        end
                        if setreadonly then setreadonly(tbl, true) end
                    end)
                end
            end
        end
    end)
    RegisterCommand({
        Name = "os",
        Aliases = {"opensource"},
        Description = "Opens the ultimate Overseer module, Use at your own risk."
    }, function()
        module:CreateUI()
    end)
end

Modules.OverseerCE = {
    State = {
        IsEnabled = false,
        ActivePatches = {},
        SelectedModule = nil,
        CurrentTable = nil,
        PathStack = {},
        UI = nil,
        ModuleList = {},
        PatchList = {},
        VisitedTables = {},
        MetatableChain = {},
        FreezeList = {},
        EditingRow = nil,
        SearchFilter = "",
        ShowMetatables = true,
        ShowFunctions = true,
        AutoRefresh = false,
        ScanResults = {},
        ScanInProgress = false,
        DumpedModules = {},
        InjectionHistory = {},
        AntiTamperActive = false,
        OriginalFunctions = {},
        HookedFunctions = {},
        Base64DecoderEnabled = true,
        ShowRawValues = false,
        ModuleTypeCache = {},
        DecompiledFunctions = {},
        FunctionPatches = {},
        CurrentModuleDecompiled = nil,
        UpvalueMonitors = {},
        CallTrackers = {},
        ReturnHooks = {},
        ConstantPatches = {},
        DecompilerCache = {},
	   ActivePoisons = {},
        PoisonTemplates = {},
        PoisonHistory = {},
        RequireHooks = {},
        CoroutineHijacks = {},
        MetatableTraps = {},
        CascadeTriggers = {},
        PoisonValidationResults = {},
        PoisonTypes = {
            "ReturnOverride", "TableHijack", "FunctionWrapper", 
            "ConstantPatch", "UpvalueInject", "MetatableTrap",
            "PrototypePoison", "RequireHook", "YieldSpoof",
            "CoroutineHijack", "ErrorInducer", "DataExfil",
            "AntiDetection", "SelfHeal", "CascadeTrigger"
        }
    },
    Config = {
        BG_LIGHT = Color3.fromRGB(240, 240, 240),
        BG_PANEL = Color3.fromRGB(236, 233, 216),
        BG_DARK = Color3.fromRGB(212, 208, 200),
        BG_WHITE = Color3.fromRGB(255, 255, 255),
        BORDER_DARK = Color3.fromRGB(128, 128, 128),
        BORDER_LIGHT = Color3.fromRGB(255, 255, 255),
        TEXT_BLACK = Color3.fromRGB(0, 0, 0),
        TEXT_GRAY = Color3.fromRGB(128, 128, 128),
        ACCENT_BLUE = Color3.fromRGB(49, 106, 197),
        HIGHLIGHT = Color3.fromRGB(51, 153, 255),
        FROZEN_RED = Color3.fromRGB(255, 0, 0),
        SUCCESS_GREEN = Color3.fromRGB(0, 180, 0),
        WARNING_ORANGE = Color3.fromRGB(255, 165, 0),
		POISON_PURPLE = Color3.fromRGB(138, 43, 226),
        HEADER_HEIGHT = 24,
        ROW_HEIGHT = 20,
        BUTTON_HEIGHT = 23,
        PADDING = 4,
        ANIM_SPEED = 0.15,
        HOVER_BRIGHTNESS = 1.1
    }
}
function Modules.OverseerCE:Initialize()
    if self.State.Base64DecoderEnabled then
        self:InitializeBase64Decoder()
    end
    if self.State.AntiTamperActive then
        self:SetupAntiTamper()
    end
    if self.State.AutoRefresh then
        self:SetupAutoRefresh()
    end
    print("[HEX Overseer] Initialized successfully")
    print("[HEX Overseer] Version 1.0 - Advanced Module Editor & Poison System")
end
function Modules.OverseerCE:InitializeBase64Decoder()
    local b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    self.Base64Decode = function(data)
        local bits = ''
        local chars = {}
        for i = 1, #data do
            local c = data:sub(i, i)
            local index = b64chars:find(c, 1, true)
            if index then
                bits = bits .. string.format('%06d', tonumber(string.format('%b', index - 1):sub(3)))
            end
        end
        for i = 1, #bits, 8 do
            local byte = bits:sub(i, i + 7)
            if #byte == 8 then
                table.insert(chars, string.char(tonumber(byte, 2)))
            end
        end
        return table.concat(chars)
    end
    self.Base64Encode = function(data)
        local bytes = {}
        for i = 1, #data do
            table.insert(bytes, string.format('%08d', tonumber(string.format('%b', data:byte(i)):sub(3))))
        end
        local bits = table.concat(bytes)
        local result = {}
        for i = 1, #bits, 6 do
            local six = bits:sub(i, i + 5)
            if #six == 6 then
                table.insert(result, b64chars:sub(tonumber(six, 2) + 1, tonumber(six, 2) + 1))
            end
        end
        while #result % 4 ~= 0 do
            table.insert(result, '=')
        end
        return table.concat(result)
    end
end
function Modules.OverseerCE:SetupAntiTamper()
    local protectedFunctions = {
        "RemovePoison",
        "ClearAllPoisons",
        "Initialize",
        "SetupAntiTamper"
    }
    for _, funcName in ipairs(protectedFunctions) do
        local func = self[funcName]
        if type(func) == "function" then
            self.State.OriginalFunctions[funcName] = func
        end
    end
    self.AntiTamperConnection = RunService.Heartbeat:Connect(function()
        for funcName, originalFunc in pairs(self.State.OriginalFunctions) do
            if self[funcName] ~= originalFunc then
                warn("[HEX Overseer] TAMPERING DETECTED: Function " .. funcName .. " was modified!")
                self[funcName] = originalFunc
            end
        end
    end)
    self.State.AntiTamperActive = true
end
function Modules.OverseerCE:DisableAntiTamper()
    if self.AntiTamperConnection then
        self.AntiTamperConnection:Disconnect()
        self.AntiTamperConnection = nil
    end
    self.State.AntiTamperActive = false
end
function Modules.OverseerCE:SetupAutoRefresh()
    if self.AutoRefreshConnection then
        self.AutoRefreshConnection:Disconnect()
    end
    self.AutoRefreshConnection = RunService.Heartbeat:Connect(function()
        if self.State.AutoRefresh and self.State.UI then
            if self.State.CurrentTable then
                task.spawn(function()
                    self:RefreshInspector()
                end)
            end
        end
    end)
end
function Modules.OverseerCE:ToggleAutoRefresh()
    self.State.AutoRefresh = not self.State.AutoRefresh
    if self.State.AutoRefresh then
        self:SetupAutoRefresh()
    elseif self.AutoRefreshConnection then
        self.AutoRefreshConnection:Disconnect()
        self.AutoRefreshConnection = nil
    end
    return self.State.AutoRefresh
end
function Modules.OverseerCE:FreezeValue(tbl, key, frozenValue)
    if type(tbl) ~= "table" then
        return false, "Target is not a table"
    end
    local freezeId = tostring(tbl) .. "_" .. tostring(key)
    if self.State.FreezeList[freezeId] then
        return false, "Value already frozen"
    end
    self.State.FreezeList[freezeId] = {
        Table = tbl,
        Key = key,
        FrozenValue = frozenValue,
        OriginalValue = tbl[key],
        Connection = nil
    }
    if setreadonly then pcall(setreadonly, tbl, false) end
    tbl[key] = frozenValue
    if setreadonly then pcall(setreadonly, tbl, true) end
    self.State.FreezeList[freezeId].Connection = RunService.Heartbeat:Connect(function()
        if tbl[key] ~= frozenValue then
            if setreadonly then pcall(setreadonly, tbl, false) end
            tbl[key] = frozenValue
            if setreadonly then pcall(setreadonly, tbl, true) end
        end
    end)
    return true, freezeId
end
function Modules.OverseerCE:UnfreezeValue(freezeId)
    local freeze = self.State.FreezeList[freezeId]
    if not freeze then
        return false, "Freeze not found"
    end
    if freeze.Connection then
        freeze.Connection:Disconnect()
    end
    if setreadonly then pcall(setreadonly, freeze.Table, false) end
    freeze.Table[freeze.Key] = freeze.OriginalValue
    if setreadonly then pcall(setreadonly, freeze.Table, true) end
    self.State.FreezeList[freezeId] = nil
    return true
end
function Modules.OverseerCE:UnfreezeAll()
    local count = 0
    for freezeId in pairs(self.State.FreezeList) do
        if self:UnfreezeValue(freezeId) then
            count = count + 1
        end
    end
    return count
end
function Modules.OverseerCE:ScanForModules(pattern, scanDepth)
    scanDepth = scanDepth or 3
    self.State.ScanInProgress = true
    self.State.ScanResults = {}
    local function scanTable(tbl, path, depth)
        if depth > scanDepth then return end
        if type(tbl) ~= "table" then return end
        for key, value in pairs(tbl) do
            local newPath = path .. "." .. tostring(key)
            if pattern then
                if string.find(tostring(key):lower(), pattern:lower()) or 
                   string.find(newPath:lower(), pattern:lower()) then
                    table.insert(self.State.ScanResults, {
                        Path = newPath,
                        Value = value,
                        Type = type(value),
                        Key = key
                    })
                end
            else
                table.insert(self.State.ScanResults, {
                    Path = newPath,
                    Value = value,
                    Type = type(value),
                    Key = key
                })
            end
            if type(value) == "table" and depth < scanDepth then
                scanTable(value, newPath, depth + 1)
            end
        end
    end
    local scanLocations = {
        {name = "ReplicatedStorage", obj = ReplicatedStorage},
        {name = "Workspace", obj = Workspace},
        {name = "Players.LocalPlayer", obj = Players.LocalPlayer},
        {name = "_G", obj = _G}
    }
    for _, location in ipairs(scanLocations) do
        scanTable(location.obj, location.name, 0)
    end
    self.State.ScanInProgress = false
    return self.State.ScanResults
end
function Modules.OverseerCE:GetScanResults()
    return self.State.ScanResults
end
function Modules.OverseerCE:TraceMetatableChain(tbl)
    self.State.MetatableChain = {}
    local current = tbl
    local depth = 0
    local maxDepth = 20
    while depth < maxDepth do
        local mt, method = self:GetRawMetatable(current)
        if not mt then break end
        table.insert(self.State.MetatableChain, {
            Depth = depth,
            Metatable = mt,
            Method = method,
            HasIndex = mt.__index ~= nil,
            HasNewIndex = mt.__newindex ~= nil,
            IsLocked = pcall(getmetatable, current) == false
        })
        if type(mt.__index) == "table" then
            current = mt.__index
            depth = depth + 1
        else
            break
        end
    end
    return self.State.MetatableChain
end
function Modules.OverseerCE:PoisonYieldSpoof(func, fakeYieldTime)
    if type(func) ~= "function" then
        return false, "Target must be a function"
    end
    if not hookfunction then
        return false, "hookfunction not available"
    end
    fakeYieldTime = fakeYieldTime or 0.1
    local success, originalFunc = pcall(function()
        return hookfunction(func, function(...)
            local startTime = tick()
            local results = {pcall(func, ...)}
            local elapsed = tick() - startTime
            if elapsed < fakeYieldTime then
                task.wait(fakeYieldTime - elapsed)
            end
            if results[1] then
                return select(2, unpack(results))
            else
                error(results[2], 2)
            end
        end)
    end)
    if not success then
        return false, "Failed to hook function"
    end
    local poisonData = {
        Id = #self.State.ActivePoisons + 1,
        Type = "YieldSpoof",
        TargetFunction = func,
        OriginalFunction = originalFunc,
        FakeYieldTime = fakeYieldTime,
        Timestamp = os.time(),
        Active = true
    }
    table.insert(self.State.ActivePoisons, poisonData)
    return true, poisonData.Id
end
function Modules.OverseerCE:PoisonCoroutineHijack(callback)
    if not hookfunction then
        return false, "hookfunction not available"
    end
    local originalCreate = coroutine.create
    local originalWrap = coroutine.wrap
    local originalResume = coroutine.resume
    local hijackedCreate = function(func)
        if callback then
            callback("create", func)
        end
        return originalCreate(func)
    end
    local hijackedWrap = function(func)
        if callback then
            callback("wrap", func)
        end
        return originalWrap(func)
    end
    local hijackedResume = function(co, ...)
        if callback then
            callback("resume", co, ...)
        end
        return originalResume(co, ...)
    end
    coroutine.create = hijackedCreate
    coroutine.wrap = hijackedWrap
    coroutine.resume = hijackedResume
    local poisonData = {
        Id = #self.State.ActivePoisons + 1,
        Type = "CoroutineHijack",
        OriginalCreate = originalCreate,
        OriginalWrap = originalWrap,
        OriginalResume = originalResume,
        Callback = callback,
        Timestamp = os.time(),
        Active = true
    }
    table.insert(self.State.ActivePoisons, poisonData)
    table.insert(self.State.CoroutineHijacks, poisonData)
    return true, poisonData.Id
end
function Modules.OverseerCE:PoisonErrorInducer(func, condition, errorMsg)
    if type(func) ~= "function" then
        return false, "Target must be a function"
    end
    if not hookfunction then
        return false, "hookfunction not available"
    end
    errorMsg = errorMsg or "Induced error"
    local success, originalFunc = pcall(function()
        return hookfunction(func, function(...)
            local shouldError = false
            if type(condition) == "function" then
                shouldError = condition(...)
            elseif condition == true then
                shouldError = true
            end
            if shouldError then
                error(errorMsg, 2)
            end
            return func(...)
        end)
    end)
    if not success then
        return false, "Failed to hook function"
    end
    local poisonData = {
        Id = #self.State.ActivePoisons + 1,
        Type = "ErrorInducer",
        TargetFunction = func,
        OriginalFunction = originalFunc,
        Condition = condition,
        ErrorMessage = errorMsg,
        Timestamp = os.time(),
        Active = true
    }
    table.insert(self.State.ActivePoisons, poisonData)
    return true, poisonData.Id
end
function Modules.OverseerCE:PoisonDataExfil(func, storageTable)
    if type(func) ~= "function" then
        return false, "Target must be a function"
    end
    if not hookfunction then
        return false, "hookfunction not available"
    end
    storageTable = storageTable or {}
    local success, originalFunc = pcall(function()
        return hookfunction(func, function(...)
            local callData = {
                Timestamp = tick(),
                Arguments = {...},
                Stacktrace = debug.traceback()
            }
            table.insert(storageTable, callData)
            local results = {func(...)}
            callData.Returns = results
            return unpack(results)
        end)
    end)
    if not success then
        return false, "Failed to hook function"
    end
    local poisonData = {
        Id = #self.State.ActivePoisons + 1,
        Type = "DataExfil",
        TargetFunction = func,
        OriginalFunction = originalFunc,
        StorageTable = storageTable,
        Timestamp = os.time(),
        Active = true
    }
    table.insert(self.State.ActivePoisons, poisonData)
    return true, poisonData.Id, storageTable
end
function Modules.OverseerCE:PoisonAntiDetection(func, legitimateSignature)
    if type(func) ~= "function" then
        return false, "Target must be a function"
    end
    local signature = legitimateSignature or {
        source = "=[C]",
        what = "C",
        name = "legitimate_function"
    }
    if debug and debug.getinfo then
        local originalGetInfo = debug.getinfo
        debug.getinfo = function(target, ...)
            if target == func then
                return signature
            end
            return originalGetInfo(target, ...)
        end
    end
    local poisonData = {
        Id = #self.State.ActivePoisons + 1,
        Type = "AntiDetection",
        TargetFunction = func,
        FakeSignature = signature,
        Timestamp = os.time(),
        Active = true
    }
    table.insert(self.State.ActivePoisons, poisonData)
    return true, poisonData.Id
end
function Modules.OverseerCE:PoisonSelfHeal(poisonId, checkInterval)
    local poison = self.State.ActivePoisons[poisonId]
    if not poison then
        return false, "Poison not found"
    end
    checkInterval = checkInterval or 1
    local selfHealFunc
    selfHealFunc = function()
        if not poison.Active then return end
        local isValid = false
        if poison.Type == "TableHijack" then
            local testKey = next(poison.Overrides)
            if testKey then
                isValid = poison.Target[testKey] == poison.Overrides[testKey]
            end
        elseif poison.Type == "UpvalueInject" then
            local success, currentValue = pcall(getupvalue, poison.TargetFunction, poison.UpvalueIndex)
            isValid = success and currentValue == poison.NewValue
        end
        if not isValid then
            warn("[HEX Overseer] Self-heal: Restoring poison #" .. poisonId)
            if poison.Type == "TableHijack" then
                for key, value in pairs(poison.Overrides) do
                    poison.Target[key] = value
                end
            elseif poison.Type == "UpvalueInject" then
                pcall(setupvalue, poison.TargetFunction, poison.UpvalueIndex, poison.NewValue)
            end
        end
        task.wait(checkInterval)
        selfHealFunc()
    end
    poison.SelfHealConnection = task.spawn(selfHealFunc)
    return true
end
function Modules.OverseerCE:PoisonCascadeTrigger(triggerFunc, poisonSequence, delay)
    if type(triggerFunc) ~= "function" then
        return false, "Trigger must be a function"
    end
    if not hookfunction then
        return false, "hookfunction not available"
    end
    delay = delay or 0.1
    local success, originalFunc = pcall(function()
        return hookfunction(triggerFunc, function(...)
            local results = {triggerFunc(...)}
            task.spawn(function()
                for i, poisonId in ipairs(poisonSequence) do
                    task.wait(delay)
                    local poison = self.State.ActivePoisons[poisonId]
                    if poison and not poison.Active then
                        poison.Active = true
                        warn("[HEX Overseer] Cascade: Activated poison #" .. poisonId)
                    end
                end
            end)
            return unpack(results)
        end)
    end)
    if not success then
        return false, "Failed to hook trigger function"
    end
    local poisonData = {
        Id = #self.State.ActivePoisons + 1,
        Type = "CascadeTrigger",
        TriggerFunction = triggerFunc,
        OriginalFunction = originalFunc,
        PoisonSequence = poisonSequence,
        Delay = delay,
        Timestamp = os.time(),
        Active = true
    }
    table.insert(self.State.ActivePoisons, poisonData)
    table.insert(self.State.CascadeTriggers, poisonData)
    return true, poisonData.Id
end
function Modules.OverseerCE:GetRawMetatable(tbl)
    local mt = nil
    local success, result = pcall(getmetatable, tbl)
    if success and result then
        return result, "standard"
    end
    if getrawmetatable then
        success, result = pcall(getrawmetatable, tbl)
        if success and result then
            return result, "getrawmetatable"
        end
    end
    if debug and debug.getmetatable then
        success, result = pcall(debug.getmetatable, tbl)
        if success and result then
            return result, "debug.getmetatable"
        end
    end
    if hookmetamethod then
        local old
        success, result = pcall(function()
            old = hookmetamethod(game, "__index", function() end)
            hookmetamethod(game, "__index", old)
            return getmetatable(tbl)
        end)
        if success and result then
            return result, "hookmetamethod"
        end
    end
    return nil, "failed"
end
function Modules.OverseerCE:UnlockMetatable(tbl)
    if type(tbl) ~= "table" then
        return false, "Not a table"
    end
    local mt, method = self:GetRawMetatable(tbl)
    if not mt then
        return false, "No metatable found"
    end
    local isLocked = false
    local lockCheckSuccess, lockCheckResult = pcall(function()
        return getmetatable(tbl)
    end)
    if not lockCheckSuccess or lockCheckResult == nil then
        isLocked = true
    end
    local unlocked = false
    local unlockMethod = nil
    if setrawmetatable and isLocked then
        local success = pcall(function()
            setrawmetatable(tbl, mt)
        end)
        if success then
            unlocked = true
            unlockMethod = "setrawmetatable"
        end
    end
    if not unlocked and mt then
        local success = pcall(function()
            if setreadonly then setreadonly(mt, false) end
            rawset(mt, "__metatable", nil)
            if setreadonly then setreadonly(mt, true) end
        end)
        if success then
            unlocked = true
            unlockMethod = "removed __metatable"
        end
    end
    if not unlocked and mt then
        local newMt = {}
        for k, v in pairs(mt) do
            newMt[k] = v
        end
        newMt.__metatable = nil
        local success = pcall(function()
            if setreadonly then setreadonly(tbl, false) end
            if setmetatable then
                setmetatable(tbl, newMt)
            end
            if setreadonly then setreadonly(tbl, true) end
        end)
        if success then
            unlocked = true
            unlockMethod = "replaced metatable"
        end
    end
    if unlocked then
        return true, "Unlocked using: " .. (unlockMethod or "unknown")
    else
        return true, "Readonly access via: " .. method
    end
end
function Modules.OverseerCE:DecompileFunction(func)
    if type(func) ~= "function" then
        return nil, "Not a function"
    end
    local funcStr = tostring(func)
    if self.State.DecompilerCache[funcStr] then
        return self.State.DecompilerCache[funcStr]
    end
    local decompiled = {
        Address = funcStr,
        Info = {},
        Constants = {},
        Upvalues = {},
        Protos = {},
        SourceCode = nil,
        AccessMethod = "basic"
    }
    if debug and debug.getinfo then
        local success, info = pcall(debug.getinfo, func)
        if success then
            decompiled.Info = {
                Source = info.source or "?",
                ShortSource = info.short_src or "?",
                LineDefined = info.linedefined or -1,
                LastLineDefined = info.lastlinedefined or -1,
                NumParams = info.nparams or 0,
                IsVararg = info.isvararg or false,
                What = info.what or "?",
                Name = info.name or "<anonymous>"
            }
            decompiled.AccessMethod = "debug.getinfo"
        end
    elseif getinfo then
        local success, info = pcall(getinfo, func)
        if success then
            decompiled.Info = info
            decompiled.AccessMethod = "getinfo"
        end
    end
    if getconstants then
        local success, constants = pcall(getconstants, func)
        if success and constants then
            decompiled.Constants = constants
        end
    elseif debug and debug.getconstants then
        local success, constants = pcall(debug.getconstants, func)
        if success and constants then
            decompiled.Constants = constants
        end
    end
    if getupvalues then
        local success, upvalues = pcall(getupvalues, func)
        if success and upvalues then
            decompiled.Upvalues = upvalues
        end
    elseif debug and debug.getupvalues then
        local success, upvalues = pcall(debug.getupvalues, func)
        if success and upvalues then
            decompiled.Upvalues = upvalues
        end
    end
    if getprotos then
        local success, protos = pcall(getprotos, func)
        if success and protos then
            decompiled.Protos = protos
        end
    end
    if decompile then
        local success, source = pcall(decompile, func)
        if success and source then
            decompiled.SourceCode = source
        end
    end
    self.State.DecompilerCache[funcStr] = decompiled
    return decompiled
end
function Modules.OverseerCE:DecompileModuleScript(moduleScript)
    if not moduleScript or not moduleScript:IsA("ModuleScript") then
        return nil, "Not a ModuleScript"
    end
    local decompiled = {
        Name = moduleScript.Name,
        FullName = moduleScript:GetFullName(),
        SourceCode = nil,
        DecompileMethod = "none",
        Functions = {},
        RequireSuccess = false,
        ModuleContent = nil
    }
    if decompile then
        local success, source = pcall(decompile, moduleScript)
        if success and source then
            decompiled.SourceCode = source
            decompiled.DecompileMethod = "decompile(ModuleScript)"
            print("[Decompiler] âœ“ Decompiled module via decompile()")
        end
    end
    if not decompiled.SourceCode then
        local success, moduleFunc = pcall(function()
            return require(moduleScript)
        end)
        if success then
            decompiled.RequireSuccess = true
            decompiled.ModuleContent = moduleFunc
            if type(moduleFunc) == "function" and decompile then
                local funcSuccess, funcSource = pcall(decompile, moduleFunc)
                if funcSuccess and funcSource then
                    decompiled.SourceCode = funcSource
                    decompiled.DecompileMethod = "decompile(require(module))"
                    print("[Decompiler] âœ“ Decompiled via require() return")
                end
            end
            if type(moduleFunc) == "table" then
                local functionCount = 0
                for key, value in pairs(moduleFunc) do
                    if type(value) == "function" then
                        local funcDecomp = self:DecompileFunction(value)
                        if funcDecomp and funcDecomp.SourceCode then
                            table.insert(decompiled.Functions, {
                                Name = tostring(key),
                                Decompiled = funcDecomp
                            })
                            functionCount = functionCount + 1
                        end
                    end
                end
                if functionCount > 0 then
                    local compositeParts = {
                        "-- Module: " .. decompiled.Name,
                        "-- Decompiled " .. functionCount .. " functions",
                        "-- Original module returns a table",
                        "",
                        "local module = {}",
                        ""
                    }
                    for _, funcData in ipairs(decompiled.Functions) do
                        table.insert(compositeParts, "-- Function: " .. funcData.Name)
                        table.insert(compositeParts, "function module." .. funcData.Name .. "()")
                        if funcData.Decompiled.SourceCode then
                            table.insert(compositeParts, funcData.Decompiled.SourceCode)
                        else
                            table.insert(compositeParts, "    -- Could not decompile")
                        end
                        table.insert(compositeParts, "end")
                        table.insert(compositeParts, "")
                    end
                    table.insert(compositeParts, "return module")
                    decompiled.SourceCode = table.concat(compositeParts, "\n")
                    decompiled.DecompileMethod = "reconstructed from table functions"
                    print("[Decompiler] âœ“ Reconstructed from " .. functionCount .. " functions")
                end
            end
        end
    end
    if not decompiled.SourceCode then
        local infoParts = {
            "-- Module: " .. decompiled.Name,
            "-- Path: " .. decompiled.FullName,
            "-- Status: Could not decompile source code",
            "",
            "-- This can happen because:",
            "-- 1. Your executor doesn't have a decompiler",
            "-- 2. The module uses bytecode protection",
            "-- 3. The module is a native C module",
            "",
            "-- However, you can still:",
            "-- â€¢ View the module structure in the Table Inspector",
            "-- â€¢ Decompile individual functions from the function browser",
            "-- â€¢ Use the Scanner to find specific values",
            "",
        }
        if decompiled.RequireSuccess and decompiled.ModuleContent then
            table.insert(infoParts, "-- Module loaded successfully!")
            table.insert(infoParts, "-- Type: " .. type(decompiled.ModuleContent))
            if type(decompiled.ModuleContent) == "table" then
                table.insert(infoParts, "")
                table.insert(infoParts, "-- Module Structure:")
                local count = 0
                for k, v in pairs(decompiled.ModuleContent) do
                    if count < 20 then
                        table.insert(infoParts, "-- " .. tostring(k) .. " = " .. type(v))
                        count = count + 1
                    end
                end
                if count >= 20 then
                    table.insert(infoParts, "-- ... and more entries")
                end
            end
        else
            table.insert(infoParts, "-- Module could not be required")
        end
        decompiled.SourceCode = table.concat(infoParts, "\n")
        decompiled.DecompileMethod = "fallback info"
    end
    return decompiled
end
function Modules.OverseerCE:PatchFunctionReturn(func, returnValue)
    if type(func) ~= "function" then
        return false, "Not a function"
    end
    local patchId = tostring(func) .. "_return"
    if not hookfunction then
        return false, "hookfunction not available"
    end
    local success, originalFunc = pcall(function()
        return hookfunction(func, function(...)
            return returnValue
        end)
    end)
    if success then
        self.State.ReturnHooks[patchId] = {
            Original = originalFunc,
            ReturnValue = returnValue,
            Function = func,
            Timestamp = os.time()
        }
        return true, "Return value hooked"
    else
        return false, "Hook failed: " .. tostring(originalFunc)
    end
end
function Modules.OverseerCE:PatchFunctionUpvalue(func, upvalueName, newValue)
    if type(func) ~= "function" then
        return false, "Not a function"
    end
    if not setupvalue then
        return false, "setupvalue not available"
    end
    local upvalues = {}
    if getupvalues then
        local success, uvs = pcall(getupvalues, func)
        if success then upvalues = uvs end
    end
    local uvIndex = nil
    for i, name in pairs(upvalues) do
        if name == upvalueName or i == tonumber(upvalueName) then
            uvIndex = i
            break
        end
    end
    if not uvIndex then
        return false, "Upvalue not found: " .. upvalueName
    end
    local success, result = pcall(setupvalue, func, uvIndex, newValue)
    if success then
        local patchId = tostring(func) .. "_uv_" .. upvalueName
        self.State.UpvalueMonitors[patchId] = {
            Function = func,
            UpvalueName = upvalueName,
            UpvalueIndex = uvIndex,
            NewValue = newValue,
            Timestamp = os.time()
        }
        return true, "Upvalue patched"
    else
        return false, "Failed to set upvalue"
    end
end
function Modules.OverseerCE:PatchFunctionConstant(func, constantIndex, newValue)
    if type(func) ~= "function" then
        return false, "Not a function"
    end
    if not setconstant then
        return false, "setconstant not available"
    end
    local success, result = pcall(setconstant, func, constantIndex, newValue)
    if success then
        local patchId = tostring(func) .. "_const_" .. constantIndex
        self.State.ConstantPatches[patchId] = {
            Function = func,
            ConstantIndex = constantIndex,
            NewValue = newValue,
            Timestamp = os.time()
        }
        return true, "Constant patched"
    else
        return false, "Failed to set constant: " .. tostring(result)
    end
end
function Modules.OverseerCE:HookFunctionCalls(func, callback)
    if type(func) ~= "function" then
        return false, "Not a function"
    end
    if not hookfunction then
        return false, "hookfunction not available"
    end
    local callCount = 0
    local patchId = tostring(func) .. "_tracker"
    local success, originalFunc = pcall(function()
        return hookfunction(func, function(...)
            callCount = callCount + 1
            if self.State.CallTrackers[patchId] then
                table.insert(self.State.CallTrackers[patchId].Calls, {
                    Timestamp = tick(),
                    Args = {...}
                })
            end
            if callback then
                callback(callCount, ...)
            end
            return originalFunc(...)
        end)
    end)
    if success then
        self.State.CallTrackers[patchId] = {
            Original = originalFunc,
            Function = func,
            CallCount = callCount,
            Calls = {},
            Callback = callback,
            Timestamp = os.time()
        }
        return true, "Call tracker installed"
    else
        return false, "Hook failed"
    end
end
function Modules.OverseerCE:ReplaceClosure(oldFunc, newFunc)
    if type(oldFunc) ~= "function" or type(newFunc) ~= "function" then
        return false, "Both arguments must be functions"
    end
    if replaceclosure then
        local success = pcall(replaceclosure, oldFunc, newFunc)
        if success then
            return true, "Closure replaced using replaceclosure"
        end
    end
    if hookfunction then
        local success = pcall(hookfunction, oldFunc, newFunc)
        if success then
            return true, "Closure replaced using hookfunction"
        end
    end
    return false, "No closure replacement method available"
end
function Modules.OverseerCE:GetFunctionCallstack(func)
    if type(func) ~= "function" then
        return nil, "Not a function"
    end
    local callstack = {}
    if debug and debug.traceback then
        local trace = debug.traceback()
        for line in trace:gmatch("[^\r\n]+") do
            table.insert(callstack, line)
        end
    end
    return callstack
end
function Modules.OverseerCE:PopulateFunctionList(panel)
    if not self.State.CurrentTable then 
        self:_showNotification("No module loaded to scan", "warning")
        return 
    end
    local listArea = panel:FindFirstChild("FunctionListScroll", true)
    if not listArea then 
        warn("[Decompiler] Could not find FunctionListScroll")
        self:_showNotification("Error: Function list area not found", "error")
        return 
    end
    for _, child in ipairs(listArea:GetChildren()) do
        if not child:IsA("UIListLayout") then 
            child:Destroy() 
        end
    end
    local foundFunctions = {}
    local successCount = 0
    local errorCount = 0
    for k, v in pairs(self.State.CurrentTable) do
        if type(v) == "function" then
            table.insert(foundFunctions, {Name = tostring(k), Func = v, Source = "Module"})
            successCount = successCount + 1
        end
    end
    local mt = self:GetRawMetatable(self.State.CurrentTable)
    if mt and mt.__index then
        local target = mt.__index
        if type(target) == "table" then
            for k, v in pairs(target) do
                if type(v) == "function" then
                    table.insert(foundFunctions, {Name = "[MT] "..tostring(k), Func = v, Source = "Metatable"})
                    successCount = successCount + 1
                end
            end
        end
    end
    if #foundFunctions == 0 then
        self:_showNotification("No functions found in this module", "warning")
        local noFuncLabel = Instance.new("TextLabel", listArea)
        noFuncLabel.Size = UDim2.new(1, -4, 0, 40)
        noFuncLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 220)
        noFuncLabel.Text = "No functions found.\n\nThis module may only\ncontain data or tables."
        noFuncLabel.TextColor3 = self.Config.TEXT_BLACK
        noFuncLabel.Font = Enum.Font.SourceSans
        noFuncLabel.TextSize = 9
        noFuncLabel.TextWrapped = true
        noFuncLabel.BorderSizePixel = 0
        self:_createBorder(noFuncLabel, true)
        return
    end
    for _, data in ipairs(foundFunctions) do
        local btn = self:_createButton(listArea, data.Name, UDim2.new(1, -4, 0, 20), UDim2.new(0,0,0,0), function()
            self:_showNotification("Analyzing: " .. data.Name, "info")
            print("[Decompiler] Decompiling function:", data.Name)
            local decomp = self:DecompileFunction(data.Func)
            if decomp then
                self.State.CurrentDecompiledFunction = decomp
                self.State.CurrentDecompiledFunctionRef = data.Func
                self.State.CurrentDecompiledName = data.Name
                self:SwitchDecompilerTab("Info", panel)
                self:_showNotification("Function decompiled: " .. data.Name, "success")
            else
                self:_showNotification("Failed to decompile function", "error")
            end
        end)
        btn.TextXAlignment = Enum.TextXAlignment.Left
        btn.TextSize = 9
        btn.TextWrapped = false
        btn.TextTruncate = Enum.TextTruncate.AtEnd
        btn.ZIndex = 103
        local btnPadding = Instance.new("UIPadding", btn)
        btnPadding.PaddingLeft = UDim.new(0, 4)
        if data.Source == "Metatable" then
            btn.TextColor3 = Color3.fromRGB(0, 120, 215)
        end
    end
    self:_showNotification(string.format("Found %d functions", #foundFunctions), "success")
    print(string.format("[Decompiler] Found %d functions in module", #foundFunctions))
end
function Modules.OverseerCE:CreateDecompilerPanel(parent)
    local panel = self:_createPanel(parent, UDim2.fromOffset(4, 4), UDim2.new(1, -8, 1, -8), "Function Decompiler & Browser")
    panel.ZIndex = 100
    panel.ClipsDescendants = true
    local browserFrame = Instance.new("Frame", panel)
    browserFrame.Size = UDim2.new(0.25, -6, 1, -35)
    browserFrame.Position = UDim2.fromOffset(4, 28)
    browserFrame.BackgroundColor3 = self.Config.BG_DARK
    browserFrame.BorderSizePixel = 0
    browserFrame.ZIndex = 101
    self:_createBorder(browserFrame, true)
    local browserLabel = Instance.new("TextLabel", browserFrame)
    browserLabel.Size = UDim2.new(1, 0, 0, 18)
    browserLabel.Position = UDim2.fromOffset(0, 0)
    browserLabel.Text = "Functions in Module"
    browserLabel.Font = Enum.Font.SourceSansBold
    browserLabel.TextSize = 10
    browserLabel.BackgroundColor3 = self.Config.BG_PANEL
    browserLabel.TextColor3 = self.Config.TEXT_BLACK
    browserLabel.BorderSizePixel = 0
    browserLabel.ZIndex = 102
    local listScroll = Instance.new("ScrollingFrame", browserFrame)
    listScroll.Name = "FunctionListScroll"
    listScroll.Size = UDim2.new(1, -4, 1, -45)
    listScroll.Position = UDim2.fromOffset(2, 20)
    listScroll.BackgroundColor3 = self.Config.BG_WHITE
    listScroll.BorderSizePixel = 0
    listScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
    listScroll.ScrollBarThickness = 4
    listScroll.ZIndex = 102
    self:_createBorder(listScroll, true)
    local listLayout = Instance.new("UIListLayout", listScroll)
    listLayout.Padding = UDim.new(0, 1)
    local scanBtn = self:_createButton(browserFrame, "Scan Module", UDim2.new(1, -4, 0, 20), UDim2.new(0, 2, 1, -22), function()
        if not self.State.CurrentTable then
            self:_showNotification("No module loaded. Select a module from the left panel first.", "warning")
            return
        end
        self:PopulateFunctionList(panel)
        self:_showNotification("Scanning for functions...", "info")
    end)
    local decompileModuleBtn = self:_createButton(browserFrame, "Decompile Module", UDim2.new(1, -4, 0, 20), UDim2.new(0, 2, 1, -44), function()
        if not self.State.SelectedModule then
            self:_showNotification("No module selected. Select one from the main Module List first.", "warning")
            return
        end
        self:_showNotification("Decompiling entire module...", "info")
        local moduleDecomp = self:DecompileModuleScript(self.State.SelectedModule)
        if moduleDecomp then
            self.State.CurrentModuleDecompiled = moduleDecomp
            self:SwitchDecompilerTab("ModuleSource", panel)
            self:_showNotification("Module decompiled: " .. moduleDecomp.Name, "success")
        else
            self:_showNotification("Failed to decompile module", "error")
        end
    end)
    decompileModuleBtn.ZIndex = 102
    decompileModuleBtn.TextSize = 9
    decompileModuleBtn.BackgroundColor3 = Color3.fromRGB(100, 200, 100)
    scanBtn.ZIndex = 102
    scanBtn.TextSize = 9
    local contentContainer = Instance.new("Frame", panel)
    contentContainer.Size = UDim2.new(0.75, -6, 1, -35)
    contentContainer.Position = UDim2.new(0.25, 2, 0, 28)
    contentContainer.BackgroundTransparency = 1
    contentContainer.ZIndex = 100
    local tabContainer = Instance.new("Frame", contentContainer)
    tabContainer.Size = UDim2.new(1, 0, 0, 26)
    tabContainer.Position = UDim2.fromOffset(0, 0)
    tabContainer.BackgroundColor3 = self.Config.BG_DARK
    tabContainer.BorderSizePixel = 0
    tabContainer.ZIndex = 101
    self:_createBorder(tabContainer, true)
    local tabs = {"Info", "Constants", "Upvalues", "Protos", "Source", "ModuleSource"}
    local tabButtons = {}
    local tabWidth = (tabContainer.AbsoluteSize.X - 12) / #tabs
    for i, tabName in ipairs(tabs) do
        local tabBtn = self:_createButton(tabContainer, tabName, UDim2.new(0, tabWidth - 2, 0, 22), UDim2.fromOffset(2 + (i-1) * tabWidth, 2), function()
            self:SwitchDecompilerTab(tabName, panel)
            for _, btn in pairs(tabButtons) do
                if btn and btn.Parent then
                    btn.BackgroundColor3 = self.Config.BG_PANEL
                    btn.TextColor3 = self.Config.TEXT_BLACK
                end
            end
            if tabBtn and tabBtn.Parent then
                tabBtn.BackgroundColor3 = self.Config.ACCENT_BLUE
                tabBtn.TextColor3 = self.Config.BG_WHITE
            end
        end)
        tabBtn.ZIndex = 102
        tabBtn.TextSize = 9
        tabButtons[tabName] = tabBtn
    end
    local contentArea = Instance.new("ScrollingFrame", contentContainer)
    contentArea.Name = "DecompilerContent"
    contentArea.Size = UDim2.new(1, 0, 1, -106)
    contentArea.Position = UDim2.fromOffset(0, 28)
    contentArea.BackgroundColor3 = self.Config.BG_WHITE
    contentArea.BorderSizePixel = 0
    contentArea.ScrollBarThickness = 12
    contentArea.ScrollBarImageColor3 = self.Config.BG_DARK
    contentArea.AutomaticCanvasSize = Enum.AutomaticSize.Y
    contentArea.CanvasSize = UDim2.new(0, 0, 0, 0)
    contentArea.ZIndex = 101
    contentArea.ClipsDescendants = true
    self:_createBorder(contentArea, true)
    local emptyLabel = Instance.new("TextLabel", contentArea)
    emptyLabel.Name = "EmptyMessage"
    emptyLabel.Size = UDim2.new(1, -16, 0, 80)
    emptyLabel.Position = UDim2.fromOffset(8, 8)
    emptyLabel.BackgroundTransparency = 1
    emptyLabel.Text = [[HOW TO USE DECOMPILER:
1. Select a module from the Module List (left panel)
2. Click "Scan Module" in the function browser
3. Click any function name to decompile it
4. Use tabs above to view Info/Constants/Upvalues/Source
5. Use Quick Actions below to patch/hook functions]]
    emptyLabel.TextColor3 = self.Config.TEXT_GRAY
    emptyLabel.Font = Enum.Font.SourceSans
    emptyLabel.TextSize = 11
    emptyLabel.TextWrapped = true
    emptyLabel.TextXAlignment = Enum.TextXAlignment.Left
    emptyLabel.TextYAlignment = Enum.TextYAlignment.Top
    emptyLabel.ZIndex = 102
    local actionFrame = Instance.new("Frame", contentContainer)
    actionFrame.Size = UDim2.new(1, 0, 0, 76)
    actionFrame.Position = UDim2.new(0, 0, 1, -76)
    actionFrame.BackgroundColor3 = self.Config.BG_PANEL
    actionFrame.BorderSizePixel = 0
    actionFrame.ZIndex = 101
    self:_createBorder(actionFrame, true)
    local actionTitle = Instance.new("TextLabel", actionFrame)
    actionTitle.Size = UDim2.new(1, -8, 0, 16)
    actionTitle.Position = UDim2.fromOffset(4, 2)
    actionTitle.BackgroundTransparency = 1
    actionTitle.Text = "Quick Actions (select a function first)"
    actionTitle.TextColor3 = self.Config.TEXT_BLACK
    actionTitle.Font = Enum.Font.SourceSansBold
    actionTitle.TextSize = 9
    actionTitle.TextXAlignment = Enum.TextXAlignment.Left
    actionTitle.ZIndex = 102
    local buttonStartY = 20
    local buttonHeight = 22
    local buttonSpacing = 2
    local buttonsPerRow = 4
    local actionButtons = {
        {label = "Hook Return", func = function() self:ShowReturnHookDialog(panel) end},
        {label = "Patch Upvalue", func = function() self:ShowUpvaluePatchDialog(panel) end},
        {label = "Patch Constant", func = function() self:ShowConstantPatchDialog(panel) end},
        {label = "Track Calls", func = function() self:ShowCallTrackerDialog(panel) end},
        {label = "Replace Closure", func = function() self:ShowClosureReplaceDialog(panel) end},
        {label = "View Patches", func = function() self:ShowFunctionPatchList(panel) end},
        {label = "Clear All Patches", func = function() 
            self:ClearAllFunctionPatches()
            self:_showNotification("All function patches cleared", "success")
        end},
        {label = "Export Info", func = function()
            if self.State.CurrentDecompiledFunction then
                self:ExportFunctionInfo(self.State.CurrentDecompiledFunction)
            else
                self:_showNotification("No function decompiled yet", "warning")
            end
        end}
    }
    for i, btnData in ipairs(actionButtons) do
        local row = math.floor((i - 1) / buttonsPerRow)
        local col = (i - 1) % buttonsPerRow
        local btn = self:_createButton(
            actionFrame, 
            btnData.label, 
            UDim2.new(0.25, -3, 0, buttonHeight), 
            UDim2.new(col * 0.25, 2, 0, buttonStartY + row * (buttonHeight + buttonSpacing)),
            btnData.func
        )
        btn.ZIndex = 102
        btn.TextSize = 8
        btn.TextWrapped = true
    end
    return panel
end
function Modules.OverseerCE:DecompileFunctionFromPath(path, panel)
    local func = self:GetValueFromPath(path)
    if type(func) ~= "function" then
        self:_showNotification("Path does not point to a function", "error")
        return
    end
    self:_showNotification("Decompiling function...", "info")
    local decompiled = self:DecompileFunction(func)
    if not decompiled then
        self:_showNotification("Decompilation failed", "error")
        return
    end
    self.State.CurrentDecompiledFunction = decompiled
    self.State.CurrentDecompiledFunctionRef = func
    self.State.CurrentDecompiledPath = path
    self:SwitchDecompilerTab("Info", panel)
    self:_showNotification("Function decompiled successfully", "success")
end
function Modules.OverseerCE:SwitchDecompilerTab(tabName, panel)
    local contentArea = panel:FindFirstChild("DecompilerContent")
    if not contentArea then return end
    for _, child in ipairs(contentArea:GetChildren()) do
        if not child:IsA("UIListLayout") then
            child:Destroy()
        end
    end
    if tabName == "ModuleSource" then
        self:ShowModuleSource(contentArea)
        return
    end
    if not self.State.CurrentDecompiledFunction then
        local emptyLabel = Instance.new("TextLabel", contentArea)
        emptyLabel.Size = UDim2.new(1, -8, 0, 30)
        emptyLabel.Position = UDim2.fromOffset(4, 4)
        emptyLabel.BackgroundTransparency = 1
        emptyLabel.Text = "No function decompiled yet"
        emptyLabel.TextColor3 = self.Config.TEXT_GRAY
        emptyLabel.Font = Enum.Font.SourceSans
        emptyLabel.TextSize = 11
        emptyLabel.ZIndex = 102
        return
    end
    local decomp = self.State.CurrentDecompiledFunction
    if tabName == "Info" then
        self:ShowDecompilerInfo(contentArea, decomp)
    elseif tabName == "Constants" then
        self:ShowDecompilerConstants(contentArea, decomp)
    elseif tabName == "Upvalues" then
        self:ShowDecompilerUpvalues(contentArea, decomp)
    elseif tabName == "Protos" then
        self:ShowDecompilerProtos(contentArea, decomp)
    elseif tabName == "Source" then
        self:ShowDecompilerSource(contentArea, decomp)
    end
end
function Modules.OverseerCE:ShowDecompilerInfo(parent, decomp)
    local yPos = 4
    local infoText = string.format([[Function Information:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Address: %s
Access Method: %s
Source: %s
Short Source: %s
Line Defined: %d
Last Line Defined: %d
Number of Parameters: %d
Is Vararg: %s
What: %s
Name: %s
Constants: %d found
Upvalues: %d found
Protos: %d found
]], 
        decomp.Address,
        decomp.AccessMethod,
        decomp.Info.Source or "?",
        decomp.Info.ShortSource or "?",
        decomp.Info.LineDefined or -1,
        decomp.Info.LastLineDefined or -1,
        decomp.Info.NumParams or 0,
        decomp.Info.IsVararg and "Yes" or "No",
        decomp.Info.What or "?",
        decomp.Info.Name or "<anonymous>",
        #decomp.Constants,
        #decomp.Upvalues,
        #decomp.Protos
    )
    local infoLabel = Instance.new("TextLabel", parent)
    infoLabel.Size = UDim2.new(1, -8, 0, 280)
    infoLabel.Position = UDim2.fromOffset(4, yPos)
    infoLabel.BackgroundColor3 = Color3.fromRGB(250, 250, 250)
    infoLabel.Text = infoText
    infoLabel.TextColor3 = self.Config.TEXT_BLACK
    infoLabel.Font = Enum.Font.Code
    infoLabel.TextSize = 9
    infoLabel.TextXAlignment = Enum.TextXAlignment.Left
    infoLabel.TextYAlignment = Enum.TextYAlignment.Top
    infoLabel.TextWrapped = true
    infoLabel.ZIndex = 102
    self:_createBorder(infoLabel, true)
    local infoPadding = Instance.new("UIPadding", infoLabel)
    infoPadding.PaddingLeft = UDim.new(0, 6)
    infoPadding.PaddingTop = UDim.new(0, 6)
    infoPadding.PaddingRight = UDim.new(0, 6)
end
function Modules.OverseerCE:ShowDecompilerConstants(parent, decomp)
    local yPos = 4
    local headerLabel = Instance.new("TextLabel", parent)
    headerLabel.Size = UDim2.new(1, -8, 0, 20)
    headerLabel.Position = UDim2.fromOffset(4, yPos)
    headerLabel.BackgroundTransparency = 1
    headerLabel.Text = string.format("Constants (%d found)", #decomp.Constants)
    headerLabel.TextColor3 = self.Config.TEXT_BLACK
    headerLabel.Font = Enum.Font.SourceSansBold
    headerLabel.TextSize = 11
    headerLabel.TextXAlignment = Enum.TextXAlignment.Left
    headerLabel.ZIndex = 102
    yPos = yPos + 24
    if #decomp.Constants == 0 then
        local emptyLabel = Instance.new("TextLabel", parent)
        emptyLabel.Size = UDim2.new(1, -8, 0, 20)
        emptyLabel.Position = UDim2.fromOffset(4, yPos)
        emptyLabel.BackgroundTransparency = 1
        emptyLabel.Text = "No constants found"
        emptyLabel.TextColor3 = self.Config.TEXT_GRAY
        emptyLabel.Font = Enum.Font.SourceSans
        emptyLabel.TextSize = 10
        emptyLabel.TextXAlignment = Enum.TextXAlignment.Left
        emptyLabel.ZIndex = 102
        return
    end
    for i, constant in ipairs(decomp.Constants) do
        local constFrame = Instance.new("Frame", parent)
        constFrame.Size = UDim2.new(1, -8, 0, 24)
        constFrame.Position = UDim2.fromOffset(4, yPos)
        constFrame.BackgroundColor3 = i % 2 == 0 and self.Config.BG_WHITE or Color3.fromRGB(245, 245, 245)
        constFrame.BorderSizePixel = 0
        constFrame.ZIndex = 102
        self:_createBorder(constFrame, true)
        local indexLabel = Instance.new("TextLabel", constFrame)
        indexLabel.Size = UDim2.new(0, 40, 1, 0)
        indexLabel.Position = UDim2.fromOffset(4, 0)
        indexLabel.BackgroundTransparency = 1
        indexLabel.Text = tostring(i)
        indexLabel.TextColor3 = self.Config.TEXT_GRAY
        indexLabel.Font = Enum.Font.Code
        indexLabel.TextSize = 10
        indexLabel.TextXAlignment = Enum.TextXAlignment.Left
        indexLabel.ZIndex = 103
        local typeLabel = Instance.new("TextLabel", constFrame)
        typeLabel.Size = UDim2.new(0, 60, 1, 0)
        typeLabel.Position = UDim2.fromOffset(48, 0)
        typeLabel.BackgroundTransparency = 1
        typeLabel.Text = type(constant)
        typeLabel.TextColor3 = self.Config.ACCENT_BLUE
        typeLabel.Font = Enum.Font.Code
        typeLabel.TextSize = 10
        typeLabel.TextXAlignment = Enum.TextXAlignment.Left
        typeLabel.ZIndex = 103
        local valueLabel = Instance.new("TextLabel", constFrame)
        valueLabel.Size = UDim2.new(1, -200, 1, 0)
        valueLabel.Position = UDim2.fromOffset(112, 0)
        valueLabel.BackgroundTransparency = 1
        valueLabel.Text = tostring(constant)
        valueLabel.TextColor3 = self.Config.TEXT_BLACK
        valueLabel.Font = Enum.Font.Code
        valueLabel.TextSize = 9
        valueLabel.TextXAlignment = Enum.TextXAlignment.Left
        valueLabel.TextTruncate = Enum.TextTruncate.AtEnd
        valueLabel.ZIndex = 103
        local patchBtn = self:_createButton(constFrame, "Patch", UDim2.fromOffset(60, 18), UDim2.new(1, -64, 0, 3), function()
            self:ShowConstantPatchDialogWithIndex(i, constant)
        end)
        patchBtn.ZIndex = 104
        patchBtn.TextSize = 8
        yPos = yPos + 26
    end
end
function Modules.OverseerCE:ShowDecompilerUpvalues(parent, decomp)
    local yPos = 4
    local headerLabel = Instance.new("TextLabel", parent)
    headerLabel.Size = UDim2.new(1, -8, 0, 20)
    headerLabel.Position = UDim2.fromOffset(4, yPos)
    headerLabel.BackgroundTransparency = 1
    headerLabel.Text = string.format("Upvalues (%d found)", #decomp.Upvalues)
    headerLabel.TextColor3 = self.Config.TEXT_BLACK
    headerLabel.Font = Enum.Font.SourceSansBold
    headerLabel.TextSize = 11
    headerLabel.TextXAlignment = Enum.TextXAlignment.Left
    headerLabel.ZIndex = 102
    yPos = yPos + 24
    if #decomp.Upvalues == 0 then
        local emptyLabel = Instance.new("TextLabel", parent)
        emptyLabel.Size = UDim2.new(1, -8, 0, 20)
        emptyLabel.Position = UDim2.fromOffset(4, yPos)
        emptyLabel.BackgroundTransparency = 1
        emptyLabel.Text = "No upvalues found"
        emptyLabel.TextColor3 = self.Config.TEXT_GRAY
        emptyLabel.Font = Enum.Font.SourceSans
        emptyLabel.TextSize = 10
        emptyLabel.TextXAlignment = Enum.TextXAlignment.Left
        emptyLabel.ZIndex = 102
        return
    end
    for name, value in pairs(decomp.Upvalues) do
        local uvFrame = Instance.new("Frame", parent)
        uvFrame.Size = UDim2.new(1, -8, 0, 24)
        uvFrame.Position = UDim2.fromOffset(4, yPos)
        uvFrame.BackgroundColor3 = yPos % 48 == 4 and self.Config.BG_WHITE or Color3.fromRGB(245, 245, 245)
        uvFrame.BorderSizePixel = 0
        uvFrame.ZIndex = 102
        self:_createBorder(uvFrame, true)
        local nameLabel = Instance.new("TextLabel", uvFrame)
        nameLabel.Size = UDim2.new(0, 120, 1, 0)
        nameLabel.Position = UDim2.fromOffset(4, 0)
        nameLabel.BackgroundTransparency = 1
        nameLabel.Text = tostring(name)
        nameLabel.TextColor3 = self.Config.ACCENT_BLUE
        nameLabel.Font = Enum.Font.Code
        nameLabel.TextSize = 10
        nameLabel.TextXAlignment = Enum.TextXAlignment.Left
        nameLabel.ZIndex = 103
        local typeLabel = Instance.new("TextLabel", uvFrame)
        typeLabel.Size = UDim2.new(0, 60, 1, 0)
        typeLabel.Position = UDim2.fromOffset(128, 0)
        typeLabel.BackgroundTransparency = 1
        typeLabel.Text = type(value)
        typeLabel.TextColor3 = self.Config.TEXT_GRAY
        typeLabel.Font = Enum.Font.Code
        typeLabel.TextSize = 10
        typeLabel.TextXAlignment = Enum.TextXAlignment.Left
        typeLabel.ZIndex = 103
        local valueLabel = Instance.new("TextLabel", uvFrame)
        valueLabel.Size = UDim2.new(1, -280, 1, 0)
        valueLabel.Position = UDim2.fromOffset(192, 0)
        valueLabel.BackgroundTransparency = 1
        valueLabel.Text = tostring(value)
        valueLabel.TextColor3 = self.Config.TEXT_BLACK
        valueLabel.Font = Enum.Font.Code
        valueLabel.TextSize = 9
        valueLabel.TextXAlignment = Enum.TextXAlignment.Left
        valueLabel.TextTruncate = Enum.TextTruncate.AtEnd
        valueLabel.ZIndex = 103
        local patchBtn = self:_createButton(uvFrame, "Patch", UDim2.fromOffset(60, 18), UDim2.new(1, -64, 0, 3), function()
            self:ShowUpvaluePatchDialogWithName(name, value)
        end)
        patchBtn.ZIndex = 104
        patchBtn.TextSize = 8
        yPos = yPos + 26
    end
end
function Modules.OverseerCE:ShowDecompilerProtos(parent, decomp)
    local yPos = 4
    local headerLabel = Instance.new("TextLabel", parent)
    headerLabel.Size = UDim2.new(1, -8, 0, 20)
    headerLabel.Position = UDim2.fromOffset(4, yPos)
    headerLabel.BackgroundTransparency = 1
    headerLabel.Text = string.format("Nested Functions/Protos (%d found)", #decomp.Protos)
    headerLabel.TextColor3 = self.Config.TEXT_BLACK
    headerLabel.Font = Enum.Font.SourceSansBold
    headerLabel.TextSize = 11
    headerLabel.TextXAlignment = Enum.TextXAlignment.Left
    headerLabel.ZIndex = 102
    yPos = yPos + 24
    if #decomp.Protos == 0 then
        local emptyLabel = Instance.new("TextLabel", parent)
        emptyLabel.Size = UDim2.new(1, -8, 0, 20)
        emptyLabel.Position = UDim2.fromOffset(4, yPos)
        emptyLabel.BackgroundTransparency = 1
        emptyLabel.Text = "No nested functions found"
        emptyLabel.TextColor3 = self.Config.TEXT_GRAY
        emptyLabel.Font = Enum.Font.SourceSans
        emptyLabel.TextSize = 10
        emptyLabel.TextXAlignment = Enum.TextXAlignment.Left
        emptyLabel.ZIndex = 102
        return
    end
    for i, proto in ipairs(decomp.Protos) do
        local protoFrame = Instance.new("Frame", parent)
        protoFrame.Size = UDim2.new(1, -8, 0, 30)
        protoFrame.Position = UDim2.fromOffset(4, yPos)
        protoFrame.BackgroundColor3 = i % 2 == 0 and self.Config.BG_WHITE or Color3.fromRGB(245, 245, 245)
        protoFrame.BorderSizePixel = 0
        protoFrame.ZIndex = 102
        self:_createBorder(protoFrame, true)
        local indexLabel = Instance.new("TextLabel", protoFrame)
        indexLabel.Size = UDim2.new(0, 40, 1, 0)
        indexLabel.Position = UDim2.fromOffset(4, 0)
        indexLabel.BackgroundTransparency = 1
        indexLabel.Text = "Proto " .. i
        indexLabel.TextColor3 = self.Config.ACCENT_BLUE
        indexLabel.Font = Enum.Font.Code
        indexLabel.TextSize = 10
        indexLabel.TextXAlignment = Enum.TextXAlignment.Left
        indexLabel.ZIndex = 103
        local addrLabel = Instance.new("TextLabel", protoFrame)
        addrLabel.Size = UDim2.new(1, -140, 1, 0)
        addrLabel.Position = UDim2.fromOffset(50, 0)
        addrLabel.BackgroundTransparency = 1
        addrLabel.Text = tostring(proto)
        addrLabel.TextColor3 = self.Config.TEXT_BLACK
        addrLabel.Font = Enum.Font.Code
        addrLabel.TextSize = 9
        addrLabel.TextXAlignment = Enum.TextXAlignment.Left
        addrLabel.TextTruncate = Enum.TextTruncate.AtEnd
        addrLabel.ZIndex = 103
        local decompileBtn = self:_createButton(protoFrame, "Decompile", UDim2.fromOffset(80, 20), UDim2.new(1, -84, 0, 5), function()
            if type(proto) == "function" then
                local protoDecomp = self:DecompileFunction(proto)
                if protoDecomp then
                    self.State.CurrentDecompiledFunction = protoDecomp
                    self.State.CurrentDecompiledFunctionRef = proto
                    self:SwitchDecompilerTab("Info", parent:GetParent())
                    self:_showNotification("Proto decompiled", "success")
                end
            end
        end)
        decompileBtn.ZIndex = 104
        decompileBtn.TextSize = 8
        yPos = yPos + 32
    end
end
function Modules.OverseerCE:ShowDecompilerSource(parent, decomp)
    local yPos = 4
    local sourceBox = Instance.new("TextBox", parent)
    sourceBox.Size = UDim2.new(1, -8, 1, -8)
    sourceBox.Position = UDim2.fromOffset(4, yPos)
    sourceBox.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    sourceBox.TextColor3 = Color3.fromRGB(220, 220, 220)
    sourceBox.Font = Enum.Font.Code
    sourceBox.TextSize = 9
    sourceBox.TextXAlignment = Enum.TextXAlignment.Left
    sourceBox.TextYAlignment = Enum.TextYAlignment.Top
    sourceBox.TextWrapped = true
    sourceBox.ClearTextOnFocus = false
    sourceBox.MultiLine = true
    sourceBox.ZIndex = 102
    if decomp.SourceCode then
        sourceBox.Text = decomp.SourceCode
    else
        sourceBox.Text = "-- Source code not available\n-- Decompiler not found or function is native\n\n-- Use the other tabs to view function details"
    end
    self:_createBorder(sourceBox, true)
    local sourcePadding = Instance.new("UIPadding", sourceBox)
    sourcePadding.PaddingLeft = UDim.new(0, 6)
    sourcePadding.PaddingTop = UDim.new(0, 6)
    sourcePadding.PaddingRight = UDim.new(0, 6)
    sourcePadding.PaddingBottom = UDim.new(0, 6)
end
function Modules.OverseerCE:ShowModuleSource(parent)
    local yPos = 4
    if not self.State.CurrentModuleDecompiled then
        local infoLabel = Instance.new("TextLabel", parent)
        infoLabel.Size = UDim2.new(1, -8, 0, 80)
        infoLabel.Position = UDim2.fromOffset(4, yPos)
        infoLabel.BackgroundColor3 = Color3.fromRGB(255, 250, 220)
        infoLabel.Text = [[MODULE SOURCE VIEWER
To view the full module source code:
1. Select a module from the Module List (left panel)
2. Click "Decompile Module" button in the function browser
3. The full module source will appear here
Note: Individual function source is in the "Source" tab]]
        infoLabel.TextColor3 = self.Config.TEXT_BLACK
        infoLabel.Font = Enum.Font.SourceSans
        infoLabel.TextSize = 11
        infoLabel.TextXAlignment = Enum.TextXAlignment.Left
        infoLabel.TextYAlignment = Enum.TextYAlignment.Top
        infoLabel.TextWrapped = true
        infoLabel.ZIndex = 102
        self:_createBorder(infoLabel, true)
        local labelPadding = Instance.new("UIPadding", infoLabel)
        labelPadding.PaddingLeft = UDim.new(0, 8)
        labelPadding.PaddingTop = UDim.new(0, 8)
        return
    end
    local moduleDecomp = self.State.CurrentModuleDecompiled
    local headerLabel = Instance.new("TextLabel", parent)
    headerLabel.Size = UDim2.new(1, -8, 0, 24)
    headerLabel.Position = UDim2.fromOffset(4, yPos)
    headerLabel.BackgroundColor3 = self.Config.ACCENT_BLUE
    headerLabel.Text = "ðŸ“„ " .. moduleDecomp.Name .. " - " .. moduleDecomp.DecompileMethod
    headerLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    headerLabel.Font = Enum.Font.SourceSansBold
    headerLabel.TextSize = 11
    headerLabel.TextXAlignment = Enum.TextXAlignment.Left
    headerLabel.ZIndex = 102
    self:_createBorder(headerLabel, true)
    local headerPadding = Instance.new("UIPadding", headerLabel)
    headerPadding.PaddingLeft = UDim.new(0, 6)
    yPos = yPos + 28
    local btnContainer = Instance.new("Frame", parent)
    btnContainer.Size = UDim2.new(1, -8, 0, 26)
    btnContainer.Position = UDim2.fromOffset(4, yPos)
    btnContainer.BackgroundTransparency = 1
    btnContainer.ZIndex = 102
    local copyBtn = self:_createButton(btnContainer, "Copy Source", UDim2.fromOffset(100, 22), UDim2.fromOffset(0, 0), function()
        local copied = self:_setClipboard(moduleDecomp.SourceCode)
        if copied then
            self:_showNotification("Source copied to clipboard!", "success")
        else
            self:_showNotification("Clipboard not available", "error")
        end
    end)
    copyBtn.ZIndex = 103
    copyBtn.TextSize = 9
    local refreshBtn = self:_createButton(btnContainer, "Re-Decompile", UDim2.fromOffset(100, 22), UDim2.fromOffset(104, 0), function()
        if self.State.SelectedModule then
            self:_showNotification("Re-decompiling...", "info")
            local newDecomp = self:DecompileModuleScript(self.State.SelectedModule)
            if newDecomp then
                self.State.CurrentModuleDecompiled = newDecomp
                self:SwitchDecompilerTab("ModuleSource", parent:GetParent())
                self:_showNotification("Module re-decompiled!", "success")
            end
        end
    end)
    refreshBtn.ZIndex = 103
    refreshBtn.TextSize = 9
    local exportBtn = self:_createButton(btnContainer, "Export Info", UDim2.fromOffset(100, 22), UDim2.fromOffset(208, 0), function()
        local exportData = {
            Name = moduleDecomp.Name,
            FullName = moduleDecomp.FullName,
            Method = moduleDecomp.DecompileMethod,
            SourceCode = moduleDecomp.SourceCode,
            FunctionCount = #moduleDecomp.Functions
        }
        local success, json = pcall(function()
            return game:GetService("HttpService"):JSONEncode(exportData)
        end)
        if success then
            self:_setClipboard(json)
            self:_showNotification("Module info exported!", "success")
        end
    end)
    exportBtn.ZIndex = 103
    exportBtn.TextSize = 9
    yPos = yPos + 30
    local sourceBox = Instance.new("TextBox", parent)
    sourceBox.Size = UDim2.new(1, -8, 1, -yPos - 4)
    sourceBox.Position = UDim2.fromOffset(4, yPos)
    sourceBox.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    sourceBox.TextColor3 = Color3.fromRGB(220, 220, 220)
    sourceBox.Font = Enum.Font.Code
    sourceBox.TextSize = 9
    sourceBox.TextXAlignment = Enum.TextXAlignment.Left
    sourceBox.TextYAlignment = Enum.TextYAlignment.Top
    sourceBox.TextWrapped = true
    sourceBox.ClearTextOnFocus = false
    sourceBox.MultiLine = true
    sourceBox.ZIndex = 102
    sourceBox.Text = moduleDecomp.SourceCode or "-- No source code available"
    self:_createBorder(sourceBox, true)
    local sourcePadding = Instance.new("UIPadding", sourceBox)
    sourcePadding.PaddingLeft = UDim.new(0, 6)
    sourcePadding.PaddingTop = UDim.new(0, 6)
    sourcePadding.PaddingRight = UDim.new(0, 6)
    sourcePadding.PaddingBottom = UDim.new(0, 6)
end
function Modules.OverseerCE:ShowReturnHookDialog(panel)
    if not self.State.CurrentDecompiledFunctionRef then
        self:_showNotification("No function selected", "warning")
        return
    end
    self:_showNotification("Return hook feature - Enter value in console", "info")
    print("[Decompiler] Enter return value to hook:")
    print("[Decompiler] Example: Modules.OverseerCE:PatchFunctionReturn(<function>, <returnValue>)")
end
function Modules.OverseerCE:ShowUpvaluePatchDialog(panel)
    if not self.State.CurrentDecompiledFunctionRef then
        self:_showNotification("No function selected", "warning")
        return
    end
    self:_showNotification("Upvalue patch feature - See upvalues tab", "info")
end
function Modules.OverseerCE:ShowUpvaluePatchDialogWithName(name, currentValue)
    if not self.State.CurrentDecompiledFunctionRef then
        self:_showNotification("No function selected", "warning")
        return
    end
    local func = self.State.CurrentDecompiledFunctionRef
    print(string.format("[Decompiler] Patch upvalue '%s'", name))
    print(string.format("[Decompiler] Current value: %s", tostring(currentValue)))
    print("[Decompiler] To patch, use:")
    print(string.format("    Modules.OverseerCE:PatchFunctionUpvalue(<function>, '%s', <newValue>)", name))
end
function Modules.OverseerCE:ShowConstantPatchDialog(panel)
    if not self.State.CurrentDecompiledFunctionRef then
        self:_showNotification("No function selected", "warning")
        return
    end
    self:_showNotification("Constant patch feature - See constants tab", "info")
end
function Modules.OverseerCE:ShowConstantPatchDialogWithIndex(index, currentValue)
    if not self.State.CurrentDecompiledFunctionRef then
        self:_showNotification("No function selected", "warning")
        return
    end
    print(string.format("[Decompiler] Patch constant #%d", index))
    print(string.format("[Decompiler] Current value: %s", tostring(currentValue)))
    print("[Decompiler] To patch, use:")
    print(string.format("    Modules.OverseerCE:PatchFunctionConstant(<function>, %d, <newValue>)", index))
end
function Modules.OverseerCE:ShowCallTrackerDialog(panel)
    if not self.State.CurrentDecompiledFunctionRef then
        self:_showNotification("No function selected", "warning")
        return
    end
    local func = self.State.CurrentDecompiledFunctionRef
    local success, msg = self:HookFunctionCalls(func, function(count, ...)
        print(string.format("[Call Tracker] Function called #%d with args:", count))
        local args = {...}
        for i, arg in ipairs(args) do
            print(string.format("  [%d] = %s", i, tostring(arg)))
        end
    end)
    if success then
        self:_showNotification("Call tracking enabled", "success")
    else
        self:_showNotification("Failed to enable tracking: " .. msg, "error")
    end
end
function Modules.OverseerCE:ShowClosureReplaceDialog(panel)
    if not self.State.CurrentDecompiledFunctionRef then
        self:_showNotification("No function selected", "warning")
        return
    end
    self:_showNotification("Closure replacement - Use console", "info")
    print("[Decompiler] To replace this function's closure, use:")
    print("    Modules.OverseerCE:ReplaceClosure(<oldFunc>, <newFunc>)")
end
function Modules.OverseerCE:ShowFunctionPatchList(panel)
    print("=== ACTIVE FUNCTION PATCHES ===")
    print("\n[Return Hooks]")
    for id, patch in pairs(self.State.ReturnHooks) do
        print(string.format("  %s -> returns %s", id, tostring(patch.ReturnValue)))
    end
    print("\n[Upvalue Patches]")
    for id, patch in pairs(self.State.UpvalueMonitors) do
        print(string.format("  %s[%s] = %s", id, patch.UpvalueName, tostring(patch.NewValue)))
    end
    print("\n[Constant Patches]")
    for id, patch in pairs(self.State.ConstantPatches) do
        print(string.format("  %s[%d] = %s", id, patch.ConstantIndex, tostring(patch.NewValue)))
    end
    print("\n[Call Trackers]")
    for id, tracker in pairs(self.State.CallTrackers) do
        print(string.format("  %s - %d calls tracked", id, #tracker.Calls))
    end
    self:_showNotification("Patch list printed to console", "info")
end
function Modules.OverseerCE:ClearAllFunctionPatches()
    for id, patch in pairs(self.State.ReturnHooks) do
        if patch.Original and hookfunction then
            pcall(hookfunction, patch.Function, patch.Original)
        end
    end
    self.State.ReturnHooks = {}
    for id, tracker in pairs(self.State.CallTrackers) do
        if tracker.Original and hookfunction then
            pcall(hookfunction, tracker.Function, tracker.Original)
        end
    end
    self.State.CallTrackers = {}
    self.State.UpvalueMonitors = {}
    self.State.ConstantPatches = {}
    self.State.FunctionPatches = {}
end
function Modules.OverseerCE:RefreshDecompilerView(panel)
    if self.State.CurrentDecompiledPath then
        self:DecompileFunctionFromPath(self.State.CurrentDecompiledPath, panel)
    end
end
function Modules.OverseerCE:ExportFunctionInfo(decomp)
    local export = {
        Address = decomp.Address,
        Info = decomp.Info,
        Constants = {},
        Upvalues = {},
        ProtosCount = #decomp.Protos,
        HasSourceCode = decomp.SourceCode ~= nil,
        SourceCode = decomp.SourceCode
    }
    for i, const in ipairs(decomp.Constants) do
        export.Constants[i] = {
            Index = i,
            Type = type(const),
            Value = tostring(const)
        }
    end
    for name, value in pairs(decomp.Upvalues) do
        table.insert(export.Upvalues, {
            Name = tostring(name),
            Type = type(value),
            Value = tostring(value)
        })
    end
    local success, exportText = pcall(function()
        return game:GetService("HttpService"):JSONEncode(export)
    end)
    if success then
        local copied = self:_setClipboard(exportText)
        if copied then
            self:_showNotification("Function info exported to clipboard", "success")
        else
            print("[Decompiler Export]")
            print(exportText)
            self:_showNotification("Export printed to console", "info")
        end
    else
        self:_showNotification("Export failed", "error")
    end
end
function Modules.OverseerCE:GetValueFromPath(path)
    local parts = {}
    for part in path:gmatch("[^%.]+") do
        table.insert(parts, part)
    end
    if #parts == 0 then return nil end
    local current = _G
    for i, part in ipairs(parts) do
        if current[part] ~= nil then
            current = current[part]
        else
            current = game
            for j = i, #parts do
                local suc, res = pcall(function() return current[parts[j]] end)
                if suc and res then
                    current = res
                else
                    return nil
                end
            end
            break
        end
    end
    return current
end
function Modules.OverseerCE:GetTableWithMetatable(tbl)
    if type(tbl) ~= "table" then
        return tbl
    end
    local mt, method = self:GetRawMetatable(tbl)
    if mt then
        local unlocked, unlockMsg = self:UnlockMetatable(tbl)
        local combined = {}
        for k, v in pairs(tbl) do
            combined[k] = v
        end
        combined["[METATABLE]"] = mt
        combined["[METATABLE_INFO]"] = {
            Locked = not unlocked,
            AccessMethod = method,
            UnlockMessage = unlockMsg
        }
        return combined
    end
    return tbl
end
function Modules.OverseerCE:DecodeBase64(data)
    local success, result = pcall(function()
        local b = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
        data = string.gsub(data, '[^'..b..'=]', '')
        return (data:gsub('.', function(x)
            if x == '=' then return '' end
            local r,f='',(b:find(x)-1)
            for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end
            return r;
        end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
            if #x ~= 8 then return '' end
            local c=0
            for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end
            return string.char(c)
        end))
    end)
    if success and result then
        return result
    end
    return nil
end
function Modules.OverseerCE:IsBase64(str)
    if type(str) ~= "string" then return false end
    if #str < 4 or #str % 4 ~= 0 then return false end
    return str:match("^[A-Za-z0-9+/]*=*$") ~= nil
end
function Modules.OverseerCE:GetDisplayValue(value, key)
    local valueType = type(value)
    if valueType == "string" then
        if self.State.Base64DecoderEnabled and self:IsBase64(value) and #value >= 8 then
            local decoded = self:DecodeBase64(value)
            if decoded and decoded ~= value then
                return string.format('"%s" [Base64: %s]', 
                    value:sub(1, 20)..(#value > 20 and "..." or ""), 
                    decoded:sub(1, 40)..(#decoded > 40 and "..." or ""))
            end
        end
        return '"' .. tostring(value) .. '"'
    elseif valueType == "number" then
        if value == math.floor(value) and value >= 0 and value < 2^32 then
            return string.format("%d (0x%X)", value, value)
        end
        return tostring(value)
    elseif valueType == "boolean" then
        return tostring(value)
    elseif valueType == "table" then
        local size = 0
        for _ in pairs(value) do size = size + 1 end
        local mt = getmetatable(value)
        if mt and mt.__tostring then
            local success, str = pcall(function() return tostring(value) end)
            if success and str ~= "table" and not str:find("table: 0x") then
                return str .. " [table: " .. size .. " entries]"
            end
        end
        return "{table: " .. size .. " entries}"
    elseif valueType == "function" then
        local info = debug and debug.getinfo and debug.getinfo(value)
        if info then
            local source = info.source or "?"
            local line = info.linedefined or "?"
            return string.format("function (%s:%s)", source:sub(1, 20), line)
        end
        return "function"
    elseif valueType == "userdata" then
        local success, str = pcall(function() return tostring(value) end)
        if success then
            return str .. " [userdata]"
        end
        return "[userdata]"
    else
        return tostring(value)
    end
end
function Modules.OverseerCE:GetModuleContent(module)
    if module == nil then
        return {
            ["[Error]"] = "Module returned nil",
            ["[Type]"] = "nil",
            ["[Info]"] = "This module doesn't return a value"
        }
    end
    local moduleType = type(module)
    if module ~= nil then
        self.State.ModuleTypeCache[module] = moduleType
    end
    if moduleType == "table" then
        return module
    elseif moduleType == "function" then
        local success, result = pcall(module)
        if success then
            if type(result) == "table" then
                return result
            else
                return {
                    ["[Return Value]"] = result,
                    ["[Type]"] = type(result),
                    ["[Function Info]"] = debug and debug.getinfo and debug.getinfo(module) or "unavailable"
                }
            end
        else
            return {
                ["[Error]"] = tostring(result),
                ["[Type]"] = "function (failed to execute)",
                ["[Function Info]"] = debug and debug.getinfo and debug.getinfo(module) or "unavailable"
            }
        end
    elseif moduleType == "userdata" or moduleType == "string" or moduleType == "number" or moduleType == "boolean" then
        local wrapper = {
            ["[Value]"] = module,
            ["[Type]"] = moduleType,
            ["[String Representation]"] = tostring(module)
        }
        local success, mt = pcall(getmetatable, module)
        if success and mt then
            wrapper["[Metatable]"] = mt
        end
        if moduleType == "string" and self.State.Base64DecoderEnabled and self:IsBase64(module) then
            local decoded = self:DecodeBase64(module)
            if decoded then
                wrapper["[Base64 Decoded]"] = decoded
            end
        end
        return wrapper
    else
        return {
            ["[Value]"] = tostring(module),
            ["[Type]"] = moduleType,
            ["[Raw]"] = module
        }
    end
end
function Modules.OverseerCE:_createBorder(parent, inset)
    local topColor = inset and self.Config.BORDER_DARK or self.Config.BORDER_LIGHT
    local bottomColor = inset and self.Config.BORDER_LIGHT or self.Config.BORDER_DARK
    local top = Instance.new("Frame", parent)
    top.Name = "BorderTop"
    top.Size = UDim2.new(1, 0, 0, 1)
    top.Position = UDim2.new(0, 0, 0, 0)
    top.BackgroundColor3 = topColor
    top.BorderSizePixel = 0
    top.ZIndex = parent.ZIndex + 1
    local left = Instance.new("Frame", parent)
    left.Name = "BorderLeft"
    left.Size = UDim2.new(0, 1, 1, 0)
    left.Position = UDim2.new(0, 0, 0, 0)
    left.BackgroundColor3 = topColor
    left.BorderSizePixel = 0
    left.ZIndex = parent.ZIndex + 1
    local bottom = Instance.new("Frame", parent)
    bottom.Name = "BorderBottom"
    bottom.Size = UDim2.new(1, 0, 0, 1)
    bottom.Position = UDim2.new(0, 0, 1, -1)
    bottom.BackgroundColor3 = bottomColor
    bottom.BorderSizePixel = 0
    bottom.ZIndex = parent.ZIndex + 1
    local right = Instance.new("Frame", parent)
    right.Name = "BorderRight"
    right.Size = UDim2.new(0, 1, 1, 0)
    right.Position = UDim2.new(1, -1, 0, 0)
    right.BackgroundColor3 = bottomColor
    right.BorderSizePixel = 0
    right.ZIndex = parent.ZIndex + 1
    return {top, left, bottom, right}
end
function Modules.OverseerCE:_createButton(parent, text, size, position, callback)
    local btn = Instance.new("TextButton", parent)
    btn.Size = size
    btn.Position = position
    btn.BackgroundColor3 = self.Config.BG_PANEL
    btn.Text = text
    btn.TextColor3 = self.Config.TEXT_BLACK
    btn.Font = Enum.Font.SourceSans
    btn.TextSize = 11
    btn.BorderSizePixel = 0
    btn.AutoButtonColor = false
    btn.ClipsDescendants = true
    self:_createBorder(btn, false)
    if callback then
        btn.MouseButton1Click:Connect(callback)
    end
    btn.MouseButton1Down:Connect(function()
        btn.BackgroundColor3 = self.Config.BG_DARK
        for _, child in ipairs(btn:GetChildren()) do
            if child.Name == "BorderTop" or child.Name == "BorderLeft" then
                child.BackgroundColor3 = self.Config.BORDER_DARK
            elseif child.Name == "BorderBottom" or child.Name == "BorderRight" then
                child.BackgroundColor3 = self.Config.BORDER_LIGHT
            end
        end
    end)
    btn.MouseButton1Up:Connect(function()
        btn.BackgroundColor3 = self.Config.BG_PANEL
        for _, child in ipairs(btn:GetChildren()) do
            if child.Name == "BorderTop" or child.Name == "BorderLeft" then
                child.BackgroundColor3 = self.Config.BORDER_LIGHT
            elseif child.Name == "BorderBottom" or child.Name == "BorderRight" then
                child.BackgroundColor3 = self.Config.BORDER_DARK
            end
        end
    end)
    btn.MouseEnter:Connect(function()
        if btn.BackgroundColor3 ~= self.Config.BG_DARK then
            local tween = TweenService:Create(btn, TweenInfo.new(0.1), {
                BackgroundColor3 = self.Config.BG_LIGHT
            })
            tween:Play()
        end
    end)
    btn.MouseLeave:Connect(function()
        if btn.BackgroundColor3 ~= self.Config.BG_DARK then
            local tween = TweenService:Create(btn, TweenInfo.new(0.1), {
                BackgroundColor3 = self.Config.BG_PANEL
            })
            tween:Play()
        end
    end)
    return btn
end
function Modules.OverseerCE:_createPanel(parent, position, size, title)
    local panel = Instance.new("Frame", parent)
    panel.Position = position
    panel.Size = size
    panel.BackgroundColor3 = self.Config.BG_PANEL
    panel.BorderSizePixel = 0
    panel.ClipsDescendants = false
    self:_createBorder(panel, false)
    if title then
        local titleLabel = Instance.new("TextLabel", panel)
        titleLabel.Size = UDim2.new(1, -4, 0, 18)
        titleLabel.Position = UDim2.new(0, 2, 0, 2)
        titleLabel.BackgroundColor3 = self.Config.BG_DARK
        titleLabel.Text = title
        titleLabel.TextColor3 = self.Config.TEXT_BLACK
        titleLabel.Font = Enum.Font.SourceSansBold
        titleLabel.TextSize = 11
        titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        titleLabel.BorderSizePixel = 0
        local titlePadding = Instance.new("UIPadding", titleLabel)
        titlePadding.PaddingLeft = UDim.new(0, 4)
        self:_createBorder(titleLabel, true)
    end
    return panel
end
function Modules.OverseerCE:_setClipboard(txt)
    if setclipboard then 
        setclipboard(txt)
        return true
    elseif toclipboard then
        toclipboard(txt)
        return true
    end
    return false
end
function Modules.OverseerCE:_generateUID()
    local charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
    local result = ""
    for i = 1, 12 do
        local rand = math.random(1, #charset)
        result = result .. charset:sub(rand, rand)
    end
    return result
end
function Modules.OverseerCE:_showNotification(message, messageType)
    if not self.State.UI or not self.State.UI.Main then return end
    local notif = Instance.new("Frame", self.State.UI.Main)
    notif.Size = UDim2.fromOffset(300, 60)
    notif.Position = UDim2.new(1, -310, 1, 10)
    notif.BackgroundColor3 = messageType == "success" and Color3.fromRGB(220, 255, 220)
        or messageType == "error" and Color3.fromRGB(255, 220, 220)
        or messageType == "warning" and Color3.fromRGB(255, 245, 220)
        or self.Config.BG_LIGHT
    notif.BorderSizePixel = 0
    notif.ZIndex = 1000
    self:_createBorder(notif, true)
    local icon = Instance.new("TextLabel", notif)
    icon.Size = UDim2.fromOffset(40, 40)
    icon.Position = UDim2.fromOffset(10, 10)
    icon.BackgroundTransparency = 1
    icon.Text = messageType == "success" and "âœ“" 
        or messageType == "error" and "âœ—" 
        or messageType == "warning" and "âš "
        or "â„¹"
    icon.TextColor3 = messageType == "success" and self.Config.SUCCESS_GREEN
        or messageType == "error" and self.Config.FROZEN_RED
        or messageType == "warning" and self.Config.WARNING_ORANGE
        or self.Config.ACCENT_BLUE
    icon.Font = Enum.Font.SourceSansBold
    icon.TextSize = 24
    icon.ZIndex = 1001
    local msg = Instance.new("TextLabel", notif)
    msg.Size = UDim2.new(1, -60, 1, -4)
    msg.Position = UDim2.fromOffset(54, 2)
    msg.BackgroundTransparency = 1
    msg.Text = message
    msg.TextColor3 = self.Config.TEXT_BLACK
    msg.Font = Enum.Font.SourceSans
    msg.TextSize = 10
    msg.TextXAlignment = Enum.TextXAlignment.Left
    msg.TextYAlignment = Enum.TextYAlignment.Center
    msg.TextWrapped = true
    msg.ZIndex = 1001
    local slideTween = TweenService:Create(notif, TweenInfo.new(0.3, Enum.EasingStyle.Back), {
        Position = UDim2.new(1, -310, 1, -70)
    })
    slideTween:Play()
    task.delay(3, function()
        local fadeOut = TweenService:Create(notif, TweenInfo.new(0.3), {
            Position = UDim2.new(1, -310, 1, 10)
        })
        fadeOut:Play()
        fadeOut.Completed:Connect(function()
            notif:Destroy()
        end)
    end)
end
function Modules.OverseerCE:ScanForConstant(searchValue, searchType, exactMatch)
    self.State.ScanResults = {}
    self.State.ScanInProgress = true
    local results = {}
    local scanned = {}
    local function scanTable(tbl, path, depth)
        if depth > 20 then return end
        if scanned[tbl] then return end
        scanned[tbl] = true
        for key, value in pairs(tbl) do
            local matches = false
            if searchType == "any" or type(value) == searchType then
                if exactMatch then
                    matches = (value == searchValue)
                else
                    if type(value) == "string" and type(searchValue) == "string" then
                        matches = value:lower():find(searchValue:lower(), 1, true) ~= nil
                    elseif type(value) == "number" and type(searchValue) == "number" then
                        matches = math.abs(value - searchValue) < 0.0001
                    else
                        matches = (tostring(value):lower():find(tostring(searchValue):lower(), 1, true) ~= nil)
                    end
                end
            end
            if matches then
                table.insert(results, {
                    Path = path .. "." .. tostring(key),
                    Key = key,
                    Value = value,
                    Type = type(value),
                    Table = tbl,
                    Depth = depth
                })
            end
            if type(value) == "table" and depth < 20 then
                scanTable(value, path .. "." .. tostring(key), depth + 1)
            end
        end
        local mt = getmetatable(tbl)
        if mt and type(mt) == "table" then
            scanTable(mt, path .. ".[MT]", depth + 1)
        end
    end
    for _, moduleData in ipairs(self.State.ModuleList) do
        local success, moduleTable = pcall(function()
            return require(moduleData.Script)
        end)
        if success and type(moduleTable) == "table" then
            scanTable(moduleTable, moduleData.Name, 0)
        end
    end
    self.State.ScanResults = results
    self.State.ScanInProgress = false
    return results
end
function Modules.OverseerCE:FindReferences(targetValue)
    local references = {}
    local scanned = {}
    local function findRefs(tbl, path, depth)
        if depth > 20 then return end
        if scanned[tbl] then return end
        scanned[tbl] = true
        for key, value in pairs(tbl) do
            if value == targetValue or rawequal(value, targetValue) then
                table.insert(references, {
                    Path = path .. "." .. tostring(key),
                    Key = key,
                    Table = tbl,
                    Depth = depth
                })
            end
            if type(value) == "table" then
                findRefs(value, path .. "." .. tostring(key), depth + 1)
            end
        end
        local mt = getmetatable(tbl)
        if mt and type(mt) == "table" then
            findRefs(mt, path .. ".[MT]", depth + 1)
        end
    end
    for _, moduleData in ipairs(self.State.ModuleList) do
        local success, moduleTable = pcall(function()
            return require(moduleData.Script)
        end)
        if success and type(moduleTable) == "table" then
            findRefs(moduleTable, moduleData.Name, 0)
        end
    end
    return references
end
function Modules.OverseerCE:DumpModule(moduleScript, includeMetatables, includeFunctions, maxDepth)
    maxDepth = maxDepth or 10
    local success, moduleTable = pcall(function()
        return require(moduleScript)
    end)
    if not success then
        return {Success = false, Error = "Failed to require module"}
    end
    local dump = {
        Name = moduleScript.Name,
        Path = moduleScript:GetFullName(),
        Timestamp = os.date("%Y-%m-%d %H:%M:%S"),
        Structure = {}
    }
    local visited = {}
    local function dumpValue(value, depth)
        if depth > maxDepth then
            return {Type = type(value), Value = "[MAX DEPTH]"}
        end
        local valueType = type(value)
        if valueType == "nil" or valueType == "boolean" or valueType == "number" then
            return {Type = valueType, Value = value}
        elseif valueType == "string" then
            return {Type = valueType, Value = value:sub(1, 100)}
        elseif valueType == "function" then
            if not includeFunctions then
                return {Type = "function", Value = "[FUNCTION]"}
            end
            local info = {}
            pcall(function()
                if debug and debug.getinfo then
                    local dbgInfo = debug.getinfo(value)
                    info = {
                        Source = dbgInfo.source,
                        LineDefined = dbgInfo.linedefined,
                        NumParams = dbgInfo.nparams,
                        NumUpvalues = dbgInfo.nups
                    }
                end
            end)
            return {
                Type = "function",
                Value = tostring(value),
                DebugInfo = info
            }
        elseif valueType == "table" then
            if visited[value] then
                return {Type = "table", Value = "[CIRCULAR:" .. tostring(value) .. "]"}
            end
            visited[value] = true
            local tableDump = {
                Type = "table",
                Address = tostring(value),
                Fields = {}
            }
            for k, v in pairs(value) do
                tableDump.Fields[tostring(k)] = dumpValue(v, depth + 1)
            end
            if includeMetatables then
                local mt = getmetatable(value)
                if mt then
                    tableDump.Metatable = dumpValue(mt, depth + 1)
                end
            end
            return tableDump
        else
            return {Type = valueType, Value = tostring(value)}
        end
    end
    dump.Structure = dumpValue(moduleTable, 0)
    table.insert(self.State.DumpedModules, dump)
    return {Success = true, Dump = dump}
end
function Modules.OverseerCE:ExportDump(dump)
    local HttpService = game:GetService("HttpService")
    local success, json = pcall(function()
        return HttpService:JSONEncode(dump)
    end)
    if success then
        local copied = self:_setClipboard(json)
        if copied then
            self:_showNotification("Dump exported to clipboard!", "success")
        else
            self:_showNotification("Failed to copy to clipboard", "error")
        end
        return {Success = true, JSON = json}
    else
        self:_showNotification("JSON encoding failed", "error")
        return {Success = false, Error = "JSON encoding failed: " .. tostring(json)}
    end
end
function Modules.OverseerCE:DumpAllModules()
    local allDumps = {}
    for _, moduleData in ipairs(self.State.ModuleList) do
        local result = self:DumpModule(moduleData.Script, true, true, 8)
        if result.Success then
            table.insert(allDumps, result.Dump)
        end
    end
    return {
        Success = true,
        Timestamp = os.date("%Y-%m-%d %H:%M:%S"),
        TotalModules = #allDumps,
        Dumps = allDumps
    }
end
function Modules.OverseerCE:InjectCode(code, targetModule, withUpvalues)
    local success, result = pcall(function()
        local func = loadstring(code)
        if not func then
            return {Success = false, Error = "Failed to compile code"}
        end
        local env = {}
        local envMeta = {}
        if targetModule then
            local moduleTable = require(targetModule)
            envMeta.__index = function(_, key)
                if moduleTable[key] ~= nil then
                    return moduleTable[key]
                end
                return _G[key]
            end
            envMeta.__newindex = function(_, key, value)
                if moduleTable[key] ~= nil then
                    moduleTable[key] = value
                else
                    _G[key] = value
                end
            end
        else
            envMeta.__index = _G
            envMeta.__newindex = _G
        end
        setmetatable(env, envMeta)
        if setfenv then
            setfenv(func, env)
        end
        local execResult = {func()}
        table.insert(self.State.InjectionHistory, {
            Code = code,
            Target = targetModule and targetModule.Name or "Global",
            Timestamp = tick(),
            Result = execResult
        })
        return {Success = true, Result = execResult}
    end)
    if success then
        return result
    else
        return {Success = false, Error = tostring(result)}
    end
end
function Modules.OverseerCE:GetUpvalues(func)
    if type(func) ~= "function" then
        return {Success = false, Error = "Not a function"}
    end
    local upvalues = {}
    if debug and debug.getupvalue then
        local i = 1
        while true do
            local name, value = debug.getupvalue(func, i)
            if not name then break end
            table.insert(upvalues, {
                Index = i,
                Name = name,
                Value = value,
                Type = type(value)
            })
            i = i + 1
        end
    end
    return {Success = true, Upvalues = upvalues}
end
function Modules.OverseerCE:SetUpvalue(func, index, newValue)
    if type(func) ~= "function" then
        return {Success = false, Error = "Not a function"}
    end
    if debug and debug.setupvalue then
        local name = debug.setupvalue(func, index, newValue)
        if name then
            return {Success = true, UpvalueName = name}
        else
            return {Success = false, Error = "Invalid upvalue index"}
        end
    end
    return {Success = false, Error = "debug.setupvalue not available"}
end
function Modules.OverseerCE:EnableAntiTamper()
    if self.State.AntiTamperActive then
        return {Success = false, Error = "Anti-tamper already active"}
    end
    self.State.OriginalFunctions = {
        getmetatable = getmetatable,
        setmetatable = setmetatable,
        rawget = rawget,
        rawset = rawset,
        rawequal = rawequal,
        type = type,
        typeof = typeof
    }
    local originalGetmetatable = getmetatable
    getmetatable = function(tbl)
        local mt = originalGetmetatable(tbl)
        if mt and self.State.ActivePatches[mt] then
            local cleanMt = {}
            for k, v in pairs(mt) do
                if not self.State.ActivePatches[mt][k] then
                    cleanMt[k] = v
                else
                    cleanMt[k] = self.State.ActivePatches[mt][k].Original
                end
            end
            return cleanMt
        end
        return mt
    end
    local originalSetmetatable = setmetatable
    setmetatable = function(tbl, mt)
        print("[Anti-Tamper] setmetatable called on:", tostring(tbl))
        return originalSetmetatable(tbl, mt)
    end
    local originalRawset = rawset
    rawset = function(tbl, key, value)
        for patchId, patch in pairs(self.State.FreezeList) do
            if patch.Table == tbl and patch.Key == key then
                print("[Anti-Tamper] Blocked rawset on frozen patch:", key)
                return
            end
        end
        return originalRawset(tbl, key, value)
    end
    local originalType = type
    type = function(value)
        if self.State.HookedFunctions[value] then
            return "function"
        end
        return originalType(value)
    end
    if typeof then
        local originalTypeof = typeof
        typeof = function(value)
            if self.State.HookedFunctions[value] then
                return "function"
            end
            return originalTypeof(value)
        end
    end
    self.State.AntiTamperActive = true
    print("[Anti-Tamper] Protection enabled")
    return {Success = true}
end
function Modules.OverseerCE:DisableAntiTamper()
    if not self.State.AntiTamperActive then
        return {Success = false, Error = "Anti-tamper not active"}
    end
    getmetatable = self.State.OriginalFunctions.getmetatable
    setmetatable = self.State.OriginalFunctions.setmetatable
    rawget = self.State.OriginalFunctions.rawget
    rawset = self.State.OriginalFunctions.rawset
    rawequal = self.State.OriginalFunctions.rawequal
    type = self.State.OriginalFunctions.type
    if typeof then
        typeof = self.State.OriginalFunctions.typeof
    end
    self.State.AntiTamperActive = false
    self.State.OriginalFunctions = {}
    print("[Anti-Tamper] Protection disabled")
    return {Success = true}
end
function Modules.OverseerCE:DetectAntiCheat()
    local detections = {}
    local patterns = {
        {Name = "getfenv Hook", Check = function()
            return getfenv ~= debug.getfenv
        end},
        {Name = "Protected Metatables", Check = function()
            local test = {}
            local success = pcall(function()
                setmetatable(test, {__metatable = "Locked"})
                getmetatable(test)
            end)
            return not success
        end},
        {Name = "Debug Library Available", Check = function()
            return debug ~= nil
        end},
        {Name = "Global Hooks", Check = function()
            return _G.__HOOKED or _G.__PROTECTED or _G.__ANTICHEAT
        end}
    }
    for _, pattern in ipairs(patterns) do
        local success, result = pcall(pattern.Check)
        if success then
            table.insert(detections, {
                Name = pattern.Name,
                Detected = result,
                Timestamp = tick()
            })
        end
    end
    return {Success = true, Detections = detections}
end
function Modules.OverseerCE:AnalyzeMetatableChain(tbl)
    local chain = {}
    local current = tbl
    local depth = 0
    local visited = {}
    while current and depth < 20 do
        if visited[current] then break end
        visited[current] = true
        local mt, method = self:GetRawMetatable(current)
        if not mt then break end
        local unlocked, unlockMsg = self:UnlockMetatable(current)
        local chainEntry = {
            Depth = depth,
            Metatable = mt,
            Fields = {},
            HasIndex = false,
            IndexType = nil,
            IndexValue = nil,
            Locked = not unlocked,
            AccessMethod = method,
            UnlockMessage = unlockMsg
        }
        local fieldSuccess, fieldErr = pcall(function()
            for k, v in pairs(mt) do
                table.insert(chainEntry.Fields, {
                    Key = k,
                    Value = v,
                    Type = type(v)
                })
                if k == "__index" then
                    chainEntry.HasIndex = true
                    chainEntry.IndexType = type(v)
                    chainEntry.IndexValue = v
                end
            end
        end)
        if not fieldSuccess then
            table.insert(chainEntry.Fields, {
                Key = "[ERROR]",
                Value = "Cannot iterate metatable: " .. tostring(fieldErr),
                Type = "error"
            })
        end
        table.insert(chain, chainEntry)
        if chainEntry.HasIndex and chainEntry.IndexType == "table" then
            current = chainEntry.IndexValue
        else
            break
        end
        depth = depth + 1
    end
    return chain
end
function Modules.OverseerCE:CreatePatch(tbl, key, newValue, freeze)
    if not tbl or key == nil then return false end
    local patchId = self:_generateUID()
    pcall(function()
        if setreadonly then setreadonly(tbl, false) 
        elseif make_writeable then make_writeable(tbl) end
    end)
    local originalValue = rawget(tbl, key)
    local patch = {
        ID = patchId,
        Table = tbl,
        Key = key,
        Original = originalValue,
        NewValue = newValue,
        Frozen = freeze or false,
        Type = type(newValue),
        Timestamp = tick(),
        Active = true
    }
    rawset(tbl, key, newValue)
    self.State.ActivePatches[patchId] = patch
    if freeze then
        self.State.FreezeList[patchId] = patch
    end
    pcall(function()
        if setreadonly then setreadonly(tbl, true) end
    end)
    self:RefreshPatchList()
    self:_showNotification("Patch applied to: " .. tostring(key), "success")
    return patchId
end
function Modules.OverseerCE:CreateQuickHook(func, parentTable, key, hookType, customValue)
    if type(func) ~= "function" then
        self:_showNotification("Can only hook functions", "error")
        return false
    end
    local hookId = self:_generateUID()
    local originalFunc = func
    local hookFunc
    if hookType == "return_true" then
        hookFunc = function(...)
            return true
        end
    elseif hookType == "return_false" then
        hookFunc = function(...)
            return false
        end
    elseif hookType == "return_nil" then
        hookFunc = function(...)
            return nil
        end
    elseif hookType == "return_zero" then
        hookFunc = function(...)
            return 0
        end
    elseif hookType == "return_one" then
        hookFunc = function(...)
            return 1
        end
    elseif hookType == "return_empty_table" then
        hookFunc = function(...)
            return {}
        end
    elseif hookType == "return_empty_string" then
        hookFunc = function(...)
            return ""
        end
    elseif hookType == "block" then
        hookFunc = function(...)
        end
    elseif hookType == "log_passthrough" then
        hookFunc = function(...)
            local args = {...}
            print("[Hook Log]", key, "called with", #args, "arguments")
            for i, arg in ipairs(args) do
                print("  Arg " .. i .. ":", tostring(arg))
            end
            local results = {originalFunc(...)}
            print("[Hook Log]", key, "returned", #results, "values")
            for i, result in ipairs(results) do
                print("  Result " .. i .. ":", tostring(result))
            end
            return table.unpack(results)
        end
    elseif hookType == "custom" then
        hookFunc = function(...)
            return customValue
        end
    else
        self:_showNotification("Unknown hook type", "error")
        return false
    end
    pcall(function()
        if setreadonly then setreadonly(parentTable, false) 
        elseif make_writeable then make_writeable(parentTable) end
    end)
    rawset(parentTable, key, hookFunc)
    pcall(function()
        if setreadonly then setreadonly(parentTable, true) end
    end)
    self.State.HookedFunctions[hookId] = {
        ID = hookId,
        Table = parentTable,
        Key = key,
        Original = originalFunc,
        HookFunction = hookFunc,
        HookType = hookType,
        CustomValue = customValue,
        Enabled = true,
        CallCount = 0,
        Timestamp = tick()
    }
    self.State.ActivePatches[hookId] = {
        ID = hookId,
        Table = parentTable,
        Key = key,
        Original = originalFunc,
        NewValue = hookFunc,
        Type = "function_hook",
        Frozen = false,
        Timestamp = tick(),
        Active = true,
        HookType = hookType
    }
    self:RefreshPatchList()
    self:RefreshHookList()
    local hookName = self:GetHookTypeName(hookType, customValue)
    self:_showNotification("Hooked: " .. tostring(key) .. " â†’ " .. hookName, "success")
    return hookId
end
function Modules.OverseerCE:GetHookTypeName(hookType, customValue)
    local names = {
        return_true = "return true",
        return_false = "return false",
        return_nil = "return nil",
        return_zero = "return 0",
        return_one = "return 1",
        return_empty_table = "return {}",
        return_empty_string = 'return ""',
        block = "block (no return)",
        log_passthrough = "log & passthrough",
        custom = "return " .. tostring(customValue)
    }
    return names[hookType] or hookType
end
function Modules.OverseerCE:RemoveHook(hookId)
    local hook = self.State.HookedFunctions[hookId]
    if not hook then return false end
    pcall(function()
        if setreadonly then setreadonly(hook.Table, false) 
        elseif make_writeable then make_writeable(hook.Table) end
        rawset(hook.Table, hook.Key, hook.Original)
        if setreadonly then setreadonly(hook.Table, true) end
    end)
    self.State.HookedFunctions[hookId] = nil
    self.State.ActivePatches[hookId] = nil
    self:RefreshPatchList()
    self:RefreshHookList()
    self:_showNotification("Hook removed", "success")
    return true
end
function Modules.OverseerCE:ToggleHook(hookId)
    local hook = self.State.HookedFunctions[hookId]
    if not hook then return end
    pcall(function()
        if setreadonly then setreadonly(hook.Table, false) 
        elseif make_writeable then make_writeable(hook.Table) end
    end)
    if hook.Enabled then
        rawset(hook.Table, hook.Key, hook.Original)
        hook.Enabled = false
    else
        rawset(hook.Table, hook.Key, hook.HookFunction)
        hook.Enabled = true
    end
    pcall(function()
        if setreadonly then setreadonly(hook.Table, true) end
    end)
    self:RefreshHookList()
end
function Modules.OverseerCE:ShowQuickHookMenu(func, parentTable, key, buttonPosition)
    if not self.State.UI then return end
    local existingMenu = self.State.UI.Main:FindFirstChild("QuickHookMenu")
    if existingMenu then existingMenu:Destroy() end
    local menu = Instance.new("Frame", self.State.UI.Main)
    menu.Name = "QuickHookMenu"
    menu.Size = UDim2.fromOffset(200, 260)
    menu.Position = buttonPosition or UDim2.fromOffset(400, 300)
    menu.BackgroundColor3 = self.Config.BG_PANEL
    menu.BorderSizePixel = 0
    menu.ZIndex = 500
    self:_createBorder(menu, false)
    local title = Instance.new("TextLabel", menu)
    title.Size = UDim2.new(1, -4, 0, 20)
    title.Position = UDim2.fromOffset(2, 2)
    title.BackgroundColor3 = self.Config.ACCENT_BLUE
    title.Text = "Quick Hook: " .. tostring(key)
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.Font = Enum.Font.SourceSansBold
    title.TextSize = 10
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.TextTruncate = Enum.TextTruncate.AtEnd
    title.BorderSizePixel = 0
    title.ZIndex = 501
    local titlePadding = Instance.new("UIPadding", title)
    titlePadding.PaddingLeft = UDim.new(0, 4)
    self:_createBorder(title, true)
    local hookOptions = {
        {label = "Return true", hookType = "return_true"},
        {label = "Return false", hookType = "return_false"},
        {label = "Return nil", hookType = "return_nil"},
        {label = "Return 0", hookType = "return_zero"},
        {label = "Return 1", hookType = "return_one"},
        {label = "Return {}", hookType = "return_empty_table"},
        {label = 'Return ""', hookType = "return_empty_string"},
        {label = "Block (no return)", hookType = "block"},
        {label = "Log & Passthrough", hookType = "log_passthrough"}
    }
    local yPos = 26
    for _, option in ipairs(hookOptions) do
        local btn = self:_createButton(menu, option.label, UDim2.new(1, -8, 0, 22), UDim2.fromOffset(4, yPos), function()
            self:CreateQuickHook(func, parentTable, key, option.hookType, nil)
            menu:Destroy()
        end)
        btn.ZIndex = 501
        btn.TextSize = 10
        btn.TextXAlignment = Enum.TextXAlignment.Left
        local btnPadding = Instance.new("UIPadding", btn)
        btnPadding.PaddingLeft = UDim.new(0, 4)
        yPos = yPos + 24
    end
    local customLabel = Instance.new("TextLabel", menu)
    customLabel.Size = UDim2.new(1, -8, 0, 16)
    customLabel.Position = UDim2.fromOffset(4, yPos)
    customLabel.BackgroundTransparency = 1
    customLabel.Text = "Custom Return Value:"
    customLabel.TextColor3 = self.Config.TEXT_BLACK
    customLabel.Font = Enum.Font.SourceSansBold
    customLabel.TextSize = 9
    customLabel.TextXAlignment = Enum.TextXAlignment.Left
    customLabel.ZIndex = 501
    yPos = yPos + 18
    local customInput = Instance.new("TextBox", menu)
    customInput.Size = UDim2.new(1, -48, 0, 22)
    customInput.Position = UDim2.fromOffset(4, yPos)
    customInput.BackgroundColor3 = self.Config.BG_WHITE
    customInput.PlaceholderText = "Enter value..."
    customInput.Text = ""
    customInput.TextColor3 = self.Config.TEXT_BLACK
    customInput.Font = Enum.Font.Code
    customInput.TextSize = 9
    customInput.TextXAlignment = Enum.TextXAlignment.Left
    customInput.BorderSizePixel = 0
    customInput.ClearTextOnFocus = false
    customInput.ZIndex = 501
    self:_createBorder(customInput, true)
    local customBtn = self:_createButton(menu, "OK", UDim2.fromOffset(38, 22), UDim2.new(1, -42, 0, yPos), function()
        local value = self:ParseValue(customInput.Text, "any")
        if value ~= nil then
            self:CreateQuickHook(func, parentTable, key, "custom", value)
            menu:Destroy()
        else
            self:_showNotification("Invalid value", "error")
        end
    end)
    customBtn.ZIndex = 501
    customBtn.TextSize = 9
    local closeDetector = Instance.new("TextButton", self.State.UI.Main)
    closeDetector.Size = UDim2.new(1, 0, 1, 0)
    closeDetector.BackgroundTransparency = 1
    closeDetector.Text = ""
    closeDetector.ZIndex = 499
    closeDetector.MouseButton1Click:Connect(function()
        menu:Destroy()
        closeDetector:Destroy()
    end)
    local dragging, dragStart, startPos
    title.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = menu.Position
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local delta = input.Position - dragStart
            menu.Position = UDim2.fromOffset(startPos.X.Offset + delta.X, startPos.Y.Offset + delta.Y)
        end
    end)
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)
end
function Modules.OverseerCE:ParseValue(text, expectedType)
    if expectedType == "string" or text:match('^".*"$') or text:match("^'.*'$") then
        return text:gsub('^["\']', ''):gsub('["\']$', '')
    elseif text == "true" then
        return true
    elseif text == "false" then
        return false
    elseif text == "nil" then
        return nil
    elseif text == "{}" then
        return {}
    elseif tonumber(text) then
        return tonumber(text)
    else
        if expectedType == "any" then
            return text
        end
        return nil
    end
end
function Modules.OverseerCE:RemovePatch(patchId)
    local patch = self.State.ActivePatches[patchId]
    if not patch then return false end
    pcall(function()
        if setreadonly then setreadonly(patch.Table, false) 
        elseif make_writeable then make_writeable(patch.Table) end
        rawset(patch.Table, patch.Key, patch.Original)
        if setreadonly then setreadonly(patch.Table, true) end
    end)
    self.State.ActivePatches[patchId] = nil
    self.State.FreezeList[patchId] = nil
    self:RefreshPatchList()
    self:_showNotification("Patch removed", "success")
    return true
end
function Modules.OverseerCE:ToggleFreeze(patchId)
    local patch = self.State.ActivePatches[patchId]
    if not patch then return end
    patch.Frozen = not patch.Frozen
    if patch.Frozen then
        self.State.FreezeList[patchId] = patch
    else
        self.State.FreezeList[patchId] = nil
    end
    self:RefreshPatchList()
end
function Modules.OverseerCE:CreateUI()
    if self.State.UI and self.State.UI.Main then 
        self.State.UI.Main.Visible = true 
        return 
    end
    local screenGui = Instance.new("ScreenGui", CoreGui)
    screenGui.Name = "OverseerCE"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    local main = Instance.new("Frame", screenGui)
    main.Size = UDim2.fromOffset(900, 600)
    main.Position = UDim2.new(0.5, -450, 0.5, -300)
    main.BackgroundColor3 = self.Config.BG_PANEL
    main.BorderSizePixel = 0
    main.ClipsDescendants = false
    self:_createBorder(main, false)
    local titleBar = Instance.new("Frame", main)
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1, -2, 0, 24)
    titleBar.Position = UDim2.fromOffset(1, 1)
    titleBar.BackgroundColor3 = self.Config.ACCENT_BLUE
    titleBar.BorderSizePixel = 0
    titleBar.ZIndex = 2
    local titleGradient = Instance.new("UIGradient", titleBar)
    titleGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(49, 106, 197)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(150, 190, 230))
    }
    titleGradient.Rotation = 90
    local titleIcon = Instance.new("TextLabel", titleBar)
    titleIcon.Size = UDim2.fromOffset(20, 20)
    titleIcon.Position = UDim2.fromOffset(2, 2)
    titleIcon.BackgroundTransparency = 1
    titleIcon.Text = "ðŸ”§"
    titleIcon.TextColor3 = self.Config.BG_WHITE
    titleIcon.Font = Enum.Font.SourceSansBold
    titleIcon.TextSize = 14
    titleIcon.ZIndex = 3
    local title = Instance.new("TextLabel", titleBar)
    title.Size = UDim2.new(1, -100, 1, 0)
    title.Position = UDim2.fromOffset(24, 0)
    title.Text = "Overseer CE 7.5 Enhanced - Module Inspector & Patcher"
    title.TextColor3 = self.Config.BG_WHITE
    title.Font = Enum.Font.SourceSansBold
    title.TextSize = 12
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.BackgroundTransparency = 1
    title.ZIndex = 3
    local closeBtn = self:_createButton(titleBar, "Ã—", UDim2.fromOffset(20, 20), UDim2.new(1, -22, 0, 2), function()
        main.Visible = false
    end)
    closeBtn.ZIndex = 4
    closeBtn.TextSize = 16
    closeBtn.Font = Enum.Font.SourceSansBold
    closeBtn.BackgroundColor3 = self.Config.BG_LIGHT
    local minBtn = self:_createButton(titleBar, "_", UDim2.fromOffset(20, 20), UDim2.new(1, -44, 0, 2), function()
        main.Visible = false
    end)
    minBtn.ZIndex = 4
    minBtn.TextYAlignment = Enum.TextYAlignment.Top
    minBtn.BackgroundColor3 = self.Config.BG_LIGHT
    local resizeHandle = Instance.new("Frame", main)
    resizeHandle.Name = "ResizeHandle"
    resizeHandle.Size = UDim2.fromOffset(16, 16)
    resizeHandle.Position = UDim2.new(1, -16, 1, -16)
    resizeHandle.BackgroundColor3 = self.Config.BG_DARK
    resizeHandle.BorderSizePixel = 0
    resizeHandle.ZIndex = 10
    local resizeLine1 = Instance.new("Frame", resizeHandle)
    resizeLine1.Size = UDim2.fromOffset(2, 12)
    resizeLine1.Position = UDim2.fromOffset(10, 2)
    resizeLine1.BackgroundColor3 = self.Config.BORDER_LIGHT
    resizeLine1.BorderSizePixel = 0
    resizeLine1.Rotation = 45
    local resizeLine2 = Instance.new("Frame", resizeHandle)
    resizeLine2.Size = UDim2.fromOffset(2, 12)
    resizeLine2.Position = UDim2.fromOffset(6, 2)
    resizeLine2.BackgroundColor3 = self.Config.BORDER_LIGHT
    resizeLine2.BorderSizePixel = 0
    resizeLine2.Rotation = 45
    local resizeLine3 = Instance.new("Frame", resizeHandle)
    resizeLine3.Size = UDim2.fromOffset(2, 8)
    resizeLine3.Position = UDim2.fromOffset(2, 4)
    resizeLine3.BackgroundColor3 = self.Config.BORDER_LIGHT
    resizeLine3.BorderSizePixel = 0
    resizeLine3.Rotation = 45
    local content = Instance.new("Frame", main)
    content.Size = UDim2.new(1, -4, 1, -28)
    content.Position = UDim2.fromOffset(2, 26)
    content.BackgroundColor3 = self.Config.BG_PANEL
    content.BorderSizePixel = 0
    local menuBar = Instance.new("Frame", content)
    menuBar.Size = UDim2.new(1, 0, 0, 22)
    menuBar.Position = UDim2.fromOffset(0, 0)
    menuBar.BackgroundColor3 = self.Config.BG_PANEL
    menuBar.BorderSizePixel = 0
    self:_createBorder(menuBar, false)
    local menuItems = {"Tools", "Scanner", "Dumper", "Injector", "Anti-Tamper", "Hooks", "Decompiler", "Poisons"}
    local menuX = 4
    for _, menuName in ipairs(menuItems) do
        local menuBtn = self:_createButton(menuBar, menuName, UDim2.fromOffset(75, 18), UDim2.fromOffset(menuX, 2), function()
            self:OpenToolWindow(menuName)
        end)
        menuBtn.TextSize = 10
        menuX = menuX + 77
    end
    local modulePanel = self:_createPanel(content, UDim2.fromOffset(4, 26), UDim2.new(0, 280, 1, -30), "Module List")
    local moduleSearch = Instance.new("TextBox", modulePanel)
    moduleSearch.Size = UDim2.new(1, -8, 0, 22)
    moduleSearch.Position = UDim2.fromOffset(4, 24)
    moduleSearch.BackgroundColor3 = self.Config.BG_WHITE
    moduleSearch.Text = ""
    moduleSearch.PlaceholderText = "Search modules..."
    moduleSearch.TextColor3 = self.Config.TEXT_BLACK
    moduleSearch.Font = Enum.Font.SourceSans
    moduleSearch.TextSize = 11
    moduleSearch.TextXAlignment = Enum.TextXAlignment.Left
    moduleSearch.BorderSizePixel = 0
    moduleSearch.ClearTextOnFocus = false
    local searchPadding = Instance.new("UIPadding", moduleSearch)
    searchPadding.PaddingLeft = UDim.new(0, 4)
    self:_createBorder(moduleSearch, true)
    local moduleScroll = Instance.new("ScrollingFrame", modulePanel)
    moduleScroll.Size = UDim2.new(1, -8, 1, -54)
    moduleScroll.Position = UDim2.fromOffset(4, 50)
    moduleScroll.BackgroundColor3 = self.Config.BG_WHITE
    moduleScroll.BorderSizePixel = 0
    moduleScroll.ScrollBarThickness = 12
    moduleScroll.ScrollBarImageColor3 = self.Config.BG_DARK
    moduleScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
    moduleScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
    self:_createBorder(moduleScroll, true)
    local moduleList = Instance.new("UIListLayout", moduleScroll)
    moduleList.Padding = UDim.new(0, 1)
    local inspectorPanel = self:_createPanel(content, UDim2.fromOffset(292, 26), UDim2.new(1, -596, 1, -30), "Table Inspector")
    local toolbar = Instance.new("Frame", inspectorPanel)
    toolbar.Size = UDim2.new(1, -8, 0, 28)
    toolbar.Position = UDim2.fromOffset(4, 24)
    toolbar.BackgroundColor3 = self.Config.BG_DARK
    toolbar.BorderSizePixel = 0
    self:_createBorder(toolbar, true)
    local backBtn = self:_createButton(toolbar, "< Back", UDim2.fromOffset(60, 22), UDim2.fromOffset(2, 2), function()
        self:GoBack()
    end)
    local refreshBtn = self:_createButton(toolbar, "Refresh", UDim2.fromOffset(60, 22), UDim2.fromOffset(64, 2), function()
        self:RefreshInspector()
    end)
    local pathLabel = Instance.new("TextLabel", toolbar)
    pathLabel.Size = UDim2.new(1, -130, 1, -4)
    pathLabel.Position = UDim2.fromOffset(128, 2)
    pathLabel.BackgroundTransparency = 1
    pathLabel.Text = "Root"
    pathLabel.TextColor3 = self.Config.TEXT_BLACK
    pathLabel.Font = Enum.Font.Code
    pathLabel.TextSize = 10
    pathLabel.TextXAlignment = Enum.TextXAlignment.Left
    pathLabel.TextTruncate = Enum.TextTruncate.AtEnd
    local headerFrame = Instance.new("Frame", inspectorPanel)
    headerFrame.Size = UDim2.new(1, -8, 0, self.Config.ROW_HEIGHT)
    headerFrame.Position = UDim2.fromOffset(4, 56)
    headerFrame.BackgroundColor3 = self.Config.BG_DARK
    headerFrame.BorderSizePixel = 0
    self:_createBorder(headerFrame, true)
    local headers = {"Active", "Key", "Type", "Value", "Actions"}
    local headerWidths = {0.08, 0.25, 0.12, 0.35, 0.2}
    local xPos = 0
    for i, headerText in ipairs(headers) do
        local header = Instance.new("TextLabel", headerFrame)
        header.Size = UDim2.new(headerWidths[i], -2, 1, 0)
        header.Position = UDim2.new(xPos, 1, 0, 0)
        header.BackgroundTransparency = 1
        header.Text = headerText
        header.TextColor3 = self.Config.TEXT_BLACK
        header.Font = Enum.Font.SourceSansBold
        header.TextSize = 10
        header.TextXAlignment = Enum.TextXAlignment.Left
        local headerPadding = Instance.new("UIPadding", header)
        headerPadding.PaddingLeft = UDim.new(0, 4)
        xPos = xPos + headerWidths[i]
    end
    local inspectorScroll = Instance.new("ScrollingFrame", inspectorPanel)
    inspectorScroll.Size = UDim2.new(1, -8, 1, -84)
    inspectorScroll.Position = UDim2.fromOffset(4, 76)
    inspectorScroll.BackgroundColor3 = self.Config.BG_WHITE
    inspectorScroll.BorderSizePixel = 0
    inspectorScroll.ScrollBarThickness = 12
    inspectorScroll.ScrollBarImageColor3 = self.Config.BG_DARK
    inspectorScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
    inspectorScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
    self:_createBorder(inspectorScroll, true)
    local inspectorList = Instance.new("UIListLayout", inspectorScroll)
    inspectorList.Padding = UDim.new(0, 0)
    local patchPanel = self:_createPanel(content, UDim2.new(1, -304, 0, 26), UDim2.new(0, 296, 1, -30), "Active Patches")
    local patchControls = Instance.new("Frame", patchPanel)
    patchControls.Size = UDim2.new(1, -8, 0, 28)
    patchControls.Position = UDim2.fromOffset(4, 24)
    patchControls.BackgroundColor3 = self.Config.BG_DARK
    patchControls.BorderSizePixel = 0
    self:_createBorder(patchControls, true)
    local clearAllBtn = self:_createButton(patchControls, "Clear All", UDim2.fromOffset(70, 22), UDim2.fromOffset(2, 2), function()
        for patchId in pairs(self.State.ActivePatches) do
            self:RemovePatch(patchId)
        end
    end)
    local exportBtn = self:_createButton(patchControls, "Export", UDim2.fromOffset(60, 22), UDim2.fromOffset(74, 2), function()
        self:ExportPatches()
    end)
    local patchCount = Instance.new("TextLabel", patchControls)
    patchCount.Size = UDim2.new(1, -140, 1, 0)
    patchCount.Position = UDim2.fromOffset(138, 0)
    patchCount.BackgroundTransparency = 1
    patchCount.Text = "Patches: 0"
    patchCount.TextColor3 = self.Config.TEXT_BLACK
    patchCount.Font = Enum.Font.SourceSans
    patchCount.TextSize = 10
    patchCount.TextXAlignment = Enum.TextXAlignment.Left
    local patchHeaderFrame = Instance.new("Frame", patchPanel)
    patchHeaderFrame.Size = UDim2.new(1, -8, 0, self.Config.ROW_HEIGHT)
    patchHeaderFrame.Position = UDim2.fromOffset(4, 56)
    patchHeaderFrame.BackgroundColor3 = self.Config.BG_DARK
    patchHeaderFrame.BorderSizePixel = 0
    self:_createBorder(patchHeaderFrame, true)
    local patchHeaders = {"Frozen", "Key", "Value", "Del"}
    local patchHeaderWidths = {0.15, 0.35, 0.35, 0.15}
    local patchXPos = 0
    for i, patchHeaderText in ipairs(patchHeaders) do
        local patchHeader = Instance.new("TextLabel", patchHeaderFrame)
        patchHeader.Size = UDim2.new(patchHeaderWidths[i], -2, 1, 0)
        patchHeader.Position = UDim2.new(patchXPos, 1, 0, 0)
        patchHeader.BackgroundTransparency = 1
        patchHeader.Text = patchHeaderText
        patchHeader.TextColor3 = self.Config.TEXT_BLACK
        patchHeader.Font = Enum.Font.SourceSansBold
        patchHeader.TextSize = 10
        patchHeader.TextXAlignment = Enum.TextXAlignment.Left
        local patchHeaderPadding = Instance.new("UIPadding", patchHeader)
        patchHeaderPadding.PaddingLeft = UDim.new(0, 4)
        patchXPos = patchXPos + patchHeaderWidths[i]
    end
    local patchScroll = Instance.new("ScrollingFrame", patchPanel)
    patchScroll.Size = UDim2.new(1, -8, 1, -84)
    patchScroll.Position = UDim2.fromOffset(4, 76)
    patchScroll.BackgroundColor3 = self.Config.BG_WHITE
    patchScroll.BorderSizePixel = 0
    patchScroll.ScrollBarThickness = 12
    patchScroll.ScrollBarImageColor3 = self.Config.BG_DARK
    patchScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
    patchScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
    self:_createBorder(patchScroll, true)
    local patchList = Instance.new("UIListLayout", patchScroll)
    patchList.Padding = UDim.new(0, 0)
    self.State.UI = {
        ScreenGui = screenGui,
        Main = main,
        ModuleScroll = moduleScroll,
        ModuleSearch = moduleSearch,
        InspectorScroll = inspectorScroll,
        PathLabel = pathLabel,
        PatchScroll = patchScroll,
        PatchCount = patchCount,
        ResizeHandle = resizeHandle,
        HookScroll = nil
    }
    local dragging, dragStart, startPos
    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = main.Position
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local delta = input.Position - dragStart
            main.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)
    local resizing = false
    local resizeStart = nil
    local startSize = nil
    resizeHandle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            resizing = true
            resizeStart = input.Position
            startSize = main.Size
        end
    end)
    resizeHandle.MouseEnter:Connect(function()
        resizeHandle.BackgroundColor3 = self.Config.BORDER_DARK
    end)
    resizeHandle.MouseLeave:Connect(function()
        resizeHandle.BackgroundColor3 = self.Config.BG_DARK
    end)
    UserInputService.InputChanged:Connect(function(input)
        if resizing and input.UserInputType == Enum.UserInputType.MouseMovement then
            local delta = input.Position - resizeStart
            local newWidth = math.max(700, startSize.X.Offset + delta.X)
            local newHeight = math.max(400, startSize.Y.Offset + delta.Y)
            main.Size = UDim2.fromOffset(newWidth, newHeight)
        end
    end)
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            resizing = false
        end
    end)
    local searchDebounce = nil
    moduleSearch.Changed:Connect(function(property)
        if property == "Text" then
            if searchDebounce then
                task.cancel(searchDebounce)
            end
            searchDebounce = task.delay(0.3, function()
                self:FilterModules(moduleSearch.Text)
            end)
        end
    end)
function Modules.OverseerCE:CreateHookManagerPanel(parent)
    local panel = self:_createPanel(parent, UDim2.fromOffset(4, 4), UDim2.new(1, -8, 1, -8), "Hook Manager")
    panel.ZIndex = 100
    local info = Instance.new("TextLabel", panel)
    info.Size = UDim2.new(1, -8, 0, 32)
    info.Position = UDim2.fromOffset(4, 24)
    info.BackgroundColor3 = Color3.fromRGB(220, 240, 255)
    info.Text = "Active function hooks. Toggle enabled/disabled or remove hooks below."
    info.TextColor3 = self.Config.TEXT_BLACK
    info.Font = Enum.Font.SourceSans
    info.TextSize = 10
    info.TextXAlignment = Enum.TextXAlignment.Left
    info.TextYAlignment = Enum.TextYAlignment.Top
    info.TextWrapped = true
    info.BorderSizePixel = 0
    info.ZIndex = 101
    local infoPadding = Instance.new("UIPadding", info)
    infoPadding.PaddingLeft = UDim.new(0, 4)
    infoPadding.PaddingTop = UDim.new(0, 4)
    self:_createBorder(info, true)
    local clearAllBtn = self:_createButton(panel, "Clear All Hooks", UDim2.fromOffset(120, 24), UDim2.fromOffset(4, 60), function()
        for hookId in pairs(self.State.HookedFunctions) do
            self:RemoveHook(hookId)
        end
        self:_showNotification("All hooks removed", "success")
    end)
    clearAllBtn.ZIndex = 101
    local headerFrame = Instance.new("Frame", panel)
    headerFrame.Size = UDim2.new(1, -8, 0, self.Config.ROW_HEIGHT)
    headerFrame.Position = UDim2.fromOffset(4, 88)
    headerFrame.BackgroundColor3 = self.Config.BG_DARK
    headerFrame.BorderSizePixel = 0
    headerFrame.ZIndex = 101
    self:_createBorder(headerFrame, true)
    local headers = {"On", "Function", "Hook Type", "Calls", "Remove"}
    local headerWidths = {0.08, 0.35, 0.35, 0.12, 0.1}
    local xPos = 0
    for i, headerText in ipairs(headers) do
        local header = Instance.new("TextLabel", headerFrame)
        header.Size = UDim2.new(headerWidths[i], -2, 1, 0)
        header.Position = UDim2.new(xPos, 1, 0, 0)
        header.BackgroundTransparency = 1
        header.Text = headerText
        header.TextColor3 = self.Config.TEXT_BLACK
        header.Font = Enum.Font.SourceSansBold
        header.TextSize = 10
        header.TextXAlignment = Enum.TextXAlignment.Left
        header.ZIndex = 102
        local headerPadding = Instance.new("UIPadding", header)
        headerPadding.PaddingLeft = UDim.new(0, 4)
        xPos = xPos + headerWidths[i]
    end
    local hookScroll = Instance.new("ScrollingFrame", panel)
    hookScroll.Name = "HookScroll"
    hookScroll.Size = UDim2.new(1, -8, 1, -116)
    hookScroll.Position = UDim2.fromOffset(4, 108)
    hookScroll.BackgroundColor3 = self.Config.BG_WHITE
    hookScroll.BorderSizePixel = 0
    hookScroll.ScrollBarThickness = 12
    hookScroll.ScrollBarImageColor3 = self.Config.BG_DARK
    hookScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
    hookScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
    hookScroll.ZIndex = 101
    self:_createBorder(hookScroll, true)
    local hookList = Instance.new("UIListLayout", hookScroll)
    hookList.Padding = UDim.new(0, 0)
    self.State.UI.HookScroll = hookScroll
    return panel
end
function Modules.OverseerCE:RefreshHookList()
    if not self.State.UI or not self.State.UI.HookScroll then return end
    for _, child in ipairs(self.State.UI.HookScroll:GetChildren()) do
        if not child:IsA("UIListLayout") then
            child:Destroy()
        end
    end
    for hookId, hook in pairs(self.State.HookedFunctions) do
        self:CreateHookRow(hookId, hook)
    end
end
function Modules.OverseerCE:CreateHookRow(hookId, hook)
    if not self.State.UI or not self.State.UI.HookScroll then return end
    local row = Instance.new("Frame", self.State.UI.HookScroll)
    row.Size = UDim2.new(1, -2, 0, self.Config.ROW_HEIGHT)
    row.BackgroundColor3 = hook.Enabled and self.Config.BG_WHITE or Color3.fromRGB(240, 240, 240)
    row.BorderSizePixel = 0
    row.ZIndex = 102
    local enabledBox = Instance.new("TextButton", row)
    enabledBox.Size = UDim2.fromOffset(12, 12)
    enabledBox.Position = UDim2.new(0.04, -6, 0.5, -6)
    enabledBox.BackgroundColor3 = self.Config.BG_WHITE
    enabledBox.Text = hook.Enabled and "âœ“" or ""
    enabledBox.TextColor3 = self.Config.SUCCESS_GREEN
    enabledBox.Font = Enum.Font.SourceSansBold
    enabledBox.TextSize = 10
    enabledBox.BorderSizePixel = 0
    enabledBox.AutoButtonColor = false
    enabledBox.ZIndex = 103
    self:_createBorder(enabledBox, true)
    enabledBox.MouseButton1Click:Connect(function()
        self:ToggleHook(hookId)
    end)
    local funcLabel = Instance.new("TextLabel", row)
    funcLabel.Size = UDim2.new(0.35, -4, 1, 0)
    funcLabel.Position = UDim2.new(0.08, 2, 0, 0)
    funcLabel.BackgroundTransparency = 1
    funcLabel.Text = tostring(hook.Key)
    funcLabel.TextColor3 = self.Config.TEXT_BLACK
    funcLabel.Font = Enum.Font.Code
    funcLabel.TextSize = 10
    funcLabel.TextXAlignment = Enum.TextXAlignment.Left
    funcLabel.TextTruncate = Enum.TextTruncate.AtEnd
    funcLabel.ZIndex = 103
    local hookTypeLabel = Instance.new("TextLabel", row)
    hookTypeLabel.Size = UDim2.new(0.35, -4, 1, 0)
    hookTypeLabel.Position = UDim2.new(0.43, 2, 0, 0)
    hookTypeLabel.BackgroundTransparency = 1
    hookTypeLabel.Text = self:GetHookTypeName(hook.HookType, hook.CustomValue)
    hookTypeLabel.TextColor3 = Color3.fromRGB(0, 100, 200)
    hookTypeLabel.Font = Enum.Font.SourceSans
    hookTypeLabel.TextSize = 9
    hookTypeLabel.TextXAlignment = Enum.TextXAlignment.Left
    hookTypeLabel.TextTruncate = Enum.TextTruncate.AtEnd
    hookTypeLabel.ZIndex = 103
    local callLabel = Instance.new("TextLabel", row)
    callLabel.Size = UDim2.new(0.12, -4, 1, 0)
    callLabel.Position = UDim2.new(0.78, 2, 0, 0)
    callLabel.BackgroundTransparency = 1
    callLabel.Text = tostring(hook.CallCount or 0)
    callLabel.TextColor3 = self.Config.TEXT_GRAY
    callLabel.Font = Enum.Font.SourceSans
    callLabel.TextSize = 9
    callLabel.TextXAlignment = Enum.TextXAlignment.Center
    callLabel.ZIndex = 103
    local removeBtn = self:_createButton(row, "Ã—", UDim2.fromOffset(16, 16), UDim2.new(0.90, 2, 0.5, -8), function()
        self:RemoveHook(hookId)
    end)
    removeBtn.ZIndex = 103
    removeBtn.TextSize = 12
    row.MouseEnter:Connect(function()
        row.BackgroundColor3 = Color3.fromRGB(230, 240, 255)
    end)
    row.MouseLeave:Connect(function()
        row.BackgroundColor3 = hook.Enabled and self.Config.BG_WHITE or Color3.fromRGB(240, 240, 240)
    end)
end
    self:ScanModules()
end
function Modules.OverseerCE:ScanModules()
    if not self.State.UI then return end
    for _, child in ipairs(self.State.UI.ModuleScroll:GetChildren()) do
        if not child:IsA("UIListLayout") then
            child:Destroy()
        end
    end
    self.State.ModuleList = {}
    task.spawn(function()
        local paths = {ReplicatedStorage, Players.LocalPlayer, Workspace}
        for _, parent in ipairs(paths) do
            if parent then
                for _, obj in ipairs(parent:GetDescendants()) do
                    if obj:IsA("ModuleScript") then
                        self:AddModuleToList(obj)
                    end
                end
                task.wait()
            end
        end
        self:_showNotification("Scanned " .. #self.State.ModuleList .. " modules", "success")
    end)
end
function Modules.OverseerCE:AddModuleToList(moduleScript)
    if not moduleScript or not moduleScript.Parent then return end
    if not self.State.UI then return end
    local moduleName = moduleScript.Name
    local modulePath = moduleScript:GetFullName()
    local row = Instance.new("TextButton", self.State.UI.ModuleScroll)
    row.Size = UDim2.new(1, -2, 0, self.Config.ROW_HEIGHT)
    row.BackgroundColor3 = self.Config.BG_WHITE
    row.Text = ""
    row.BorderSizePixel = 0
    row.AutoButtonColor = false
    local nameLabel = Instance.new("TextLabel", row)
    nameLabel.Size = UDim2.new(1, -8, 1, 0)
    nameLabel.Position = UDim2.fromOffset(4, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = moduleName
    nameLabel.TextColor3 = self.Config.TEXT_BLACK
    nameLabel.Font = Enum.Font.SourceSans
    nameLabel.TextSize = 10
    nameLabel.TextXAlignment = Enum.TextXAlignment.Left
    nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
    row.MouseButton1Click:Connect(function()
        self:LoadModule(moduleScript)
        for _, child in ipairs(self.State.UI.ModuleScroll:GetChildren()) do
            if child:IsA("TextButton") then
                child.BackgroundColor3 = self.Config.BG_WHITE
                for _, label in ipairs(child:GetChildren()) do
                    if label:IsA("TextLabel") then
                        label.TextColor3 = self.Config.TEXT_BLACK
                    end
                end
            end
        end
        row.BackgroundColor3 = self.Config.HIGHLIGHT
        nameLabel.TextColor3 = self.Config.BG_WHITE
    end)
    row.MouseEnter:Connect(function()
        if row.BackgroundColor3 ~= self.Config.HIGHLIGHT then
            row.BackgroundColor3 = self.Config.BG_LIGHT
        end
    end)
    row.MouseLeave:Connect(function()
        if row.BackgroundColor3 ~= self.Config.HIGHLIGHT then
            row.BackgroundColor3 = self.Config.BG_WHITE
        end
    end)
    table.insert(self.State.ModuleList, {
        Script = moduleScript,
        Row = row,
        Name = moduleName,
        Path = modulePath
    })
end
function Modules.OverseerCE:LoadModule(moduleScript)
    local success, result
    local completed = false
    task.spawn(function()
        success, result = pcall(function()
            return require(moduleScript)
        end)
        completed = true
    end)
    local timeout = 2
    local elapsed = 0
    while not completed and elapsed < timeout do
        task.wait(0.1)
        elapsed = elapsed + 0.1
    end
    if not completed then
        self:_showNotification("Module load timeout: " .. moduleScript.Name .. " (may use WaitForChild)", "warning")
        print("[Overseer CE] Module took too long to load:", moduleScript.Name)
        return
    end
    if not success then
        self:_showNotification("Failed to load module: " .. moduleScript.Name, "error")
        print("[Overseer CE] Module load error:", result)
        return
    end
    if result == nil then
        self:_showNotification("Module returned nil: " .. moduleScript.Name, "warning")
        result = {
            ["[Module Name]"] = moduleScript.Name,
            ["[Return Value]"] = "nil",
            ["[Info]"] = "This module doesn't return a value"
        }
    end
    local moduleContent = self:GetModuleContent(result)
    if type(moduleContent) ~= "table" then
        self:_showNotification("Module could not be displayed as table", "warning")
        return
    end
    self.State.SelectedModule = moduleScript
    self.State.CurrentTable = moduleContent
    self.State.PathStack = {}
    self.State.VisitedTables = {}
    self:RefreshInspector()
    local originalType = type(result)
    if originalType == "nil" then
        self:_showNotification("Loaded: " .. moduleScript.Name .. " [returns nil]", "info")
    elseif originalType ~= "table" then
        self:_showNotification("Loaded: " .. moduleScript.Name .. " [" .. originalType .. " â†’ table wrapper]", "success")
    else
        self:_showNotification("Loaded: " .. moduleScript.Name, "success")
    end
end
function Modules.OverseerCE:RefreshInspector()
    if not self.State.UI or not self.State.CurrentTable then return end
    for _, child in ipairs(self.State.UI.InspectorScroll:GetChildren()) do
        if not child:IsA("UIListLayout") then
            child:Destroy()
        end
    end
    local pathText = "Root"
    if #self.State.PathStack > 0 then
        pathText = table.concat(self.State.PathStack, " > ")
    end
    self.State.UI.PathLabel.Text = pathText
    self:PopulateTable(self.State.CurrentTable)
    local chain = self:AnalyzeMetatableChain(self.State.CurrentTable)
    self.State.MetatableChain = chain
    if #chain > 0 then
        self:DisplayMetatableChain(chain)
    end
end
function Modules.OverseerCE:PopulateTable(tbl, isMetatable)
    if not tbl or type(tbl) ~= "table" then 
        warn("[Overseer] PopulateTable: invalid input")
        return 
    end
    if self.State.VisitedTables[tbl] then 
        return 
    end
    local entries = {}
    local success, error = pcall(function()
        for key, value in pairs(tbl) do
            table.insert(entries, {Key = key, Value = value})
        end
    end)
    if not success then
        print("[Overseer] Cannot iterate table:", error)
        self:CreateInspectorRow("[ERROR]", "Cannot read table: " .. tostring(error), tbl, isMetatable)
        return
    end
    if #entries == 0 then
        self:CreateInspectorRow("[EMPTY]", "This table has no entries", tbl, isMetatable)
        self.State.VisitedTables[tbl] = true
        return
    end
    self.State.VisitedTables[tbl] = true
    table.sort(entries, function(a, b)
        local aStr = tostring(a.Key)
        local bStr = tostring(b.Key)
        local aSpecial = aStr:match("^%[")
        local bSpecial = bStr:match("^%[")
        if aSpecial and not bSpecial then return false end
        if bSpecial and not aSpecial then return true end
        local aNum = tonumber(a.Key)
        local bNum = tonumber(b.Key)
        if aNum and bNum then return aNum < bNum end
        if aNum then return true end
        if bNum then return false end
        return aStr < bStr
    end)
    for _, entry in ipairs(entries) do
        self:CreateInspectorRow(entry.Key, entry.Value, tbl, isMetatable)
    end
    print(string.format("[Overseer] âœ“ Populated table: %d entries", #entries))
end
function Modules.OverseerCE:CreateInspectorRow(key, value, parentTable, isMetatable)
    if not self.State.UI then return end
    local valueType = type(value)
    local displayValue = self:GetDisplayValue(value, key)
	if valueType == "table" then
        local tableInfo = ""
        local success, size = pcall(function()
            local count = 0
            for k, v in pairs(value) do 
                count = count + 1
                if count > 100 then break end
            end
            return count
        end)
        if success and size then
            tableInfo = " (" .. size .. (size > 100 and "+" or "") .. " entries)"
            displayValue = "{table" .. tableInfo .. "}"
        else
            displayValue = "{table: protected}"
        end
    end
    local row = Instance.new("Frame", self.State.UI.InspectorScroll)
    row.Size = UDim2.new(1, -2, 0, self.Config.ROW_HEIGHT)
    row.BackgroundColor3 = isMetatable and self.Config.BG_LIGHT or self.Config.BG_WHITE
    row.BorderSizePixel = 0
    local isPatched = false
    for _, patch in pairs(self.State.ActivePatches) do
        if patch.Table == parentTable and patch.Key == key then
            isPatched = true
            if patch.Frozen then
                row.BackgroundColor3 = Color3.fromRGB(255, 220, 220)
            end
            break
        end
    end
    local activeBox = Instance.new("TextButton", row)
    activeBox.Size = UDim2.fromOffset(12, 12)
    activeBox.Position = UDim2.new(0.04, -6, 0.5, -6)
    activeBox.BackgroundColor3 = self.Config.BG_WHITE
    activeBox.Text = isPatched and "X" or ""
    activeBox.TextColor3 = self.Config.TEXT_BLACK
    activeBox.Font = Enum.Font.SourceSansBold
    activeBox.TextSize = 10
    activeBox.BorderSizePixel = 0
    activeBox.AutoButtonColor = false
    self:_createBorder(activeBox, true)
    local keyLabel = Instance.new("TextLabel", row)
    keyLabel.Size = UDim2.new(0.25, -4, 1, 0)
    keyLabel.Position = UDim2.new(0.08, 2, 0, 0)
    keyLabel.BackgroundTransparency = 1
    keyLabel.Text = tostring(key)
    keyLabel.TextColor3 = isMetatable and Color3.fromRGB(0, 0, 128) or self.Config.TEXT_BLACK
    keyLabel.Font = isMetatable and Enum.Font.Code or Enum.Font.SourceSans
    keyLabel.TextSize = 10
    keyLabel.TextXAlignment = Enum.TextXAlignment.Left
    keyLabel.TextTruncate = Enum.TextTruncate.AtEnd
    local typeLabel = Instance.new("TextLabel", row)
    typeLabel.Size = UDim2.new(0.12, -4, 1, 0)
    typeLabel.Position = UDim2.new(0.33, 2, 0, 0)
    typeLabel.BackgroundTransparency = 1
    typeLabel.Text = valueType
    typeLabel.TextColor3 = self.Config.TEXT_GRAY
    typeLabel.Font = Enum.Font.SourceSans
    typeLabel.TextSize = 9
    typeLabel.TextXAlignment = Enum.TextXAlignment.Left
    local valueBox = Instance.new("TextBox", row)
    valueBox.Size = UDim2.new(0.35, -4, 1, 0)
    valueBox.Position = UDim2.new(0.45, 2, 0, 0)
    valueBox.BackgroundTransparency = 1
    valueBox.Text = displayValue
    valueBox.TextColor3 = self.Config.TEXT_BLACK
    valueBox.Font = Enum.Font.Code
    valueBox.TextSize = 9
    valueBox.TextXAlignment = Enum.TextXAlignment.Left
    valueBox.TextTruncate = Enum.TextTruncate.AtEnd
    valueBox.TextEditable = valueType ~= "table" and valueType ~= "function"
    valueBox.ClearTextOnFocus = false
    local patchBtn = self:_createButton(row, "Patch", UDim2.fromOffset(45, 16), UDim2.new(0.80, 2, 0.5, -8), function()
        if valueType == "table" then
            local success, err = pcall(function()
                self:DrillDown(key, value)
            end)
            if not success then
                self:_showNotification("Dive failed: " .. tostring(err), "error")
                warn("[Overseer] Dive error:", err, debug.traceback())
            end
        elseif valueType == "function" then
            self:ShowFunctionInfo(key, value, parentTable)
        else
            local newVal = self:ParseValue(valueBox.Text, valueType)
            if newVal ~= nil then
                self:CreatePatch(parentTable, key, newVal, false)
            else
                self:_showNotification("Invalid value for type: " .. valueType, "error")
            end
        end
    end)
    patchBtn.TextSize = 9
    if valueType == "table" then
        patchBtn.Text = "Dive"
        patchBtn.BackgroundColor3 = Color3.fromRGB(100, 150, 255)
    elseif valueType == "function" then
        patchBtn.Text = "Hook"
        patchBtn.BackgroundColor3 = Color3.fromRGB(255, 200, 100)
    end
    local freezeBtn = self:_createButton(row, "Freeze", UDim2.fromOffset(45, 16), UDim2.new(0.88, 2, 0.5, -8), function()
        local newVal = self:ParseValue(valueBox.Text, valueType)
        if newVal ~= nil then
            local patchId = self:CreatePatch(parentTable, key, newVal, true)
        else
            self:_showNotification("Invalid value for type: " .. valueType, "error")
        end
    end)
    freezeBtn.TextSize = 9
    if valueType == "table" then
        patchBtn.Text = "Dive"
    elseif valueType == "function" then
        patchBtn.Text = "Hook"
    end
	if valueType == "table" then
        local lastClick = 0
        row.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                local now = tick()
                if now - lastClick < 0.5 then
                    pcall(function()
                        self:DrillDown(key, value)
                    end)
                end
                lastClick = now
            end
        end)
    end
    row.MouseEnter:Connect(function()
        if row.BackgroundColor3 ~= self.Config.HIGHLIGHT then
            row.BackgroundColor3 = Color3.fromRGB(230, 240, 255)
        end
    end)
    row.MouseLeave:Connect(function()
        if isPatched then
            if patch and patch.Frozen then
                row.BackgroundColor3 = Color3.fromRGB(255, 220, 220)
            else
                row.BackgroundColor3 = Color3.fromRGB(240, 255, 240)
            end
        else
            row.BackgroundColor3 = isMetatable and self.Config.BG_LIGHT or self.Config.BG_WHITE
        end
    end)
    valueBox.FocusLost:Connect(function(enterPressed)
        if enterPressed and valueType ~= "table" and valueType ~= "function" then
            local newVal = self:ParseValue(valueBox.Text, valueType)
            if newVal ~= nil then
                self:CreatePatch(parentTable, key, newVal, false)
            else
                self:_showNotification("Invalid value for type: " .. valueType, "error")
            end
        end
    end)
end
function Modules.OverseerCE:DisplayMetatableChain(chain)
    if not self.State.UI or not chain or #chain == 0 then return end
    for i, entry in ipairs(chain) do
        local separator = Instance.new("Frame", self.State.UI.InspectorScroll)
        separator.Size = UDim2.new(1, -2, 0, self.Config.ROW_HEIGHT)
        separator.BackgroundColor3 = entry.Locked and Color3.fromRGB(200, 100, 100) or self.Config.ACCENT_BLUE
        separator.BorderSizePixel = 0
        local lockIcon = entry.Locked and "ðŸ”’ " or "ðŸ”“ "
        local statusText = entry.Locked and " [LOCKED]" or " [Unlocked]"
        local sepLabel = Instance.new("TextLabel", separator)
        sepLabel.Size = UDim2.new(1, -8, 1, 0)
        sepLabel.Position = UDim2.fromOffset(4, 0)
        sepLabel.BackgroundTransparency = 1
        sepLabel.Text = lockIcon .. "METATABLE #" .. i .. " (Depth: " .. entry.Depth .. ")" .. statusText
        sepLabel.TextColor3 = self.Config.BG_WHITE
        sepLabel.Font = Enum.Font.SourceSansBold
        sepLabel.TextSize = 10
        sepLabel.TextXAlignment = Enum.TextXAlignment.Left
        if entry.AccessMethod or entry.UnlockMessage then
            local infoRow = Instance.new("Frame", self.State.UI.InspectorScroll)
            infoRow.Size = UDim2.new(1, -2, 0, self.Config.ROW_HEIGHT)
            infoRow.BackgroundColor3 = Color3.fromRGB(240, 240, 200)
            infoRow.BorderSizePixel = 0
            local infoLabel = Instance.new("TextLabel", infoRow)
            infoLabel.Size = UDim2.new(1, -8, 1, 0)
            infoLabel.Position = UDim2.fromOffset(4, 0)
            infoLabel.BackgroundTransparency = 1
            infoLabel.Text = "  â„¹ï¸ " .. (entry.UnlockMessage or ("Access: " .. entry.AccessMethod))
            infoLabel.TextColor3 = Color3.fromRGB(100, 100, 0)
            infoLabel.Font = Enum.Font.SourceSansItalic
            infoLabel.TextSize = 9
            infoLabel.TextXAlignment = Enum.TextXAlignment.Left
        end
        for _, field in ipairs(entry.Fields) do
            self:CreateInspectorRow(field.Key, field.Value, entry.Metatable, true)
        end
    end
end
function Modules.OverseerCE:RefreshPatchList()
    if not self.State.UI then return end
    for _, child in ipairs(self.State.UI.PatchScroll:GetChildren()) do
        if not child:IsA("UIListLayout") then
            child:Destroy()
        end
    end
    local patchCount = 0
    for patchId, patch in pairs(self.State.ActivePatches) do
        patchCount = patchCount + 1
        self:CreatePatchRow(patchId, patch)
    end
    self.State.UI.PatchCount.Text = "Patches: " .. patchCount
end
function Modules.OverseerCE:CreatePatchRow(patchId, patch)
    if not self.State.UI then return end
    local row = Instance.new("Frame", self.State.UI.PatchScroll)
    row.Size = UDim2.new(1, -2, 0, self.Config.ROW_HEIGHT)
    row.BackgroundColor3 = patch.Frozen and Color3.fromRGB(255, 220, 220) or self.Config.BG_WHITE
    row.BorderSizePixel = 0
    local freezeBox = Instance.new("TextButton", row)
    freezeBox.Size = UDim2.fromOffset(12, 12)
    freezeBox.Position = UDim2.new(0.075, -6, 0.5, -6)
    freezeBox.BackgroundColor3 = self.Config.BG_WHITE
    freezeBox.Text = patch.Frozen and "X" or ""
    freezeBox.TextColor3 = self.Config.FROZEN_RED
    freezeBox.Font = Enum.Font.SourceSansBold
    freezeBox.TextSize = 10
    freezeBox.BorderSizePixel = 0
    freezeBox.AutoButtonColor = false
    self:_createBorder(freezeBox, true)
    freezeBox.MouseButton1Click:Connect(function()
        self:ToggleFreeze(patchId)
    end)
    local keyLabel = Instance.new("TextLabel", row)
    keyLabel.Size = UDim2.new(0.35, -4, 1, 0)
    keyLabel.Position = UDim2.new(0.15, 2, 0, 0)
    keyLabel.BackgroundTransparency = 1
    keyLabel.Text = tostring(patch.Key)
    keyLabel.TextColor3 = self.Config.TEXT_BLACK
    keyLabel.Font = Enum.Font.SourceSans
    keyLabel.TextSize = 9
    keyLabel.TextXAlignment = Enum.TextXAlignment.Left
    keyLabel.TextTruncate = Enum.TextTruncate.AtEnd
    local valueLabel = Instance.new("TextLabel", row)
    valueLabel.Size = UDim2.new(0.35, -4, 1, 0)
    valueLabel.Position = UDim2.new(0.50, 2, 0, 0)
    valueLabel.BackgroundTransparency = 1
    valueLabel.Text = tostring(patch.NewValue):sub(1, 20)
    valueLabel.TextColor3 = self.Config.TEXT_BLACK
    valueLabel.Font = Enum.Font.Code
    valueLabel.TextSize = 9
    valueLabel.TextXAlignment = Enum.TextXAlignment.Left
    valueLabel.TextTruncate = Enum.TextTruncate.AtEnd
    local delBtn = self:_createButton(row, "X", UDim2.fromOffset(16, 16), UDim2.new(0.88, 0, 0.5, -8), function()
        self:RemovePatch(patchId)
    end)
    delBtn.TextSize = 10
    delBtn.Font = Enum.Font.SourceSansBold
    delBtn.BackgroundColor3 = Color3.fromRGB(255, 200, 200)
end
function Modules.OverseerCE:DrillDown(name, tbl)
    if type(tbl) ~= "table" then 
        self:_showNotification("Cannot dive: " .. tostring(name) .. " is " .. type(tbl), "warning")
        return 
    end
    local canIterate, iterError = pcall(function()
        local test = next(tbl)
        return test ~= nil
    end)
    if not canIterate then
        self:_showNotification("Table is protected or empty: " .. tostring(name), "error")
        print("[Overseer] DrillDown blocked:", iterError)
        return
    end
    table.insert(self.State.PathStack, tostring(name))
    self.State.CurrentTable = tbl
    self.State.VisitedTables = {}
    print("[Overseer] âœ“ Dove into:", name)
    self:RefreshInspector()
    self:_showNotification("Viewing: " .. tostring(name), "info")
end
function Modules.OverseerCE:GoBack()
    if #self.State.PathStack == 0 then return end
    table.remove(self.State.PathStack)
    local tbl = self.State.SelectedModule and require(self.State.SelectedModule) or nil
    if not tbl then return end
    for _, pathPart in ipairs(self.State.PathStack) do
        tbl = tbl[pathPart]
        if not tbl then return end
    end
    self.State.CurrentTable = tbl
    self.State.VisitedTables = {}
    self:RefreshInspector()
end
function Modules.OverseerCE:ParseValue(text, targetType)
    if targetType == "number" then
        local num = tonumber(text)
        return num
    elseif targetType == "boolean" then
        return text:lower() == "true"
    elseif targetType == "string" then
        return text:match('^"(.*)"$') or text
    end
    return text
end
function Modules.OverseerCE:ShowFunctionInfo(key, func, parentTable)
    self:ShowQuickHookMenu(func, parentTable, key)
end
function Modules.OverseerCE:FilterModules(query)
    if not self.State.UI then return end
    query = query:lower()
    for _, moduleData in ipairs(self.State.ModuleList) do
        if query == "" or moduleData.Name:lower():find(query, 1, true) then
            moduleData.Row.Visible = true
        else
            moduleData.Row.Visible = false
        end
    end
end
function Modules.OverseerCE:OpenToolWindow(toolName)
    if self.State.UI and self.State.UI.ScreenGui then
        for _, child in ipairs(self.State.UI.ScreenGui:GetChildren()) do
            if child.Name:match("Window$") and child ~= self.State.UI.Main then
                child:Destroy()
            end
        end
    end
    local popup = Instance.new("Frame", self.State.UI.ScreenGui)
    popup.Name = toolName .. "Window"
    popup.Size = UDim2.fromOffset(500, 400)
    popup.Position = UDim2.new(0.5, -250, 0.5, -200)
    popup.BackgroundColor3 = self.Config.BG_PANEL
    popup.BorderSizePixel = 0
    popup.ZIndex = 100
    self:_createBorder(popup, false)
    local titleBar = Instance.new("Frame", popup)
    titleBar.Size = UDim2.new(1, -2, 0, 24)
    titleBar.Position = UDim2.fromOffset(1, 1)
    titleBar.BackgroundColor3 = self.Config.ACCENT_BLUE
    titleBar.BorderSizePixel = 0
    titleBar.ZIndex = 101
    local titleGradient = Instance.new("UIGradient", titleBar)
    titleGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(49, 106, 197)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(150, 190, 230))
    }
    titleGradient.Rotation = 90
    local title = Instance.new("TextLabel", titleBar)
    title.Size = UDim2.new(1, -50, 1, 0)
    title.Position = UDim2.fromOffset(4, 0)
    title.Text = toolName
    title.TextColor3 = self.Config.BG_WHITE
    title.Font = Enum.Font.SourceSansBold
    title.TextSize = 12
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.BackgroundTransparency = 1
    title.ZIndex = 102
    local closeBtn = self:_createButton(titleBar, "Ã—", UDim2.fromOffset(20, 20), UDim2.new(1, -22, 0, 2), function()
        popup:Destroy()
    end)
    closeBtn.ZIndex = 103
    closeBtn.TextSize = 16
    closeBtn.Font = Enum.Font.SourceSansBold
    closeBtn.BackgroundColor3 = self.Config.BG_LIGHT
    local contentArea = Instance.new("Frame", popup)
    contentArea.Size = UDim2.new(1, -8, 1, -32)
    contentArea.Position = UDim2.fromOffset(4, 28)
    contentArea.BackgroundColor3 = self.Config.BG_PANEL
    contentArea.BorderSizePixel = 0
    contentArea.ZIndex = 100
    if toolName == "Scanner" then
        self:CreateScannerUI(contentArea)
    elseif toolName == "Dumper" then
        self:CreateDumperUI(contentArea)
    elseif toolName == "Injector" then
        self:CreateInjectorUI(contentArea)
    elseif toolName == "Anti-Tamper" then
        self:CreateAntiTamperUI(contentArea)
    elseif toolName == "Hooks" then
        self:CreateHookManagerPanel(contentArea)
    elseif toolName == "Decompiler" then
        self:CreateDecompilerPanel(contentArea)
    elseif toolName == "Tools" then
        self:CreateToolsMenuUI(contentArea)
	elseif toolname == "Posions" then
		self:CreatePoisonMenuUI(ContentArea)					
    end
    local dragging, dragStart, startPos
    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = popup.Position
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local delta = input.Position - dragStart
            popup.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)
end
function Modules.OverseerCE:CreateScannerUI(parent)
    local searchLabel = Instance.new("TextLabel", parent)
    searchLabel.Size = UDim2.new(0, 100, 0, 22)
    searchLabel.Position = UDim2.fromOffset(4, 4)
    searchLabel.BackgroundTransparency = 1
    searchLabel.Text = "Search Value:"
    searchLabel.TextColor3 = self.Config.TEXT_BLACK
    searchLabel.Font = Enum.Font.SourceSans
    searchLabel.TextSize = 11
    searchLabel.TextXAlignment = Enum.TextXAlignment.Left
    searchLabel.ZIndex = 101
    local searchBox = Instance.new("TextBox", parent)
    searchBox.Size = UDim2.new(1, -110, 0, 22)
    searchBox.Position = UDim2.fromOffset(106, 4)
    searchBox.BackgroundColor3 = self.Config.BG_WHITE
    searchBox.Text = ""
    searchBox.PlaceholderText = "Enter value to search..."
    searchBox.TextColor3 = self.Config.TEXT_BLACK
    searchBox.Font = Enum.Font.SourceSans
    searchBox.TextSize = 11
    searchBox.TextXAlignment = Enum.TextXAlignment.Left
    searchBox.BorderSizePixel = 0
    searchBox.ZIndex = 101
    searchBox.ClearTextOnFocus = false
    local searchPadding = Instance.new("UIPadding", searchBox)
    searchPadding.PaddingLeft = UDim.new(0, 4)
    self:_createBorder(searchBox, true)
    local typeLabel = Instance.new("TextLabel", parent)
    typeLabel.Size = UDim2.new(0, 100, 0, 22)
    typeLabel.Position = UDim2.fromOffset(4, 30)
    typeLabel.BackgroundTransparency = 1
    typeLabel.Text = "Value Type:"
    typeLabel.TextColor3 = self.Config.TEXT_BLACK
    typeLabel.Font = Enum.Font.SourceSans
    typeLabel.TextSize = 11
    typeLabel.TextXAlignment = Enum.TextXAlignment.Left
    typeLabel.ZIndex = 101
    local typeDropdown = Instance.new("TextButton", parent)
    typeDropdown.Size = UDim2.new(0, 150, 0, 22)
    typeDropdown.Position = UDim2.fromOffset(106, 30)
    typeDropdown.BackgroundColor3 = self.Config.BG_WHITE
    typeDropdown.Text = "any"
    typeDropdown.TextColor3 = self.Config.TEXT_BLACK
    typeDropdown.Font = Enum.Font.SourceSans
    typeDropdown.TextSize = 11
    typeDropdown.BorderSizePixel = 0
    typeDropdown.ZIndex = 101
    typeDropdown.AutoButtonColor = false
    self:_createBorder(typeDropdown, true)
    local selectedType = "any"
    local types = {"any", "string", "number", "boolean", "table", "function"}
    local typeIndex = 1
    typeDropdown.MouseButton1Click:Connect(function()
        typeIndex = (typeIndex % #types) + 1
        selectedType = types[typeIndex]
        typeDropdown.Text = selectedType
    end)
    local exactMatch = false
    local exactCheckbox = Instance.new("TextButton", parent)
    exactCheckbox.Size = UDim2.fromOffset(16, 16)
    exactCheckbox.Position = UDim2.fromOffset(262, 33)
    exactCheckbox.BackgroundColor3 = self.Config.BG_WHITE
    exactCheckbox.Text = ""
    exactCheckbox.TextColor3 = self.Config.TEXT_BLACK
    exactCheckbox.Font = Enum.Font.SourceSansBold
    exactCheckbox.TextSize = 10
    exactCheckbox.BorderSizePixel = 0
    exactCheckbox.ZIndex = 101
    exactCheckbox.AutoButtonColor = false
    self:_createBorder(exactCheckbox, true)
    exactCheckbox.MouseButton1Click:Connect(function()
        exactMatch = not exactMatch
        exactCheckbox.Text = exactMatch and "X" or ""
    end)
    local exactLabel = Instance.new("TextLabel", parent)
    exactLabel.Size = UDim2.new(0, 100, 0, 16)
    exactLabel.Position = UDim2.fromOffset(282, 33)
    exactLabel.BackgroundTransparency = 1
    exactLabel.Text = "Exact Match"
    exactLabel.TextColor3 = self.Config.TEXT_BLACK
    exactLabel.Font = Enum.Font.SourceSans
    exactLabel.TextSize = 10
    exactLabel.TextXAlignment = Enum.TextXAlignment.Left
    exactLabel.ZIndex = 101
    local header = Instance.new("TextLabel", parent)
    header.Name = "ResultsHeader"
    header.Size = UDim2.new(1, -8, 0, 20)
    header.Position = UDim2.fromOffset(4, 66)
    header.BackgroundColor3 = self.Config.BG_DARK
    header.Text = "Results: 0"
    header.TextColor3 = self.Config.TEXT_BLACK
    header.Font = Enum.Font.SourceSansBold
    header.TextSize = 11
    header.TextXAlignment = Enum.TextXAlignment.Left
    header.BorderSizePixel = 0
    header.ZIndex = 101
    local headerPadding = Instance.new("UIPadding", header)
    headerPadding.PaddingLeft = UDim.new(0, 4)
    self:_createBorder(header, true)
    local resultsScroll = Instance.new("ScrollingFrame", parent)
    resultsScroll.Name = "ResultsScroll"
    resultsScroll.Size = UDim2.new(1, -8, 1, -120)
    resultsScroll.Position = UDim2.fromOffset(4, 88)
    resultsScroll.BackgroundColor3 = self.Config.BG_WHITE
    resultsScroll.BorderSizePixel = 0
    resultsScroll.ScrollBarThickness = 12
    resultsScroll.ScrollBarImageColor3 = self.Config.BG_DARK
    resultsScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
    resultsScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
    resultsScroll.ZIndex = 101
    self:_createBorder(resultsScroll, true)
    local resultsList = Instance.new("UIListLayout", resultsScroll)
    resultsList.Padding = UDim.new(0, 1)
    local scanBtn = self:_createButton(parent, "Scan All Modules", UDim2.fromOffset(120, 24), UDim2.fromOffset(4, 58), function()
        local searchValue = searchBox.Text
        if searchValue == "" then
            self:_showNotification("Please enter a search value", "warning")
            return
        end
        if selectedType == "number" then
            searchValue = tonumber(searchValue)
            if not searchValue then
                self:_showNotification("Invalid number format", "error")
                return
            end
        elseif selectedType == "boolean" then
            searchValue = searchBox.Text:lower() == "true"
        end
        self:_showNotification("Scanning modules...", "info")
        task.spawn(function()
            local results = self:ScanForConstant(searchValue, selectedType, exactMatch)
            for _, child in ipairs(resultsScroll:GetChildren()) do
                if not child:IsA("UIListLayout") then
                    child:Destroy()
                end
            end
            header.Text = "Results: " .. #results
            for _, result in ipairs(results) do
                local resultRow = Instance.new("TextButton", resultsScroll)
                resultRow.Size = UDim2.new(1, -2, 0, 20)
                resultRow.BackgroundColor3 = self.Config.BG_WHITE
                resultRow.Text = ""
                resultRow.BorderSizePixel = 0
                resultRow.AutoButtonColor = false
                resultRow.ZIndex = 102
                local pathLabel = Instance.new("TextLabel", resultRow)
                pathLabel.Size = UDim2.new(0.6, 0, 1, 0)
                pathLabel.Position = UDim2.fromOffset(4, 0)
                pathLabel.BackgroundTransparency = 1
                pathLabel.Text = result.Path
                pathLabel.TextColor3 = self.Config.TEXT_BLACK
                pathLabel.Font = Enum.Font.Code
                pathLabel.TextSize = 9
                pathLabel.TextXAlignment = Enum.TextXAlignment.Left
                pathLabel.TextTruncate = Enum.TextTruncate.AtEnd
                pathLabel.ZIndex = 103
                local valueLabel = Instance.new("TextLabel", resultRow)
                valueLabel.Size = UDim2.new(0.4, -8, 1, 0)
                valueLabel.Position = UDim2.new(0.6, 0, 0, 0)
                valueLabel.BackgroundTransparency = 1
                valueLabel.Text = tostring(result.Value):sub(1, 30)
                valueLabel.TextColor3 = self.Config.ACCENT_BLUE
                valueLabel.Font = Enum.Font.SourceSans
                valueLabel.TextSize = 9
                valueLabel.TextXAlignment = Enum.TextXAlignment.Left
                valueLabel.TextTruncate = Enum.TextTruncate.AtEnd
                valueLabel.ZIndex = 103
                resultRow.MouseButton1Click:Connect(function()
                    print("[Scanner] Selected:", result.Path)
                    self:_setClipboard(result.Path)
                    self:_showNotification("Path copied to clipboard", "success")
                end)
                resultRow.MouseEnter:Connect(function()
                    resultRow.BackgroundColor3 = self.Config.BG_LIGHT
                end)
                resultRow.MouseLeave:Connect(function()
                    resultRow.BackgroundColor3 = self.Config.BG_WHITE
                end)
            end
            self:_showNotification("Scan complete: " .. #results .. " results", "success")
        end)
    end)
    scanBtn.ZIndex = 101
end
function Modules.OverseerCE:CreateDumperUI(parent)
    local infoLabel = Instance.new("TextLabel", parent)
    infoLabel.Size = UDim2.new(1, -8, 0, 40)
    infoLabel.Position = UDim2.fromOffset(4, 4)
    infoLabel.BackgroundTransparency = 1
    infoLabel.Text = "Export module structures to JSON for offline analysis.\nIncludes tables, metatables, functions, and upvalues."
    infoLabel.TextColor3 = self.Config.TEXT_BLACK
    infoLabel.Font = Enum.Font.SourceSans
    infoLabel.TextSize = 10
    infoLabel.TextXAlignment = Enum.TextXAlignment.Left
    infoLabel.TextYAlignment = Enum.TextYAlignment.Top
    infoLabel.TextWrapped = true
    infoLabel.ZIndex = 101
    local includeMetatables = true
    local includeFunctions = true
    local maxDepth = 10
    local mtCheckbox = Instance.new("TextButton", parent)
    mtCheckbox.Size = UDim2.fromOffset(16, 16)
    mtCheckbox.Position = UDim2.fromOffset(4, 50)
    mtCheckbox.BackgroundColor3 = self.Config.BG_WHITE
    mtCheckbox.Text = "X"
    mtCheckbox.TextColor3 = self.Config.TEXT_BLACK
    mtCheckbox.Font = Enum.Font.SourceSansBold
    mtCheckbox.TextSize = 10
    mtCheckbox.BorderSizePixel = 0
    mtCheckbox.ZIndex = 101
    mtCheckbox.AutoButtonColor = false
    self:_createBorder(mtCheckbox, true)
    mtCheckbox.MouseButton1Click:Connect(function()
        includeMetatables = not includeMetatables
        mtCheckbox.Text = includeMetatables and "X" or ""
    end)
    local mtLabel = Instance.new("TextLabel", parent)
    mtLabel.Size = UDim2.new(0, 150, 0, 16)
    mtLabel.Position = UDim2.fromOffset(24, 50)
    mtLabel.BackgroundTransparency = 1
    mtLabel.Text = "Include Metatables"
    mtLabel.TextColor3 = self.Config.TEXT_BLACK
    mtLabel.Font = Enum.Font.SourceSans
    mtLabel.TextSize = 10
    mtLabel.TextXAlignment = Enum.TextXAlignment.Left
    mtLabel.ZIndex = 101
    local funcCheckbox = Instance.new("TextButton", parent)
    funcCheckbox.Size = UDim2.fromOffset(16, 16)
    funcCheckbox.Position = UDim2.fromOffset(4, 72)
    funcCheckbox.BackgroundColor3 = self.Config.BG_WHITE
    funcCheckbox.Text = "X"
    funcCheckbox.TextColor3 = self.Config.TEXT_BLACK
    funcCheckbox.Font = Enum.Font.SourceSansBold
    funcCheckbox.TextSize = 10
    funcCheckbox.BorderSizePixel = 0
    funcCheckbox.ZIndex = 101
    funcCheckbox.AutoButtonColor = false
    self:_createBorder(funcCheckbox, true)
    funcCheckbox.MouseButton1Click:Connect(function()
        includeFunctions = not includeFunctions
        funcCheckbox.Text = includeFunctions and "X" or ""
    end)
    local funcLabel = Instance.new("TextLabel", parent)
    funcLabel.Size = UDim2.new(0, 150, 0, 16)
    funcLabel.Position = UDim2.fromOffset(24, 72)
    funcLabel.BackgroundTransparency = 1
    funcLabel.Text = "Include Functions"
    funcLabel.TextColor3 = self.Config.TEXT_BLACK
    funcLabel.Font = Enum.Font.SourceSans
    funcLabel.TextSize = 10
    funcLabel.TextXAlignment = Enum.TextXAlignment.Left
    funcLabel.ZIndex = 101
    local depthLabel = Instance.new("TextLabel", parent)
    depthLabel.Size = UDim2.new(0, 100, 0, 22)
    depthLabel.Position = UDim2.fromOffset(4, 94)
    depthLabel.BackgroundTransparency = 1
    depthLabel.Text = "Max Depth:"
    depthLabel.TextColor3 = self.Config.TEXT_BLACK
    depthLabel.Font = Enum.Font.SourceSans
    depthLabel.TextSize = 10
    depthLabel.TextXAlignment = Enum.TextXAlignment.Left
    depthLabel.ZIndex = 101
    local depthBox = Instance.new("TextBox", parent)
    depthBox.Size = UDim2.fromOffset(60, 22)
    depthBox.Position = UDim2.fromOffset(106, 94)
    depthBox.BackgroundColor3 = self.Config.BG_WHITE
    depthBox.Text = "10"
    depthBox.TextColor3 = self.Config.TEXT_BLACK
    depthBox.Font = Enum.Font.SourceSans
    depthBox.TextSize = 10
    depthBox.BorderSizePixel = 0
    depthBox.ZIndex = 101
    depthBox.ClearTextOnFocus = false
    self:_createBorder(depthBox, true)
    depthBox.FocusLost:Connect(function()
        local num = tonumber(depthBox.Text)
        if num then
            maxDepth = math.clamp(num, 1, 20)
            depthBox.Text = tostring(maxDepth)
        else
            depthBox.Text = "10"
            maxDepth = 10
        end
    end)
    local statusLabel = Instance.new("TextLabel", parent)
    statusLabel.Size = UDim2.new(1, -8, 1, -152)
    statusLabel.Position = UDim2.fromOffset(4, 152)
    statusLabel.BackgroundColor3 = self.Config.BG_WHITE
    statusLabel.Text = "Ready to dump.\nResults will be copied to clipboard."
    statusLabel.TextColor3 = self.Config.TEXT_BLACK
    statusLabel.Font = Enum.Font.Code
    statusLabel.TextSize = 9
    statusLabel.TextXAlignment = Enum.TextXAlignment.Left
    statusLabel.TextYAlignment = Enum.TextYAlignment.Top
    statusLabel.TextWrapped = true
    statusLabel.BorderSizePixel = 0
    statusLabel.ZIndex = 101
    self:_createBorder(statusLabel, true)
    local dumpSelectedBtn = self:_createButton(parent, "Dump Selected Module", UDim2.fromOffset(150, 24), UDim2.fromOffset(4, 122), function()
        if not self.State.SelectedModule then
            self:_showNotification("No module selected", "warning")
            statusLabel.Text = "ERROR: No module selected.\nPlease select a module from the module list first."
            return
        end
        statusLabel.Text = "Dumping module: " .. self.State.SelectedModule.Name .. "\nPlease wait..."
        task.spawn(function()
            local result = self:DumpModule(self.State.SelectedModule, includeMetatables, includeFunctions, maxDepth)
            if result.Success then
                self:ExportDump(result.Dump)
                statusLabel.Text = "SUCCESS!\nExported: " .. self.State.SelectedModule.Name .. "\nCopied to clipboard."
            else
                self:_showNotification("Dump failed: " .. result.Error, "error")
                statusLabel.Text = "ERROR: " .. result.Error
            end
        end)
    end)
    dumpSelectedBtn.ZIndex = 101
    dumpSelectedBtn.TextSize = 10
    local dumpAllBtn = self:_createButton(parent, "Dump All Modules", UDim2.fromOffset(150, 24), UDim2.fromOffset(158, 122), function()
        statusLabel.Text = "Dumping all modules...\nThis may take a while..."
        task.spawn(function()
            local result = self:DumpAllModules()
            if result.Success then
                self:ExportDump(result)
                statusLabel.Text = "SUCCESS!\nExported " .. result.TotalModules .. " modules\nCopied to clipboard."
            else
                self:_showNotification("Dump failed", "error")
                statusLabel.Text = "ERROR: Failed to dump modules."
            end
        end)
    end)
    dumpAllBtn.ZIndex = 101
    dumpAllBtn.TextSize = 10
end
function Modules.OverseerCE:CreateInjectorUI(parent)
    local infoLabel = Instance.new("TextLabel", parent)
    infoLabel.Size = UDim2.new(1, -8, 0, 30)
    infoLabel.Position = UDim2.fromOffset(4, 4)
    infoLabel.BackgroundTransparency = 1
    infoLabel.Text = "Execute code with access to module context and upvalues."
    infoLabel.TextColor3 = self.Config.TEXT_BLACK
    infoLabel.Font = Enum.Font.SourceSans
    infoLabel.TextSize = 10
    infoLabel.TextXAlignment = Enum.TextXAlignment.Left
    infoLabel.TextYAlignment = Enum.TextYAlignment.Top
    infoLabel.TextWrapped = true
    infoLabel.ZIndex = 101
    local codeScroll = Instance.new("ScrollingFrame", parent)
    codeScroll.Size = UDim2.new(1, -8, 1, -80)
    codeScroll.Position = UDim2.fromOffset(4, 38)
    codeScroll.BackgroundColor3 = self.Config.BG_WHITE
    codeScroll.BorderSizePixel = 0
    codeScroll.ScrollBarThickness = 12
    codeScroll.ScrollBarImageColor3 = self.Config.BG_DARK
    codeScroll.AutomaticCanvasSize = Enum.AutomaticSize.XY
    codeScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
    codeScroll.ZIndex = 101
    self:_createBorder(codeScroll, true)
    local codeBox = Instance.new("TextBox", codeScroll)
    codeBox.Size = UDim2.new(1, -4, 1, -4)
    codeBox.Position = UDim2.fromOffset(2, 2)
    codeBox.BackgroundTransparency = 1
    codeBox.Text = "-- Enter code here\nprint('Injected!')\nreturn true"
    codeBox.TextColor3 = self.Config.TEXT_BLACK
    codeBox.Font = Enum.Font.Code
    codeBox.TextSize = 10
    codeBox.TextXAlignment = Enum.TextXAlignment.Left
    codeBox.TextYAlignment = Enum.TextYAlignment.Top
    codeBox.MultiLine = true
    codeBox.ClearTextOnFocus = false
    codeBox.TextEditable = true
    codeBox.AutomaticSize = Enum.AutomaticSize.XY
    codeBox.ZIndex = 102
    local btnContainer = Instance.new("Frame", parent)
    btnContainer.Size = UDim2.new(1, -8, 0, 28)
    btnContainer.Position = UDim2.new(0, 4, 1, -32)
    btnContainer.BackgroundTransparency = 1
    btnContainer.ZIndex = 101
    local executeBtn = self:_createButton(btnContainer, "Execute", UDim2.fromOffset(100, 24), UDim2.fromOffset(0, 0), function()
        local code = codeBox.Text
        if code == "" or code == "-- Enter code here\nprint('Injected!')\nreturn true" then
            self:_showNotification("Please enter code to execute", "warning")
            return
        end
        local targetModule = self.State.SelectedModule
        local result = self:InjectCode(code, targetModule, true)
        if result.Success then
            self:_showNotification("Code executed successfully!", "success")
            print("[Injector] Success! Result:", unpack(result.Result or {}))
        else
            self:_showNotification("Execution failed: " .. (result.Error or "Unknown error"), "error")
            warn("[Injector] Error:", result.Error)
        end
    end)
    executeBtn.ZIndex = 101
    executeBtn.TextSize = 10
    local clearBtn = self:_createButton(btnContainer, "Clear", UDim2.fromOffset(80, 24), UDim2.fromOffset(104, 0), function()
        codeBox.Text = "-- Enter code here\n"
    end)
    clearBtn.ZIndex = 101
    clearBtn.TextSize = 10
    local templateBtn = self:_createButton(btnContainer, "Load Template", UDim2.fromOffset(100, 24), UDim2.fromOffset(188, 0), function()
        codeBox.Text = [[
print("Current module:", self.State.SelectedModule.Name)
if moduleTable then
    for k, v in pairs(moduleTable) do
        print(k, "=", v)
    end
end
return "Template loaded"]]
    end)
    templateBtn.ZIndex = 101
    templateBtn.TextSize = 10
end
function Modules.OverseerCE:CreateAntiTamperUI(parent)
    local infoLabel = Instance.new("TextLabel", parent)
    infoLabel.Size = UDim2.new(1, -8, 0, 50)
    infoLabel.Position = UDim2.fromOffset(4, 4)
    infoLabel.BackgroundTransparency = 1
    infoLabel.Text = "Anti-tamper protection hides your modifications from detection.\nHooks getmetatable, setmetatable, rawset, type, and typeof to spoof normal behavior."
    infoLabel.TextColor3 = self.Config.TEXT_BLACK
    infoLabel.Font = Enum.Font.SourceSans
    infoLabel.TextSize = 10
    infoLabel.TextXAlignment = Enum.TextXAlignment.Left
    infoLabel.TextYAlignment = Enum.TextYAlignment.Top
    infoLabel.TextWrapped = true
    infoLabel.ZIndex = 101
    local statusLabel = Instance.new("TextLabel", parent)
    statusLabel.Name = "StatusLabel"
    statusLabel.Size = UDim2.new(1, -8, 0, 30)
    statusLabel.Position = UDim2.fromOffset(4, 60)
    statusLabel.BackgroundColor3 = self.State.AntiTamperActive and Color3.fromRGB(220, 255, 220) or Color3.fromRGB(255, 220, 220)
    statusLabel.Text = self.State.AntiTamperActive and "Status: ACTIVE âœ“" or "Status: INACTIVE âœ—"
    statusLabel.TextColor3 = self.Config.TEXT_BLACK
    statusLabel.Font = Enum.Font.SourceSansBold
    statusLabel.TextSize = 12
    statusLabel.BorderSizePixel = 0
    statusLabel.ZIndex = 101
    self:_createBorder(statusLabel, true)
    local toggleBtn = self:_createButton(parent, self.State.AntiTamperActive and "Disable Protection" or "Enable Protection", UDim2.fromOffset(150, 28), UDim2.fromOffset(4, 96), function()
        if self.State.AntiTamperActive then
            self:DisableAntiTamper()
            toggleBtn.Text = "Enable Protection"
            statusLabel.Text = "Status: INACTIVE âœ—"
            statusLabel.BackgroundColor3 = Color3.fromRGB(255, 220, 220)
            self:_showNotification("Anti-tamper disabled", "info")
        else
            self:EnableAntiTamper()
            toggleBtn.Text = "Disable Protection"
            statusLabel.Text = "Status: ACTIVE âœ“"
            statusLabel.BackgroundColor3 = Color3.fromRGB(220, 255, 220)
            self:_showNotification("Anti-tamper enabled", "success")
        end
    end)
    toggleBtn.ZIndex = 101
    toggleBtn.TextSize = 11
    local detectBtn = self:_createButton(parent, "Scan for Anti-Cheat", UDim2.fromOffset(150, 28), UDim2.fromOffset(158, 96), function()
        self:_showNotification("Scanning for anti-cheat...", "info")
        task.spawn(function()
            local result = self:DetectAntiCheat()
            for _, child in ipairs(parent:GetChildren()) do
                if child.Name == "DetectionScroll" then
                    child:Destroy()
                end
            end
            local detectionScroll = Instance.new("ScrollingFrame", parent)
            detectionScroll.Name = "DetectionScroll"
            detectionScroll.Size = UDim2.new(1, -8, 1, -134)
            detectionScroll.Position = UDim2.fromOffset(4, 130)
            detectionScroll.BackgroundColor3 = self.Config.BG_WHITE
            detectionScroll.BorderSizePixel = 0
            detectionScroll.ScrollBarThickness = 12
            detectionScroll.ScrollBarImageColor3 = self.Config.BG_DARK
            detectionScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
            detectionScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
            detectionScroll.ZIndex = 101
            self:_createBorder(detectionScroll, true)
            local detectionList = Instance.new("UIListLayout", detectionScroll)
            detectionList.Padding = UDim.new(0, 2)
            for _, detection in ipairs(result.Detections) do
                local detectionRow = Instance.new("Frame", detectionScroll)
                detectionRow.Size = UDim2.new(1, -4, 0, 24)
                detectionRow.BackgroundColor3 = detection.Detected and Color3.fromRGB(255, 200, 200) or Color3.fromRGB(200, 255, 200)
                detectionRow.BorderSizePixel = 0
                detectionRow.ZIndex = 102
                self:_createBorder(detectionRow, true)
                local nameLabel = Instance.new("TextLabel", detectionRow)
                nameLabel.Size = UDim2.new(0.7, 0, 1, 0)
                nameLabel.Position = UDim2.fromOffset(4, 0)
                nameLabel.BackgroundTransparency = 1
                nameLabel.Text = detection.Name
                nameLabel.TextColor3 = self.Config.TEXT_BLACK
                nameLabel.Font = Enum.Font.SourceSans
                nameLabel.TextSize = 10
                nameLabel.TextXAlignment = Enum.TextXAlignment.Left
                nameLabel.ZIndex = 103
                local statusText = Instance.new("TextLabel", detectionRow)
                statusText.Size = UDim2.new(0.3, -4, 1, 0)
                statusText.Position = UDim2.new(0.7, 0, 0, 0)
                statusText.BackgroundTransparency = 1
                statusText.Text = detection.Detected and "DETECTED" or "Not Found"
                statusText.TextColor3 = detection.Detected and Color3.fromRGB(200, 0, 0) or Color3.fromRGB(0, 150, 0)
                statusText.Font = Enum.Font.SourceSansBold
                statusText.TextSize = 10
                statusText.TextXAlignment = Enum.TextXAlignment.Right
                statusText.ZIndex = 103
            end
            local detectedCount = 0
            for _, d in ipairs(result.Detections) do
                if d.Detected then detectedCount = detectedCount + 1 end
            end
            self:_showNotification("Scan complete: " .. detectedCount .. " detections", detectedCount > 0 and "warning" or "success")
        end)
    end)
    detectBtn.ZIndex = 101
    detectBtn.TextSize = 11
end
function Modules.OverseerCE:CreatePoisonMenuUI(parent)
    local title = Instance.new("TextLabel", parent)
    title.Size = UDim2.new(1, -8, 0, 24)
    title.Position = UDim2.fromOffset(4, 4)
    title.BackgroundTransparency = 1
    title.Text = "âš  Poison System Manager"
    title.TextColor3 = self.Config.POISON_PURPLE or Color3.fromRGB(138, 43, 226)
    title.Font = Enum.Font.SourceSansBold
    title.TextSize = 14
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.ZIndex = 101
    local statsFrame = Instance.new("Frame", parent)
    statsFrame.Size = UDim2.new(1, -8, 0, 60)
    statsFrame.Position = UDim2.fromOffset(4, 32)
    statsFrame.BackgroundColor3 = self.Config.BG_PANEL
    statsFrame.BorderSizePixel = 0
    statsFrame.ZIndex = 101
    self:_createBorder(statsFrame, true)
    local function updateStats()
        local stats = self:GetPoisonStats()
        local statsText = string.format([[Active Poisons: %d / %d Total
By Type:]], stats.Active, stats.Total)
        local typeList = {}
        for pType, count in pairs(stats.ByType) do
            table.insert(typeList, string.format("  â€¢ %s: %d", pType, count))
        end
        if #typeList > 0 then
            statsText = statsText .. "\n" .. table.concat(typeList, "\n")
        end
        local statsLabel = statsFrame:FindFirstChild("StatsLabel")
        if not statsLabel then
            statsLabel = Instance.new("TextLabel", statsFrame)
            statsLabel.Name = "StatsLabel"
            statsLabel.Size = UDim2.new(1, -8, 1, -8)
            statsLabel.Position = UDim2.fromOffset(4, 4)
            statsLabel.BackgroundTransparency = 1
            statsLabel.TextColor3 = self.Config.TEXT_BLACK
            statsLabel.Font = Enum.Font.SourceSans
            statsLabel.TextSize = 10
            statsLabel.TextXAlignment = Enum.TextXAlignment.Left
            statsLabel.TextYAlignment = Enum.TextYAlignment.Top
            statsLabel.ZIndex = 102
        end
        statsLabel.Text = statsText
    end
    updateStats()
    local clearBtn = self:_createButton(parent, "Clear All Poisons", UDim2.fromOffset(150, 24), UDim2.fromOffset(4, 96), function()
        local count = self:ClearAllPoisons()
        updateStats()
        self:_showNotification(string.format("Cleared %d poisons", count), "success")
    end)
    clearBtn.ZIndex = 101
    local infoLabel = Instance.new("TextLabel", parent)
    infoLabel.Size = UDim2.new(1, -8, 1, -130)
    infoLabel.Position = UDim2.fromOffset(4, 124)
    infoLabel.BackgroundColor3 = self.Config.BG_WHITE
    infoLabel.Text = [[POISON SYSTEM READY
Use console to apply poisons:
Examples:
  Modules.OverseerCE:PoisonTableHijack(module, {key = value})
  Modules.OverseerCE.PoisonTemplates.AdminPoison(Modules.OverseerCE, module)
See PoisonExamples.lua for full documentation.
All 15 poison types are available!]]
    infoLabel.TextColor3 = self.Config.TEXT_BLACK
    infoLabel.Font = Enum.Font.Code
    infoLabel.TextSize = 10
    infoLabel.TextXAlignment = Enum.TextXAlignment.Left
    infoLabel.TextYAlignment = Enum.TextYAlignment.Top
    infoLabel.TextWrapped = true
    infoLabel.ZIndex = 101
    self:_createBorder(infoLabel, true)
end
function Modules.OverseerCE:CreateToolsMenuUI(parent)
    local title = Instance.new("TextLabel", parent)
    title.Size = UDim2.new(1, -8, 0, 30)
    title.Position = UDim2.fromOffset(4, 4)
    title.BackgroundTransparency = 1
    title.Text = "Advanced Tools Overview"
    title.TextColor3 = self.Config.TEXT_BLACK
    title.Font = Enum.Font.SourceSansBold
    title.TextSize = 14
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.ZIndex = 101
    local description = Instance.new("TextLabel", parent)
    description.Size = UDim2.new(1, -8, 1, -40)
    description.Position = UDim2.fromOffset(4, 38)
    description.BackgroundTransparency = 1
    description.Text = [[
Scanner: Search for specific values across all loaded modules
â€¢ Supports string, number, boolean, table, and function searches
â€¢ Exact match or fuzzy matching
â€¢ Deep recursive scanning through metatables
â€¢ Click results to copy path to clipboard
Dumper: Export module structures to JSON
â€¢ Complete memory dumps with metatables
â€¢ Function information and upvalue detection
â€¢ Configurable depth for large modules
â€¢ Results automatically copied to clipboard
Injector: Execute code with module context
â€¢ Full access to module environments
â€¢ Upvalue modification support
â€¢ Injection history tracking
â€¢ Template code available for quick start
Anti-Tamper: Hide modifications from detection
â€¢ Hooks getmetatable/setmetatable
â€¢ Spoofs type checking functions
â€¢ Protects frozen patches from overwrites
â€¢ Anti-cheat pattern detection & scanning
Hooks: Quick function hooking system
â€¢ Hook functions to return custom values
â€¢ Block function execution
â€¢ Log and passthrough for debugging
â€¢ Enable/disable hooks without removing them
Decompiler: Advanced function analysis & patching
â€¢ Decompile functions to view source code
â€¢ Inspect constants, upvalues, and nested functions
â€¢ Patch function return values
â€¢ Modify upvalues and constants
â€¢ Track function calls with arguments
â€¢ Replace entire closures
â€¢ Export complete function information
Metatable Unlocking: Automatic bypass for locked metatables
! Locked metatables are shown in RED
! Unlocked metatables are shown in BLUE
â€¢ Automatically uses getrawmetatable when available
â€¢ Tries multiple unlock methods (setrawmetatable, etc.)
â€¢ Even locked metatables are readable via enhanced access
â€¢ Shows access method used for each metatable
Tips:
â€¢ Use the scanner to find specific values before patching
â€¢ Export dumps for offline reverse engineering
â€¢ Enable anti-tamper before applying critical patches
â€¢ Frozen patches are automatically refreshed every frame
â€¢ Locked metatables can still be viewed and patched!
â€¢ Use Decompiler for advanced function-level modifications
    ]]
    description.TextColor3 = self.Config.TEXT_BLACK
    description.Font = Enum.Font.SourceSans
    description.TextSize = 10
    description.TextXAlignment = Enum.TextXAlignment.Left
    description.TextYAlignment = Enum.TextYAlignment.Top
    description.TextWrapped = true
    description.ZIndex = 101
end
function Modules.OverseerCE:ExportPatches()
    local export = {}
    for patchId, patch in pairs(self.State.ActivePatches) do
        table.insert(export, {
            Key = tostring(patch.Key),
            Original = tostring(patch.Original),
            NewValue = tostring(patch.NewValue),
            Type = patch.Type,
            Frozen = patch.Frozen,
            Timestamp = patch.Timestamp
        })
    end
    if #export == 0 then
        self:_showNotification("No patches to export", "warning")
        return
    end
    local success, exportText = pcall(function()
        return game:GetService("HttpService"):JSONEncode(export)
    end)
    if success then
        local copied = self:_setClipboard(exportText)
        if copied then
            self:_showNotification("Exported " .. #export .. " patches to clipboard", "success")
        else
            self:_showNotification("Failed to copy to clipboard", "error")
        end
    else
        self:_showNotification("JSON encoding failed", "error")
    end
end
function Modules.OverseerCE:Initialize()
    local module = self
    RunService.Heartbeat:Connect(function()
        for patchId, patch in pairs(module.State.FreezeList) do
            pcall(function()
                if setreadonly then setreadonly(patch.Table, false) 
                elseif make_writeable then make_writeable(patch.Table) end
                rawset(patch.Table, patch.Key, patch.NewValue)
                if setreadonly then setreadonly(patch.Table, true) end
            end)
        end
    end)
    print("[Overseer CE] Initializing Enhanced Edition...")
    -- UI will only open when command is called
    print("[Overseer CE] Ready! Module inspector and patcher active.")
end
function Modules.OverseerCE:PoisonReturnOverride(module, newValue)
    local success, moduleRef = pcall(function()
        return typeof(module) == "Instance" and require(module) or module
    end)
    if not success then
        return false, "Failed to load module: " .. tostring(moduleRef)
    end
    local poisonId = #self.State.ActivePoisons + 1
    local originalModule = moduleRef
    local poisonedFunc = function(...)
        return newValue
    end
    local poisonData = {
        Id = poisonId,
        Type = "ReturnOverride",
        Target = module,
        OriginalModule = originalModule,
        NewValue = newValue,
        PoisonedFunction = poisonedFunc,
        Timestamp = os.time(),
        Active = true
    }
    table.insert(self.State.ActivePoisons, poisonData)
    table.insert(self.State.PoisonHistory, {
        Type = "ReturnOverride",
        Target = tostring(module),
        Timestamp = os.time()
    })
    return true, poisonId, poisonedFunc
end
function Modules.OverseerCE:PoisonTableHijack(moduleTable, overrides)
    if type(moduleTable) ~= "table" then
        return false, "Target must be a table"
    end
    local mt = self:GetRawMetatable(moduleTable) or {}
    local oldIndex = mt.__index
    local oldNewIndex = mt.__newindex
    local originalMT = {
        __index = oldIndex,
        __newindex = oldNewIndex
    }
    local hijackedMT = {
        __index = function(t, k)
            if overrides[k] ~= nil then
                return overrides[k]
            end
            if type(oldIndex) == "function" then
                return oldIndex(t, k)
            elseif type(oldIndex) == "table" then
                return oldIndex[k]
            end
            return rawget(t, k)
        end,
        __newindex = function(t, k, v)
            if overrides.Protect and overrides.Protect[k] then
                return
            end
            if type(oldNewIndex) == "function" then
                return oldNewIndex(t, k, v)
            end
            return rawset(t, k, v)
        end,
        __metatable = "Locked"
    }
    local applySuccess = pcall(function()
        if setrawmetatable then
            setrawmetatable(moduleTable, hijackedMT)
        elseif setreadonly then
            setreadonly(moduleTable, false)
            setmetatable(moduleTable, hijackedMT)
            setreadonly(moduleTable, true)
        else
            setmetatable(moduleTable, hijackedMT)
        end
    end)
    if not applySuccess then
        return false, "Failed to apply metatable hijack"
    end
    local poisonData = {
        Id = #self.State.ActivePoisons + 1,
        Type = "TableHijack",
        Target = moduleTable,
        Overrides = overrides,
        OriginalMetatable = originalMT,
        HijackedMetatable = hijackedMT,
        Timestamp = os.time(),
        Active = true
    }
    table.insert(self.State.ActivePoisons, poisonData)
    return true, poisonData.Id
end
function Modules.OverseerCE:PoisonFunctionWrapper(func, wrapper)
    if type(func) ~= "function" then
        return false, "Target must be a function"
    end
    if type(wrapper) ~= "function" then
        return false, "Wrapper must be a function"
    end
    local wrappedFunc = function(...)
        local args = {...}
        local results = {wrapper(func, args)}
        return unpack(results)
    end
    local poisonData = {
        Id = #self.State.ActivePoisons + 1,
        Type = "FunctionWrapper",
        OriginalFunction = func,
        Wrapper = wrapper,
        WrappedFunction = wrappedFunc,
        Timestamp = os.time(),
        Active = true
    }
    table.insert(self.State.ActivePoisons, poisonData)
    return true, poisonData.Id, wrappedFunc
end
function Modules.OverseerCE:PoisonConstantPatch(func, constantMap)
    if type(func) ~= "function" then
        return false, "Target must be a function"
    end
    if not getconstants then
        return false, "getconstants not available in executor"
    end
    if not setconstant then
        return false, "setconstant not available in executor"
    end
    local success, constants = pcall(getconstants, func)
    if not success then
        return false, "Failed to get constants"
    end
    local patchedConstants = {}
    for oldValue, newValue in pairs(constantMap) do
        for i, const in ipairs(constants) do
            if const == oldValue then
                local patchSuccess = pcall(setconstant, func, i, newValue)
                if patchSuccess then
                    table.insert(patchedConstants, {
                        Index = i,
                        Old = oldValue,
                        New = newValue
                    })
                end
            end
        end
    end
    if #patchedConstants == 0 then
        return false, "No constants matched for patching"
    end
    local poisonData = {
        Id = #self.State.ActivePoisons + 1,
        Type = "ConstantPatch",
        TargetFunction = func,
        ConstantMap = constantMap,
        PatchedConstants = patchedConstants,
        Timestamp = os.time(),
        Active = true
    }
    table.insert(self.State.ActivePoisons, poisonData)
    table.insert(self.State.ConstantPatches, poisonData)
    return true, poisonData.Id, patchedConstants
end
function Modules.OverseerCE:PoisonUpvalueInject(func, upvalueIndex, newValue)
    if type(func) ~= "function" then
        return false, "Target must be a function"
    end
    if not setupvalue then
        return false, "setupvalue not available in executor"
    end
    if not getupvalue then
        return false, "getupvalue not available in executor"
    end
    local success, originalValue = pcall(getupvalue, func, upvalueIndex)
    if not success then
        return false, "Failed to get upvalue at index " .. upvalueIndex
    end
    local setSuccess = pcall(setupvalue, func, upvalueIndex, newValue)
    if not setSuccess then
        return false, "Failed to set upvalue"
    end
    local poisonData = {
        Id = #self.State.ActivePoisons + 1,
        Type = "UpvalueInject",
        TargetFunction = func,
        UpvalueIndex = upvalueIndex,
        OriginalValue = originalValue,
        NewValue = newValue,
        Timestamp = os.time(),
        Active = true
    }
    table.insert(self.State.ActivePoisons, poisonData)
    table.insert(self.State.UpvalueMonitors, poisonData)
    return true, poisonData.Id
end
function Modules.OverseerCE:GetPoisonStats()
    local stats = {
        Total = #self.State.ActivePoisons,
        Active = 0,
        ByType = {}
    }
    for _, poison in pairs(self.State.ActivePoisons) do
        if poison.Active then
            stats.Active = stats.Active + 1
            stats.ByType[poison.Type] = (stats.ByType[poison.Type] or 0) + 1
        end
    end
    return stats
end
function Modules.OverseerCE:RemovePoison(poisonId)
    local poison = self.State.ActivePoisons[poisonId]
    if not poison then
        return false, "Poison not found"
    end
    if poison.Type == "TableHijack" and poison.OriginalMetatable then
        pcall(function()
            if setrawmetatable then
                setrawmetatable(poison.Target, poison.OriginalMetatable)
            else
                setmetatable(poison.Target, poison.OriginalMetatable)
            end
        end)
    elseif poison.Type == "UpvalueInject" and poison.OriginalValue then
        pcall(setupvalue, poison.TargetFunction, poison.UpvalueIndex, poison.OriginalValue)
    elseif poison.Type == "RequireHook" and poison.OriginalRequire then
        _G.require = poison.OriginalRequire
    elseif poison.Type == "SelfHeal" and poison.SelfHealConnection then
        poison.SelfHealConnection:Disconnect()
    end
    poison.Active = false
    return true, "Poison removed"
end
function Modules.OverseerCE:ClearAllPoisons()
    local count = 0
    for id, poison in pairs(self.State.ActivePoisons) do
        if poison.Active then
            self:RemovePoison(id)
            count = count + 1
        end
    end
    self.State.ActivePoisons = {}
    self.State.RequireHooks = {}
    self.State.CoroutineHijacks = {}
    self.State.MetatableTraps = {}
    self.State.CascadeTriggers = {}
    return count
end
function Modules.OverseerCE:ValidatePoison(poisonId, testFunc)
    local poison = self.State.ActivePoisons[poisonId]
    if not poison then
        return false, "Poison not found"
    end
    if not poison.Active then
        return false, "Poison is inactive"
    end
    local validationResult = {
        PoisonId = poisonId,
        Type = poison.Type,
        Timestamp = os.time()
    }
    if poison.Type == "TableHijack" then
        local testKey = next(poison.Overrides)
        if testKey then
            local success, value = pcall(function()
                return poison.Target[testKey]
            end)
            validationResult.Success = success and value == poison.Overrides[testKey]
            validationResult.TestedKey = testKey
            validationResult.ExpectedValue = poison.Overrides[testKey]
            validationResult.ActualValue = value
        end
    elseif poison.Type == "UpvalueInject" then
        local success, currentValue = pcall(getupvalue, poison.TargetFunction, poison.UpvalueIndex)
        validationResult.Success = success and currentValue == poison.NewValue
        validationResult.ExpectedValue = poison.NewValue
        validationResult.ActualValue = currentValue
    elseif testFunc and type(testFunc) == "function" then
        local success, result = pcall(testFunc, poison)
        validationResult.Success = success and result
        validationResult.CustomResult = result
    else
        validationResult.Success = poison.Active
    end
    table.insert(self.State.PoisonValidationResults, validationResult)
    return validationResult.Success, validationResult
end
function Modules.OverseerCE:ExportPoisonConfig()
    local export = {
        Poisons = {},
        Templates = {},
        Timestamp = os.time()
    }
    for id, poison in pairs(self.State.ActivePoisons) do
        if poison.Active then
            table.insert(export.Poisons, {
                Id = id,
                Type = poison.Type,
                Active = poison.Active,
                Timestamp = poison.Timestamp
            })
        end
    end
    local success, jsonData = pcall(function()
        return game:GetService("HttpService"):JSONEncode(export)
    end)
    if success then
        return jsonData
    else
        return nil, "Failed to encode poison config"
    end
end
Modules.OverseerCE.PoisonTemplates = {
    AdminPoison = function(self, adminModule)
        if type(adminModule) ~= "table" then
            return false, "Admin module must be a table"
        end
        local poisons = {
            Kick = function() return true end,
            Ban = function() return true end,
            Shutdown = function() end,
            Kill = function() end,
            Teleport = function() end
        }
        return self:PoisonTableHijack(adminModule, poisons)
    end,
    AntiCheatPoison = function(self, anticheatModule)
        if type(anticheatModule) ~= "table" then
            return false, "Anti-cheat module must be a table"
        end
        anticheatModule.Enabled = false
        local disablePoisons = {
            CheckPlayer = function() return true end,
            Scan = function() return {} end,
            Detect = function() return false end,
            Ban = function() end,
            Kick = function() end
        }
        return self:PoisonTableHijack(anticheatModule, disablePoisons)
    end,
    CurrencyPoison = function(self, currencyModule, amount)
        amount = amount or math.huge
        local currencyPoisons = {
            GetBalance = function() return amount end,
            CanAfford = function() return true end,
            Deduct = function() return true end,
            Add = function() return true end
        }
        return self:PoisonTableHijack(currencyModule, currencyPoisons)
    end,
    UnlockAllPoison = function(self, unlockModule)
        local unlockPoisons = {
            IsUnlocked = function() return true end,
            HasAccess = function() return true end,
            CanUse = function() return true end,
            IsOwned = function() return true end
        }
        return self:PoisonTableHijack(unlockModule, unlockPoisons)
    end
}
RegisterCommand({
    Name = "OverseerUpdated",
    Aliases = {"HexOS"},
    Description = "Opens the ultimate Overseer module, Use at your own risk."
}, function()
    Modules.OverseerCE:CreateUI()
end)
Modules.ModelBring = {
    State = {
        IsEnabled = false,
        BroughtObjects = {},
        Connections = {},
        SelectedObject = nil,
        UI = nil
    },
    Config = {
        DISTANCE = 5,
        VERTICAL_OFFSET = 0,
        HORIZONTAL_OFFSET = 0,
        ShowHighlight = true,
        HighlightColor = Color3.fromRGB(0, 255, 200)
    }
}
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
function Modules.ModelBring:_createUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "ModelBring_Zuka"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
    self.State.UI = screenGui
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.fromOffset(360, 480)
    mainFrame.Position = UDim2.new(1, -370, 0.5, -240)
    mainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
    mainFrame.BorderSizePixel = 0
    mainFrame.Parent = screenGui
    Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 8)
    local stroke = Instance.new("UIStroke", mainFrame)
    stroke.Color = Color3.fromRGB(0, 255, 200)
    stroke.Thickness = 2
    local glowTween = TweenService:Create(stroke, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {
        Thickness = 3
    })
    glowTween:Play()
    local titleBar = Instance.new("Frame", mainFrame)
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1, 0, 0, 35)
    titleBar.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
    titleBar.BorderSizePixel = 0
    Instance.new("UICorner", titleBar).CornerRadius = UDim.new(0, 8)
    local title = Instance.new("TextLabel", titleBar)
    title.Size = UDim2.new(1, -70, 1, 0)
    title.Position = UDim2.fromOffset(10, 0)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.Code
    title.Text = "â–¸ MODEL BRING"
    title.TextColor3 = Color3.fromRGB(0, 255, 200)
    title.TextSize = 16
    title.TextXAlignment = Enum.TextXAlignment.Left
    local statusIndicator = Instance.new("TextLabel", titleBar)
    statusIndicator.Name = "StatusIndicator"
    statusIndicator.Size = UDim2.fromOffset(80, 20)
    statusIndicator.Position = UDim2.new(1, -150, 0.5, -10)
    statusIndicator.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    statusIndicator.BorderSizePixel = 0
    statusIndicator.Font = Enum.Font.GothamBold
    statusIndicator.Text = "0 ACTIVE"
    statusIndicator.TextColor3 = Color3.fromRGB(200, 200, 200)
    statusIndicator.TextSize = 10
    Instance.new("UICorner", statusIndicator).CornerRadius = UDim.new(0, 4)
    local closeBtn = Instance.new("TextButton", titleBar)
    closeBtn.Size = UDim2.fromOffset(30, 30)
    closeBtn.Position = UDim2.new(1, -32, 0, 2)
    closeBtn.BackgroundColor3 = Color3.fromRGB(255, 50, 100)
    closeBtn.BorderSizePixel = 0
    closeBtn.Text = "Ã—"
    closeBtn.TextColor3 = Color3.new(1, 1, 1)
    closeBtn.Font = Enum.Font.GothamBold
    closeBtn.TextSize = 20
    Instance.new("UICorner", closeBtn).CornerRadius = UDim.new(0, 6)
    closeBtn.MouseButton1Click:Connect(function()
        self:Disable()
    end)
    local dragStart, startPos
    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragStart = input.Position
            startPos = mainFrame.Position
            local moveConn, endConn
            moveConn = game:GetService("UserInputService").InputChanged:Connect(function(moveInput)
                if moveInput.UserInputType == Enum.UserInputType.MouseMovement then
                    local delta = moveInput.Position - dragStart
                    mainFrame.Position = UDim2.new(
                        startPos.X.Scale, startPos.X.Offset + delta.X,
                        startPos.Y.Scale, startPos.Y.Offset + delta.Y
                    )
                end
            end)
            endConn = game:GetService("UserInputService").InputEnded:Connect(function(endInput)
                if endInput.UserInputType == Enum.UserInputType.MouseButton1 then
                    moveConn:Disconnect()
                    endConn:Disconnect()
                end
            end)
        end
    end)
    local content = Instance.new("Frame", mainFrame)
    content.Name = "Content"
    content.Size = UDim2.new(1, -20, 1, -45)
    content.Position = UDim2.fromOffset(10, 40)
    content.BackgroundTransparency = 1
    local selectionLabel = Instance.new("TextLabel", content)
    selectionLabel.Name = "SelectionLabel"
    selectionLabel.Size = UDim2.new(1, 0, 0, 35)
    selectionLabel.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    selectionLabel.BorderSizePixel = 0
    selectionLabel.Font = Enum.Font.GothamMedium
    selectionLabel.Text = "Click an object to select"
    selectionLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    selectionLabel.TextSize = 12
    Instance.new("UICorner", selectionLabel).CornerRadius = UDim.new(0, 6)
    local settingsLabel = Instance.new("TextLabel", content)
    settingsLabel.Size = UDim2.new(1, 0, 0, 20)
    settingsLabel.Position = UDim2.fromOffset(0, 45)
    settingsLabel.BackgroundTransparency = 1
    settingsLabel.Font = Enum.Font.GothamBold
    settingsLabel.Text = "Position Settings:"
    settingsLabel.TextColor3 = Color3.new(1, 1, 1)
    settingsLabel.TextSize = 13
    settingsLabel.TextXAlignment = Enum.TextXAlignment.Left
    local distanceLabel = Instance.new("TextLabel", content)
    distanceLabel.Size = UDim2.new(1, 0, 0, 18)
    distanceLabel.Position = UDim2.fromOffset(0, 70)
    distanceLabel.BackgroundTransparency = 1
    distanceLabel.Font = Enum.Font.Gotham
    distanceLabel.Text = "Distance: 5"
    distanceLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    distanceLabel.TextSize = 11
    distanceLabel.TextXAlignment = Enum.TextXAlignment.Left
    local distanceInput = Instance.new("TextBox", content)
    distanceInput.Size = UDim2.new(1, 0, 0, 30)
    distanceInput.Position = UDim2.fromOffset(0, 92)
    distanceInput.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    distanceInput.BorderSizePixel = 0
    distanceInput.Font = Enum.Font.Code
    distanceInput.Text = "5"
    distanceInput.TextColor3 = Color3.new(1, 1, 1)
    distanceInput.TextSize = 12
    distanceInput.PlaceholderText = "Distance from player..."
    Instance.new("UICorner", distanceInput).CornerRadius = UDim.new(0, 6)
    distanceInput.FocusLost:Connect(function()
        local value = tonumber(distanceInput.Text)
        if value then
            self.Config.DISTANCE = value
            distanceLabel.Text = "Distance: " .. value
        else
            distanceInput.Text = tostring(self.Config.DISTANCE)
        end
    end)
    local verticalLabel = Instance.new("TextLabel", content)
    verticalLabel.Size = UDim2.new(1, 0, 0, 18)
    verticalLabel.Position = UDim2.fromOffset(0, 130)
    verticalLabel.BackgroundTransparency = 1
    verticalLabel.Font = Enum.Font.Gotham
    verticalLabel.Text = "Vertical Offset: 0"
    verticalLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    verticalLabel.TextSize = 11
    verticalLabel.TextXAlignment = Enum.TextXAlignment.Left
    local verticalInput = Instance.new("TextBox", content)
    verticalInput.Size = UDim2.new(1, 0, 0, 30)
    verticalInput.Position = UDim2.fromOffset(0, 152)
    verticalInput.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    verticalInput.BorderSizePixel = 0
    verticalInput.Font = Enum.Font.Code
    verticalInput.Text = "0"
    verticalInput.TextColor3 = Color3.new(1, 1, 1)
    verticalInput.TextSize = 12
    verticalInput.PlaceholderText = "Height offset..."
    Instance.new("UICorner", verticalInput).CornerRadius = UDim.new(0, 6)
    verticalInput.FocusLost:Connect(function()
        local value = tonumber(verticalInput.Text)
        if value then
            self.Config.VERTICAL_OFFSET = value
            verticalLabel.Text = "Vertical Offset: " .. value
        else
            verticalInput.Text = tostring(self.Config.VERTICAL_OFFSET)
        end
    end)
    local horizontalLabel = Instance.new("TextLabel", content)
    horizontalLabel.Size = UDim2.new(1, 0, 0, 18)
    horizontalLabel.Position = UDim2.fromOffset(0, 190)
    horizontalLabel.BackgroundTransparency = 1
    horizontalLabel.Font = Enum.Font.Gotham
    horizontalLabel.Text = "Horizontal Offset: 0"
    horizontalLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    horizontalLabel.TextSize = 11
    horizontalLabel.TextXAlignment = Enum.TextXAlignment.Left
    local horizontalInput = Instance.new("TextBox", content)
    horizontalInput.Size = UDim2.new(1, 0, 0, 30)
    horizontalInput.Position = UDim2.fromOffset(0, 212)
    horizontalInput.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    horizontalInput.BorderSizePixel = 0
    horizontalInput.Font = Enum.Font.Code
    horizontalInput.Text = "0"
    horizontalInput.TextColor3 = Color3.new(1, 1, 1)
    horizontalInput.TextSize = 12
    horizontalInput.PlaceholderText = "Side offset..."
    Instance.new("UICorner", horizontalInput).CornerRadius = UDim.new(0, 6)
    horizontalInput.FocusLost:Connect(function()
        local value = tonumber(horizontalInput.Text)
        if value then
            self.Config.HORIZONTAL_OFFSET = value
            horizontalLabel.Text = "Horizontal Offset: " .. value
        else
            horizontalInput.Text = tostring(self.Config.HORIZONTAL_OFFSET)
        end
    end)
    local actionsLabel = Instance.new("TextLabel", content)
    actionsLabel.Size = UDim2.new(1, 0, 0, 20)
    actionsLabel.Position = UDim2.fromOffset(0, 252)
    actionsLabel.BackgroundTransparency = 1
    actionsLabel.Font = Enum.Font.GothamBold
    actionsLabel.Text = "Actions:"
    actionsLabel.TextColor3 = Color3.new(1, 1, 1)
    actionsLabel.TextSize = 13
    actionsLabel.TextXAlignment = Enum.TextXAlignment.Left
    local bringBtn = Instance.new("TextButton", content)
    bringBtn.Name = "BringButton"
    bringBtn.Size = UDim2.new(1, 0, 0, 40)
    bringBtn.Position = UDim2.fromOffset(0, 277)
    bringBtn.BackgroundColor3 = Color3.fromRGB(0, 200, 150)
    bringBtn.BorderSizePixel = 0
    bringBtn.Font = Enum.Font.GothamBold
    bringBtn.Text = "BRING SELECTED"
    bringBtn.TextColor3 = Color3.new(1, 1, 1)
    bringBtn.TextSize = 14
    Instance.new("UICorner", bringBtn).CornerRadius = UDim.new(0, 6)
    bringBtn.MouseButton1Click:Connect(function()
        self:BringSelected()
    end)
    local releaseBtn = Instance.new("TextButton", content)
    releaseBtn.Size = UDim2.new(0.48, 0, 0, 35)
    releaseBtn.Position = UDim2.fromOffset(0, 327)
    releaseBtn.BackgroundColor3 = Color3.fromRGB(200, 100, 50)
    releaseBtn.BorderSizePixel = 0
    releaseBtn.Font = Enum.Font.GothamBold
    releaseBtn.Text = "RELEASE"
    releaseBtn.TextColor3 = Color3.new(1, 1, 1)
    releaseBtn.TextSize = 12
    Instance.new("UICorner", releaseBtn).CornerRadius = UDim.new(0, 6)
    releaseBtn.MouseButton1Click:Connect(function()
        self:ReleaseSelected()
    end)
    local releaseAllBtn = Instance.new("TextButton", content)
    releaseAllBtn.Size = UDim2.new(0.48, 0, 0, 35)
    releaseAllBtn.Position = UDim2.new(0.52, 0, 0, 327)
    releaseAllBtn.BackgroundColor3 = Color3.fromRGB(255, 50, 100)
    releaseAllBtn.BorderSizePixel = 0
    releaseAllBtn.Font = Enum.Font.GothamBold
    releaseAllBtn.Text = "RELEASE ALL"
    releaseAllBtn.TextColor3 = Color3.new(1, 1, 1)
    releaseAllBtn.TextSize = 12
    Instance.new("UICorner", releaseAllBtn).CornerRadius = UDim.new(0, 6)
    releaseAllBtn.MouseButton1Click:Connect(function()
        self:ReleaseAll()
    end)
    local listLabel = Instance.new("TextLabel", content)
    listLabel.Size = UDim2.new(1, 0, 0, 20)
    listLabel.Position = UDim2.fromOffset(0, 372)
    listLabel.BackgroundTransparency = 1
    listLabel.Font = Enum.Font.GothamBold
    listLabel.Text = "Brought Objects:"
    listLabel.TextColor3 = Color3.new(1, 1, 1)
    listLabel.TextSize = 13
    listLabel.TextXAlignment = Enum.TextXAlignment.Left
    local objectList = Instance.new("ScrollingFrame", content)
    objectList.Name = "ObjectList"
    objectList.Size = UDim2.new(1, 0, 0, 83)
    objectList.Position = UDim2.fromOffset(0, 397)
    objectList.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
    objectList.BorderSizePixel = 0
    objectList.ScrollBarThickness = 4
    objectList.ScrollBarImageColor3 = Color3.fromRGB(0, 255, 200)
    objectList.CanvasSize = UDim2.fromOffset(0, 0)
    objectList.AutomaticCanvasSize = Enum.AutomaticSize.Y
    Instance.new("UICorner", objectList).CornerRadius = UDim.new(0, 6)
    local listLayout = Instance.new("UIListLayout", objectList)
    listLayout.Padding = UDim.new(0, 3)
    listLayout.SortOrder = Enum.SortOrder.LayoutOrder
    screenGui.Parent = CoreGui
    return selectionLabel, statusIndicator, objectList
end
function Modules.ModelBring:GetPrimaryPart(obj)
    if obj:IsA("Model") then
        return obj.PrimaryPart or obj:FindFirstChildWhichIsA("BasePart", true)
    elseif obj:IsA("BasePart") then
        return obj
    end
    return nil
end
function Modules.ModelBring:BringSelected()
    if not self.State.SelectedObject then
        print("âš  No object selected")
        return
    end
    local obj = self.State.SelectedObject
    local primaryPart = self:GetPrimaryPart(obj)
    if not primaryPart then
        print("âœ— Object has no valid part to bring")
        return
    end
    for _, data in pairs(self.State.BroughtObjects) do
        if data.Object == obj then
            print("âš  Object already brought")
            return
        end
    end
    local myChar = LocalPlayer.Character
    if not myChar or not myChar:FindFirstChild("HumanoidRootPart") then
        print("âœ— Character not found")
        return
    end
    local highlight = Instance.new("Highlight")
    highlight.Name = "ModelBring_Highlight"
    highlight.FillColor = self.Config.HighlightColor
    highlight.OutlineColor = self.Config.HighlightColor
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.Adornee = obj:IsA("Model") and obj or primaryPart
    highlight.Parent = obj:IsA("Model") and obj or primaryPart
    local connection = RunService.Heartbeat:Connect(function()
        local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
        if not (myRoot and primaryPart and primaryPart.Parent) then
            return
        end
        if primaryPart:IsA("BasePart") then
            primaryPart.Velocity = Vector3.new(0, 0, 0)
            primaryPart.RotVelocity = Vector3.new(0, 0, 0)
        end
        local offset = CFrame.new(
            self.Config.HORIZONTAL_OFFSET,
            self.Config.VERTICAL_OFFSET,
            -self.Config.DISTANCE
        )
        if obj:IsA("Model") and obj.PrimaryPart then
            obj:SetPrimaryPartCFrame(myRoot.CFrame * offset)
        elseif primaryPart then
            primaryPart.CFrame = myRoot.CFrame * offset
        end
    end)
    table.insert(self.State.BroughtObjects, {
        Object = obj,
        Connection = connection,
        Highlight = highlight,
        Name = obj.Name
    })
    print(string.format("âœ“ Brought: %s", obj.Name))
    self:UpdateDisplay()
end
function Modules.ModelBring:ReleaseSelected()
    if not self.State.SelectedObject then
        print("âš  No object selected")
        return
    end
    for i, data in ipairs(self.State.BroughtObjects) do
        if data.Object == self.State.SelectedObject then
            if data.Connection then
                data.Connection:Disconnect()
            end
            if data.Highlight then
                data.Highlight:Destroy()
            end
            table.remove(self.State.BroughtObjects, i)
            print(string.format("âœ“ Released: %s", data.Name))
            self:UpdateDisplay()
            return
        end
    end
    print("âš  Selected object is not brought")
end
function Modules.ModelBring:ReleaseAll()
    if #self.State.BroughtObjects == 0 then
        print("âš  No objects to release")
        return
    end
    local count = #self.State.BroughtObjects
    for _, data in ipairs(self.State.BroughtObjects) do
        if data.Connection then
            data.Connection:Disconnect()
        end
        if data.Highlight then
            data.Highlight:Destroy()
        end
    end
    self.State.BroughtObjects = {}
    print(string.format("âœ“ Released %d objects", count))
    self:UpdateDisplay()
end
function Modules.ModelBring:SelectObject(obj)
    if not obj or (not obj:IsA("Model") and not obj:IsA("BasePart")) then
        print("âš  Invalid object selected")
        return
    end
    if self.State.SelectedObject then
        local oldHighlight = self.State.SelectedObject:FindFirstChild("ModelBring_Selection")
        if oldHighlight then
            oldHighlight:Destroy()
        end
    end
    self.State.SelectedObject = obj
    local selectionBox = Instance.new("SelectionBox")
    selectionBox.Name = "ModelBring_Selection"
    selectionBox.Adornee = obj:IsA("Model") and obj or obj
    selectionBox.LineThickness = 0.05
    selectionBox.Color3 = Color3.fromRGB(255, 255, 0)
    selectionBox.Parent = obj
    print(string.format("âœ“ Selected: %s", obj.Name))
    self:UpdateDisplay()
end
function Modules.ModelBring:UpdateDisplay()
    if not self.State.UI then return end
    local selectionLabel = self.State.UI.MainFrame.Content.SelectionLabel
    local statusIndicator = self.State.UI.MainFrame.TitleBar.StatusIndicator
    local objectList = self.State.UI.MainFrame.Content.ObjectList
    if self.State.SelectedObject then
        selectionLabel.Text = "Selected: " .. self.State.SelectedObject.Name
        selectionLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
    else
        selectionLabel.Text = "Click an object to select"
        selectionLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    end
    local count = #self.State.BroughtObjects
    statusIndicator.Text = count .. " ACTIVE"
    statusIndicator.BackgroundColor3 = count > 0 and Color3.fromRGB(0, 200, 150) or Color3.fromRGB(50, 50, 50)
    statusIndicator.TextColor3 = count > 0 and Color3.new(1, 1, 1) or Color3.fromRGB(200, 200, 200)
    for _, child in pairs(objectList:GetChildren()) do
        if not child:IsA("UIListLayout") then
            child:Destroy()
        end
    end
    for i, data in ipairs(self.State.BroughtObjects) do
        local entry = Instance.new("TextButton")
        entry.Size = UDim2.new(1, -5, 0, 25)
        entry.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
        entry.BorderSizePixel = 0
        entry.Font = Enum.Font.Code
        entry.Text = string.format("[%d] %s", i, data.Name)
        entry.TextColor3 = Color3.fromRGB(0, 255, 200)
        entry.TextSize = 11
        entry.TextXAlignment = Enum.TextXAlignment.Left
        entry.AutoButtonColor = false
        entry.Parent = objectList
        Instance.new("UICorner", entry).CornerRadius = UDim.new(0, 4)
        local padding = Instance.new("UIPadding", entry)
        padding.PaddingLeft = UDim.new(0, 8)
        entry.MouseButton1Click:Connect(function()
            self.State.SelectedObject = data.Object
            self:SelectObject(data.Object)
        end)
        entry.MouseEnter:Connect(function()
            entry.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
        end)
        entry.MouseLeave:Connect(function()
            entry.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
        end)
    end
end
function Modules.ModelBring:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    self:_createUI()
    self.State.Connections.MouseClick = game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            local mouse = LocalPlayer:GetMouse()
            local target = mouse.Target
            if target then
                local obj = target:IsA("Model") and target or target.Parent
                if obj:IsA("Model") or obj:IsA("BasePart") then
                    self:SelectObject(obj)
                end
            end
        end
    end)
    print("âœ“ Model Bring enabled - Click objects to select")
end
function Modules.ModelBring:Disable()
    if not self.State.IsEnabled then return end
    self:ReleaseAll()
    self.State.IsEnabled = false
    if self.State.SelectedObject then
        local highlight = self.State.SelectedObject:FindFirstChild("ModelBring_Selection")
        if highlight then
            highlight:Destroy()
        end
    end
    for _, conn in pairs(self.State.Connections) do
        if conn then
            conn:Disconnect()
        end
    end
    table.clear(self.State.Connections)
    if self.State.UI then
        self.State.UI:Destroy()
        self.State.UI = nil
    end
    self.State.SelectedObject = nil
    print("âœ“ Model Bring disabled")
end
function Modules.ModelBring:Toggle()
    if self.State.IsEnabled then
        self:Disable()
    else
        self:Enable()
    end
end
RegisterCommand({
    Name = "bringmodel",
    Aliases = {""},
    Description = "Brings any workspace model or part to you. Click to select, then click 'BRING SELECTED'."
}, function()
    Modules.ModelBring:Toggle()
end)
Modules.ApexCounter = {
    State = {
        IsEnabled = false,
        LagShieldActive = false,
        GhostMode = false,
        Blender = false,
        AcidProtection = false,
        Connections = {},
        BlacklistedRemotes = {
            "AcidSpit",
            "PLACE_LANDMINE",
            "AbilityPlayer",
            "PlayerAttack",
            "ReplicateAcidAbility",
            "AcidDamageVisual",
        },
        AcidSpamCounter = 0,
        LastAcidTime = 0,
        AcidThreshold = 10,
    },
    Services = {
        Players = game:GetService("Players"),
        RunService = game:GetService("RunService"),
        ReplicatedStorage = game:GetService("ReplicatedStorage"),
        Workspace = game:GetService("Workspace"),
        Debris = game:GetService("Debris")
    }
}
function Modules.ApexCounter:ToggleLagShield(state)
    self.State.LagShieldActive = state
    if state then
        local targetFolder = self.Services.Workspace:FindFirstChild("Interaction") 
            and self.Services.Workspace.Interaction:FindFirstChild("PlayerPlaced")
        if targetFolder then
            for _, child in ipairs(targetFolder:GetChildren()) do
                if child.Name:find("Landmine") or child.Name:find("Acid") then
                    child:Destroy()
                end
            end
            self.State.Connections.LagMonitor = targetFolder.ChildAdded:Connect(function(child)
                task.defer(function()
                    if child and child.Parent then
                        if child.Name:find("Landmine") or child.Name:find("Acid") then
                            child:Destroy()
                            local currentTime = tick()
                            if currentTime - self.State.LastAcidTime < 1 then
                                self.State.AcidSpamCounter = self.State.AcidSpamCounter + 1
                            else
                                self.State.AcidSpamCounter = 0
                            end
                            self.State.LastAcidTime = currentTime
                            if self.State.AcidSpamCounter > self.State.AcidThreshold then
                                DoNotif("âš  HEAVY ACID SPAM DETECTED - Deflecting", 1)
                            end
                        end
                    end
                end)
            end)
        end
        DoNotif("ðŸ›¡ Lag Deflector: ACTIVE (Blocking Exploit Spam)", 2)
    else
        if self.State.Connections.LagMonitor then
            self.State.Connections.LagMonitor:Disconnect()
        end
        self.State.AcidSpamCounter = 0
        DoNotif("Lag Deflector: DISABLED", 2)
    end
end
function Modules.ApexCounter:ToggleGhost(state)
    self.State.GhostMode = state
    local lp = self.Services.Players.LocalPlayer
    local char = lp.Character
    if state and char then
        pcall(function()
            char:SetAttribute("Team", "Ghost")
            local hum = char:FindFirstChildOfClass("Humanoid")
            if hum then
                local mt = getrawmetatable(game)
                local oldIndex = mt.__index
                setreadonly(mt, false)
                mt.__index = newcclosure(function(t, k)
                    if t == hum and k == "Health" and not checkcaller() then
                        return 0
                    end
                    return oldIndex(t, k)
                end)
                setreadonly(mt, true)
            end
        end)
        DoNotif("ðŸ‘» Ghost Mode: ACTIVE (Invisible to Kill Aura)", 2)
    else
        DoNotif("Ghost Mode: DISABLED", 2)
    end
end
function Modules.ApexCounter:RunBlender()
    if self.State.BlenderActive then return end
    self.State.BlenderActive = true
    local lp = self.Services.Players.LocalPlayer
    local meleeRemote = self.Services.ReplicatedStorage:FindFirstChild("Remotes") 
        and self.Services.ReplicatedStorage.Remotes:FindFirstChild("Melee") 
        and self.Services.ReplicatedStorage.Remotes.Melee:FindFirstChild("Damage")
    local zombieRemote = self.Services.ReplicatedStorage:FindFirstChild("Remotes")
        and self.Services.ReplicatedStorage.Remotes:FindFirstChild("ZombieRelated") 
        and self.Services.ReplicatedStorage.Remotes.ZombieRelated:FindFirstChild("PlayerAttack")
    local isProcessing = false
    local lastCall = 0
    local callDelay = 0.05
    local oldNamecall
    oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
        local method = getnamecallmethod()
        local args = {...}
        if (self == meleeRemote or self == zombieRemote) and method == "InvokeServer" and not checkcaller() then
            local currentTime = tick()
            if not isProcessing and (currentTime - lastCall) > callDelay then
                isProcessing = true
                lastCall = currentTime
                for i = 1, 6 do
                    task.spawn(function()
                        pcall(function()
                            oldNamecall(self, unpack(args))
                        end)
                    end)
                end
                isProcessing = false
                return nil
            end
        end
        return oldNamecall(self, ...)
    end))
    DoNotif("âš” Kill Blender: ACTIVE (6x Multiplier)", 2)
end
function Modules.ApexCounter:NullifySkidRemotes()
    local mt = getrawmetatable(game)
    local oldNamecall = mt.__namecall
    setreadonly(mt, false)
    mt.__namecall = newcclosure(function(self, ...)
        local method = getnamecallmethod()
        if not checkcaller() then
            local remoteName = self.Name
            for _, blocked in ipairs(Modules.ApexCounter.State.BlacklistedRemotes) do
                if remoteName == blocked and (method == "FireServer" or method == "InvokeServer") then
                    return nil
                end
            end
        end
        return oldNamecall(self, ...)
    end)
    setreadonly(mt, true)
    DoNotif("ðŸ”’ Remote Shield: ACTIVE (Blocking Exploit Remotes)", 2)
end
function Modules.ApexCounter:ToggleAcidProtection(state)
    self.State.AcidProtection = state
    if state then
        self.State.Connections.AcidReplication = self.Services.ReplicatedStorage
            :FindFirstChild("Remotes", true) and self.Services.ReplicatedStorage.Remotes
            :FindFirstChild("Replication", true) and self.Services.ReplicatedStorage.Remotes.Replication
            :FindFirstChild("ReplicateAcidAbility")
        if self.State.Connections.AcidReplication then
            local oldConnect = self.State.Connections.AcidReplication.OnClientEvent.Connect
            self.State.Connections.AcidReplication.OnClientEvent.Connect = function(...)
                return {Disconnect = function() end}
            end
        end
        task.spawn(function()
            while self.State.AcidProtection do
                for _, v in ipairs(self.Services.Workspace:GetDescendants()) do
                    if v:IsA("BasePart") and v.Name:find("Acid") then
                        v:Destroy()
                    end
                end
                task.wait(0.5)
            end
        end)
        local acidDamageModule = self.Services.ReplicatedStorage:FindFirstChild("Modules", true)
            and self.Services.ReplicatedStorage.Modules:FindFirstChild("MostRandomStuff", true)
            and self.Services.ReplicatedStorage.Modules.MostRandomStuff:FindFirstChild("AcidDamage")
        if acidDamageModule then
            local mt = getrawmetatable(game)
            local oldRequire = mt.__index
            setreadonly(mt, false)
            local originalAcidDamage = require(acidDamageModule)
            mt.__index = newcclosure(function(t, k)
                if k == acidDamageModule then
                    return function() end
                end
                return oldRequire(t, k)
            end)
            setreadonly(mt, true)
        end
        DoNotif("â˜£ Acid Protection: MAXIMUM (Full Immunity)", 2)
    else
        if self.State.Connections.AcidReplicationHook then
            self.State.Connections.AcidReplicationHook:Disconnect()
        end
        DoNotif("Acid Protection: DISABLED", 2)
    end
end
function Modules.ApexCounter:CleanVisualEffects()
    if not self.State.IsEnabled then return end
    task.spawn(function()
        while self.State.IsEnabled do
            for _, player in ipairs(self.Services.Players:GetPlayers()) do
                if player.Character then
                    for _, part in ipairs(player.Character:GetDescendants()) do
                        if part:IsA("ParticleEmitter") and part.Name == "ParticleEmitter" then
                            part:Destroy()
                        elseif part:IsA("Sound") and part.Name == "Burn" then
                            part:Destroy()
                        end
                    end
                end
            end
            task.wait(1)
        end
    end)
end
function Modules.ApexCounter:EnableNetworkProtection()
    local eventCounter = {}
    local threshold = 50
    local oldFireServer
    oldFireServer = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
        local method = getnamecallmethod()
        if method == "FireServer" or method == "InvokeServer" then
            local remoteName = tostring(self)
            local currentTime = tick()
            if not eventCounter[remoteName] then
                eventCounter[remoteName] = {count = 0, lastReset = currentTime}
            end
            local data = eventCounter[remoteName]
            if currentTime - data.lastReset >= 1 then
                data.count = 0
                data.lastReset = currentTime
            end
            data.count = data.count + 1
            if data.count > threshold then
                if not checkcaller() then
                    return nil
                end
            end
        end
        return oldFireServer(self, ...)
    end))
    DoNotif("ðŸŒ Network Protection: ENABLED", 2)
end
function Modules.ApexCounter:Initialize()
    local module = self
    RegisterCommand({
        Name = "zcounter",
        Aliases = {"zc"},
        Description = "Toggles the counter-exploit suite (APEX Edition)."
    }, function(args)
        module.State.IsEnabled = not module.State.IsEnabled
        if module.State.IsEnabled then
            DoNotif("âš¡ APEX SUITE: INITIALIZING...", 1.5)
            task.wait(0.5)
            module:ToggleLagShield(true)
            module:ToggleGhost(true)
            module:ToggleAcidProtection(true)
            module:RunBlender()
            module:NullifySkidRemotes()
            module:CleanVisualEffects()
            module:EnableNetworkProtection()
            task.wait(0.5)
            DoNotif("âœ… APEX SUITE: FULLY OPERATIONAL", 3)
            DoNotif("ðŸ›¡ All Protections: ACTIVE", 2)
        else
            module:ToggleLagShield(false)
            module:ToggleGhost(false)
            module:ToggleAcidProtection(false)
            for _, conn in pairs(module.State.Connections) do
                if typeof(conn) == "RBXScriptConnection" then
                    conn:Disconnect()
                end
            end
            module.State.Connections = {}
            module.State.BlenderActive = false
            DoNotif("ðŸ”´ APEX SUITE: DEACTIVATED", 3)
        end
    end)
    RegisterCommand({
        Name = "acidblock",
        Aliases = {"ab"},
        Description = "Toggle acid-specific protection only."
    }, function(args)
        local newState = not module.State.AcidProtection
        module:ToggleAcidProtection(newState)
    end)
end
    RegisterCommand({
        Name = "minigunsniper",
        Aliases = {"spawnsniper"},
        Description = "For Zombie Game Series."
    }, function()
        local shop = game:GetService("ReplicatedStorage").Remotes.Shop.EquipWeapon
        shop:InvokeServer("Sniper")
        find.Sniper(true)
        task.wait(0.2)
        local gun = localplayer.Character:FindFirstChild("Sniper") or localplayer.Backpack:FindFirstChild("Sniper")
        if gun then
            local scr = getsenv(gun:FindFirstChildOfClass("LocalScript"))
            if scr and scr.FireGun then
                self.Services.RunService.Heartbeat:Connect(function()
                    if localplayer:GetMouse().Button1Down then
                        pcall(scr.FireGun, lp:GetMouse().X, lp:GetMouse().Y)
                    end
                end)
                DoNotif("Rapid Fire: ENABLED", 2)
            end
        end
    end)
    RegisterCommand({
        Name = "spwnShotgun",
        Aliases = {"spawnsgun"},
        Description = "For Zombie Game Series."
    }, function()
        local shop = game:GetService("ReplicatedStorage").Remotes.Shop.EquipWeapon
        shop:InvokeServer("Shotgun")
        find.Shotgun(true)
        task.wait(0.2)
        local gun = localplayer.Character:FindFirstChild("Shotgun") or localplayer.Backpack:FindFirstChild("Shotgun")
        if gun then
            local scr = getsenv(gun:FindFirstChildOfClass("LocalScript"))
            if scr and scr.FireGun then
                self.Services.RunService.Heartbeat:Connect(function()
                    if localplayer:GetMouse().Button1Down then
                        pcall(scr.FireGun, lp:GetMouse().X, lp:GetMouse().Y)
                    end
                end)
                DoNotif("Rapid Fire: ENABLED", 2)
            end
        end
    end)
Modules.ModuleExplorer = {
    State = {
        IsOpen = false,
        SelectedModule = nil,
        SelectedPath = {},
        GUI = nil,
        Hooks = {},
        GhostIndexes = {}
    }
}

local TweenService = game:GetService("TweenService")
local CoreGui = game:GetService("CoreGui")

local function CreateGUI()
    local gui = Instance.new("ScreenGui")
    gui.Name = "ModuleExplorer"
    gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    gui.ResetOnSpawn = false
    gui.Parent = CoreGui
    
    local main = Instance.new("Frame")
    main.Name = "MainFrame"
    main.Size = UDim2.fromOffset(1100, 650)
    main.Position = UDim2.fromScale(0.5, 0.5)
    main.AnchorPoint = Vector2.new(0.5, 0.5)
    main.BackgroundColor3 = Color3.fromRGB(10, 10, 15)
    main.BorderSizePixel = 0
    main.ClipsDescendants = true
    main.Parent = gui
    
    local mainCorner = Instance.new("UICorner", main)
    mainCorner.CornerRadius = UDim.new(0, 12)
    
    local mainStroke = Instance.new("UIStroke", main)
    mainStroke.Color = Color3.fromRGB(0, 255, 150)
    mainStroke.Thickness = 2
    
    -- Title Bar
    local titleBar = Instance.new("Frame")
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1, 0, 0, 40)
    titleBar.BackgroundColor3 = Color3.fromRGB(15, 15, 25)
    titleBar.BorderSizePixel = 0
    titleBar.Parent = main
    
    local titleCorner = Instance.new("UICorner", titleBar)
    titleCorner.CornerRadius = UDim.new(0, 12)
    
    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, -100, 1, 0)
    title.Position = UDim2.fromOffset(15, 0)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.Code
    title.Text = "â–¸ MODULE EXPLORER v2.0"
    title.TextColor3 = Color3.fromRGB(0, 255, 150)
    title.TextSize = 16
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.Parent = titleBar
    
    local closeBtn = Instance.new("TextButton")
    closeBtn.Size = UDim2.fromOffset(30, 30)
    closeBtn.Position = UDim2.new(1, -35, 0, 5)
    closeBtn.BackgroundColor3 = Color3.fromRGB(255, 50, 100)
    closeBtn.BorderSizePixel = 0
    closeBtn.Font = Enum.Font.GothamBold
    closeBtn.Text = "Ã—"
    closeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeBtn.TextSize = 20
    closeBtn.Parent = titleBar
    
    local closeBtnCorner = Instance.new("UICorner", closeBtn)
    closeBtnCorner.CornerRadius = UDim.new(0, 8)
    
    -- Left Panel (Module List)
    local leftPanel = Instance.new("Frame")
    leftPanel.Name = "ModuleList"
    leftPanel.Size = UDim2.new(0.25, -5, 1, -50)
    leftPanel.Position = UDim2.fromOffset(5, 45)
    leftPanel.BackgroundColor3 = Color3.fromRGB(15, 15, 25)
    leftPanel.BorderSizePixel = 0
    leftPanel.Parent = main
    
    local leftCorner = Instance.new("UICorner", leftPanel)
    leftCorner.CornerRadius = UDim.new(0, 8)
    
    local leftStroke = Instance.new("UIStroke", leftPanel)
    leftStroke.Color = Color3.fromRGB(0, 255, 150)
    leftStroke.Thickness = 1
    leftStroke.Transparency = 0.5
    
    local moduleScroll = Instance.new("ScrollingFrame")
    moduleScroll.Name = "ModuleScroll"
    moduleScroll.Size = UDim2.new(1, -10, 1, -10)
    moduleScroll.Position = UDim2.fromOffset(5, 5)
    moduleScroll.BackgroundTransparency = 1
    moduleScroll.BorderSizePixel = 0
    moduleScroll.ScrollBarThickness = 4
    moduleScroll.ScrollBarImageColor3 = Color3.fromRGB(0, 255, 150)
    moduleScroll.CanvasSize = UDim2.fromOffset(0, 0)
    moduleScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
    moduleScroll.Parent = leftPanel
    
    local moduleLayout = Instance.new("UIListLayout", moduleScroll)
    moduleLayout.Padding = UDim.new(0, 5)
    moduleLayout.SortOrder = Enum.SortOrder.LayoutOrder
    
    -- Middle Panel (Details)
    local middlePanel = Instance.new("Frame")
    middlePanel.Name = "DetailsPanel"
    middlePanel.Size = UDim2.new(0.45, -5, 1, -50)
    middlePanel.Position = UDim2.new(0.25, 5, 0, 45)
    middlePanel.BackgroundColor3 = Color3.fromRGB(15, 15, 25)
    middlePanel.BorderSizePixel = 0
    middlePanel.Parent = main
    
    local middleCorner = Instance.new("UICorner", middlePanel)
    middleCorner.CornerRadius = UDim.new(0, 8)
    
    local middleStroke = Instance.new("UIStroke", middlePanel)
    middleStroke.Color = Color3.fromRGB(0, 255, 150)
    middleStroke.Thickness = 1
    middleStroke.Transparency = 0.5
    
    local detailsScroll = Instance.new("ScrollingFrame")
    detailsScroll.Name = "DetailsScroll"
    detailsScroll.Size = UDim2.new(1, -10, 1, -10)
    detailsScroll.Position = UDim2.fromOffset(5, 5)
    detailsScroll.BackgroundTransparency = 1
    detailsScroll.BorderSizePixel = 0
    detailsScroll.ScrollBarThickness = 4
    detailsScroll.ScrollBarImageColor3 = Color3.fromRGB(0, 255, 150)
    detailsScroll.CanvasSize = UDim2.fromOffset(0, 0)
    detailsScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
    detailsScroll.Parent = middlePanel
    
    local detailsLayout = Instance.new("UIListLayout", detailsScroll)
    detailsLayout.Padding = UDim.new(0, 5)
    detailsLayout.SortOrder = Enum.SortOrder.LayoutOrder
    
    -- Right Panel (Actions)
    local rightPanel = Instance.new("Frame")
    rightPanel.Name = "ActionsPanel"
    rightPanel.Size = UDim2.new(0.3, -10, 1, -50)
    rightPanel.Position = UDim2.new(0.7, 5, 0, 45)
    rightPanel.BackgroundColor3 = Color3.fromRGB(15, 15, 25)
    rightPanel.BorderSizePixel = 0
    rightPanel.Parent = main
    
    local rightCorner = Instance.new("UICorner", rightPanel)
    rightCorner.CornerRadius = UDim.new(0, 8)
    
    local rightStroke = Instance.new("UIStroke", rightPanel)
    rightStroke.Color = Color3.fromRGB(0, 255, 150)
    rightStroke.Thickness = 1
    rightStroke.Transparency = 0.5
    
    local actionsScroll = Instance.new("ScrollingFrame")
    actionsScroll.Name = "ActionsScroll"
    actionsScroll.Size = UDim2.new(1, -10, 1, -10)
    actionsScroll.Position = UDim2.fromOffset(5, 5)
    actionsScroll.BackgroundTransparency = 1
    actionsScroll.BorderSizePixel = 0
    actionsScroll.ScrollBarThickness = 4
    actionsScroll.ScrollBarImageColor3 = Color3.fromRGB(0, 255, 150)
    actionsScroll.CanvasSize = UDim2.fromOffset(0, 0)
    actionsScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
    actionsScroll.Parent = rightPanel
    
    local actionsLayout = Instance.new("UIListLayout", actionsScroll)
    actionsLayout.Padding = UDim.new(0, 8)
    actionsLayout.SortOrder = Enum.SortOrder.LayoutOrder
    
    -- Make draggable
    local dragging = false
    local dragInput, dragStart, startPos
    
    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = main.Position
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    
    titleBar.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            dragInput = input
        end
    end)
    
    game:GetService("UserInputService").InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            local delta = input.Position - dragStart
            main.Position = UDim2.new(
                startPos.X.Scale,
                startPos.X.Offset + delta.X,
                startPos.Y.Scale,
                startPos.Y.Offset + delta.Y
            )
        end
    end)
    
    closeBtn.MouseButton1Click:Connect(function()
        local closeTween = TweenService:Create(main, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
            Size = UDim2.fromOffset(0, 0)
        })
        closeTween:Play()
        closeTween.Completed:Wait()
        gui:Destroy()
        Modules.ModuleExplorer.State.IsOpen = false
    end)
    
    return gui, main, moduleScroll, detailsScroll, actionsScroll
end

local function ScanModules()
    local modules = {}
    local locations = {
        game:GetService("ReplicatedStorage"),
        game:GetService("ReplicatedFirst"),
        game:GetService("StarterPlayer"):WaitForChild("StarterPlayerScripts", 5)
    }
    
    for _, location in pairs(locations) do
        if location then
            for _, obj in pairs(location:GetDescendants()) do
                if obj:IsA("ModuleScript") then
                    table.insert(modules, obj)
                end
            end
        end
    end
    
    return modules
end

local function CreateModuleButton(module, parent, onClick)
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(1, 0, 0, 35)
    btn.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
    btn.BorderSizePixel = 0
    btn.Font = Enum.Font.Code
    btn.Text = "  " .. module.Name
    btn.TextColor3 = Color3.fromRGB(0, 255, 150)
    btn.TextSize = 13
    btn.TextXAlignment = Enum.TextXAlignment.Left
    btn.AutoButtonColor = false
    btn.Parent = parent
    
    local btnCorner = Instance.new("UICorner", btn)
    btnCorner.CornerRadius = UDim.new(0, 6)
    
    local btnStroke = Instance.new("UIStroke", btn)
    btnStroke.Color = Color3.fromRGB(0, 255, 150)
    btnStroke.Thickness = 1
    btnStroke.Transparency = 0.8
    
    btn.MouseButton1Click:Connect(function()
        onClick(module)
        for _, child in pairs(parent:GetChildren()) do
            if child:IsA("TextButton") then
                child.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
            end
        end
        btn.BackgroundColor3 = Color3.fromRGB(0, 150, 100)
    end)
    
    btn.MouseEnter:Connect(function()
        TweenService:Create(btnStroke, TweenInfo.new(0.2), {
            Transparency = 0.3
        }):Play()
    end)
    
    btn.MouseLeave:Connect(function()
        TweenService:Create(btnStroke, TweenInfo.new(0.2), {
            Transparency = 0.8
        }):Play()
    end)
    
    return btn
end

local function CreateLabel(text, color, parent, isBold)
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 0, 0)
    label.AutomaticSize = Enum.AutomaticSize.Y
    label.BackgroundTransparency = 1
    label.Font = isBold and Enum.Font.GothamBold or Enum.Font.Code
    label.Text = text
    label.TextColor3 = color or Color3.fromRGB(200, 200, 200)
    label.TextSize = isBold and 14 or 12
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.TextWrapped = true
    label.RichText = true
    label.Parent = parent
    
    return label
end

local function CreateActionButton(text, color, parent, onClick)
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(1, 0, 0, 35)
    btn.BackgroundColor3 = color
    btn.BorderSizePixel = 0
    btn.Font = Enum.Font.GothamBold
    btn.Text = text
    btn.TextColor3 = Color3.fromRGB(255, 255, 255)
    btn.TextSize = 12
    btn.AutoButtonColor = false
    btn.Parent = parent
    
    local btnCorner = Instance.new("UICorner", btn)
    btnCorner.CornerRadius = UDim.new(0, 6)
    
    btn.MouseButton1Click:Connect(onClick)
    
    btn.MouseEnter:Connect(function()
        local h, s, v = color:ToHSV()
        btn.BackgroundColor3 = Color3.fromHSV(h, s, math.min(v + 0.1, 1))
    end)
    
    btn.MouseLeave:Connect(function()
        btn.BackgroundColor3 = color
    end)
    
    return btn
end

local function CreateInputField(placeholder, parent)
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 0, 35)
    frame.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
    frame.BorderSizePixel = 0
    frame.Parent = parent
    
    local frameCorner = Instance.new("UICorner", frame)
    frameCorner.CornerRadius = UDim.new(0, 6)
    
    local frameStroke = Instance.new("UIStroke", frame)
    frameStroke.Color = Color3.fromRGB(0, 255, 150)
    frameStroke.Thickness = 1
    frameStroke.Transparency = 0.7
    
    local input = Instance.new("TextBox")
    input.Size = UDim2.new(1, -10, 1, 0)
    input.Position = UDim2.fromOffset(5, 0)
    input.BackgroundTransparency = 1
    input.Font = Enum.Font.Code
    input.PlaceholderText = placeholder
    input.PlaceholderColor3 = Color3.fromRGB(100, 100, 100)
    input.Text = ""
    input.TextColor3 = Color3.fromRGB(0, 255, 150)
    input.TextSize = 12
    input.TextXAlignment = Enum.TextXAlignment.Left
    input.ClearTextOnFocus = false
    input.Parent = frame
    
    input.Focused:Connect(function()
        TweenService:Create(frameStroke, TweenInfo.new(0.2), {
            Transparency = 0.3
        }):Play()
    end)
    
    input.FocusLost:Connect(function()
        TweenService:Create(frameStroke, TweenInfo.new(0.2), {
            Transparency = 0.7
        }):Play()
    end)
    
    return input
end

local function ParseValue(str)
    -- Try to parse as different types
    if str == "true" then
        return true
    elseif str == "false" then
        return false
    elseif str == "nil" then
        return nil
    elseif tonumber(str) then
        return tonumber(str)
    else
        return str
    end
end

local function GetNestedValue(tbl, path)
    local current = tbl
    for _, key in ipairs(path) do
        if type(current) == "table" then
            current = current[key]
        else
            return nil
        end
    end
    return current
end

local function SetNestedValue(tbl, path, value)
    local current = tbl
    for i = 1, #path - 1 do
        if type(current) == "table" then
            current = current[path[i]]
        else
            return false
        end
    end
    if type(current) == "table" then
        current[path[#path]] = value
        return true
    end
    return false
end

local function CreateClickableLabel(text, color, parent, isBold, onClick, path)
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(1, 0, 0, 0)
    btn.AutomaticSize = Enum.AutomaticSize.Y
    btn.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
    btn.BackgroundTransparency = 1
    btn.BorderSizePixel = 0
    btn.Font = isBold and Enum.Font.GothamBold or Enum.Font.Code
    btn.Text = text
    btn.TextColor3 = color or Color3.fromRGB(200, 200, 200)
    btn.TextSize = isBold and 14 or 12
    btn.TextXAlignment = Enum.TextXAlignment.Left
    btn.TextWrapped = true
    btn.RichText = true
    btn.AutoButtonColor = false
    btn.Parent = parent
    
    if onClick then
        btn.MouseButton1Click:Connect(function()
            onClick(path)
        end)
        
        btn.MouseEnter:Connect(function()
            btn.BackgroundTransparency = 0.9
        end)
        
        btn.MouseLeave:Connect(function()
            btn.BackgroundTransparency = 1
        end)
    end
    
    return btn
end

local function InspectValue(value, depth, maxDepth, detailsScroll, path, onSelect)
    depth = depth or 0
    maxDepth = maxDepth or 3
    path = path or {}
    
    if depth > maxDepth then
        return "..."
    end
    
    local indent = string.rep("  ", depth)
    local valueType = typeof(value)
    
    if valueType == "table" then
        CreateLabel(indent .. "{ -- Table", Color3.fromRGB(100, 200, 255), detailsScroll)
        
        for k, v in pairs(value) do
            local keyStr = tostring(k)
            local valueStr = tostring(v)
            local vType = typeof(v)
            local currentPath = {table.unpack(path)}
            table.insert(currentPath, k)
            
            if vType == "function" then
                CreateClickableLabel(
                    indent .. "  " .. keyStr .. " = <function>",
                    Color3.fromRGB(255, 150, 0),
                    detailsScroll,
                    false,
                    onSelect,
                    currentPath
                )
            elseif vType == "table" then
                CreateClickableLabel(
                    indent .. "  " .. keyStr .. " = <table>",
                    Color3.fromRGB(100, 200, 255),
                    detailsScroll,
                    false,
                    onSelect,
                    currentPath
                )
                if depth < maxDepth then
                    InspectValue(v, depth + 1, maxDepth, detailsScroll, currentPath, onSelect)
                end
            else
                CreateClickableLabel(
                    indent .. "  " .. keyStr .. " = " .. valueStr,
                    Color3.fromRGB(0, 255, 150),
                    detailsScroll,
                    false,
                    onSelect,
                    currentPath
                )
            end
        end
        
        -- Check metatable
        local mt = getmetatable(value)
        if mt then
            CreateLabel(indent .. "  __metatable = <table>", Color3.fromRGB(255, 0, 200), detailsScroll)
            if depth < maxDepth then
                local mtPath = {table.unpack(path)}
                table.insert(mtPath, "__metatable")
                InspectValue(mt, depth + 1, maxDepth, detailsScroll, mtPath, onSelect)
            end
        end
        
        CreateLabel(indent .. "}", Color3.fromRGB(100, 200, 255), detailsScroll)
    elseif valueType == "function" then
        local info = debug.getinfo(value)
        CreateLabel(indent .. "Function: " .. (info.name or "anonymous"), Color3.fromRGB(255, 150, 0), detailsScroll)
        CreateLabel(indent .. "  Parameters: " .. info.nparams, Color3.fromRGB(180, 180, 180), detailsScroll)
    else
        CreateLabel(indent .. tostring(value) .. " (" .. valueType .. ")", Color3.fromRGB(200, 200, 200), detailsScroll)
    end
end

local function DisplayActions(moduleResult, selectedPath, actionsScroll)
    -- Clear previous actions
    for _, child in pairs(actionsScroll:GetChildren()) do
        if not child:IsA("UIListLayout") then
            child:Destroy()
        end
    end
    
    CreateLabel("â•â•â• ACTIONS â•â•â•", Color3.fromRGB(0, 255, 150), actionsScroll, true)
    CreateLabel("", Color3.fromRGB(255, 255, 255), actionsScroll)
    
    if #selectedPath == 0 then
        CreateLabel("Select an item to modify", Color3.fromRGB(180, 180, 180), actionsScroll)
        return
    end
    
    local pathStr = table.concat(selectedPath, ".")
    CreateLabel("Selected: " .. pathStr, Color3.fromRGB(100, 200, 255), actionsScroll, true)
    CreateLabel("", Color3.fromRGB(255, 255, 255), actionsScroll)
    
    local value = GetNestedValue(moduleResult, selectedPath)
    local valueType = typeof(value)
    
    CreateLabel("Type: " .. valueType, Color3.fromRGB(180, 180, 180), actionsScroll)
    CreateLabel("", Color3.fromRGB(255, 255, 255), actionsScroll)
    
    -- Modify Value
    if valueType ~= "function" then
        CreateLabel("â–¸ Modify Value:", Color3.fromRGB(255, 200, 0), actionsScroll, true)
        local valueInput = CreateInputField("New value...", actionsScroll)
        
        CreateActionButton("Apply Change", Color3.fromRGB(0, 150, 255), actionsScroll, function()
            local newValue = ParseValue(valueInput.Text)
            if SetNestedValue(moduleResult, selectedPath, newValue) then
                print(string.format("âœ“ Changed %s to %s", pathStr, tostring(newValue)))
                valueInput.Text = ""
            else
                print("âœ— Failed to modify value")
            end
        end)
        
        CreateLabel("", Color3.fromRGB(255, 255, 255), actionsScroll)
    end
    
    -- Hook Function
    if valueType == "function" then
        CreateLabel("â–¸ Hook Function:", Color3.fromRGB(255, 150, 0), actionsScroll, true)
        
        CreateActionButton("Hook - Log Calls", Color3.fromRGB(255, 100, 0), actionsScroll, function()
            local originalFunc = value
            local hookKey = pathStr
            
            if Modules.ModuleExplorer.State.Hooks[hookKey] then
                print("âš  Function already hooked!")
                return
            end
            
            local hooked = function(...)
                local args = {...}
                print(string.format("ðŸ”— Hook [%s] called with %d args:", pathStr, #args))
                for i, arg in ipairs(args) do
                    print(string.format("  [%d] = %s (%s)", i, tostring(arg), typeof(arg)))
                end
                local results = {originalFunc(...)}
                print(string.format("  â†’ Returned %d values", #results))
                return table.unpack(results)
            end
            
            Modules.ModuleExplorer.State.Hooks[hookKey] = originalFunc
            SetNestedValue(moduleResult, selectedPath, hooked)
            print(string.format("âœ“ Hooked function: %s", pathStr))
        end)
        
        CreateActionButton("Hook - Block Calls", Color3.fromRGB(255, 0, 100), actionsScroll, function()
            local originalFunc = value
            local hookKey = pathStr
            
            if Modules.ModuleExplorer.State.Hooks[hookKey] then
                print("âš  Function already hooked!")
                return
            end
            
            local hooked = function(...)
                print(string.format("ðŸš« Blocked call to: %s", pathStr))
                return nil
            end
            
            Modules.ModuleExplorer.State.Hooks[hookKey] = originalFunc
            SetNestedValue(moduleResult, selectedPath, hooked)
            print(string.format("âœ“ Blocked function: %s", pathStr))
        end)
        
        -- Force True
        CreateActionButton("Hook - Force Return True", Color3.fromRGB(0, 200, 100), actionsScroll, function()
            local originalFunc = value
            local hookKey = pathStr
            
            if Modules.ModuleExplorer.State.Hooks[hookKey] then
                print("âš  Function already hooked!")
                return
            end
            
            local hooked = function(...)
                originalFunc(...)
                print(string.format("âœ“ Forced true return: %s", pathStr))
                return true
            end
            
            Modules.ModuleExplorer.State.Hooks[hookKey] = originalFunc
            SetNestedValue(moduleResult, selectedPath, hooked)
            print(string.format("âœ“ Hooked to force return true: %s", pathStr))
        end)
        
        -- Force False
        CreateActionButton("Hook - Force Return False", Color3.fromRGB(200, 50, 50), actionsScroll, function()
            local originalFunc = value
            local hookKey = pathStr
            
            if Modules.ModuleExplorer.State.Hooks[hookKey] then
                print("âš  Function already hooked!")
                return
            end
            
            local hooked = function(...)
                originalFunc(...)
                print(string.format("âœ“ Forced false return: %s", pathStr))
                return false
            end
            
            Modules.ModuleExplorer.State.Hooks[hookKey] = originalFunc
            SetNestedValue(moduleResult, selectedPath, hooked)
            print(string.format("âœ“ Hooked to force return false: %s", pathStr))
        end)
        
        -- Force Nil
        CreateActionButton("Hook - Force Return Nil", Color3.fromRGB(100, 100, 100), actionsScroll, function()
            local originalFunc = value
            local hookKey = pathStr
            
            if Modules.ModuleExplorer.State.Hooks[hookKey] then
                print("âš  Function already hooked!")
                return
            end
            
            local hooked = function(...)
                originalFunc(...)
                print(string.format("âœ“ Forced nil return: %s", pathStr))
                return nil
            end
            
            Modules.ModuleExplorer.State.Hooks[hookKey] = originalFunc
            SetNestedValue(moduleResult, selectedPath, hooked)
            print(string.format("âœ“ Hooked to force return nil: %s", pathStr))
        end)
        
        -- Custom Return Value
        CreateLabel("", Color3.fromRGB(255, 255, 255), actionsScroll)
        CreateLabel("Custom Return:", Color3.fromRGB(150, 150, 255), actionsScroll, true)
        local customReturnInput = CreateInputField("Return value...", actionsScroll)
        
        CreateActionButton("Hook - Custom Return", Color3.fromRGB(150, 0, 255), actionsScroll, function()
            local originalFunc = value
            local hookKey = pathStr
            
            if Modules.ModuleExplorer.State.Hooks[hookKey] then
                print("âš  Function already hooked!")
                return
            end
            
            local customValue = ParseValue(customReturnInput.Text)
            
            local hooked = function(...)
                originalFunc(...)
                print(string.format("âœ“ Forced custom return: %s -> %s", pathStr, tostring(customValue)))
                return customValue
            end
            
            Modules.ModuleExplorer.State.Hooks[hookKey] = originalFunc
            SetNestedValue(moduleResult, selectedPath, hooked)
            print(string.format("âœ“ Hooked to force return: %s = %s", pathStr, tostring(customValue)))
            customReturnInput.Text = ""
        end)
        
        -- Multiply Numbers
        CreateLabel("", Color3.fromRGB(255, 255, 255), actionsScroll)
        CreateLabel("Numeric Multiplier:", Color3.fromRGB(255, 200, 100), actionsScroll, true)
        local multiplierInput = CreateInputField("Multiplier (e.g., 999)...", actionsScroll)
        
        CreateActionButton("Hook - Multiply Numbers", Color3.fromRGB(255, 150, 0), actionsScroll, function()
            local originalFunc = value
            local hookKey = pathStr
            
            if Modules.ModuleExplorer.State.Hooks[hookKey] then
                print("âš  Function already hooked!")
                return
            end
            
            local multiplier = tonumber(multiplierInput.Text) or 1
            
            local hooked = function(...)
                local results = {originalFunc(...)}
                -- Modify numeric returns
                for i, result in ipairs(results) do
                    if type(result) == "number" then
                        results[i] = result * multiplier
                    end
                end
                print(string.format("âœ“ Multiplied numeric returns by %d: %s", multiplier, pathStr))
                return table.unpack(results)
            end
            
            Modules.ModuleExplorer.State.Hooks[hookKey] = originalFunc
            SetNestedValue(moduleResult, selectedPath, hooked)
            print(string.format("âœ“ Hooked with %dx multiplier: %s", multiplier, pathStr))
            multiplierInput.Text = ""
        end)
        
        if Modules.ModuleExplorer.State.Hooks[pathStr] then
            CreateLabel("", Color3.fromRGB(255, 255, 255), actionsScroll)
            CreateActionButton("Unhook Function", Color3.fromRGB(0, 200, 100), actionsScroll, function()
                local originalFunc = Modules.ModuleExplorer.State.Hooks[pathStr]
                SetNestedValue(moduleResult, selectedPath, originalFunc)
                Modules.ModuleExplorer.State.Hooks[pathStr] = nil
                print(string.format("âœ“ Unhooked function: %s", pathStr))
            end)
        end
        
        CreateLabel("", Color3.fromRGB(255, 255, 255), actionsScroll)
    end
    
    -- Ghost Index (for tables)
    if valueType == "table" then
        CreateLabel("â–¸ Ghost Index:", Color3.fromRGB(200, 0, 255), actionsScroll, true)
        CreateLabel("Add fake properties that appear to exist", Color3.fromRGB(150, 150, 150), actionsScroll)
        
        local ghostKeyInput = CreateInputField("Key name...", actionsScroll)
        local ghostValueInput = CreateInputField("Value...", actionsScroll)
        
        CreateActionButton("Add Ghost Index", Color3.fromRGB(200, 0, 255), actionsScroll, function()
            local key = ghostKeyInput.Text
            local val = ParseValue(ghostValueInput.Text)
            
            if key == "" then
                print("âœ— Please enter a key name")
                return
            end
            
            local ghostKey = pathStr .. ".__ghost__"
            if not Modules.ModuleExplorer.State.GhostIndexes[ghostKey] then
                Modules.ModuleExplorer.State.GhostIndexes[ghostKey] = {}
            end
            
            -- Set up __index metamethod
            local mt = getmetatable(value) or {}
            local oldIndex = mt.__index
            
            mt.__index = function(tbl, k)
                if Modules.ModuleExplorer.State.GhostIndexes[ghostKey][k] then
                    print(string.format("ðŸ‘» Ghost index accessed: %s.%s", pathStr, k))
                    return Modules.ModuleExplorer.State.GhostIndexes[ghostKey][k]
                end
                if type(oldIndex) == "function" then
                    return oldIndex(tbl, k)
                elseif type(oldIndex) == "table" then
                    return oldIndex[k]
                end
                return rawget(tbl, k)
            end
            
            setmetatable(value, mt)
            Modules.ModuleExplorer.State.GhostIndexes[ghostKey][key] = val
            
            print(string.format("âœ“ Added ghost index: %s.%s = %s", pathStr, key, tostring(val)))
            ghostKeyInput.Text = ""
            ghostValueInput.Text = ""
        end)
        
        CreateLabel("", Color3.fromRGB(255, 255, 255), actionsScroll)
    end
    
    -- Copy Path
    CreateActionButton("Copy Path to Clipboard", Color3.fromRGB(100, 100, 100), actionsScroll, function()
        setclipboard(pathStr)
        print(string.format("âœ“ Copied to clipboard: %s", pathStr))
    end)
end

local function DisplayModuleDetails(module, detailsScroll, actionsScroll)
    -- Clear previous details
    for _, child in pairs(detailsScroll:GetChildren()) do
        if not child:IsA("UIListLayout") then
            child:Destroy()
        end
    end
    
    CreateLabel("â•â•â• MODULE: " .. module.Name .. " â•â•â•", Color3.fromRGB(0, 255, 150), detailsScroll, true)
    CreateLabel("Path: " .. module:GetFullName(), Color3.fromRGB(180, 180, 180), detailsScroll)
    CreateLabel("", Color3.fromRGB(255, 255, 255), detailsScroll)
    
    -- Try to require the module
    local success, result = pcall(require, module)
    
    if not success then
        CreateLabel("âœ— Failed to require module:", Color3.fromRGB(255, 50, 100), detailsScroll, true)
        CreateLabel(tostring(result), Color3.fromRGB(255, 100, 100), detailsScroll)
        return
    end
    
    CreateLabel("âœ“ Module loaded successfully", Color3.fromRGB(0, 255, 100), detailsScroll, true)
    CreateLabel("", Color3.fromRGB(255, 255, 255), detailsScroll)
    
    local resultType = typeof(result)
    CreateLabel("Type: " .. resultType, Color3.fromRGB(100, 200, 255), detailsScroll, true)
    CreateLabel("", Color3.fromRGB(255, 255, 255), detailsScroll)
    
    if resultType == "table" then
        CreateLabel("â•â•â• CONTENTS â•â•â•", Color3.fromRGB(0, 255, 150), detailsScroll, true)
        CreateLabel("Click any item to modify it", Color3.fromRGB(150, 150, 150), detailsScroll)
        CreateLabel("", Color3.fromRGB(255, 255, 255), detailsScroll)
        
        -- Store module result for modifications
        Modules.ModuleExplorer.State.ModuleResult = result
        
        local function onSelect(path)
            Modules.ModuleExplorer.State.SelectedPath = path
            DisplayActions(result, path, actionsScroll)
        end
        
        InspectValue(result, 0, 2, detailsScroll, {}, onSelect)
    else
        CreateLabel("Value: " .. tostring(result), Color3.fromRGB(200, 200, 200), detailsScroll)
    end
end

RegisterCommand({
    Name = "Nodex",
    Aliases = {},
    Description = "Opens the module explorer GUI with patching, hooking, and ghost index features."
}, function(args)
    if Modules.ModuleExplorer.State.IsOpen then
        print("Module Explorer is already open.")
        return
    end
    
    print("Opening Module Explorer...")
    
    local gui, main, moduleScroll, detailsScroll, actionsScroll = CreateGUI()
    Modules.ModuleExplorer.State.GUI = gui
    Modules.ModuleExplorer.State.IsOpen = true
    
    -- Animate opening
    main.Size = UDim2.fromOffset(0, 0)
    local openTween = TweenService:Create(main, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Size = UDim2.fromOffset(1100, 650)
    })
    openTween:Play()
    
    -- Scan and populate modules
    local modules = ScanModules()
    print(string.format("Found %d modules", #modules))
    
    for i, module in pairs(modules) do
        CreateModuleButton(module, moduleScroll, function(selectedModule)
            Modules.ModuleExplorer.State.SelectedModule = selectedModule
            Modules.ModuleExplorer.State.SelectedPath = {}
            DisplayModuleDetails(selectedModule, detailsScroll, actionsScroll)
        end)
    end
    
    -- Initial actions display
    DisplayActions(nil, {}, actionsScroll)
end)

Modules.ModuleEditor = {
    State = {
        IsEnabled = false,
        UI = nil,
        CurrentTable = nil,
        TableStack = {},
        Connections = {},
        IsMinimized = false,
        IsMaximized = false,
        PreMaximizeSize = nil,
        PreMaximizePosition = nil
    },
    Theme = {
        Background = Color3.fromRGB(0, 0, 0),
        WindowGray = Color3.fromRGB(192, 192, 192),
        DarkGray = Color3.fromRGB(128, 128, 128),
        LightGray = Color3.fromRGB(223, 223, 223),
        White = Color3.fromRGB(255, 255, 255),
        Blue = Color3.fromRGB(0, 0, 128),
        Accent = Color3.fromRGB(0, 255, 0),
        Text = Color3.fromRGB(0, 0, 0),
        Font = Enum.Font.Code
    },
    Services = {
        Workspace = game:GetService("Workspace"),
        Players = game:GetService("Players"),
        ReplicatedStorage = game:GetService("ReplicatedStorage"),
        CoreGui = game:GetService("CoreGui"),
        TweenService = game:GetService("TweenService"),
        UserInputService = game:GetService("UserInputService")
    }
}
function Modules.ModuleEditor:Minimize()
    if self.State.IsMinimized then return end
    self.State.IsMinimized = true
    local mainFrame = self.State.UI:FindFirstChild("WindowFrame")
    if not mainFrame then return end
    local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local tween = self.Services.TweenService:Create(mainFrame, tweenInfo, {
        Position = UDim2.new(0.5, -mainFrame.Size.X.Offset/2, 1, 50),
        Size = UDim2.new(0, mainFrame.Size.X.Offset, 0, 30)
    })
    tween:Play()
end
function Modules.ModuleEditor:Restore()
    if not self.State.IsMinimized then return end
    self.State.IsMinimized = false
    local mainFrame = self.State.UI:FindFirstChild("WindowFrame")
    if not mainFrame then return end
    local targetSize = self.State.PreMaximizeSize or UDim2.new(0, 600, 0, 450)
    local targetPos = self.State.PreMaximizePosition or UDim2.new(0.5, -300, 0.5, -225)
    local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local tween = self.Services.TweenService:Create(mainFrame, tweenInfo, {
        Position = targetPos,
        Size = targetSize
    })
    tween:Play()
end
function Modules.ModuleEditor:Maximize()
    local mainFrame = self.State.UI:FindFirstChild("WindowFrame")
    if not mainFrame then return end
    if self.State.IsMaximized then
        self.State.IsMaximized = false
        local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = self.Services.TweenService:Create(mainFrame, tweenInfo, {
            Position = self.State.PreMaximizePosition,
            Size = self.State.PreMaximizeSize
        })
        tween:Play()
    else
        self.State.PreMaximizeSize = mainFrame.Size
        self.State.PreMaximizePosition = mainFrame.Position
        self.State.IsMaximized = true
        local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = self.Services.TweenService:Create(mainFrame, tweenInfo, {
            Position = UDim2.new(0, 0, 0, 0),
            Size = UDim2.new(1, 0, 1, 0)
        })
        tween:Play()
    end
end
function Modules.ModuleEditor:DestroyUI()
    if self.State.UI then
        self.State.UI:Destroy()
        self.State.UI = nil
    end
    self.State.TableStack = {}
    self.State.CurrentTable = nil
    self.State.IsMinimized = false
    self.State.IsMaximized = false
end
function Modules.ModuleEditor:ShowTable(tbl, tableScroll, backBtn)
    tableScroll:ClearAllChildren()
    self.State.CurrentTable = tbl
    backBtn.Visible = #self.State.TableStack > 0
    local count = 0
    for key, value in pairs(tbl) do
        if typeof(value) == "function" then
            continue
        end
        count += 1
        local isTable = typeof(value) == "table"
        local displayValue
        if isTable then
            displayValue = "[table]"
        elseif typeof(value) == "string" then
            displayValue = '"' .. value .. '"'
        else
            displayValue = tostring(value)
        end
        local keyContainer = Instance.new("Frame", tableScroll)
        keyContainer.Size = UDim2.new(0.35, -5, 0, 22)
        keyContainer.Position = UDim2.new(0, 3, 0, (count - 1) * 27)
        keyContainer.BackgroundColor3 = self.Theme.White
        keyContainer.BorderSizePixel = 0
        local function CreateWin95Border(parent, isInset)
            local topColor = isInset and self.Theme.DarkGray or self.Theme.White
            local bottomColor = isInset and self.Theme.White or self.Theme.DarkGray
            local topBorder = Instance.new("Frame", parent)
            topBorder.Size = UDim2.new(1, 0, 0, 1)
            topBorder.Position = UDim2.new(0, 0, 0, 0)
            topBorder.BackgroundColor3 = topColor
            topBorder.BorderSizePixel = 0
            topBorder.ZIndex = parent.ZIndex + 1
            local leftBorder = Instance.new("Frame", parent)
            leftBorder.Size = UDim2.new(0, 1, 1, 0)
            leftBorder.Position = UDim2.new(0, 0, 0, 0)
            leftBorder.BackgroundColor3 = topColor
            leftBorder.BorderSizePixel = 0
            leftBorder.ZIndex = parent.ZIndex + 1
            local bottomBorder = Instance.new("Frame", parent)
            bottomBorder.Size = UDim2.new(1, 0, 0, 1)
            bottomBorder.Position = UDim2.new(0, 0, 1, -1)
            bottomBorder.BackgroundColor3 = bottomColor
            bottomBorder.BorderSizePixel = 0
            bottomBorder.ZIndex = parent.ZIndex + 1
            local rightBorder = Instance.new("Frame", parent)
            rightBorder.Size = UDim2.new(0, 1, 1, 0)
            rightBorder.Position = UDim2.new(1, -1, 0, 0)
            rightBorder.BackgroundColor3 = bottomColor
            rightBorder.BorderSizePixel = 0
            rightBorder.ZIndex = parent.ZIndex + 1
        end
        CreateWin95Border(keyContainer, true)
        local keyLabel = Instance.new("TextLabel", keyContainer)
        keyLabel.Size = UDim2.new(1, -4, 1, 0)
        keyLabel.Position = UDim2.new(0, 2, 0, 0)
        keyLabel.BackgroundTransparency = 1
        keyLabel.TextColor3 = self.Theme.Text
        keyLabel.Font = self.Theme.Font
        keyLabel.TextSize = 12
        keyLabel.TextXAlignment = Enum.TextXAlignment.Left
        keyLabel.Text = tostring(key)
        if isTable then
            local hasEditable = false
            for _, v in pairs(value) do
                if typeof(v) ~= "table" and typeof(v) ~= "function" then
                    hasEditable = true
                    break
                end
            end
            local icon = hasEditable and "âœ”" or "âœ–"
            local openBtn = Instance.new("TextButton", tableScroll)
            openBtn.Size = UDim2.new(0.65, -8, 0, 22)
            openBtn.Position = UDim2.new(0.35, 5, 0, (count - 1) * 27)
            openBtn.BackgroundColor3 = self.Theme.WindowGray
            openBtn.BorderSizePixel = 0
            openBtn.TextColor3 = self.Theme.Text
            openBtn.Font = self.Theme.Font
            openBtn.TextSize = 12
            openBtn.Text = icon .. " Â» [table]"
            CreateWin95Border(openBtn, false)
            openBtn.MouseButton1Click:Connect(function()
                table.insert(self.State.TableStack, tbl)
                self:ShowTable(value, tableScroll, backBtn)
            end)
        else
            local valueBox = Instance.new("TextBox", tableScroll)
            valueBox.Size = UDim2.new(0.65, -8, 0, 22)
            valueBox.Position = UDim2.new(0.35, 5, 0, (count - 1) * 27)
            valueBox.BackgroundColor3 = self.Theme.White
            valueBox.BorderSizePixel = 0
            valueBox.TextColor3 = self.Theme.Text
            valueBox.Font = self.Theme.Font
            valueBox.TextSize = 12
            valueBox.ClearTextOnFocus = false
            valueBox.TextWrapped = false
            valueBox.TextTruncate = Enum.TextTruncate.AtEnd
            valueBox.Text = displayValue
            CreateWin95Border(valueBox, true)
            valueBox.FocusLost:Connect(function()
                local input = valueBox.Text
                local newValue
                if input:match('^".*"$') then
                    newValue = input:sub(2, -2)
                elseif input == "true" then
                    newValue = true
                elseif input == "false" then
                    newValue = false
                elseif input == "nil" then
                    newValue = nil
                else
                    newValue = tonumber(input) or input
                end
                tbl[key] = newValue
                print("[ModuleEditor] Patch Applied:", key, "=", newValue)
                DoNotif("Patched: " .. tostring(key), 2)
            end)
        end
    end
    tableScroll.CanvasSize = UDim2.new(0, 0, 0, count * 27 + 10)
end
function Modules.ModuleEditor:CreateUI()
    if self.State.UI then self.State.UI.Enabled = true return end
    local module = self
    local function CreateWin95Border(parent, isInset)
        local topColor = isInset and module.Theme.DarkGray or module.Theme.White
        local bottomColor = isInset and module.Theme.White or module.Theme.DarkGray
        local topBorder = Instance.new("Frame", parent)
        topBorder.Name = "TopBorder"
        topBorder.Size = UDim2.new(1, 0, 0, 2)
        topBorder.Position = UDim2.new(0, 0, 0, 0)
        topBorder.BackgroundColor3 = topColor
        topBorder.BorderSizePixel = 0
        topBorder.ZIndex = parent.ZIndex + 1
        local leftBorder = Instance.new("Frame", parent)
        leftBorder.Name = "LeftBorder"
        leftBorder.Size = UDim2.new(0, 2, 1, 0)
        leftBorder.Position = UDim2.new(0, 0, 0, 0)
        leftBorder.BackgroundColor3 = topColor
        leftBorder.BorderSizePixel = 0
        leftBorder.ZIndex = parent.ZIndex + 1
        local bottomBorder = Instance.new("Frame", parent)
        bottomBorder.Name = "BottomBorder"
        bottomBorder.Size = UDim2.new(1, 0, 0, 2)
        bottomBorder.Position = UDim2.new(0, 0, 1, -2)
        bottomBorder.BackgroundColor3 = bottomColor
        bottomBorder.BorderSizePixel = 0
        bottomBorder.ZIndex = parent.ZIndex + 1
        local rightBorder = Instance.new("Frame", parent)
        rightBorder.Name = "RightBorder"
        rightBorder.Size = UDim2.new(0, 2, 1, 0)
        rightBorder.Position = UDim2.new(1, -2, 0, 0)
        rightBorder.BackgroundColor3 = bottomColor
        rightBorder.BorderSizePixel = 0
        rightBorder.ZIndex = parent.ZIndex + 1
    end
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "ModuleTableEditor_Win95"
    screenGui.ResetOnSpawn = false
    screenGui.IgnoreGuiInset = true
    screenGui.Parent = self.Services.CoreGui
    self.State.UI = screenGui
    local mainFrame = Instance.new("Frame", screenGui)
    mainFrame.Name = "WindowFrame"
    mainFrame.Size = UDim2.new(0, 600, 0, 450)
    mainFrame.Position = UDim2.new(0.5, -300, 0.5, -225)
    mainFrame.BackgroundColor3 = self.Theme.WindowGray
    mainFrame.BorderSizePixel = 0
    mainFrame.Active = true
    mainFrame.ClipsDescendants = false
    CreateWin95Border(mainFrame, false)
    local titleBar = Instance.new("Frame", mainFrame)
    titleBar.Name = "TitleBar"
    titleBar.Position = UDim2.new(0, 3, 0, 3)
    titleBar.Size = UDim2.new(1, -6, 0, 22)
    titleBar.BackgroundColor3 = self.Theme.Blue
    titleBar.BorderSizePixel = 0
    titleBar.ZIndex = 2
    local titleGradient = Instance.new("UIGradient", titleBar)
    titleGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 0, 168)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(16, 132, 208))
    }
    titleGradient.Rotation = 90
    local titleLabel = Instance.new("TextLabel", titleBar)
    titleLabel.Name = "Title"
    titleLabel.Position = UDim2.new(0, 4, 0, 0)
    titleLabel.Size = UDim2.new(1, -70, 1, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Font = Enum.Font.SourceSansBold
    titleLabel.Text = "Module Table Editor - Overseer Mini"
    titleLabel.TextColor3 = self.Theme.White
    titleLabel.TextSize = 13
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.TextYAlignment = Enum.TextYAlignment.Center
    titleLabel.ZIndex = 3
    local minimizeButton = Instance.new("TextButton", titleBar)
    minimizeButton.Name = "MinimizeButton"
    minimizeButton.Position = UDim2.new(1, -54, 0, 2)
    minimizeButton.Size = UDim2.new(0, 16, 0, 16)
    minimizeButton.BackgroundColor3 = self.Theme.WindowGray
    minimizeButton.BorderSizePixel = 0
    minimizeButton.Font = Enum.Font.SourceSansBold
    minimizeButton.Text = "_"
    minimizeButton.TextColor3 = Color3.fromRGB(0, 0, 0)
    minimizeButton.TextSize = 14
    minimizeButton.TextYAlignment = Enum.TextYAlignment.Top
    minimizeButton.ZIndex = 4
    CreateWin95Border(minimizeButton, false)
    minimizeButton.MouseButton1Click:Connect(function()
        if module.State.IsMinimized then
            module:Restore()
        else
            module:Minimize()
        end
    end)
    local maximizeButton = Instance.new("TextButton", titleBar)
    maximizeButton.Name = "MaximizeButton"
    maximizeButton.Position = UDim2.new(1, -36, 0, 2)
    maximizeButton.Size = UDim2.new(0, 16, 0, 16)
    maximizeButton.BackgroundColor3 = self.Theme.WindowGray
    maximizeButton.BorderSizePixel = 0
    maximizeButton.Font = Enum.Font.SourceSansBold
    maximizeButton.Text = "â–¡"
    maximizeButton.TextColor3 = Color3.fromRGB(0, 0, 0)
    maximizeButton.TextSize = 14
    maximizeButton.ZIndex = 4
    CreateWin95Border(maximizeButton, false)
    maximizeButton.MouseButton1Click:Connect(function()
        module:Maximize()
    end)
    local closeButton = Instance.new("TextButton", titleBar)
    closeButton.Name = "CloseButton"
    closeButton.Position = UDim2.new(1, -18, 0, 2)
    closeButton.Size = UDim2.new(0, 16, 0, 16)
    closeButton.BackgroundColor3 = self.Theme.WindowGray
    closeButton.BorderSizePixel = 0
    closeButton.Font = Enum.Font.SourceSansBold
    closeButton.Text = "Ã—"
    closeButton.TextColor3 = Color3.fromRGB(0, 0, 0)
    closeButton.TextSize = 16
    closeButton.ZIndex = 4
    CreateWin95Border(closeButton, false)
    closeButton.MouseButton1Click:Connect(function()
        module:DestroyUI()
    end)
    local sidebarContainer = Instance.new("Frame", mainFrame)
    sidebarContainer.Name = "SidebarContainer"
    sidebarContainer.Size = UDim2.new(0, 180, 1, -34)
    sidebarContainer.Position = UDim2.new(0, 6, 0, 28)
    sidebarContainer.BackgroundColor3 = self.Theme.WindowGray
    sidebarContainer.BorderSizePixel = 0
    sidebarContainer.ZIndex = 1
    CreateWin95Border(sidebarContainer, true)
    local scroll = Instance.new("ScrollingFrame", sidebarContainer)
    scroll.Size = UDim2.new(1, -8, 1, -8)
    scroll.Position = UDim2.new(0, 4, 0, 4)
    scroll.CanvasSize = UDim2.new(0, 0, 5, 0)
    scroll.BackgroundTransparency = 1
    scroll.BorderSizePixel = 0
    scroll.ScrollBarThickness = 16
    scroll.ScrollBarImageColor3 = self.Theme.WindowGray
    local tableFrame = Instance.new("Frame", mainFrame)
    tableFrame.Name = "TableContainer"
    tableFrame.Position = UDim2.new(0, 192, 0, 28)
    tableFrame.Size = UDim2.new(1, -198, 1, -34)
    tableFrame.BackgroundColor3 = self.Theme.WindowGray
    tableFrame.BorderSizePixel = 0
    tableFrame.Visible = false
    tableFrame.ZIndex = 1
    CreateWin95Border(tableFrame, true)
    local backBtn = Instance.new("TextButton", tableFrame)
    backBtn.Size = UDim2.new(0, 70, 0, 22)
    backBtn.Position = UDim2.new(0, 6, 0, 6)
    backBtn.Text = "Â« Back"
    backBtn.BackgroundColor3 = self.Theme.WindowGray
    backBtn.BorderSizePixel = 0
    backBtn.TextColor3 = self.Theme.Text
    backBtn.Font = self.Theme.Font
    backBtn.TextSize = 12
    backBtn.Visible = false
    backBtn.ZIndex = 2
    CreateWin95Border(backBtn, false)
    backBtn.MouseButton1Click:Connect(function()
        if #module.State.TableStack > 0 then
            local prev = table.remove(module.State.TableStack)
            module:ShowTable(prev, tableScroll, backBtn)
        end
    end)
    local tableScroll = Instance.new("ScrollingFrame", tableFrame)
    tableScroll.Size = UDim2.new(1, -12, 1, -40)
    tableScroll.Position = UDim2.new(0, 6, 0, 32)
    tableScroll.ScrollBarThickness = 16
    tableScroll.ScrollBarImageColor3 = self.Theme.WindowGray
    tableScroll.BackgroundTransparency = 1
    tableScroll.BorderSizePixel = 0
    tableScroll.ZIndex = 2
    local yOffset = 0
    local containers = {
        ["Workspace"] = self.Services.Workspace,
        ["Players"] = self.Services.Players,
        ["ReplicatedStorage"] = self.Services.ReplicatedStorage
    }
    for serviceName, service in pairs(containers) do
        local serviceBtn = Instance.new("TextButton", scroll)
        serviceBtn.Size = UDim2.new(1, -4, 0, 24)
        serviceBtn.Position = UDim2.new(0, 2, 0, yOffset)
        serviceBtn.BackgroundColor3 = self.Theme.WindowGray
        serviceBtn.BorderSizePixel = 0
        serviceBtn.TextColor3 = self.Theme.Text
        serviceBtn.Text = "ðŸ“ " .. serviceName
        serviceBtn.Font = self.Theme.Font
        serviceBtn.TextSize = 12
        CreateWin95Border(serviceBtn, false)
        yOffset += 27
        serviceBtn.MouseButton1Click:Connect(function()
            for _, btn in ipairs(scroll:GetChildren()) do
                if btn:IsA("TextButton") and not btn.Text:find("ðŸ“") then
                    btn:Destroy()
                end
            end
            local modOffset = yOffset
            for _, obj in ipairs(service:GetDescendants()) do
                if obj:IsA("ModuleScript") then
                    local success, moduleTable = pcall(function() return require(obj) end)
                    local icon = (success and typeof(moduleTable) == "table") and "âœ”" or "âœ–"
                    local modBtn = Instance.new("TextButton", scroll)
                    modBtn.Size = UDim2.new(1, -4, 0, 24)
                    modBtn.Position = UDim2.new(0, 2, 0, modOffset)
                    modBtn.BackgroundColor3 = self.Theme.WindowGray
                    modBtn.BorderSizePixel = 0
                    modBtn.TextColor3 = self.Theme.Text
                    modBtn.Text = "  " .. icon .. " " .. obj.Name
                    modBtn.Font = self.Theme.Font
                    modBtn.TextSize = 11
                    modBtn.TextXAlignment = Enum.TextXAlignment.Left
                    CreateWin95Border(modBtn, false)
                    modOffset += 27
                    modBtn.MouseButton1Click:Connect(function()
                        if success and typeof(moduleTable) == "table" then
                            module.State.TableStack = {}
                            tableFrame.Visible = true
                            module:ShowTable(moduleTable, tableScroll, backBtn)
                        else
                            tableFrame.Visible = false
                            DoNotif("Failed to require: " .. obj.Name, 3)
                        end
                    end)
                end
            end
            scroll.CanvasSize = UDim2.fromOffset(0, modOffset + 50)
        end)
    end
    local resizeHandle = Instance.new("Frame")
    resizeHandle.Name = "ResizeHandle"
    resizeHandle.Size = UDim2.fromOffset(16, 16)
    resizeHandle.Position = UDim2.new(1, -16, 1, -16)
    resizeHandle.BackgroundColor3 = self.Theme.WindowGray
    resizeHandle.BorderSizePixel = 0
    resizeHandle.ZIndex = 10
    resizeHandle.Parent = mainFrame
    for i = 0, 2 do
        local line = Instance.new("Frame", resizeHandle)
        line.Size = UDim2.new(0, 2, 1, -4 * i)
        line.Position = UDim2.new(0, 4 + (4 * i), 0, 4 * i)
        line.BackgroundColor3 = self.Theme.DarkGray
        line.BorderSizePixel = 0
        line.Rotation = 45
    end
    local dragging, resizing = false, false
    local dragStart, resizeStart, startPos, startSize
    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = mainFrame.Position
            local conn; conn = input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                    conn:Disconnect()
                end
            end)
        end
    end)
    resizeHandle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            resizing = true
            resizeStart = input.Position
            startSize = mainFrame.Size
            local conn; conn = input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    resizing = false
                    conn:Disconnect()
                end
            end)
        end
    end)
    self.Services.UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            if dragging then
                local delta = input.Position - dragStart
                mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
            elseif resizing then
                local delta = Vector2.new(input.Position.X - resizeStart.X, input.Position.Y - resizeStart.Y)
                local newX = math.max(400, startSize.X.Offset + delta.X)
                local newY = math.max(300, startSize.Y.Offset + delta.Y)
                mainFrame.Size = UDim2.new(0, newX, 0, newY)
            end
        end
    end)
    DoNotif("Module Table Editor: INITIALIZED", 2)
end
function Modules.ModuleEditor:Initialize()
    local module = self
    RegisterCommand({
        Name = "modui",
        Aliases = {},
        Description = "Opens the Module Table Editor to live-patch constants."
    }, function()
        module:CreateUI()
    end)
end
Modules.ScriptExecutor2 = {
    State = {
        IsEnabled = false,
        UI = nil,
        IsMinimized = false,
        IsMaximized = false,
        PreMaximizeSize = nil,
        PreMaximizePosition = nil,
        SavedScripts = {},
        ScriptHistory = {},
        TaskbarButton = nil
    },
    Theme = {
        Background = Color3.fromRGB(0, 0, 0),
        WindowGray = Color3.fromRGB(192, 192, 192),
        DarkGray = Color3.fromRGB(128, 128, 128),
        LightGray = Color3.fromRGB(223, 223, 223),
        White = Color3.fromRGB(255, 255, 255),
        Blue = Color3.fromRGB(0, 0, 128),
        TitleGradientStart = Color3.fromRGB(0, 0, 168),
        TitleGradientEnd = Color3.fromRGB(16, 132, 208),
        Accent = Color3.fromRGB(0, 255, 0),
        Text = Color3.fromRGB(0, 0, 0),
        EditorBg = Color3.fromRGB(255, 255, 255),
        EditorText = Color3.fromRGB(0, 0, 0),
        Font = Enum.Font.Code,
        UIFont = Enum.Font.SourceSansBold
    },
    Config = {
        SCRIPTS_DIR = "workspace/executor_scripts",
        MIN_WIDTH = 450,
        MIN_HEIGHT = 350,
        DEFAULT_WIDTH = 700,
        DEFAULT_HEIGHT = 550
    },
    Services = {
        CoreGui = game:GetService("CoreGui"),
        TweenService = game:GetService("TweenService"),
        UserInputService = game:GetService("UserInputService")
    }
}
function Modules.ScriptExecutor2:Minimize()
    if self.State.IsMinimized then return end
    self.State.IsMinimized = true
    local mainFrame = self.State.UI:FindFirstChild("WindowFrame")
    if not mainFrame then return end
    mainFrame.Visible = false
    local taskbarBtn = Instance.new("Frame")
    taskbarBtn.Name = "TaskbarButton"
    taskbarBtn.Size = UDim2.new(0, 120, 0, 30)
    taskbarBtn.Position = UDim2.new(0, 10, 1, -40)
    taskbarBtn.BackgroundColor3 = self.Theme.WindowGray
    taskbarBtn.BorderSizePixel = 0
    taskbarBtn.ZIndex = 200
    taskbarBtn.Parent = self.State.UI
    self:CreateWin95Border(taskbarBtn, false)
    local logo = Instance.new("Frame", taskbarBtn)
    logo.Size = UDim2.new(0, 20, 0, 20)
    logo.Position = UDim2.new(0, 5, 0, 5)
    logo.BackgroundTransparency = 1
    logo.ZIndex = 201
    local colors = {
        {Color3.fromRGB(255, 0, 0), UDim2.new(0, 0, 0, 0)},
        {Color3.fromRGB(0, 255, 0), UDim2.new(0, 11, 0, 0)},
        {Color3.fromRGB(0, 0, 255), UDim2.new(0, 0, 0, 11)},
        {Color3.fromRGB(255, 255, 0), UDim2.new(0, 11, 0, 11)}
    }
    for _, colorData in ipairs(colors) do
        local square = Instance.new("Frame", logo)
        square.Size = UDim2.new(0, 8, 0, 8)
        square.Position = colorData[2]
        square.BackgroundColor3 = colorData[1]
        square.BorderSizePixel = 0
        square.ZIndex = 202
    end
    local btnText = Instance.new("TextLabel", taskbarBtn)
    btnText.Size = UDim2.new(1, -30, 1, 0)
    btnText.Position = UDim2.new(0, 28, 0, 0)
    btnText.BackgroundTransparency = 1
    btnText.Font = self.Theme.UIFont
    btnText.Text = "Script Exec..."
    btnText.TextColor3 = self.Theme.Text
    btnText.TextSize = 11
    btnText.TextXAlignment = Enum.TextXAlignment.Left
    btnText.TextTruncate = Enum.TextTruncate.AtEnd
    btnText.ZIndex = 201
    local clickBtn = Instance.new("TextButton", taskbarBtn)
    clickBtn.Size = UDim2.new(1, 0, 1, 0)
    clickBtn.BackgroundTransparency = 1
    clickBtn.Text = ""
    clickBtn.ZIndex = 202
    local module = self
    clickBtn.MouseButton1Click:Connect(function()
        module:Restore()
    end)
    clickBtn.MouseButton1Down:Connect(function()
        taskbarBtn.BackgroundColor3 = self.Theme.DarkGray
        for _, child in ipairs(taskbarBtn:GetChildren()) do
            if child.Name == "TopBorder" or child.Name == "LeftBorder" then
                child.BackgroundColor3 = self.Theme.DarkGray
            elseif child.Name == "BottomBorder" or child.Name == "RightBorder" then
                child.BackgroundColor3 = self.Theme.White
            end
        end
    end)
    clickBtn.MouseButton1Up:Connect(function()
        taskbarBtn.BackgroundColor3 = self.Theme.WindowGray
        for _, child in ipairs(taskbarBtn:GetChildren()) do
            if child.Name == "TopBorder" or child.Name == "LeftBorder" then
                child.BackgroundColor3 = self.Theme.White
            elseif child.Name == "BottomBorder" or child.Name == "RightBorder" then
                child.BackgroundColor3 = self.Theme.DarkGray
            end
        end
    end)
    self.State.TaskbarButton = taskbarBtn
end
function Modules.ScriptExecutor2:Restore()
    if not self.State.IsMinimized then return end
    self.State.IsMinimized = false
    local mainFrame = self.State.UI:FindFirstChild("WindowFrame")
    if not mainFrame then return end
    if self.State.TaskbarButton then
        self.State.TaskbarButton:Destroy()
        self.State.TaskbarButton = nil
    end
    mainFrame.Visible = true
end
function Modules.ScriptExecutor2:Maximize()
    local mainFrame = self.State.UI:FindFirstChild("WindowFrame")
    if not mainFrame then return end
    if self.State.IsMaximized then
        self.State.IsMaximized = false
        local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = self.Services.TweenService:Create(mainFrame, tweenInfo, {
            Position = self.State.PreMaximizePosition,
            Size = self.State.PreMaximizeSize
        })
        tween:Play()
    else
        self.State.PreMaximizeSize = mainFrame.Size
        self.State.PreMaximizePosition = mainFrame.Position
        self.State.IsMaximized = true
        local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = self.Services.TweenService:Create(mainFrame, tweenInfo, {
            Position = UDim2.new(0, 0, 0, 0),
            Size = UDim2.new(1, 0, 1, 0)
        })
        tween:Play()
    end
end
function Modules.ScriptExecutor2:DestroyUI()
    if self.State.TaskbarButton then
        self.State.TaskbarButton:Destroy()
        self.State.TaskbarButton = nil
    end
    if self.State.UI then
        self.State.UI:Destroy()
        self.State.UI = nil
    end
    self.State.IsMinimized = false
    self.State.IsMaximized = false
    self.State.IsEnabled = false
end
function Modules.ScriptExecutor2:Execute(scriptText)
    if not scriptText or scriptText == "" then
        DoNotif("No script to execute", 2)
        return
    end
    table.insert(self.State.ScriptHistory, 1, {
        code = scriptText,
        time = os.time()
    })
    while #self.State.ScriptHistory > 10 do
        table.remove(self.State.ScriptHistory)
    end
    local success, err = pcall(function()
        local func, loadErr = loadstring(scriptText)
        if not func then
            error(loadErr)
        end
        func()
    end)
    if success then
        DoNotif("âœ“ Script executed successfully", 2)
    else
        DoNotif("âœ— Execution failed", 3)
        warn("[ScriptExecutor] Error:", err)
    end
end
function Modules.ScriptExecutor2:SaveScript(scriptName, scriptCode)
    if not writefile or not makefolder then
        DoNotif("File system not supported", 3)
        return false
    end
    local success = pcall(function()
        if not isfolder or not isfolder(self.Config.SCRIPTS_DIR) then
            makefolder(self.Config.SCRIPTS_DIR)
        end
    end)
    if not success then
        DoNotif("Failed to create scripts folder", 3)
        return false
    end
    local filePath = self.Config.SCRIPTS_DIR .. "/" .. scriptName .. ".lua"
    success = pcall(function()
        writefile(filePath, scriptCode)
    end)
    if success then
        self.State.SavedScripts[scriptName] = {
            path = filePath,
            code = scriptCode,
            saved = os.time()
        }
        DoNotif("âœ“ Saved: " .. scriptName, 2)
        self:RefreshScriptList()
        return true
    else
        DoNotif("âœ— Save failed", 3)
        return false
    end
end
function Modules.ScriptExecutor2:DeleteScript(scriptName)
    if not delfile then
        DoNotif("File deletion not supported", 3)
        return false
    end
    local scriptData = self.State.SavedScripts[scriptName]
    if not scriptData then
        DoNotif("Script not found", 3)
        return false
    end
    local success = pcall(function()
        delfile(scriptData.path)
    end)
    if success then
        self.State.SavedScripts[scriptName] = nil
        DoNotif("âœ“ Deleted: " .. scriptName, 2)
        self:RefreshScriptList()
        return true
    else
        DoNotif("âœ— Delete failed", 3)
        return false
    end
end
function Modules.ScriptExecutor2:RefreshScriptList()
    if not self.State.UI then return end
    local windowFrame = self.State.UI:FindFirstChild("WindowFrame")
    if not windowFrame then return end
    local scriptPanel = windowFrame:FindFirstChild("ScriptPanel")
    if not scriptPanel then return end
    local listContainer = scriptPanel:FindFirstChild("ListContainer")
    if not listContainer then return end
    local scriptList = listContainer:FindFirstChild("ScriptList")
    if not scriptList then 
        warn("[ScriptExecutor] ScriptList not found!")
        return 
    end
    for _, child in ipairs(scriptList:GetChildren()) do
        if child:IsA("Frame") then
            child:Destroy()
        end
    end
    self:LoadSavedScripts()
    local scriptCount = 0
    for _ in pairs(self.State.SavedScripts) do
        scriptCount = scriptCount + 1
    end
    print("[ScriptExecutor] Found " .. scriptCount .. " scripts in SavedScripts table")
    for name, data in pairs(self.State.SavedScripts) do
        print("[ScriptExecutor] Script: " .. name)
    end
    local yOffset = 0
    local scriptBox = self.State.UI:FindFirstChild("WindowFrame"):FindFirstChild("EditorContainer"):FindFirstChild("EditorScroll"):FindFirstChild("ScriptEditor")
    for scriptName, scriptData in pairs(self.State.SavedScripts) do
        local item = Instance.new("Frame", scriptList)
        item.Name = scriptName
        item.Size = UDim2.new(1, -4, 0, 24)
        item.Position = UDim2.new(0, 2, 0, yOffset)
        item.BackgroundColor3 = self.Theme.WindowGray
        item.BorderSizePixel = 0
        item.ZIndex = 3
        self:CreateWin95Border(item, false)
        local nameLabel = Instance.new("TextLabel", item)
        nameLabel.Size = UDim2.new(1, -50, 1, 0)
        nameLabel.Position = UDim2.new(0, 4, 0, 0)
        nameLabel.BackgroundTransparency = 1
        nameLabel.Font = Enum.Font.SourceSans
        nameLabel.Text = scriptName
        nameLabel.TextColor3 = self.Theme.Text
        nameLabel.TextSize = 11
        nameLabel.TextXAlignment = Enum.TextXAlignment.Left
        nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
        nameLabel.ZIndex = 4
        local loadBtn = self:CreateWin95Button(item, {
            Name = "LoadBtn",
            Position = UDim2.new(1, -44, 0, 2),
            Size = UDim2.new(0, 20, 0, 20),
            Text = "ðŸ“‚",
            TextSize = 10,
            ZIndex = 5,
            Callback = function()
                if scriptBox then
                    scriptBox.Text = scriptData.code
                    DoNotif("âœ“ Loaded: " .. scriptName, 2)
                end
            end
        })
        local delBtn = self:CreateWin95Button(item, {
            Name = "DelBtn",
            Position = UDim2.new(1, -22, 0, 2),
            Size = UDim2.new(0, 20, 0, 20),
            Text = "Ã—",
            TextSize = 14,
            ZIndex = 5,
            Callback = function()
                self:DeleteScript(scriptName)
            end
        })
        yOffset = yOffset + 26
    end
    scriptList.CanvasSize = UDim2.new(1, 0, 0, yOffset)
end
function Modules.ScriptExecutor2:ShowSaveDialog(scriptCode)
    local module = self
    local dialogBackdrop = Instance.new("Frame")
    dialogBackdrop.Name = "SaveDialog"
    dialogBackdrop.Size = UDim2.new(1, 0, 1, 0)
    dialogBackdrop.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    dialogBackdrop.BackgroundTransparency = 0.5
    dialogBackdrop.BorderSizePixel = 0
    dialogBackdrop.ZIndex = 100
    dialogBackdrop.Parent = self.State.UI
    local dialog = Instance.new("Frame", dialogBackdrop)
    dialog.Name = "DialogWindow"
    dialog.Size = UDim2.new(0, 350, 0, 120)
    dialog.Position = UDim2.new(0.5, -175, 0.5, -60)
    dialog.BackgroundColor3 = self.Theme.WindowGray
    dialog.BorderSizePixel = 0
    dialog.ZIndex = 101
    self:CreateWin95Border(dialog, false)
    local dialogTitle = Instance.new("Frame", dialog)
    dialogTitle.Name = "TitleBar"
    dialogTitle.Position = UDim2.new(0, 3, 0, 3)
    dialogTitle.Size = UDim2.new(1, -6, 0, 20)
    dialogTitle.BackgroundColor3 = self.Theme.Blue
    dialogTitle.BorderSizePixel = 0
    dialogTitle.ZIndex = 102
    local titleGradient = Instance.new("UIGradient", dialogTitle)
    titleGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, self.Theme.TitleGradientStart),
        ColorSequenceKeypoint.new(1, self.Theme.TitleGradientEnd)
    }
    titleGradient.Rotation = 90
    local titleText = Instance.new("TextLabel", dialogTitle)
    titleText.Size = UDim2.new(1, -4, 1, 0)
    titleText.Position = UDim2.new(0, 4, 0, 0)
    titleText.BackgroundTransparency = 1
    titleText.Font = self.Theme.UIFont
    titleText.Text = "Save Script"
    titleText.TextColor3 = self.Theme.White
    titleText.TextSize = 12
    titleText.TextXAlignment = Enum.TextXAlignment.Left
    titleText.ZIndex = 103
    local label = Instance.new("TextLabel", dialog)
    label.Size = UDim2.new(1, -20, 0, 20)
    label.Position = UDim2.new(0, 10, 0, 30)
    label.BackgroundTransparency = 1
    label.Font = Enum.Font.SourceSans
    label.Text = "Script Name:"
    label.TextColor3 = self.Theme.Text
    label.TextSize = 11
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.ZIndex = 102
    local inputContainer = Instance.new("Frame", dialog)
    inputContainer.Size = UDim2.new(1, -20, 0, 22)
    inputContainer.Position = UDim2.new(0, 10, 0, 52)
    inputContainer.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    inputContainer.BorderSizePixel = 0
    inputContainer.ZIndex = 102
    self:CreateWin95Border(inputContainer, true)
    local textInput = Instance.new("TextBox", inputContainer)
    textInput.Size = UDim2.new(1, -8, 1, -4)
    textInput.Position = UDim2.new(0, 4, 0, 2)
    textInput.BackgroundTransparency = 1
    textInput.Font = Enum.Font.SourceSans
    textInput.Text = "MyScript"
    textInput.TextColor3 = self.Theme.Text
    textInput.TextSize = 11
    textInput.TextXAlignment = Enum.TextXAlignment.Left
    textInput.ClearTextOnFocus = false
    textInput.ZIndex = 103
    local saveBtn = self:CreateWin95Button(dialog, {
        Name = "SaveBtn",
        Position = UDim2.new(0.5, -90, 1, -32),
        Size = UDim2.new(0, 80, 0, 24),
        Text = "Save",
        TextSize = 11,
        ZIndex = 102,
        Callback = function()
            local scriptName = textInput.Text:gsub("%.lua$", "")
            if scriptName and scriptName ~= "" then
                module:SaveScript(scriptName, scriptCode)
                dialogBackdrop:Destroy()
            else
                DoNotif("Please enter a valid name", 2)
            end
        end
    })
    local cancelBtn = self:CreateWin95Button(dialog, {
        Name = "CancelBtn",
        Position = UDim2.new(0.5, 10, 1, -32),
        Size = UDim2.new(0, 80, 0, 24),
        Text = "Cancel",
        TextSize = 11,
        ZIndex = 102,
        Callback = function()
            dialogBackdrop:Destroy()
        end
    })
    textInput:CaptureFocus()
    textInput.SelectionStart = 1
    textInput.CursorPosition = #textInput.Text + 1
    textInput.FocusLost:Connect(function(enterPressed)
        if enterPressed then
            saveBtn.MouseButton1Click:Fire()
        end
    end)
end
function Modules.ScriptExecutor2:LoadSavedScripts()
    if not listfiles or not isfolder then 
        print("[ScriptExecutor] listfiles or isfolder not available")
        return 0 
    end
    local success, files = pcall(function()
        if not isfolder(self.Config.SCRIPTS_DIR) then
            print("[ScriptExecutor] Scripts directory doesn't exist: " .. self.Config.SCRIPTS_DIR)
            return {}
        end
        return listfiles(self.Config.SCRIPTS_DIR)
    end)
    if not success or not files then 
        print("[ScriptExecutor] Failed to list files or no files found")
        return 0 
    end
    print("[ScriptExecutor] Found " .. #files .. " files in directory")
    local count = 0
    for _, filePath in ipairs(files) do
        print("[ScriptExecutor] Checking file: " .. filePath)
        if filePath:lower():match("%.lua$") then
            local loadSuccess, content = pcall(function()
                return readfile(filePath)
            end)
            if loadSuccess and content then
                local scriptName = filePath:match("([^/\\]+)%.lua$") or filePath:match("([^/\\]+)$")
                print("[ScriptExecutor] Loaded script: " .. scriptName)
                self.State.SavedScripts[scriptName] = {
                    path = filePath,
                    code = content,
                    saved = os.time()
                }
                count = count + 1
            else
                print("[ScriptExecutor] Failed to read file: " .. filePath)
            end
        end
    end
    print("[ScriptExecutor] Total scripts loaded: " .. count)
    return count
end
function Modules.ScriptExecutor2:CreateWin95Border(parent, isInset)
    local topColor = isInset and self.Theme.DarkGray or self.Theme.White
    local bottomColor = isInset and self.Theme.White or self.Theme.DarkGray
    local topBorder = Instance.new("Frame", parent)
    topBorder.Name = "TopBorder"
    topBorder.Size = UDim2.new(1, 0, 0, 2)
    topBorder.Position = UDim2.new(0, 0, 0, 0)
    topBorder.BackgroundColor3 = topColor
    topBorder.BorderSizePixel = 0
    topBorder.ZIndex = parent.ZIndex + 1
    local leftBorder = Instance.new("Frame", parent)
    leftBorder.Name = "LeftBorder"
    leftBorder.Size = UDim2.new(0, 2, 1, 0)
    leftBorder.Position = UDim2.new(0, 0, 0, 0)
    leftBorder.BackgroundColor3 = topColor
    leftBorder.BorderSizePixel = 0
    leftBorder.ZIndex = parent.ZIndex + 1
    local bottomBorder = Instance.new("Frame", parent)
    bottomBorder.Name = "BottomBorder"
    bottomBorder.Size = UDim2.new(1, 0, 0, 2)
    bottomBorder.Position = UDim2.new(0, 0, 1, -2)
    bottomBorder.BackgroundColor3 = bottomColor
    bottomBorder.BorderSizePixel = 0
    bottomBorder.ZIndex = parent.ZIndex + 1
    local rightBorder = Instance.new("Frame", parent)
    rightBorder.Name = "RightBorder"
    rightBorder.Size = UDim2.new(0, 2, 1, 0)
    rightBorder.Position = UDim2.new(1, -2, 0, 0)
    rightBorder.BackgroundColor3 = bottomColor
    rightBorder.BorderSizePixel = 0
    rightBorder.ZIndex = parent.ZIndex + 1
end
function Modules.ScriptExecutor2:CreateWin95Button(parent, props)
    local button = Instance.new("TextButton", parent)
    button.Name = props.Name or "Button"
    button.Position = props.Position
    button.Size = props.Size
    button.BackgroundColor3 = self.Theme.WindowGray
    button.BorderSizePixel = 0
    button.Font = self.Theme.UIFont
    button.Text = props.Text or ""
    button.TextColor3 = self.Theme.Text
    button.TextSize = props.TextSize or 12
    button.ZIndex = props.ZIndex or 2
    self:CreateWin95Border(button, false)
    button.MouseButton1Down:Connect(function()
        button.BackgroundColor3 = self.Theme.DarkGray
        for _, child in ipairs(button:GetChildren()) do
            if child.Name == "TopBorder" or child.Name == "LeftBorder" then
                child.BackgroundColor3 = self.Theme.DarkGray
            elseif child.Name == "BottomBorder" or child.Name == "RightBorder" then
                child.BackgroundColor3 = self.Theme.White
            end
        end
    end)
    button.MouseButton1Up:Connect(function()
        button.BackgroundColor3 = self.Theme.WindowGray
        for _, child in ipairs(button:GetChildren()) do
            if child.Name == "TopBorder" or child.Name == "LeftBorder" then
                child.BackgroundColor3 = self.Theme.White
            elseif child.Name == "BottomBorder" or child.Name == "RightBorder" then
                child.BackgroundColor3 = self.Theme.DarkGray
            end
        end
    end)
    button.MouseLeave:Connect(function()
        button.BackgroundColor3 = self.Theme.WindowGray
        for _, child in ipairs(button:GetChildren()) do
            if child.Name == "TopBorder" or child.Name == "LeftBorder" then
                child.BackgroundColor3 = self.Theme.White
            elseif child.Name == "BottomBorder" or child.Name == "RightBorder" then
                child.BackgroundColor3 = self.Theme.DarkGray
            end
        end
    end)
    if props.Callback then
        button.MouseButton1Click:Connect(props.Callback)
    end
    return button
end
function Modules.ScriptExecutor2:CreateMenuBar(parent, scriptBox)
    local menuBar = Instance.new("Frame", parent)
    menuBar.Name = "MenuBar"
    menuBar.Position = UDim2.new(0, 3, 0, 28)
    menuBar.Size = UDim2.new(1, -6, 0, 20)
    menuBar.BackgroundColor3 = self.Theme.WindowGray
    menuBar.BorderSizePixel = 0
    menuBar.ZIndex = 2
    self:CreateWin95Border(menuBar, false)
    local fileMenu = self:CreateWin95Button(menuBar, {
        Name = "FileMenu",
        Position = UDim2.new(0, 4, 0, 2),
        Size = UDim2.new(0, 60, 0, 16),
        Text = "File",
        TextSize = 11,
        ZIndex = 3
    })
    local scriptsMenu = self:CreateWin95Button(menuBar, {
        Name = "ScriptsMenu",
        Position = UDim2.new(0, 68, 0, 2),
        Size = UDim2.new(0, 60, 0, 16),
        Text = "Scripts",
        TextSize = 11,
        ZIndex = 3
    })
    local helpMenu = self:CreateWin95Button(menuBar, {
        Name = "HelpMenu",
        Position = UDim2.new(0, 132, 0, 2),
        Size = UDim2.new(0, 60, 0, 16),
        Text = "Help",
        TextSize = 11,
        ZIndex = 3,
        Callback = function()
            DoNotif("Script Executor v1.0 - Windows 95 Edition", 3)
        end
    })
    return menuBar
end
function Modules.ScriptExecutor2:UpdateLineNumbers(scriptBox, lineNumText)
    local lineCount = select(2, scriptBox.Text:gsub("\n", "\n")) + 1
    local numbers = {}
    for i = 1, math.min(lineCount, 1000) do
        table.insert(numbers, tostring(i))
    end
    lineNumText.Text = table.concat(numbers, "\n")
end
function Modules.ScriptExecutor2:CreateUI()
    if self.State.UI then 
        self.State.UI.Enabled = true 
        return 
    end
    local module = self
    self:LoadSavedScripts()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "ScriptExecutor_Win95"
    screenGui.ResetOnSpawn = false
    screenGui.IgnoreGuiInset = true
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.Parent = self.Services.CoreGui
    self.State.UI = screenGui
    local mainFrame = Instance.new("Frame", screenGui)
    mainFrame.Name = "WindowFrame"
    mainFrame.Size = UDim2.new(0, self.Config.DEFAULT_WIDTH, 0, self.Config.DEFAULT_HEIGHT)
    mainFrame.Position = UDim2.new(0.5, -self.Config.DEFAULT_WIDTH/2, 0.5, -self.Config.DEFAULT_HEIGHT/2)
    mainFrame.BackgroundColor3 = self.Theme.WindowGray
    mainFrame.BorderSizePixel = 0
    mainFrame.Active = true
    mainFrame.ClipsDescendants = false
    mainFrame.ZIndex = 1
    self:CreateWin95Border(mainFrame, false)
    local titleBar = Instance.new("Frame", mainFrame)
    titleBar.Name = "TitleBar"
    titleBar.Position = UDim2.new(0, 3, 0, 3)
    titleBar.Size = UDim2.new(1, -6, 0, 22)
    titleBar.BackgroundColor3 = self.Theme.Blue
    titleBar.BorderSizePixel = 0
    titleBar.Active = true
    titleBar.ZIndex = 2
    local titleGradient = Instance.new("UIGradient", titleBar)
    titleGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, self.Theme.TitleGradientStart),
        ColorSequenceKeypoint.new(1, self.Theme.TitleGradientEnd)
    }
    titleGradient.Rotation = 90
    local icon = Instance.new("Frame", titleBar)
    icon.Size = UDim2.new(0, 16, 0, 16)
    icon.Position = UDim2.new(0, 4, 0, 3)
    icon.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    icon.BorderSizePixel = 0
    icon.ZIndex = 3
    local iconText = Instance.new("TextLabel", icon)
    iconText.Size = UDim2.new(1, 0, 1, 0)
    iconText.BackgroundTransparency = 1
    iconText.Text = "âš¡"
    iconText.TextColor3 = Color3.fromRGB(255, 165, 0)
    iconText.Font = Enum.Font.SourceSansBold
    iconText.TextSize = 14
    iconText.ZIndex = 4
    local titleLabel = Instance.new("TextLabel", titleBar)
    titleLabel.Name = "Title"
    titleLabel.Position = UDim2.new(0, 24, 0, 0)
    titleLabel.Size = UDim2.new(1, -90, 1, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Font = self.Theme.UIFont
    titleLabel.Text = "Script Executor - Windows 95 Edition"
    titleLabel.TextColor3 = self.Theme.White
    titleLabel.TextSize = 13
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.TextYAlignment = Enum.TextYAlignment.Center
    titleLabel.ZIndex = 3
    local minimizeButton = self:CreateWin95Button(titleBar, {
        Name = "MinimizeButton",
        Position = UDim2.new(1, -60, 0, 2),
        Size = UDim2.new(0, 18, 0, 18),
        Text = "_",
        TextSize = 14,
        ZIndex = 4,
        Callback = function()
            if module.State.IsMinimized then
                module:Restore()
            else
                module:Minimize()
            end
        end
    })
    minimizeButton.TextYAlignment = Enum.TextYAlignment.Top
    local maximizeButton = self:CreateWin95Button(titleBar, {
        Name = "MaximizeButton",
        Position = UDim2.new(1, -40, 0, 2),
        Size = UDim2.new(0, 18, 0, 18),
        Text = "â–¡",
        TextSize = 14,
        ZIndex = 4,
        Callback = function()
            module:Maximize()
        end
    })
    local closeButton = self:CreateWin95Button(titleBar, {
        Name = "CloseButton",
        Position = UDim2.new(1, -20, 0, 2),
        Size = UDim2.new(0, 18, 0, 18),
        Text = "Ã—",
        TextSize = 16,
        ZIndex = 4,
        Callback = function()
            module:DestroyUI()
        end
    })
    local scriptPanel = Instance.new("Frame", mainFrame)
    scriptPanel.Name = "ScriptPanel"
    scriptPanel.Position = UDim2.new(0, 8, 0, 52)
    scriptPanel.Size = UDim2.new(0, 150, 1, -96)
    scriptPanel.BackgroundColor3 = self.Theme.WindowGray
    scriptPanel.BorderSizePixel = 0
    scriptPanel.ZIndex = 1
    self:CreateWin95Border(scriptPanel, false)
    local panelTitle = Instance.new("Frame", scriptPanel)
    panelTitle.Size = UDim2.new(1, -4, 0, 20)
    panelTitle.Position = UDim2.new(0, 2, 0, 2)
    panelTitle.BackgroundColor3 = self.Theme.Blue
    panelTitle.BorderSizePixel = 0
    panelTitle.ZIndex = 2
    local panelTitleText = Instance.new("TextLabel", panelTitle)
    panelTitleText.Size = UDim2.new(1, -4, 1, 0)
    panelTitleText.Position = UDim2.new(0, 2, 0, 0)
    panelTitleText.BackgroundTransparency = 1
    panelTitleText.Font = self.Theme.UIFont
    panelTitleText.Text = "Saved Scripts"
    panelTitleText.TextColor3 = self.Theme.White
    panelTitleText.TextSize = 11
    panelTitleText.TextXAlignment = Enum.TextXAlignment.Left
    panelTitleText.ZIndex = 3
    local scriptListContainer = Instance.new("Frame", scriptPanel)
    scriptListContainer.Name = "ListContainer"
    scriptListContainer.Size = UDim2.new(1, -8, 1, -30)
    scriptListContainer.Position = UDim2.new(0, 4, 0, 24)
    scriptListContainer.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    scriptListContainer.BorderSizePixel = 0
    scriptListContainer.ClipsDescendants = true
    scriptListContainer.ZIndex = 2
    self:CreateWin95Border(scriptListContainer, true)
    local scriptList = Instance.new("ScrollingFrame", scriptListContainer)
    scriptList.Name = "ScriptList"
    scriptList.Size = UDim2.new(1, -4, 1, -4)
    scriptList.Position = UDim2.new(0, 2, 0, 2)
    scriptList.BackgroundTransparency = 1
    scriptList.BorderSizePixel = 0
    scriptList.ScrollBarThickness = 6
    scriptList.CanvasSize = UDim2.new(1, 0, 0, 0)
    scriptList.ScrollBarImageColor3 = self.Theme.WindowGray
    scriptList.ZIndex = 3
    local editorContainer = Instance.new("Frame", mainFrame)
    editorContainer.Name = "EditorContainer"
    editorContainer.Position = UDim2.new(0, 164, 0, 52)
    editorContainer.Size = UDim2.new(1, -172, 1, -96)
    editorContainer.BackgroundColor3 = self.Theme.EditorBg
    editorContainer.BorderSizePixel = 0
    editorContainer.ClipsDescendants = true
    editorContainer.ZIndex = 1
    self:CreateWin95Border(editorContainer, true)
    local lineNumbers = Instance.new("Frame", editorContainer)
    lineNumbers.Name = "LineNumbers"
    lineNumbers.Size = UDim2.new(0, 40, 1, -4)
    lineNumbers.Position = UDim2.new(0, 2, 0, 2)
    lineNumbers.BackgroundColor3 = Color3.fromRGB(240, 240, 240)
    lineNumbers.BorderSizePixel = 0
    lineNumbers.ClipsDescendants = true
    lineNumbers.ZIndex = 2
    local lineNumScroll = Instance.new("ScrollingFrame", lineNumbers)
    lineNumScroll.Name = "LineNumScroll"
    lineNumScroll.Size = UDim2.new(1, 0, 1, 0)
    lineNumScroll.Position = UDim2.new(0, 0, 0, 0)
    lineNumScroll.BackgroundTransparency = 1
    lineNumScroll.BorderSizePixel = 0
    lineNumScroll.ScrollBarThickness = 0
    lineNumScroll.ScrollingEnabled = false
    lineNumScroll.CanvasSize = UDim2.new(1, 0, 1, 0)
    lineNumScroll.ZIndex = 3
    local lineNumText = Instance.new("TextLabel", lineNumScroll)
    lineNumText.Name = "LineNumText"
    lineNumText.Size = UDim2.new(1, -4, 1, 0)
    lineNumText.Position = UDim2.new(0, 0, 0, 4)
    lineNumText.BackgroundTransparency = 1
    lineNumText.Font = self.Theme.Font
    lineNumText.TextSize = 12
    lineNumText.TextColor3 = Color3.fromRGB(128, 128, 128)
    lineNumText.TextXAlignment = Enum.TextXAlignment.Right
    lineNumText.TextYAlignment = Enum.TextYAlignment.Top
    lineNumText.Text = "1"
    lineNumText.ZIndex = 4
    local numPadding = Instance.new("UIPadding", lineNumText)
    numPadding.PaddingRight = UDim.new(0, 4)
    local editorScroll = Instance.new("ScrollingFrame", editorContainer)
    editorScroll.Name = "EditorScroll"
    editorScroll.Size = UDim2.new(1, -48, 1, -8)
    editorScroll.Position = UDim2.new(0, 44, 0, 4)
    editorScroll.BackgroundTransparency = 1
    editorScroll.BorderSizePixel = 0
    editorScroll.ScrollBarThickness = 8
    editorScroll.CanvasSize = UDim2.new(1, 0, 1, 0)
    editorScroll.ScrollingDirection = Enum.ScrollingDirection.XY
    editorScroll.ElasticBehavior = Enum.ElasticBehavior.Never
    editorScroll.ZIndex = 2
    editorScroll.ScrollBarImageColor3 = self.Theme.WindowGray
    editorScroll.ScrollBarImageTransparency = 0
    local scriptBox = Instance.new("TextBox", editorScroll)
    scriptBox.Name = "ScriptEditor"
    scriptBox.Size = UDim2.new(1, 0, 1, 0)
    scriptBox.Position = UDim2.new(0, 0, 0, 0)
    scriptBox.BackgroundTransparency = 1
    scriptBox.Font = self.Theme.Font
    scriptBox.TextSize = 12
    scriptBox.TextColor3 = self.Theme.EditorText
    scriptBox.TextXAlignment = Enum.TextXAlignment.Left
    scriptBox.TextYAlignment = Enum.TextYAlignment.Top
    scriptBox.ClearTextOnFocus = false
    scriptBox.MultiLine = true
    scriptBox.Text = "-- Windows 95 Script Executor\n-- Enter your Lua script here\n\nprint('Hello from the 90s!')\nDoNotif('Script loaded!', 2)"
    scriptBox.TextWrapped = false
    scriptBox.ZIndex = 3
    local function updateCanvasSize()
        local textSize = game:GetService("TextService"):GetTextSize(
            scriptBox.Text,
            scriptBox.TextSize,
            scriptBox.Font,
            Vector2.new(math.huge, math.huge)
        )
        local canvasWidth = math.max(textSize.X + 20, editorScroll.AbsoluteSize.X)
        local canvasHeight = math.max(textSize.Y + 20, editorScroll.AbsoluteSize.Y)
        editorScroll.CanvasSize = UDim2.new(0, canvasWidth, 0, canvasHeight)
        scriptBox.Size = UDim2.new(0, canvasWidth, 0, canvasHeight)
        lineNumScroll.CanvasSize = UDim2.new(1, 0, 0, canvasHeight)
        lineNumText.Size = UDim2.new(1, -4, 0, canvasHeight)
        module:UpdateLineNumbers(scriptBox, lineNumText)
    end
    scriptBox:GetPropertyChangedSignal("Text"):Connect(updateCanvasSize)
    editorScroll:GetPropertyChangedSignal("CanvasPosition"):Connect(function()
        lineNumScroll.CanvasPosition = Vector2.new(0, editorScroll.CanvasPosition.Y)
    end)
    updateCanvasSize()
    local menuBar = self:CreateMenuBar(mainFrame, scriptBox)
    local statusBar = Instance.new("Frame", mainFrame)
    statusBar.Name = "StatusBar"
    statusBar.Position = UDim2.new(0, 164, 1, -24)
    statusBar.Size = UDim2.new(1, -167, 0, 21)
    statusBar.BackgroundColor3 = self.Theme.WindowGray
    statusBar.BorderSizePixel = 0
    statusBar.ZIndex = 1
    self:CreateWin95Border(statusBar, true)
    local statusText = Instance.new("TextLabel", statusBar)
    statusText.Name = "StatusText"
    statusText.Size = UDim2.new(1, -8, 1, -4)
    statusText.Position = UDim2.new(0, 4, 0, 2)
    statusText.BackgroundTransparency = 1
    statusText.Font = Enum.Font.SourceSans
    statusText.Text = "Ready"
    statusText.TextColor3 = self.Theme.Text
    statusText.TextSize = 11
    statusText.TextXAlignment = Enum.TextXAlignment.Left
    statusText.ZIndex = 2
    local buttonBar = Instance.new("Frame", mainFrame)
    buttonBar.Name = "ButtonBar"
    buttonBar.Position = UDim2.new(0, 164, 1, -61)
    buttonBar.Size = UDim2.new(1, -172, 0, 32)
    buttonBar.BackgroundColor3 = self.Theme.WindowGray
    buttonBar.BorderSizePixel = 0
    buttonBar.ZIndex = 1
    self:CreateWin95Border(buttonBar, true)
    local executeBtn = self:CreateWin95Button(buttonBar, {
        Name = "ExecuteButton",
        Position = UDim2.new(0, 6, 0, 6),
        Size = UDim2.new(0, 90, 0, 20),
        Text = "â–¶ Execute",
        TextSize = 11,
        ZIndex = 2,
        Callback = function()
            statusText.Text = "Executing script..."
            task.wait(0.1)
            module:Execute(scriptBox.Text)
            statusText.Text = "Ready"
        end
    })
    local clearBtn = self:CreateWin95Button(buttonBar, {
        Name = "ClearButton",
        Position = UDim2.new(0, 102, 0, 6),
        Size = UDim2.new(0, 80, 0, 20),
        Text = "ðŸ—‘ Clear",
        TextSize = 11,
        ZIndex = 2,
        Callback = function()
            scriptBox.Text = ""
            DoNotif("Editor cleared", 2)
            statusText.Text = "Editor cleared"
        end
    })
    local copyBtn = self:CreateWin95Button(buttonBar, {
        Name = "CopyButton",
        Position = UDim2.new(0, 188, 0, 6),
        Size = UDim2.new(0, 80, 0, 20),
        Text = "ðŸ“‹ Copy",
        TextSize = 11,
        ZIndex = 2,
        Callback = function()
            if setclipboard then
                setclipboard(scriptBox.Text)
                DoNotif("Copied to clipboard", 2)
                statusText.Text = "Copied to clipboard"
            else
                DoNotif("Clipboard not supported", 2)
                statusText.Text = "Clipboard not available"
            end
        end
    })
    local pasteBtn = self:CreateWin95Button(buttonBar, {
        Name = "PasteButton",
        Position = UDim2.new(0, 274, 0, 6),
        Size = UDim2.new(0, 80, 0, 20),
        Text = "ðŸ“„ Paste",
        TextSize = 11,
        ZIndex = 2,
        Callback = function()
            if getclipboard then
                scriptBox.Text = getclipboard()
                DoNotif("Pasted from clipboard", 2)
                statusText.Text = "Pasted from clipboard"
            else
                DoNotif("Clipboard not supported", 2)
                statusText.Text = "Clipboard not available"
            end
        end
    })
    local saveBtn = self:CreateWin95Button(buttonBar, {
        Name = "SaveButton",
        Position = UDim2.new(0, 360, 0, 6),
        Size = UDim2.new(0, 80, 0, 20),
        Text = "ðŸ’¾ Save",
        TextSize = 11,
        ZIndex = 2,
        Callback = function()
            module:ShowSaveDialog(scriptBox.Text)
        end
    })
    local resizeHandle = Instance.new("Frame")
    resizeHandle.Name = "ResizeHandle"
    resizeHandle.Size = UDim2.fromOffset(16, 16)
    resizeHandle.Position = UDim2.new(1, -16, 1, -16)
    resizeHandle.BackgroundColor3 = self.Theme.WindowGray
    resizeHandle.BorderSizePixel = 0
    resizeHandle.ZIndex = 10
    resizeHandle.Parent = mainFrame
    for i = 0, 2 do
        local line = Instance.new("Frame", resizeHandle)
        line.Size = UDim2.new(0, 2, 1, -4 * i)
        line.Position = UDim2.new(0, 4 + (4 * i), 0, 4 * i)
        line.BackgroundColor3 = self.Theme.DarkGray
        line.BorderSizePixel = 0
        line.Rotation = 45
        line.ZIndex = 11
    end
    local dragging, resizing = false, false
    local dragStart, resizeStart, startPos, startSize
    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 and not module.State.IsMaximized then
            dragging = true
            dragStart = input.Position
            startPos = mainFrame.Position
            local conn; conn = input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                    conn:Disconnect()
                end
            end)
        end
    end)
    local lastClick = 0
    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            local now = tick()
            if now - lastClick < 0.3 then
                module:Maximize()
            end
            lastClick = now
        end
    end)
    resizeHandle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 and not module.State.IsMaximized then
            resizing = true
            resizeStart = input.Position
            startSize = mainFrame.Size
            startPos = mainFrame.Position
            local conn; conn = input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    resizing = false
                    conn:Disconnect()
                end
            end)
        end
    end)
    self.Services.UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            if dragging then
                local delta = input.Position - dragStart
                mainFrame.Position = UDim2.new(
                    startPos.X.Scale, 
                    startPos.X.Offset + delta.X, 
                    startPos.Y.Scale, 
                    startPos.Y.Offset + delta.Y
                )
            elseif resizing then
                local delta = Vector2.new(
                    input.Position.X - resizeStart.X, 
                    input.Position.Y - resizeStart.Y
                )
                local newWidth = math.max(module.Config.MIN_WIDTH, startSize.X.Offset + delta.X)
                local newHeight = math.max(module.Config.MIN_HEIGHT, startSize.Y.Offset + delta.Y)
                mainFrame.Size = UDim2.new(0, newWidth, 0, newHeight)
            end
        end
    end)
    self.State.IsEnabled = true
    statusText.Text = "Script Executor loaded - Ready"
    DoNotif("âš¡ Script Executor opened", 2)
    self:RefreshScriptList()
end
function Modules.ScriptExecutor2:Toggle()
    if self.State.IsEnabled then
        self:DestroyUI()
        DoNotif("Script Executor closed", 2)
    else
        self:CreateUI()
    end
end
function Modules.ScriptExecutor2:Initialize()
    local module = self
    RegisterCommand({
        Name = "fastexec",
        Aliases = {"quickexec", "exec95"},
        Description = "Opens the Windows 95 style script executor"
    }, function()
        module:Toggle()
    end)
    print("[ScriptExecutor] Windows 95 Edition initialized")
end
Modules.CreepSequence = {
    State = {
        IsExecuting = false
    },
    Dependencies = {"TweenService", "RunService", "Players",},
    Services = {}
}
function Modules.CreepSequence:Execute(targetName)
    if self.State.IsExecuting then return end
    local target = Utilities.findPlayer(targetName)
    if not target then
        return DoNotif("Creep: Target not found.", 3)
    end
    local lp = self.Services.Players.LocalPlayer
    local char = lp.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    local tChar = target.Character
    local tRoot = tChar and tChar:FindFirstChild("HumanoidRootPart")
    if not root or not tRoot then
        return DoNotif("Creep: Character parts missing.", 3)
    end
    self.State.IsExecuting = true
    DoNotif("Executing creep sequence on " .. target.Name, 1.5)
    root.CFrame = tRoot.CFrame * CFrame.new(0, -10, 4)
    task.wait()
    local noclipConn
    noclipConn = self.Services.RunService.Stepped:Connect(function()
        if not char or not self.State.IsExecuting then
            noclipConn:Disconnect()
            return
        end
        for _, part in ipairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end)
    root.Anchored = true
    task.wait()
    local tweenInfo = TweenInfo.new(1000, Enum.EasingStyle.Linear)
    local risingTween = self.Services.TweenService:Create(root, tweenInfo, {
        CFrame = CFrame.new(root.Position.X, 10000, root.Position.Z)
    })
    risingTween:Play()
    task.wait(1.5)
    risingTween:Pause()
    root.Anchored = false
    self.State.IsExecuting = false
    risingTween:Destroy()
    DoNotif("Sequence Complete.", 1)
end
function Modules.CreepSequence:Initialize()
    local module = self
    for _, serviceName in ipairs(module.Dependencies) do
        module.Services[serviceName] = game:GetService(serviceName)
    end
    RegisterCommand({
        Name = "creep",
        Aliases = {},
        Description = "Teleports you behind/under a player and rises through the floor."
    }, function(args)
        if #args == 0 then
            return DoNotif("Usage: ;creep <PlayerName>", 3)
        end
        module:Execute(args[1])
    end)
end
Modules.NextGenDesync = {
    State = {
        IsEnabled = false
    }
}
function Modules.NextGenDesync:Toggle()
    if type(setfflag) ~= "function" then
        return DoNotif("Architect Error: Executor does not support 'setfflag'.", 3)
    end
    if not self.State.IsEnabled then
        local success, err = pcall(function()
            setfflag("NextGenReplicatorEnabledWrite4", "false")
            setfflag("NextGenReplicatorEnabledWrite4", "true")
        end)
        if success then
            self.State.IsEnabled = true
            DoNotif("NextGen Desync: ENABLED. Replicator authority hijacked.", 4)
        else
            warn("--> [NextGenDesync] Enable Failed:", err)
            DoNotif("FFlag Error: Check F9 for details.", 4)
        end
    else
        local success, err = pcall(function()
            setfflag("NextGenReplicatorEnabledWrite4", "true")
            setfflag("NextGenReplicatorEnabledWrite4", "false")
        end)
        if success then
            self.State.IsEnabled = false
            DoNotif("NextGen Desync: DISABLED. Re-synced with server.", 3)
        else
            warn("--> [NextGenDesync] Disable Failed:", err)
            DoNotif("FFlag Error: Check F9 for details.", 4)
        end
    end
end
function Modules.NextGenDesync:Initialize()
    local module = self
    RegisterCommand({
        Name = "newsync",
        Aliases = {},
        Description = "New method for desync WIP"
    }, function()
        module:Toggle()
    end)
end
Modules.MirrorMimic = {
    State = {
        IsEnabled = false,
        TargetPlayer = nil,
        Delay = 0,
        UID = 0,
        AnimatePrevDisabled = nil,
        PrevAutoRotate = true,
        PoseQueue = {},
        PoseHead = 1,
        AnimEvents = {},
        AnimHead = 1,
        ActiveSlots = {},
        Connections = {}
    },
    Dependencies = {"RunService", "Players", "Workspace"},
    Services = {}
}
function Modules.MirrorMimic:_cleanup()
    local lp = self.Services.Players.LocalPlayer
    local char = lp.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    for key, conn in pairs(self.State.Connections) do
        conn:Disconnect()
    end
    table.clear(self.State.Connections)
    for _, slot in pairs(self.State.ActiveSlots) do
        if slot.mt then pcall(function() slot.mt:Stop(0) end) end
    end
    table.clear(self.State.ActiveSlots)
    if hum then
        local animator = hum:FindFirstChildOfClass("Animator")
        if animator then
            for _, tr in ipairs(animator:GetPlayingAnimationTracks()) do
                pcall(function() tr:Stop(0) end)
            end
        end
        hum.AutoRotate = self.State.PrevAutoRotate
    end
    local animate = char and char:FindFirstChild("Animate")
    if animate and self.State.AnimatePrevDisabled ~= nil then
        animate.Disabled = self.State.AnimatePrevDisabled
    end
    self.State.PoseQueue = {}
    self.State.PoseHead = 1
    self.State.AnimEvents = {}
    self.State.AnimHead = 1
    self.State.IsEnabled = false
    self.State.TargetPlayer = nil
end
function Modules.MirrorMimic:_scheduleAnim(track, kind, extra)
    local now = os.clock()
    table.insert(self.State.AnimEvents, {
        t = now + self.State.Delay,
        kind = kind,
        track = track,
        animId = track.Animation.AnimationId,
        speed = (type(track.Speed) == "number" and track.Speed) or 1,
        baseTP = track.TimePosition or 0,
        looped = track.Looped,
        data = extra
    })
end
function Modules.MirrorMimic:Enable(targetName, delayVal)
    local target = Utilities.findPlayer(targetName)
    if not target or not target.Character then
        return DoNotif("Mimic: Target not found or has no character.", 3)
    end
    local lp = self.Services.Players.LocalPlayer
    local myChar = lp.Character
    local tChar = target.Character
    local myHum = myChar and myChar:FindFirstChildOfClass("Humanoid")
    local tHum = tChar and tChar:FindFirstChildOfClass("Humanoid")
    if not (myHum and tHum) or myHum.RigType ~= tHum.RigType then
        return DoNotif("Mimic Error: Character rig types do not match.", 3)
    end
    self:_cleanup()
    self.State.IsEnabled = true
    self.State.TargetPlayer = target
    self.State.Delay = tonumber(delayVal) or 0
    self.State.PrevAutoRotate = myHum.AutoRotate
    myHum.AutoRotate = false
    local myRoot = myChar:FindFirstChild("HumanoidRootPart")
    local tRoot = tChar:FindFirstChild("HumanoidRootPart")
    local myAnimator = myHum:FindFirstChildOfClass("Animator") or Instance.new("Animator", myHum)
    local tAnimator = tHum:FindFirstChildOfClass("Animator")
    local animate = myChar:FindFirstChild("Animate")
    if animate then
        self.State.AnimatePrevDisabled = animate.Disabled
        animate.Disabled = true
    end
    self.State.Connections.AnimPlayed = tHum.AnimationPlayed:Connect(function(tt)
        self:_scheduleAnim(tt, "start")
        self.State.Connections["TrackSpd_"..tostring(tt)] = tt:GetPropertyChangedSignal("Speed"):Connect(function()
            self:_scheduleAnim(tt, "speed")
        end)
        self.State.Connections["TrackStop_"..tostring(tt)] = tt.Stopped:Connect(function()
            self:_scheduleAnim(tt, "stop")
        end)
    end)
    self.State.Connections.ToolEquip = tChar.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then
            local match = lp.Backpack:FindFirstChild(child.Name)
            if match then pcall(function() myHum:EquipTool(match) end) end
        end
    end)
    local lastLook = Vector3.new(0,0,-1)
    self.State.Connections.MainLoop = self.Services.RunService.Heartbeat:Connect(function()
        if not (tChar.Parent and tRoot.Parent and myChar.Parent) then
            return self:_cleanup()
        end
        local now = os.clock()
        local lv = tRoot.CFrame.LookVector
        local flat = Vector3.new(lv.X, 0, lv.Z)
        if flat.Magnitude >= 1e-4 then lastLook = flat.Unit end
        table.insert(self.State.PoseQueue, {
            t = now,
            pos = tRoot.Position,
            look = lastLook,
            vel = tRoot.AssemblyLinearVelocity,
            angY = tRoot.AssemblyAngularVelocity.Y
        })
        local snap
        while self.State.PoseHead <= #self.State.PoseQueue and self.State.PoseQueue[self.State.PoseHead].t <= (now - self.State.Delay) do
            snap = self.State.PoseQueue[self.State.PoseHead]
            self.State.PoseHead = self.State.PoseHead + 1
        end
        if snap then
            myRoot.CFrame = CFrame.lookAt(snap.pos, snap.pos + snap.look)
            myRoot.AssemblyLinearVelocity = snap.vel
            myRoot.AssemblyAngularVelocity = Vector3.new(0, snap.angY, 0)
            if self.State.PoseHead > 64 then
                local newBuf = {}
                for i = self.State.PoseHead, #self.State.PoseQueue do table.insert(newBuf, self.State.PoseQueue[i]) end
                self.State.PoseQueue, self.State.PoseHead = newBuf, 1
            end
        end
        while self.State.AnimHead <= #self.State.AnimEvents and self.State.AnimEvents[self.State.AnimHead].t <= now do
            local e = self.State.AnimEvents[self.State.AnimHead]
            self.State.AnimHead = self.State.AnimHead + 1
            if e.kind == "start" and e.animId ~= "" then
                self.State.UID = self.State.UID + 1
                local animObj = Instance.new("Animation")
                animObj.AnimationId = e.animId
                local mt = myAnimator:LoadAnimation(animObj)
                pcall(function()
                    mt:Play(0, 1, 1)
                    mt:AdjustSpeed(0)
                    mt.TimePosition = e.baseTP
                end)
                self.State.ActiveSlots[self.State.UID] = {
                    mt = mt,
                    track = e.track,
                    baseTP = e.baseTP,
                    segments = {{t = e.t, speed = e.speed}},
                    looped = e.looped,
                    alive = true
                }
            elseif e.kind == "speed" then
                for _, s in pairs(self.State.ActiveSlots) do
                    if s.alive and s.track == e.track then
                        table.insert(s.segments, {t = e.t, speed = e.speed})
                    end
                end
            elseif e.kind == "stop" then
                for id, s in pairs(self.State.ActiveSlots) do
                    if s.alive and s.track == e.track then
                        pcall(function() s.mt:Stop(0) end)
                        s.alive = false
                        self.State.ActiveSlots[id] = nil
                    end
                end
            end
        end
        for _, s in pairs(self.State.ActiveSlots) do
            if s.alive and s.mt then
                local len = s.mt.Length
                if len > 0 then
                    local tp = s.baseTP
                    for i = 1, #s.segments do
                        local st = s.segments[i].t
                        local sp = s.segments[i].speed
                        local en = (i < #s.segments) and s.segments[i+1].t or now
                        if en > st then tp = tp + (en - st) * sp end
                    end
                    tp = s.looped and (tp % len) or math.clamp(tp, 0, len - 0.03)
                    pcall(function() s.mt.TimePosition = tp end)
                end
            end
        end
    end)
    DoNotif("Mirror Active: Mimicking " .. target.Name, 2)
end
function Modules.MirrorMimic:Initialize()
    local module = self
    for _, serviceName in ipairs(module.Dependencies) do
        module.Services[serviceName] = game:GetService(serviceName)
    end
    RegisterCommand({
        Name = "mimic",
        Aliases = {"mirror", "mclone", "mcopy", "mimi"},
        Description = "Clones a player's movement and animations."
    }, function(args)
        if #args == 0 then return DoNotif("Usage: ;mimic <PlayerName> [delay]", 3) end
        module:Enable(args[1], args[2] or 0)
    end)
    RegisterCommand({
        Name = "unmimic",
        Aliases = {"mstop", "moff", "stopmimic"},
        Description = "Stops movement mirroring."
    }, function()
        module:_cleanup()
        DoNotif("Mimic Disabled.", 2)
    end)
end
Modules.ServerHopper = {
    State = {
        IsSearching = false
    },
    Dependencies = {"HttpService", "TeleportService", "Players"},
    Services = {}
}
function Modules.ServerHopper:Hop(mode)
    if self.State.IsSearching then return end
    self.State.IsSearching = true
    local http = self.Services.HttpService
    local tp = self.Services.TeleportService
    local placeId = game.PlaceId
    local jobId = game.JobId
    DoNotif("Searching for a " .. (mode == "High" and "large" or "small") .. " server...", 3)
    task.spawn(function()
        local success, result = pcall(function()
            return game:HttpGet(string.format("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Asc&limit=100", placeId))
        end)
        if not success or not result then
            self.State.IsSearching = false
            return DoNotif("Server Hop Error: Failed to fetch server list.", 3)
        end
        local data = http:JSONDecode(result)
        if not data or not data.data then
            self.State.IsSearching = false
            return DoNotif("Server Hop Error: Empty API response.", 3)
        end
        local serverList = data.data
        local candidates = {}
        for _, server in ipairs(serverList) do
            if server.id ~= jobId and server.playing < server.maxPlayers then
                table.insert(candidates, server)
            end
        end
        if #candidates == 0 then
            self.State.IsSearching = false
            return DoNotif("No valid servers found in this batch.", 3)
        end
        if mode == "High" then
            table.sort(candidates, function(a, b) return a.playing > b.playing end)
        else
            table.sort(candidates, function(a, b) return a.playing < b.playing end)
        end
        local target = candidates[1]
        DoNotif(string.format("Joining server [%d/%d players]...", target.playing, target.maxPlayers), 3)
        task.wait(0.5)
        local tpSuccess, tpErr = pcall(function()
            tp:TeleportToPlaceInstance(placeId, target.id, self.Services.Players.LocalPlayer)
        end)
        if not tpSuccess then
            warn("--> [ServerHopper] Teleport Failed:", tpErr)
            DoNotif("Teleport failed. Check console.", 3)
        end
        self.State.IsSearching = false
    end)
end
function Modules.ServerHopper:Initialize()
    local module = self
    for _, serviceName in ipairs(module.Dependencies) do
        module.Services[serviceName] = game:GetService(serviceName)
    end
    RegisterCommand({
        Name = "serverhop",
        Aliases = {"shop", "hop"},
        Description = "Teleports you to a different, populated server."
    }, function()
        module:Hop("High")
    end)
    RegisterCommand({
        Name = "smallserverhop",
        Aliases = {"sshop", "smallhop", "minihop"},
        Description = "Teleports you to a server with the fewest players."
    }, function()
        module:Hop("Low")
    end)
end
Modules.ForceSpawn = {}
function Modules.ForceSpawn:Execute()
    local Players = game:GetService("Players")
    local Workspace = game:GetService("Workspace")
    local localPlayer = Players.LocalPlayer
    if localPlayer.Character then
        DoNotif("Your character already exists. Use '.respawn' to reset a broken character.", 4)
        return
    end
    DoNotif("Attempting to trigger server-side spawn from nil character...", 2)
    local success, err = pcall(function()
        local tempModel = Instance.new("Model")
        tempModel.Name = "ZukaSpawnTrigger"
        tempModel.Parent = Workspace
        localPlayer.Character = tempModel
        task.wait()
        localPlayer.Character = nil
        tempModel:Destroy()
    end)
    if not success then
        warn("[ForceSpawn] Spawn trigger logic failed:", err)
        DoNotif("Spawn trigger failed. See developer console for details.", 4)
    end
end
function Modules.ForceSpawn:Initialize()
    RegisterCommand({
        Name = "spawn",
        Aliases = {"forcespawn"},
        Description = "Forces your character to spawn if you are stuck as a camera (no character)."
    }, function()
        Modules.ForceSpawn:Execute()
    end)
end
Modules.Aura = {
    State = {
        IsEnabled = false,
        Distance = 20,
        Connection = nil,
        Visualizer = nil,
        LastAttack = 0
    },
    Config = {
        ATTACK_INTERVAL = 0.1,
        VISUAL_TRANSPARENCY = 0.8,
        VISUAL_COLOR = Color3.fromRGB(255, 50, 50)
    }
}
function Modules.Aura:_createVisualizer()
    if self.State.Visualizer then self.State.Visualizer:Destroy() end
    local sphere = Instance.new("Part")
    sphere.Name = "AuraVisualizer"
    sphere.Shape = Enum.PartType.Ball
    sphere.Size = Vector3.one * (self.State.Distance * 2)
    sphere.Transparency = self.Config.VISUAL_TRANSPARENCY
    sphere.Color = self.Config.VISUAL_COLOR
    sphere.Material = Enum.Material.Neon
    sphere.CanCollide = false
    sphere.CanTouch = false
    sphere.CanQuery = false
    sphere.Anchored = true
    sphere.Parent = Workspace
    self.State.Visualizer = sphere
end
function Modules.Aura:_getAttackPart(): BasePart?
    local char = Players.LocalPlayer.Character
    if not char then return nil end
    local tool = char:FindFirstChildOfClass("Tool")
    if not tool then return nil end
    return tool:FindFirstChild("Handle") or tool:FindFirstChildWhichIsA("BasePart")
end
function Modules.Aura:Disable()
    if not self.State.IsEnabled then return end
    self.State.IsEnabled = false
    if self.State.Connection then
        self.State.Connection:Disconnect()
        self.State.Connection = nil
    end
    if self.State.Visualizer then
        self.State.Visualizer:Destroy()
        self.State.Visualizer = nil
    end
    DoNotif("Kill Aura: DISABLED", 2)
end
function Modules.Aura:Enable()
    if not firetouchinterest then
        return DoNotif("Executor does not support 'firetouchinterest'.", 4)
    end
    self:Disable()
    self.State.IsEnabled = true
    self:_createVisualizer()
    self.State.Connection = RunService.Heartbeat:Connect(function()
        local char = Players.LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp or not self.State.Visualizer then return end
        self.State.Visualizer.CFrame = hrp.CFrame
        if os.clock() - self.State.LastAttack < self.Config.ATTACK_INTERVAL then
            return
        end
        local weapon = self:_getAttackPart()
        if not weapon then return end
        self.State.LastAttack = os.clock()
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= Players.LocalPlayer and player.Character then
                local targetHrp = player.Character:FindFirstChild("HumanoidRootPart")
                local targetHum = player.Character:FindFirstChildOfClass("Humanoid")
                if targetHrp and targetHum and targetHum.Health > 0 then
                    local mag = (targetHrp.Position - hrp.Position).Magnitude
                    if mag <= self.State.Distance then
                        pcall(function()
                            firetouchinterest(weapon, targetHrp, 0)
                            firetouchinterest(weapon, targetHrp, 1)
                        end)
                    end
                end
            end
        end
    end)
    DoNotif("Kill Aura: ENABLED (" .. self.State.Distance .. " studs)", 2)
end
function Modules.Aura:Initialize()
    local module = self
    RegisterCommand({
        Name = "aura",
        Aliases = {"killaura", "ka"},
        Description = "Toggles a touch-based kill aura. Optional: ;aura [distance]"
    }, function(args)
        local dist = tonumber(args[1])
        if dist then
            module.State.Distance = dist
            if module.State.IsEnabled then
                module:Enable()
            end
        else
            if module.State.IsEnabled then
                module:Disable()
            else
                module:Enable()
            end
        end
    end)
end
Modules.VoodooDoll = {
    State = { IsActive = false, Target = nil, Connection = nil },
    Config = { OFFSET = Vector3.new(0, 5, 0) },
    Dependencies = {"Players", "RunService", "Workspace"}
}
function Modules.VoodooDoll:Possess(targetName)
    local targetPlr = Utilities.findPlayer(targetName)
    if not targetPlr or not targetPlr.Character then return DoNotif("Target not found.", 2) end
    self.State.IsActive = true
    self.State.Target = targetPlr.Character
    self.State.Connection = RunService.Heartbeat:Connect(function()
        local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        local tRoot = self.State.Target:FindFirstChild("HumanoidRootPart")
        if myRoot and tRoot then
            tRoot.Velocity = Vector3.new(0, 30, 0)
            tRoot.CFrame = myRoot.CFrame * CFrame.new(self.Config.OFFSET)
        end
    end)
    DoNotif("Voodoo: Possessing " .. targetPlr.Name, 2)
end
function Modules.VoodooDoll:Initialize()
    RegisterCommand({
        Name = "netbring",
        Aliases = {},
        Description = "Locally possess an unanchored character/object."
    }, function(args)
        if self.State.IsActive then
            self.State.Connection:Disconnect()
            self.State.IsActive = false
            DoNotif("Voodoo: Released target.", 2)
        else
            self:Possess(args[1])
        end
    end)
end
Modules.HumanShield = {
    State = {
        IsEnabled = false,
        Targets = {},
        Connections = {}
    },
    Config = {
        DISTANCE = 3.5,
        VERTICAL_OFFSET = 0,
    },
    Dependencies = {"Players", "RunService"}
}
function Modules.HumanShield:Stop(): ()
    self.State.IsEnabled = false
    for _, connection in pairs(self.State.Connections) do
        if connection then
            connection:Disconnect()
        end
    end
    self.State.Connections = {}
    self.State.Targets = {}
end
function Modules.HumanShield:PossessAll(): ()
    if self.State.IsEnabled then self:Stop() end
    local myChar = Players.LocalPlayer.Character
    if not myChar or not myChar:FindFirstChild("HumanoidRootPart") then
        return DoNotif("Your character not found.", 2)
    end
    local targets = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            table.insert(targets, player.Character)
        end
    end
    if #targets == 0 then
        return DoNotif("No valid targets found.", 2)
    end
    self.State.IsEnabled = true
    self.State.Targets = targets
    for i, character in ipairs(targets) do
        local tRoot = character:FindFirstChild("HumanoidRootPart")
        if tRoot then
            local connection = RunService.Heartbeat:Connect(function()
                local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
                if not (myRoot and tRoot and tRoot.Parent) then
                    return
                end
                tRoot.Velocity = Vector3.new(0, 30.01, 0)
                tRoot.CFrame = myRoot.CFrame * CFrame.new(0, self.Config.VERTICAL_OFFSET, -self.Config.DISTANCE)
            end)
            table.insert(self.State.Connections, connection)
        end
    end
    DoNotif("Shield Active: All players (" .. #targets .. ")", 2)
end
function Modules.HumanShield:Possess(targetName: string): ()
    local targetPlr = Utilities.findPlayer(targetName)
    if not targetPlr or not targetPlr.Character then 
        return DoNotif("Target not found.", 2) 
    end
    if self.State.IsEnabled then self:Stop() end
    local character = targetPlr.Character
    local tRoot = character:FindFirstChild("HumanoidRootPart")
    if not tRoot then return end
    self.State.IsEnabled = true
    table.insert(self.State.Targets, character)
    local connection = RunService.Heartbeat:Connect(function()
        local myChar = Players.LocalPlayer.Character
        local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
        if not (myRoot and tRoot and tRoot.Parent) then
            self:Stop()
            return
        end
        tRoot.Velocity = Vector3.new(0, 30.01, 0)
        tRoot.CFrame = myRoot.CFrame * CFrame.new(0, self.Config.VERTICAL_OFFSET, -self.Config.DISTANCE)
    end)
    table.insert(self.State.Connections, connection)
    DoNotif("Shield Active: " .. targetPlr.Name, 2)
end
function Modules.HumanShield:Initialize(): ()
    local module = self
    RegisterCommand({
        Name = "bring",
        Aliases = {"b"},
        Description = "Positions a player in front of you with their back turned. Use 'all' to bring all players."
    }, function(args)
        if module.State.IsEnabled then
            module:Stop()
            DoNotif("Shield Released.", 2)
        else
            if #args > 0 then
                if args[1]:lower() == "all" then
                    module:PossessAll()
                else
                    module:Possess(args[1])
                end
            else
                DoNotif("Usage: ;bring [player/all]", 3)
            end
        end
    end)
end
Modules.NetworkClaim = {
    State = {
        IsEnabled = false,
        ClaimedObjects = {},
        SelectedObject = nil,
        UI = nil,
        Connections = {},
        AutoClaim = false
    },
    Config = {
        HighlightColor = Color3.fromRGB(255, 100, 0),
        ClaimMethod = "ownership",
        UpdateRate = 0.03,
        ShowVisuals = true
    }
}
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
function Modules.NetworkClaim:_createUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "NetworkClaim_Zuka"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
    self.State.UI = screenGui
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.fromOffset(380, 560)
    mainFrame.Position = UDim2.new(1, -390, 0.5, -280)
    mainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
    mainFrame.BorderSizePixel = 0
    mainFrame.Parent = screenGui
    Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 8)
    local stroke = Instance.new("UIStroke", mainFrame)
    stroke.Color = Color3.fromRGB(255, 100, 0)
    stroke.Thickness = 2
    local glowTween = TweenService:Create(stroke, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {
        Thickness = 3
    })
    glowTween:Play()
    local titleBar = Instance.new("Frame", mainFrame)
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1, 0, 0, 35)
    titleBar.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
    titleBar.BorderSizePixel = 0
    Instance.new("UICorner", titleBar).CornerRadius = UDim.new(0, 8)
    local title = Instance.new("TextLabel", titleBar)
    title.Size = UDim2.new(1, -90, 1, 0)
    title.Position = UDim2.fromOffset(10, 0)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.Code
    title.Text = "â–¸ NETWORK CLAIM"
    title.TextColor3 = Color3.fromRGB(255, 100, 0)
    title.TextSize = 16
    title.TextXAlignment = Enum.TextXAlignment.Left
    local statusIndicator = Instance.new("TextLabel", titleBar)
    statusIndicator.Name = "StatusIndicator"
    statusIndicator.Size = UDim2.fromOffset(90, 20)
    statusIndicator.Position = UDim2.new(1, -160, 0.5, -10)
    statusIndicator.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    statusIndicator.BorderSizePixel = 0
    statusIndicator.Font = Enum.Font.GothamBold
    statusIndicator.Text = "0 CLAIMED"
    statusIndicator.TextColor3 = Color3.fromRGB(200, 200, 200)
    statusIndicator.TextSize = 10
    Instance.new("UICorner", statusIndicator).CornerRadius = UDim.new(0, 4)
    local closeBtn = Instance.new("TextButton", titleBar)
    closeBtn.Size = UDim2.fromOffset(30, 30)
    closeBtn.Position = UDim2.new(1, -32, 0, 2)
    closeBtn.BackgroundColor3 = Color3.fromRGB(255, 50, 100)
    closeBtn.BorderSizePixel = 0
    closeBtn.Text = "Ã—"
    closeBtn.TextColor3 = Color3.new(1, 1, 1)
    closeBtn.Font = Enum.Font.GothamBold
    closeBtn.TextSize = 20
    Instance.new("UICorner", closeBtn).CornerRadius = UDim.new(0, 6)
    closeBtn.MouseButton1Click:Connect(function()
        self:Disable()
    end)
    local dragStart, startPos
    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragStart = input.Position
            startPos = mainFrame.Position
            local moveConn, endConn
            moveConn = game:GetService("UserInputService").InputChanged:Connect(function(moveInput)
                if moveInput.UserInputType == Enum.UserInputType.MouseMovement then
                    local delta = moveInput.Position - dragStart
                    mainFrame.Position = UDim2.new(
                        startPos.X.Scale, startPos.X.Offset + delta.X,
                        startPos.Y.Scale, startPos.Y.Offset + delta.Y
                    )
                end
            end)
            endConn = game:GetService("UserInputService").InputEnded:Connect(function(endInput)
                if endInput.UserInputType == Enum.UserInputType.MouseButton1 then
                    moveConn:Disconnect()
                    endConn:Disconnect()
                end
            end)
        end
    end)
    local content = Instance.new("Frame", mainFrame)
    content.Name = "Content"
    content.Size = UDim2.new(1, -20, 1, -45)
    content.Position = UDim2.fromOffset(10, 40)
    content.BackgroundTransparency = 1
    local selectionLabel = Instance.new("TextLabel", content)
    selectionLabel.Name = "SelectionLabel"
    selectionLabel.Size = UDim2.new(1, 0, 0, 35)
    selectionLabel.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    selectionLabel.BorderSizePixel = 0
    selectionLabel.Font = Enum.Font.GothamMedium
    selectionLabel.Text = "Click an object to select"
    selectionLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    selectionLabel.TextSize = 12
    Instance.new("UICorner", selectionLabel).CornerRadius = UDim.new(0, 6)
    local methodLabel = Instance.new("TextLabel", content)
    methodLabel.Size = UDim2.new(1, 0, 0, 20)
    methodLabel.Position = UDim2.fromOffset(0, 45)
    methodLabel.BackgroundTransparency = 1
    methodLabel.Font = Enum.Font.GothamBold
    methodLabel.Text = "Claim Method:"
    methodLabel.TextColor3 = Color3.new(1, 1, 1)
    methodLabel.TextSize = 13
    methodLabel.TextXAlignment = Enum.TextXAlignment.Left
    local methodButtons = {}
    local methods = {
        {id = "ownership", name = "OWNERSHIP", desc = "Set network owner"},
        {id = "velocity", name = "VELOCITY", desc = "Spam velocity changes"},
        {id = "cframe", name = "CFRAME", desc = "Spam CFrame updates"}
    }
    for i, method in ipairs(methods) do
        local btn = Instance.new("TextButton", content)
        btn.Name = method.id .. "Btn"
        btn.Size = UDim2.fromOffset(110, 30)
        btn.Position = UDim2.fromOffset((i-1) * 120, 70)
        btn.BackgroundColor3 = method.id == "ownership" and Color3.fromRGB(255, 100, 0) or Color3.fromRGB(50, 50, 65)
        btn.BorderSizePixel = 0
        btn.Font = Enum.Font.GothamSemibold
        btn.Text = method.name
        btn.TextColor3 = Color3.new(1, 1, 1)
        btn.TextSize = 10
        Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 6)
        methodButtons[method.id] = btn
        btn.MouseButton1Click:Connect(function()
            self.Config.ClaimMethod = method.id
            for m, b in pairs(methodButtons) do
                b.BackgroundColor3 = m == method.id and Color3.fromRGB(255, 100, 0) or Color3.fromRGB(50, 50, 65)
            end
            print(string.format("âœ“ Claim method: %s", method.name))
        end)
        local tooltip = Instance.new("TextLabel", btn)
        tooltip.Size = UDim2.new(1, 0, 0, 15)
        tooltip.Position = UDim2.new(0, 0, 1, 2)
        tooltip.BackgroundTransparency = 1
        tooltip.Font = Enum.Font.Gotham
        tooltip.Text = method.desc
        tooltip.TextColor3 = Color3.fromRGB(150, 150, 150)
        tooltip.TextSize = 8
        tooltip.TextWrapped = true
    end
    local autoClaimToggle = Instance.new("TextButton", content)
    autoClaimToggle.Name = "AutoClaimToggle"
    autoClaimToggle.Size = UDim2.new(1, 0, 0, 35)
    autoClaimToggle.Position = UDim2.fromOffset(0, 120)
    autoClaimToggle.BackgroundColor3 = Color3.fromRGB(50, 50, 65)
    autoClaimToggle.BorderSizePixel = 0
    autoClaimToggle.Font = Enum.Font.GothamBold
    autoClaimToggle.Text = "AUTO-CLAIM: OFF"
    autoClaimToggle.TextColor3 = Color3.new(1, 1, 1)
    autoClaimToggle.TextSize = 12
    Instance.new("UICorner", autoClaimToggle).CornerRadius = UDim.new(0, 6)
    autoClaimToggle.MouseButton1Click:Connect(function()
        self.State.AutoClaim = not self.State.AutoClaim
        autoClaimToggle.Text = "AUTO-CLAIM: " .. (self.State.AutoClaim and "ON" or "OFF")
        autoClaimToggle.BackgroundColor3 = self.State.AutoClaim and Color3.fromRGB(0, 200, 100) or Color3.fromRGB(50, 50, 65)
        print(string.format("âœ“ Auto-claim: %s", self.State.AutoClaim and "ON" or "OFF"))
    end)
    local actionsLabel = Instance.new("TextLabel", content)
    actionsLabel.Size = UDim2.new(1, 0, 0, 20)
    actionsLabel.Position = UDim2.fromOffset(0, 165)
    actionsLabel.BackgroundTransparency = 1
    actionsLabel.Font = Enum.Font.GothamBold
    actionsLabel.Text = "Actions:"
    actionsLabel.TextColor3 = Color3.new(1, 1, 1)
    actionsLabel.TextSize = 13
    actionsLabel.TextXAlignment = Enum.TextXAlignment.Left
    local claimBtn = Instance.new("TextButton", content)
    claimBtn.Name = "ClaimButton"
    claimBtn.Size = UDim2.new(1, 0, 0, 40)
    claimBtn.Position = UDim2.fromOffset(0, 190)
    claimBtn.BackgroundColor3 = Color3.fromRGB(255, 150, 0)
    claimBtn.BorderSizePixel = 0
    claimBtn.Font = Enum.Font.GothamBold
    claimBtn.Text = "CLAIM SELECTED"
    claimBtn.TextColor3 = Color3.new(1, 1, 1)
    claimBtn.TextSize = 14
    Instance.new("UICorner", claimBtn).CornerRadius = UDim.new(0, 6)
    claimBtn.MouseButton1Click:Connect(function()
        self:ClaimSelected()
    end)
    local releaseBtn = Instance.new("TextButton", content)
    releaseBtn.Size = UDim2.new(0.48, 0, 0, 35)
    releaseBtn.Position = UDim2.fromOffset(0, 240)
    releaseBtn.BackgroundColor3 = Color3.fromRGB(200, 100, 50)
    releaseBtn.BorderSizePixel = 0
    releaseBtn.Font = Enum.Font.GothamBold
    releaseBtn.Text = "RELEASE"
    releaseBtn.TextColor3 = Color3.new(1, 1, 1)
    releaseBtn.TextSize = 12
    Instance.new("UICorner", releaseBtn).CornerRadius = UDim.new(0, 6)
    releaseBtn.MouseButton1Click:Connect(function()
        self:ReleaseSelected()
    end)
    local releaseAllBtn = Instance.new("TextButton", content)
    releaseAllBtn.Size = UDim2.new(0.48, 0, 0, 35)
    releaseAllBtn.Position = UDim2.new(0.52, 0, 0, 240)
    releaseAllBtn.BackgroundColor3 = Color3.fromRGB(255, 50, 100)
    releaseAllBtn.BorderSizePixel = 0
    releaseAllBtn.Font = Enum.Font.GothamBold
    releaseAllBtn.Text = "RELEASE ALL"
    releaseAllBtn.TextColor3 = Color3.new(1, 1, 1)
    releaseAllBtn.TextSize = 12
    Instance.new("UICorner", releaseAllBtn).CornerRadius = UDim.new(0, 6)
    releaseAllBtn.MouseButton1Click:Connect(function()
        self:ReleaseAll()
    end)
    local bulkLabel = Instance.new("TextLabel", content)
    bulkLabel.Size = UDim2.new(1, 0, 0, 20)
    bulkLabel.Position = UDim2.fromOffset(0, 285)
    bulkLabel.BackgroundTransparency = 1
    bulkLabel.Font = Enum.Font.GothamBold
    bulkLabel.Text = "Bulk Actions:"
    bulkLabel.TextColor3 = Color3.new(1, 1, 1)
    bulkLabel.TextSize = 13
    bulkLabel.TextXAlignment = Enum.TextXAlignment.Left
    local claimModelBtn = Instance.new("TextButton", content)
    claimModelBtn.Size = UDim2.new(1, 0, 0, 35)
    claimModelBtn.Position = UDim2.fromOffset(0, 310)
    claimModelBtn.BackgroundColor3 = Color3.fromRGB(150, 80, 200)
    claimModelBtn.BorderSizePixel = 0
    claimModelBtn.Font = Enum.Font.GothamBold
    claimModelBtn.Text = "CLAIM ENTIRE MODEL"
    claimModelBtn.TextColor3 = Color3.new(1, 1, 1)
    claimModelBtn.TextSize = 12
    Instance.new("UICorner", claimModelBtn).CornerRadius = UDim.new(0, 6)
    claimModelBtn.MouseButton1Click:Connect(function()
        self:ClaimEntireModel()
    end)
    local claimChildrenBtn = Instance.new("TextButton", content)
    claimChildrenBtn.Size = UDim2.new(1, 0, 0, 35)
    claimChildrenBtn.Position = UDim2.fromOffset(0, 352)
    claimChildrenBtn.BackgroundColor3 = Color3.fromRGB(100, 150, 200)
    claimChildrenBtn.BorderSizePixel = 0
    claimChildrenBtn.Font = Enum.Font.GothamBold
    claimChildrenBtn.Text = "CLAIM ALL DESCENDANTS"
    claimChildrenBtn.TextColor3 = Color3.new(1, 1, 1)
    claimChildrenBtn.TextSize = 12
    Instance.new("UICorner", claimChildrenBtn).CornerRadius = UDim.new(0, 6)
    claimChildrenBtn.MouseButton1Click:Connect(function()
        self:ClaimAllDescendants()
    end)
    local infoLabel = Instance.new("TextLabel", content)
    infoLabel.Size = UDim2.new(1, 0, 0, 20)
    infoLabel.Position = UDim2.fromOffset(0, 397)
    infoLabel.BackgroundTransparency = 1
    infoLabel.Font = Enum.Font.GothamBold
    infoLabel.Text = "Claimed Objects:"
    infoLabel.TextColor3 = Color3.new(1, 1, 1)
    infoLabel.TextSize = 13
    infoLabel.TextXAlignment = Enum.TextXAlignment.Left
    local claimedList = Instance.new("ScrollingFrame", content)
    claimedList.Name = "ClaimedList"
    claimedList.Size = UDim2.new(1, 0, 0, 118)
    claimedList.Position = UDim2.fromOffset(0, 422)
    claimedList.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
    claimedList.BorderSizePixel = 0
    claimedList.ScrollBarThickness = 4
    claimedList.ScrollBarImageColor3 = Color3.fromRGB(255, 100, 0)
    claimedList.CanvasSize = UDim2.fromOffset(0, 0)
    claimedList.AutomaticCanvasSize = Enum.AutomaticSize.Y
    Instance.new("UICorner", claimedList).CornerRadius = UDim.new(0, 6)
    local listLayout = Instance.new("UIListLayout", claimedList)
    listLayout.Padding = UDim.new(0, 3)
    listLayout.SortOrder = Enum.SortOrder.LayoutOrder
    screenGui.Parent = CoreGui
    return selectionLabel, statusIndicator, claimedList
end
function Modules.NetworkClaim:GetAllParts(obj)
    local parts = {}
    if obj:IsA("BasePart") then
        table.insert(parts, obj)
    elseif obj:IsA("Model") then
        for _, part in pairs(obj:GetDescendants()) do
            if part:IsA("BasePart") then
                table.insert(parts, part)
            end
        end
    end
    return parts
end
function Modules.NetworkClaim:ClaimPart(part)
    if not part:IsA("BasePart") then return false end
    local method = self.Config.ClaimMethod
    local connection
    if method == "ownership" then
        local success = pcall(function()
            part:SetNetworkOwner(LocalPlayer)
        end)
        if not success then
            connection = RunService.Heartbeat:Connect(function()
                if part and part.Parent then
                    part.Velocity = Vector3.new(0, 0.01, 0)
                end
            end)
        end
    elseif method == "velocity" then
        connection = RunService.Heartbeat:Connect(function()
            if part and part.Parent then
                part.Velocity = Vector3.new(0, 0.01, 0)
                part.RotVelocity = Vector3.new(0, 0, 0)
            end
        end)
    elseif method == "cframe" then
        local originalCF = part.CFrame
        connection = RunService.Heartbeat:Connect(function()
            if part and part.Parent then
                part.CFrame = originalCF
            end
        end)
    end
    return connection
end
function Modules.NetworkClaim:ClaimSelected()
    if not self.State.SelectedObject then
        print("âš  No object selected")
        return
    end
    local obj = self.State.SelectedObject
    local parts = self:GetAllParts(obj)
    if #parts == 0 then
        print("âœ— No valid parts found")
        return
    end
    for _, data in pairs(self.State.ClaimedObjects) do
        if data.Object == obj then
            print("âš  Object already claimed")
            return
        end
    end
    local connections = {}
    local claimedCount = 0
    for _, part in ipairs(parts) do
        local conn = self:ClaimPart(part)
        if conn then
            table.insert(connections, conn)
        end
        claimedCount = claimedCount + 1
    end
    local highlight = Instance.new("Highlight")
    highlight.Name = "NetworkClaim_Highlight"
    highlight.FillColor = self.Config.HighlightColor
    highlight.OutlineColor = self.Config.HighlightColor
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    if obj:IsA("Model") then
        highlight.Adornee = obj
        highlight.Parent = obj
    else
        highlight.Adornee = obj
        highlight.Parent = obj
    end
    table.insert(self.State.ClaimedObjects, {
        Object = obj,
        Connections = connections,
        Highlight = highlight,
        Name = obj.Name,
        PartCount = claimedCount
    })
    print(string.format("âœ“ Claimed: %s (%d parts)", obj.Name, claimedCount))
    self:UpdateDisplay()
end
function Modules.NetworkClaim:ClaimEntireModel()
    if not self.State.SelectedObject then
        print("âš  No object selected")
        return
    end
    local obj = self.State.SelectedObject
    local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
    if not model then
        print("âš  Selected object is not in a model")
        return
    end
    self.State.SelectedObject = model
    self:ClaimSelected()
end
function Modules.NetworkClaim:ClaimAllDescendants()
    if not self.State.SelectedObject then
        print("âš  No object selected")
        return
    end
    local obj = self.State.SelectedObject
    local descendants = obj:GetDescendants()
    local claimedCount = 0
    for _, descendant in ipairs(descendants) do
        if descendant:IsA("BasePart") then
            self:ClaimPart(descendant)
            claimedCount = claimedCount + 1
        end
    end
    print(string.format("âœ“ Claimed %d descendants", claimedCount))
end
function Modules.NetworkClaim:ReleaseSelected()
    if not self.State.SelectedObject then
        print("âš  No object selected")
        return
    end
    for i, data in ipairs(self.State.ClaimedObjects) do
        if data.Object == self.State.SelectedObject then
            for _, conn in ipairs(data.Connections) do
                if conn then
                    conn:Disconnect()
                end
            end
            if data.Highlight then
                data.Highlight:Destroy()
            end
            for _, part in ipairs(self:GetAllParts(data.Object)) do
                pcall(function()
                    part:SetNetworkOwnershipAuto()
                end)
            end
            table.remove(self.State.ClaimedObjects, i)
            print(string.format("âœ“ Released: %s", data.Name))
            self:UpdateDisplay()
            return
        end
    end
    print("âš  Selected object is not claimed")
end
function Modules.NetworkClaim:ReleaseAll()
    if #self.State.ClaimedObjects == 0 then
        print("âš  No objects to release")
        return
    end
    local count = #self.State.ClaimedObjects
    for _, data in ipairs(self.State.ClaimedObjects) do
        for _, conn in ipairs(data.Connections) do
            if conn then
                conn:Disconnect()
            end
        end
        if data.Highlight then
            data.Highlight:Destroy()
        end
        for _, part in ipairs(self:GetAllParts(data.Object)) do
            pcall(function()
                part:SetNetworkOwnershipAuto()
            end)
        end
    end
    self.State.ClaimedObjects = {}
    print(string.format("âœ“ Released %d objects", count))
    self:UpdateDisplay()
end
function Modules.NetworkClaim:SelectObject(obj)
    if not obj or (not obj:IsA("Model") and not obj:IsA("BasePart")) then
        print("âš  Invalid object selected")
        return
    end
    if self.State.SelectedObject then
        local oldHighlight = self.State.SelectedObject:FindFirstChild("NetworkClaim_Selection")
        if oldHighlight then
            oldHighlight:Destroy()
        end
    end
    self.State.SelectedObject = obj
    local selectionBox = Instance.new("SelectionBox")
    selectionBox.Name = "NetworkClaim_Selection"
    selectionBox.Adornee = obj
    selectionBox.LineThickness = 0.05
    selectionBox.Color3 = Color3.fromRGB(255, 255, 0)
    selectionBox.Parent = obj
    print(string.format("âœ“ Selected: %s", obj.Name))
    self:UpdateDisplay()
end
function Modules.NetworkClaim:UpdateDisplay()
    if not self.State.UI then return end
    local selectionLabel = self.State.UI.MainFrame.Content.SelectionLabel
    local statusIndicator = self.State.UI.MainFrame.TitleBar.StatusIndicator
    local claimedList = self.State.UI.MainFrame.Content.ClaimedList
    if self.State.SelectedObject then
        local objType = self.State.SelectedObject:IsA("Model") and "Model" or "Part"
        selectionLabel.Text = string.format("Selected: %s (%s)", self.State.SelectedObject.Name, objType)
        selectionLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
    else
        selectionLabel.Text = "Click an object to select"
        selectionLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    end
    local count = #self.State.ClaimedObjects
    statusIndicator.Text = count .. " CLAIMED"
    statusIndicator.BackgroundColor3 = count > 0 and Color3.fromRGB(255, 100, 0) or Color3.fromRGB(50, 50, 50)
    statusIndicator.TextColor3 = count > 0 and Color3.new(1, 1, 1) or Color3.fromRGB(200, 200, 200)
    for _, child in pairs(claimedList:GetChildren()) do
        if not child:IsA("UIListLayout") then
            child:Destroy()
        end
    end
    for i, data in ipairs(self.State.ClaimedObjects) do
        local entry = Instance.new("TextButton")
        entry.Size = UDim2.new(1, -5, 0, 30)
        entry.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
        entry.BorderSizePixel = 0
        entry.Font = Enum.Font.Code
        entry.Text = string.format("[%d] %s (%d parts)", i, data.Name, data.PartCount)
        entry.TextColor3 = Color3.fromRGB(255, 150, 0)
        entry.TextSize = 10
        entry.TextXAlignment = Enum.TextXAlignment.Left
        entry.AutoButtonColor = false
        entry.Parent = claimedList
        Instance.new("UICorner", entry).CornerRadius = UDim.new(0, 4)
        local padding = Instance.new("UIPadding", entry)
        padding.PaddingLeft = UDim.new(0, 8)
        entry.MouseButton1Click:Connect(function()
            self.State.SelectedObject = data.Object
            self:SelectObject(data.Object)
        end)
        entry.MouseEnter:Connect(function()
            entry.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
        end)
        entry.MouseLeave:Connect(function()
            entry.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
        end)
    end
end
function Modules.NetworkClaim:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    self:_createUI()
    self.State.Connections.MouseClick = game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            local mouse = LocalPlayer:GetMouse()
            local target = mouse.Target
            if target then
                local obj = target:IsA("Model") and target or target.Parent
                if obj and (obj:IsA("Model") or obj:IsA("BasePart")) then
                    self:SelectObject(obj)
                    if self.State.AutoClaim then
                        task.wait(0.1)
                        self:ClaimSelected()
                    end
                end
            end
        end
    end)
    print("âœ“ Network Claim enabled - Click objects to select")
end
function Modules.NetworkClaim:Disable()
    if not self.State.IsEnabled then return end
    self:ReleaseAll()
    self.State.IsEnabled = false
    if self.State.SelectedObject then
        local highlight = self.State.SelectedObject:FindFirstChild("NetworkClaim_Selection")
        if highlight then
            highlight:Destroy()
        end
    end
    for _, conn in pairs(self.State.Connections) do
        if conn then
            conn:Disconnect()
        end
    end
    table.clear(self.State.Connections)
    if self.State.UI then
        self.State.UI:Destroy()
        self.State.UI = nil
    end
    self.State.SelectedObject = nil
    print("âœ“ Network Claim disabled")
end
function Modules.NetworkClaim:Toggle()
    if self.State.IsEnabled then
        self:Disable()
    else
        self:Enable()
    end
end
RegisterCommand({
    Name = "networkclaim",
    Aliases = {"claim", "netclaim"},
    Description = "Forces network ownership of any workspace object. Click to select, then claim."
}, function()
    Modules.NetworkClaim:Toggle()
end)

Modules.MapStripper = {
    State = { IsEnabled = false, Connection = nil },
    Dependencies = {"Players", "UserInputService"}
}
function Modules.MapStripper:Initialize()
    local lp = Players.LocalPlayer
    local mouse = lp:GetMouse()
    RegisterCommand({
        Name = "deltool",
        Aliases = {},
        Description = "Toggle: Click any object to delete it locally."
    }, function()
        self.State.IsEnabled = not self.State.IsEnabled
        if self.State.IsEnabled then
            self.State.Connection = mouse.Button1Down:Connect(function()
                local target = mouse.Target
                if target and not target:IsDescendantOf(lp.Character) then
                    print("--> [STRIPPER]: Removed " .. target:GetFullName())
                    target:Destroy()
                end
            end)
            DoNotif("(Click to delete)", 2)
        else
            if self.State.Connection then self.State.Connection:Disconnect() end
            DoNotif("Map Stripper: DISABLED", 2)
        end
    end)
end
Modules.AdminWatcher = {
    State = { Detected = {} },
    Config = { SIGNATURES = {"Adonis", "HDAdmin", "Kohl", "Cmdr", "Flux"} }
}
function Modules.AdminWatcher:Scan()
    local found = {}
    for key, _ in pairs(_G) do
        for _, sig in ipairs(self.Config.SIGNATURES) do
            if tostring(key):find(sig) then table.insert(found, tostring(key)) end
        end
    end
    for key, _ in pairs(shared) do
        for _, sig in ipairs(self.Config.SIGNATURES) do
            if tostring(key):find(sig) then table.insert(found, tostring(key)) end
        end
    end
    if #found > 0 then
        DoNotif("ADMIN SYSTEMS DETECTED: " .. table.concat(found, ", "), 5)
        print("--- [ADMIN FORENSICS] ---")
        for _, name in ipairs(found) do print(" [!] Warning: " .. name .. " is active.") end
    else
        DoNotif("No common admin systems found.", 2)
    end
end
function Modules.AdminWatcher:Initialize()
    RegisterCommand({
        Name = "checkadmin",
        Aliases = {"scanenv"},
        Description = "Scans game memory for active admin systems."
    }, function()
        self:Scan()
    end)
end
Modules.HandleKill = {
    State = {
        ActiveTargets = {},
        HeartbeatConnection = nil
    }
}
function Modules.HandleKill:_getKillTool(): (Tool?, BasePart?)
    local character = Players.LocalPlayer.Character
    if not character then return nil, nil end
    local tool = character:FindFirstChildOfClass("Tool")
    if not tool then return nil, nil end
    local handle = tool:FindFirstChild("Handle") or tool:FindFirstChildWhichIsA("BasePart")
    return tool, handle
end
function Modules.HandleKill:_process()
    local tool, handle = self:_getKillTool()
    if not tool or not handle then return end
    for target, _ in pairs(self.State.ActiveTargets) do
        pcall(function()
            if not target or not target.Parent or not target.Character then
                self.State.ActiveTargets[target] = nil
                return
            end
            local character = target.Character
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if not humanoid or humanoid.Health <= 0 then
                return
            end
            for _, part in ipairs(character:GetChildren()) do
                if part:IsA("BasePart") then
                    firetouchinterest(handle, part, 0)
                    firetouchinterest(handle, part, 1)
                end
            end
        end)
    end
end
function Modules.HandleKill:ToggleTarget(player: Player)
    if self.State.ActiveTargets[player] then
        self.State.ActiveTargets[player] = nil
        DoNotif("HandleKill: Stopped for " .. player.Name, 2)
    else
        self.State.ActiveTargets[player] = true
        DoNotif("HandleKill: Targeting " .. player.Name, 2)
        if not self.State.HeartbeatConnection then
            self.State.HeartbeatConnection = RunService.Heartbeat:Connect(function()
                if next(self.State.ActiveTargets) == nil then
                    self.State.HeartbeatConnection:Disconnect()
                    self.State.HeartbeatConnection = nil
                    return
                end
                self:_process()
            end)
        end
    end
end
function Modules.HandleKill:Initialize()
    local module = self
    RegisterCommand({
        Name = "handlekill",
        Aliases = {"hkill", "touchkill"},
        Description = "Toggles a continuous touch-kill loop on a target using your equipped tool."
    }, function(args)
        if not firetouchinterest then
            return DoNotif("Error: Your executor does not support 'firetouchinterest'.", 4)
        end
        local targetName = table.concat(args, " ")
        if #targetName == 0 then
            return DoNotif("Usage: ;hkill <PlayerName>", 3)
        end
        local targetPlayer = Utilities.findPlayer(targetName)
        if targetPlayer then
            module:ToggleTarget(targetPlayer)
        else
            DoNotif("Player '" .. targetName .. "' not found.", 3)
        end
    end)
end
Modules.HeuristicRemoteBruteforcer = {
    State = {
        IsEnabled = false,
        Connection = nil,
        TargetQueue = {},
        FiredHistory = {},
        IsScanning = false
    },
    Config = {
        FIRE_DELAY = 0.25,
        MAX_CALLS_PER_REMOTE = 15,
        BlacklistedParents = {
            game:GetService("CoreGui"),
            game:GetService("StarterGui"),
            game:GetService("ReplicatedFirst"),
            game:GetService("Workspace")
        }
    },
    Services = {
        Players = game:GetService("Players"),
        RunService = game:GetService("RunService")
    }
}
function Modules.HeuristicRemoteBruteforcer:_getHeuristicPayloads(remote: Instance)
    local payloads = {}
    local remoteName = remote.Name:lower()
    local localPlayer = self.Services.Players.LocalPlayer
    local char = localPlayer.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    table.insert(payloads, {true})
    table.insert(payloads, {false})
    table.insert(payloads, {1})
    table.insert(payloads, {0})
    table.insert(payloads, {""})
    table.insert(payloads, {nil})
    table.insert(payloads, {localPlayer})
    table.insert(payloads, {remote.Name})
    if root then
        table.insert(payloads, {root.Position})
        table.insert(payloads, {root.CFrame})
    end
    if remoteName:find("buy") then
        table.insert(payloads, {"Gems", 100}); table.insert(payloads, {"Sword", 0})
    end
    if remoteName:find("sell") then
        table.insert(payloads, {"Rock", 999})
    end
    if remoteName:find("equip") then
        table.insert(payloads, {"Sword"})
    end
     if remoteName:find("teleport") or remoteName:find("tp") then
        table.insert(payloads, {Vector3.new(0, 100, 0)})
    end
    return payloads
end
function Modules.HeuristicRemoteBruteforcer:_scanAndQueue()
    if self.State.IsScanning then return end
    self.State.IsScanning = true
    DoNotif("Bruteforcer: Scanning for new, non-core remotes...", 2)
    task.spawn(function()
        local remotesFound = 0
        local descendants = game:GetDescendants()
        for i, remote in ipairs(descendants) do
            if (remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction")) then
                local path = remote:GetFullName()
                if not self.State.FiredHistory[path] then
                    local isBlacklisted = false
                    for _, parentService in ipairs(self.Config.BlacklistedParents) do
                        if remote:IsDescendantOf(parentService) then
                            isBlacklisted = true
                            break
                        end
                    end
                    if not isBlacklisted then
                        table.insert(self.State.TargetQueue, remote)
                        self.State.FiredHistory[path] = true
                        remotesFound = remotesFound + 1
                    end
                end
            end
            if i % 500 == 0 then task.wait() end
        end
        DoNotif(string.format("Bruteforcer: Queued %d new remotes.", remotesFound), 3)
        self.State.IsScanning = false
    end)
end
function Modules.HeuristicRemoteBruteforcer:_processQueue()
    if #self.State.TargetQueue == 0 then return end
    if not self.State.IsEnabled then return end
    local remote = table.remove(self.State.TargetQueue, 1)
    if not (remote and remote.Parent) then return end
    print("--> [Bruteforcer] Fuzzing Remote:", remote:GetFullName())
    local payloads = self:_getHeuristicPayloads(remote)
    task.spawn(function()
        for i = 1, math.min(#payloads, self.Config.MAX_CALLS_PER_REMOTE) do
            if not self.State.IsEnabled then break end
            local payload = payloads[i]
            if remote:IsA("RemoteEvent") then
                pcall(remote.FireServer, remote, unpack(payload))
            elseif remote:IsA("RemoteFunction") then
                local success, result = pcall(remote.InvokeServer, remote, unpack(payload))
                if success then
                    print("    - Invoke SUCCESS. Result:", result)
                end
            end
            task.wait(self.Config.FIRE_DELAY)
        end
    end)
end
function Modules.HeuristicRemoteBruteforcer:Enable(): ()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    self:_scanAndQueue()
    self.State.Connection = self.Services.RunService.Heartbeat:Connect(function()
        self:_processQueue()
    end)
    DoNotif("Heuristic Bruteforcer: ENABLED", 2)
end
function Modules.HeuristicRemoteBruteforcer:Disable(): ()
    if not self.State.IsEnabled then return end
    self.State.IsEnabled = false
    if self.State.Connection then
        self.State.Connection:Disconnect()
        self.State.Connection = nil
    end
    self.State.TargetQueue = {}
    DoNotif("Heuristic Bruteforcer: DISABLED. Queue cleared.", 2)
end
function Modules.HeuristicRemoteBruteforcer:Initialize(): ()
    RegisterCommand({
        Name = "bruteforce",
        Aliases = {},
        Description = "This will more than likely kick you."
    }, function()
        if self.State.IsEnabled then self:Disable() else self:Enable() end
    end)
    RegisterCommand({
        Name = "clearfiredhistory",
        Description = "Clears the history of fired remotes, allowing a new scan."
    }, function()
        self.State.FiredHistory = {}
        DoNotif("Bruteforcer history cleared. You can now scan again.", 2)
    end)
end
Modules.Strengthen = {
State = {
Enabled = false,
Density = 1000,
OriginalProperties = {},
},
}
function Modules.Strengthen:ApplyToCharacter(character)
    table.clear(self.State.OriginalProperties)
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            self.State.OriginalProperties[part] = part.CustomPhysicalProperties
            part.CustomPhysicalProperties = PhysicalProperties.new(self.State.Density, 0.3, 0.5)
        end
    end
end
function Modules.Strengthen:RevertForCharacter()
    local character = Players.LocalPlayer.Character
    if not character then return end
        for part, originalProperties in pairs(self.State.OriginalProperties) do
            if part and part.Parent and part:IsDescendantOf(character) then
                part.CustomPhysicalProperties = originalProperties
            end
        end
        table.clear(self.State.OriginalProperties)
    end
    function Modules.Strengthen:Initialize()
        local module = self
        RegisterCommand({
        Name = "stonewall",
        Aliases = {},
        Description = "Men began calling him Stonewall that very day, for he would not yield an inch."
        }, function(args)
        local character = Players.LocalPlayer.Character
        if not character then
            return DoNotif("Character not found.", 3)
        end
        local newDensity = tonumber(args[1])
        if newDensity and newDensity > 0 then
            module.State.Density = newDensity
            DoNotif("Strengthen density set to " .. module.State.Density, 2)
        end
        if module.State.Enabled then
            module:RevertForCharacter()
            module.State.Enabled = false
            DoNotif("Strengthen disabled. Character physics restored.", 2)
        else
        module:ApplyToCharacter(character)
        module.State.Enabled = true
        DoNotif("Strengthen enabled at density " .. module.State.Density, 2)
    end
end)
end
Modules.AntiAnchor = {
    State = {
        Enabled = false,
        TrackedParts = setmetatable({}, {__mode="k"}),
        OriginalProperties = setmetatable({}, {__mode="k"}),
        Signals = setmetatable({}, {__mode="k"}),
        CharacterConnections = {},
        FailsafeConnection = nil,
    },
    Dependencies = {"Players", "RunService"},
}
function Modules.AntiAnchor:Enforce(part)
    if not (part and part:IsA("BasePart")) then return end
    if self.State.OriginalProperties[part] == nil then
        self.State.OriginalProperties[part] = part.Anchored
    end
    self.State.TrackedParts[part] = true
    if part.Anchored then part.Anchored = false end
    if not self.State.Signals[part] then
        self.State.Signals[part] = part:GetPropertyChangedSignal("Anchored"):Connect(function()
            if self.State.Enabled and part.Anchored then
                part.Anchored = false
            end
        end)
    end
end
function Modules.AntiAnchor:ProcessCharacter(character)
    for _, child in ipairs(character:GetDescendants()) do self:Enforce(child) end
    table.insert(self.State.CharacterConnections, character.DescendantAdded:Connect(function(child) self:Enforce(child) end))
    table.insert(self.State.CharacterConnections, character.DescendantRemoving:Connect(function(child)
        if self.State.Signals[child] then
            self.State.Signals[child]:Disconnect()
            self.State.Signals[child] = nil
        end
        self.State.TrackedParts[child] = nil
        self.State.OriginalProperties[child] = nil
    end))
end
function Modules.AntiAnchor:Enable()
    if self.State.Enabled then return end
    self.State.Enabled = true
    local localPlayer = self.Services.Players.LocalPlayer
    if localPlayer.Character then self:ProcessCharacter(localPlayer.Character) end
    table.insert(self.State.CharacterConnections, localPlayer.CharacterAdded:Connect(function(char) self:ProcessCharacter(char) end))
    self.State.FailsafeConnection = self.Services.RunService.Stepped:Connect(function()
        for part in pairs(self.State.TrackedParts) do
            if part and part.Anchored then part.Anchored = false end
        end
    end)
    DoNotif("Anti-Anchor enabled.", 2)
end
function Modules.AntiAnchor:Disable()
    if not self.State.Enabled then return end
    self.State.Enabled = false
    for _, conn in ipairs(self.State.CharacterConnections) do conn:Disconnect() end
    for _, conn in pairs(self.State.Signals) do conn:Disconnect() end
    if self.State.FailsafeConnection then self.State.FailsafeConnection:Disconnect() end
    for part, originalValue in pairs(self.State.OriginalProperties) do
        if part and part.Parent then part.Anchored = originalValue end
    end
    table.clear(self.State.TrackedParts)
    table.clear(self.State.OriginalProperties)
    table.clear(self.State.Signals)
    table.clear(self.State.CharacterConnections)
    self.State.FailsafeConnection = nil
    DoNotif("Anti-Anchor disabled.", 2)
end
function Modules.AntiAnchor:Initialize()
    self.Services = {}
    for _, service in ipairs(self.Dependencies) do
        self.Services[service] = game:GetService(service)
    end
    RegisterCommand({
        Name = "antianchor",
        Aliases = {"aanchor"},
        Description = "Toggles a robust defense against being anchored."
    }, function()
        if self.State.Enabled then
            self:Disable()
        else
            self:Enable()
        end
    end)
end
Modules.TeleportTool = {
    State = {},
    Dependencies = {"Players"},
    Services = {}
}
function Modules.TeleportTool:Create()
    local localPlayer = self.Services.Players.LocalPlayer
    if not localPlayer then
        return DoNotif("Teleport Tool creation failed: LocalPlayer not found.", 3)
    end
    if localPlayer.Backpack:FindFirstChild("Teleport Tool") or (localPlayer.Character and localPlayer.Character:FindFirstChild("Teleport Tool")) then
        return DoNotif("You already have the Teleport Tool.", 2)
    end
    local tpTool = Instance.new("Tool")
    tpTool.Name = "Teleport Tool"
    tpTool.RequiresHandle = false
    tpTool.Parent = localPlayer.Backpack
    local mouse = localPlayer:GetMouse()
    tpTool.Activated:Connect(function()
        local character = localPlayer.Character
        local hrp = character and character:FindFirstChild("HumanoidRootPart")
        if not hrp then
            return DoNotif("Could not find HumanoidRootPart to teleport.", 3)
        end
        local success, hitPosition = pcall(function() return mouse.Hit.Position end)
        if not success or not hitPosition then
            return DoNotif("No valid target position under cursor.", 2)
        end
        local newPosition = hitPosition + Vector3.new(0, 3, 0)
        hrp.CFrame = CFrame.new(newPosition) * (hrp.CFrame - hrp.CFrame.Position)
    end)
    DoNotif("Teleport Tool has been added to your backpack.", 2)
end
function Modules.TeleportTool:Initialize()
    local module = self
    for _, serviceName in ipairs(module.Dependencies) do
        module.Services[serviceName] = game:GetService(serviceName)
    end
    RegisterCommand({
        Name = "tptool",
        Aliases = {"teleporttool"},
        Description = "Gives you a tool that teleports you to your mouse cursor on click."
    }, function()
        module:Create()
    end)
end
Modules.ClickDetectorTools = {
    State = {},
    Dependencies = {"Workspace"},
    Services = {}
}
function Modules.ClickDetectorTools:Initialize()
    self.Services.Workspace = game:GetService("Workspace")
    RegisterCommand({
        Name = "noclickdetectorlimits",
        Aliases = {"nocdlimits", "removecdlimits"},
        Description = "Removes the distance limit for all ClickDetectors in the workspace."
    }, function()
        local count = 0
        for _, v in ipairs(self.Services.Workspace:GetDescendants()) do
            if v:IsA("ClickDetector") then
                v.MaxActivationDistance = math.huge
                count = count + 1
            end
        end
        DoNotif("Removed distance limits on " .. count .. " ClickDetectors.", 2)
    end)
    RegisterCommand({
        Name = "fireclickdetectors",
        Aliases = {"fireclick"},
        Description = "Fires all ClickDetectors in the workspace, or a specific one by name."
    }, function(args)
        if not fireclickdetector then
            return DoNotif("Environment does not support 'fireclickdetector'.", 4)
        end
        local count = 0
        if args[1] then
            local name = table.concat(args, " ")
            for _, descendant in ipairs(self.Services.Workspace:GetDescendants()) do
                if descendant:IsA("ClickDetector") and (descendant.Name == name or descendant.Parent.Name == name) then
                    fireclickdetector(descendant)
                    count = count + 1
                end
            end
        else
            for _, descendant in ipairs(self.Services.Workspace:GetDescendants()) do
                if descendant:IsA("ClickDetector") then
                    fireclickdetector(descendant)
                    count = count + 1
                end
            end
        end
        DoNotif("Fired " .. count .. " ClickDetector(s).", 2)
    end)
end
Modules.PlayerAttach = {
    State = {
        IsEnabled = false,
        AttachedTo = nil,
        OriginalCFrame = nil,
        UI = nil,
        Connections = {},
        IsAttached = false
    },
    Config = {
        Distance = 5,
        VerticalOffset = 2,
        HorizontalOffset = 0,
        RotationOffset = 0,
        FollowRotation = true,
        SmoothFollow = false,
        SmoothSpeed = 0.5,
        HighlightColor = Color3.fromRGB(100, 255, 255)
    }
}

local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

function Modules.PlayerAttach:_createUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "PlayerAttach_Zuka"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
    self.State.UI = screenGui
    
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.fromOffset(380, 580)
    mainFrame.Position = UDim2.new(1, -390, 0.5, -290)
    mainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
    mainFrame.BorderSizePixel = 0
    mainFrame.Parent = screenGui
    
    Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 8)
    
    local stroke = Instance.new("UIStroke", mainFrame)
    stroke.Color = Color3.fromRGB(100, 255, 255)
    stroke.Thickness = 2
    
    local glowTween = TweenService:Create(stroke, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {
        Thickness = 3
    })
    glowTween:Play()
    
    -- Title Bar
    local titleBar = Instance.new("Frame", mainFrame)
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1, 0, 0, 35)
    titleBar.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
    titleBar.BorderSizePixel = 0
    Instance.new("UICorner", titleBar).CornerRadius = UDim.new(0, 8)
    
    local title = Instance.new("TextLabel", titleBar)
    title.Size = UDim2.new(1, -90, 1, 0)
    title.Position = UDim2.fromOffset(10, 0)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.Code
    title.Text = "â–¸ PLAYER ATTACH"
    title.TextColor3 = Color3.fromRGB(100, 255, 255)
    title.TextSize = 16
    title.TextXAlignment = Enum.TextXAlignment.Left
    
    local statusIndicator = Instance.new("TextLabel", titleBar)
    statusIndicator.Name = "StatusIndicator"
    statusIndicator.Size = UDim2.fromOffset(90, 20)
    statusIndicator.Position = UDim2.new(1, -160, 0.5, -10)
    statusIndicator.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    statusIndicator.BorderSizePixel = 0
    statusIndicator.Font = Enum.Font.GothamBold
    statusIndicator.Text = "DETACHED"
    statusIndicator.TextColor3 = Color3.fromRGB(200, 200, 200)
    statusIndicator.TextSize = 10
    Instance.new("UICorner", statusIndicator).CornerRadius = UDim.new(0, 4)
    
    local closeBtn = Instance.new("TextButton", titleBar)
    closeBtn.Size = UDim2.fromOffset(30, 30)
    closeBtn.Position = UDim2.new(1, -32, 0, 2)
    closeBtn.BackgroundColor3 = Color3.fromRGB(255, 50, 100)
    closeBtn.BorderSizePixel = 0
    closeBtn.Text = "Ã—"
    closeBtn.TextColor3 = Color3.new(1, 1, 1)
    closeBtn.Font = Enum.Font.GothamBold
    closeBtn.TextSize = 20
    Instance.new("UICorner", closeBtn).CornerRadius = UDim.new(0, 6)
    
    closeBtn.MouseButton1Click:Connect(function()
        self:Disable()
    end)
    
    -- Make draggable
    local dragStart, startPos
    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragStart = input.Position
            startPos = mainFrame.Position
            
            local moveConn, endConn
            moveConn = game:GetService("UserInputService").InputChanged:Connect(function(moveInput)
                if moveInput.UserInputType == Enum.UserInputType.MouseMovement then
                    local delta = moveInput.Position - dragStart
                    mainFrame.Position = UDim2.new(
                        startPos.X.Scale, startPos.X.Offset + delta.X,
                        startPos.Y.Scale, startPos.Y.Offset + delta.Y
                    )
                end
            end)
            
            endConn = game:GetService("UserInputService").InputEnded:Connect(function(endInput)
                if endInput.UserInputType == Enum.UserInputType.MouseButton1 then
                    moveConn:Disconnect()
                    endConn:Disconnect()
                end
            end)
        end
    end)
    
    local content = Instance.new("Frame", mainFrame)
    content.Name = "Content"
    content.Size = UDim2.new(1, -20, 1, -45)
    content.Position = UDim2.fromOffset(10, 40)
    content.BackgroundTransparency = 1
    
    -- Target Selection
    local targetLabel = Instance.new("TextLabel", content)
    targetLabel.Name = "TargetLabel"
    targetLabel.Size = UDim2.new(1, 0, 0, 35)
    targetLabel.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    targetLabel.BorderSizePixel = 0
    targetLabel.Font = Enum.Font.GothamMedium
    targetLabel.Text = "No target selected"
    targetLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    targetLabel.TextSize = 12
    Instance.new("UICorner", targetLabel).CornerRadius = UDim.new(0, 6)
    
    -- Player List
    local playersLabel = Instance.new("TextLabel", content)
    playersLabel.Size = UDim2.new(1, 0, 0, 20)
    playersLabel.Position = UDim2.fromOffset(0, 45)
    playersLabel.BackgroundTransparency = 1
    playersLabel.Font = Enum.Font.GothamBold
    playersLabel.Text = "Select Player:"
    playersLabel.TextColor3 = Color3.new(1, 1, 1)
    playersLabel.TextSize = 13
    playersLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    local playerList = Instance.new("ScrollingFrame", content)
    playerList.Name = "PlayerList"
    playerList.Size = UDim2.new(1, 0, 0, 100)
    playerList.Position = UDim2.fromOffset(0, 70)
    playerList.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
    playerList.BorderSizePixel = 0
    playerList.ScrollBarThickness = 4
    playerList.ScrollBarImageColor3 = Color3.fromRGB(100, 255, 255)
    playerList.CanvasSize = UDim2.fromOffset(0, 0)
    playerList.AutomaticCanvasSize = Enum.AutomaticSize.Y
    Instance.new("UICorner", playerList).CornerRadius = UDim.new(0, 6)
    
    local listLayout = Instance.new("UIListLayout", playerList)
    listLayout.Padding = UDim.new(0, 3)
    listLayout.SortOrder = Enum.SortOrder.LayoutOrder
    
    -- Position Settings
    local settingsLabel = Instance.new("TextLabel", content)
    settingsLabel.Size = UDim2.new(1, 0, 0, 20)
    settingsLabel.Position = UDim2.fromOffset(0, 180)
    settingsLabel.BackgroundTransparency = 1
    settingsLabel.Font = Enum.Font.GothamBold
    settingsLabel.Text = "Position Settings:"
    settingsLabel.TextColor3 = Color3.new(1, 1, 1)
    settingsLabel.TextSize = 13
    settingsLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    -- Distance
    local distanceLabel = Instance.new("TextLabel", content)
    distanceLabel.Size = UDim2.new(1, 0, 0, 18)
    distanceLabel.Position = UDim2.fromOffset(0, 205)
    distanceLabel.BackgroundTransparency = 1
    distanceLabel.Font = Enum.Font.Gotham
    distanceLabel.Text = "Distance: 5"
    distanceLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    distanceLabel.TextSize = 11
    distanceLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    local distanceInput = Instance.new("TextBox", content)
    distanceInput.Size = UDim2.new(1, 0, 0, 30)
    distanceInput.Position = UDim2.fromOffset(0, 227)
    distanceInput.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    distanceInput.BorderSizePixel = 0
    distanceInput.Font = Enum.Font.Code
    distanceInput.Text = "5"
    distanceInput.TextColor3 = Color3.new(1, 1, 1)
    distanceInput.TextSize = 12
    distanceInput.PlaceholderText = "Distance behind target..."
    Instance.new("UICorner", distanceInput).CornerRadius = UDim.new(0, 6)
    
    distanceInput.FocusLost:Connect(function()
        local value = tonumber(distanceInput.Text)
        if value then
            self.Config.Distance = value
            distanceLabel.Text = "Distance: " .. value
        else
            distanceInput.Text = tostring(self.Config.Distance)
        end
    end)
    
    -- Vertical Offset
    local verticalLabel = Instance.new("TextLabel", content)
    verticalLabel.Size = UDim2.new(1, 0, 0, 18)
    verticalLabel.Position = UDim2.fromOffset(0, 265)
    verticalLabel.BackgroundTransparency = 1
    verticalLabel.Font = Enum.Font.Gotham
    verticalLabel.Text = "Vertical Offset: 2"
    verticalLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    verticalLabel.TextSize = 11
    verticalLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    local verticalInput = Instance.new("TextBox", content)
    verticalInput.Size = UDim2.new(1, 0, 0, 30)
    verticalInput.Position = UDim2.fromOffset(0, 287)
    verticalInput.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    verticalInput.BorderSizePixel = 0
    verticalInput.Font = Enum.Font.Code
    verticalInput.Text = "2"
    verticalInput.TextColor3 = Color3.new(1, 1, 1)
    verticalInput.TextSize = 12
    verticalInput.PlaceholderText = "Height offset..."
    Instance.new("UICorner", verticalInput).CornerRadius = UDim.new(0, 6)
    
    verticalInput.FocusLost:Connect(function()
        local value = tonumber(verticalInput.Text)
        if value then
            self.Config.VerticalOffset = value
            verticalLabel.Text = "Vertical Offset: " .. value
        else
            verticalInput.Text = tostring(self.Config.VerticalOffset)
        end
    end)
    
    -- Horizontal Offset
    local horizontalLabel = Instance.new("TextLabel", content)
    horizontalLabel.Size = UDim2.new(1, 0, 0, 18)
    horizontalLabel.Position = UDim2.fromOffset(0, 325)
    horizontalLabel.BackgroundTransparency = 1
    horizontalLabel.Font = Enum.Font.Gotham
    horizontalLabel.Text = "Horizontal Offset: 0"
    horizontalLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    horizontalLabel.TextSize = 11
    horizontalLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    local horizontalInput = Instance.new("TextBox", content)
    horizontalInput.Size = UDim2.new(1, 0, 0, 30)
    horizontalInput.Position = UDim2.fromOffset(0, 347)
    horizontalInput.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    horizontalInput.BorderSizePixel = 0
    horizontalInput.Font = Enum.Font.Code
    horizontalInput.Text = "0"
    horizontalInput.TextColor3 = Color3.new(1, 1, 1)
    horizontalInput.TextSize = 12
    horizontalInput.PlaceholderText = "Side offset..."
    Instance.new("UICorner", horizontalInput).CornerRadius = UDim.new(0, 6)
    
    horizontalInput.FocusLost:Connect(function()
        local value = tonumber(horizontalInput.Text)
        if value then
            self.Config.HorizontalOffset = value
            horizontalLabel.Text = "Horizontal Offset: " .. value
        else
            horizontalInput.Text = tostring(self.Config.HorizontalOffset)
        end
    end)
    
    -- Follow Settings
    local followLabel = Instance.new("TextLabel", content)
    followLabel.Size = UDim2.new(1, 0, 0, 20)
    followLabel.Position = UDim2.fromOffset(0, 387)
    followLabel.BackgroundTransparency = 1
    followLabel.Font = Enum.Font.GothamBold
    followLabel.Text = "Follow Settings:"
    followLabel.TextColor3 = Color3.new(1, 1, 1)
    followLabel.TextSize = 13
    followLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    local followRotationToggle = Instance.new("TextButton", content)
    followRotationToggle.Name = "FollowRotationToggle"
    followRotationToggle.Size = UDim2.new(0.48, 0, 0, 30)
    followRotationToggle.Position = UDim2.fromOffset(0, 412)
    followRotationToggle.BackgroundColor3 = Color3.fromRGB(0, 200, 150)
    followRotationToggle.BorderSizePixel = 0
    followRotationToggle.Font = Enum.Font.GothamBold
    followRotationToggle.Text = "ROTATION: ON"
    followRotationToggle.TextColor3 = Color3.new(1, 1, 1)
    followRotationToggle.TextSize = 10
    Instance.new("UICorner", followRotationToggle).CornerRadius = UDim.new(0, 6)
    
    followRotationToggle.MouseButton1Click:Connect(function()
        self.Config.FollowRotation = not self.Config.FollowRotation
        followRotationToggle.Text = "ROTATION: " .. (self.Config.FollowRotation and "ON" or "OFF")
        followRotationToggle.BackgroundColor3 = self.Config.FollowRotation and Color3.fromRGB(0, 200, 150) or Color3.fromRGB(50, 50, 65)
    end)
    
    local smoothToggle = Instance.new("TextButton", content)
    smoothToggle.Name = "SmoothToggle"
    smoothToggle.Size = UDim2.new(0.48, 0, 0, 30)
    smoothToggle.Position = UDim2.new(0.52, 0, 0, 412)
    smoothToggle.BackgroundColor3 = Color3.fromRGB(50, 50, 65)
    smoothToggle.BorderSizePixel = 0
    smoothToggle.Font = Enum.Font.GothamBold
    smoothToggle.Text = "SMOOTH: OFF"
    smoothToggle.TextColor3 = Color3.new(1, 1, 1)
    smoothToggle.TextSize = 10
    Instance.new("UICorner", smoothToggle).CornerRadius = UDim.new(0, 6)
    
    smoothToggle.MouseButton1Click:Connect(function()
        self.Config.SmoothFollow = not self.Config.SmoothFollow
        smoothToggle.Text = "SMOOTH: " .. (self.Config.SmoothFollow and "ON" or "OFF")
        smoothToggle.BackgroundColor3 = self.Config.SmoothFollow and Color3.fromRGB(0, 200, 150) or Color3.fromRGB(50, 50, 65)
    end)
    
    -- Actions
    local actionsLabel = Instance.new("TextLabel", content)
    actionsLabel.Size = UDim2.new(1, 0, 0, 20)
    actionsLabel.Position = UDim2.fromOffset(0, 452)
    actionsLabel.BackgroundTransparency = 1
    actionsLabel.Font = Enum.Font.GothamBold
    actionsLabel.Text = "Actions:"
    actionsLabel.TextColor3 = Color3.new(1, 1, 1)
    actionsLabel.TextSize = 13
    actionsLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    local attachBtn = Instance.new("TextButton", content)
    attachBtn.Name = "AttachButton"
    attachBtn.Size = UDim2.new(1, 0, 0, 40)
    attachBtn.Position = UDim2.fromOffset(0, 477)
    attachBtn.BackgroundColor3 = Color3.fromRGB(0, 200, 255)
    attachBtn.BorderSizePixel = 0
    attachBtn.Font = Enum.Font.GothamBold
    attachBtn.Text = "ATTACH TO PLAYER"
    attachBtn.TextColor3 = Color3.new(1, 1, 1)
    attachBtn.TextSize = 14
    Instance.new("UICorner", attachBtn).CornerRadius = UDim.new(0, 6)
    
    attachBtn.MouseButton1Click:Connect(function()
        if self.State.IsAttached then
            self:DetachFromPlayer()
        else
            self:AttachToPlayer()
        end
    end)
    
    local detachBtn = Instance.new("TextButton", content)
    detachBtn.Size = UDim2.new(1, 0, 0, 35)
    detachBtn.Position = UDim2.fromOffset(0, 527)
    detachBtn.BackgroundColor3 = Color3.fromRGB(255, 100, 50)
    detachBtn.BorderSizePixel = 0
    detachBtn.Font = Enum.Font.GothamBold
    detachBtn.Text = "DETACH"
    detachBtn.TextColor3 = Color3.new(1, 1, 1)
    detachBtn.TextSize = 12
    Instance.new("UICorner", detachBtn).CornerRadius = UDim.new(0, 6)
    
    detachBtn.MouseButton1Click:Connect(function()
        self:DetachFromPlayer()
    end)
    
    screenGui.Parent = CoreGui
    
    return targetLabel, statusIndicator, playerList, attachBtn
end

function Modules.PlayerAttach:PopulatePlayerList()
    if not self.State.UI then return end
    
    local playerList = self.State.UI.MainFrame.Content.PlayerList
    
    -- Clear existing entries
    for _, child in pairs(playerList:GetChildren()) do
        if not child:IsA("UIListLayout") then
            child:Destroy()
        end
    end
    
    -- Add players
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local entry = Instance.new("TextButton")
            entry.Size = UDim2.new(1, -5, 0, 30)
            entry.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
            entry.BorderSizePixel = 0
            entry.Font = Enum.Font.Code
            entry.Text = "  " .. player.Name .. " (@" .. player.DisplayName .. ")"
            entry.TextColor3 = Color3.fromRGB(100, 255, 255)
            entry.TextSize = 11
            entry.TextXAlignment = Enum.TextXAlignment.Left
            entry.AutoButtonColor = false
            entry.Parent = playerList
            
            Instance.new("UICorner", entry).CornerRadius = UDim.new(0, 4)
            
            entry.MouseButton1Click:Connect(function()
                self:SelectPlayer(player)
                
                -- Highlight selected
                for _, child in pairs(playerList:GetChildren()) do
                    if child:IsA("TextButton") then
                        child.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
                    end
                end
                entry.BackgroundColor3 = Color3.fromRGB(0, 150, 200)
            end)
            
            entry.MouseEnter:Connect(function()
                if entry.BackgroundColor3 ~= Color3.fromRGB(0, 150, 200) then
                    entry.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
                end
            end)
            
            entry.MouseLeave:Connect(function()
                if entry.BackgroundColor3 ~= Color3.fromRGB(0, 150, 200) then
                    entry.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
                end
            end)
        end
    end
end

function Modules.PlayerAttach:SelectPlayer(player)
    if not player or not player.Character then
        print("âš  Invalid player selected")
        return
    end
    
    self.State.AttachedTo = player
    print(string.format("âœ“ Selected: %s", player.Name))
    self:UpdateDisplay()
end

function Modules.PlayerAttach:AttachToPlayer()
    if not self.State.AttachedTo then
        print("âš  No player selected")
        return
    end
    
    local targetPlayer = self.State.AttachedTo
    local targetChar = targetPlayer.Character
    local myChar = LocalPlayer.Character
    
    if not targetChar or not targetChar:FindFirstChild("HumanoidRootPart") then
        print("âœ— Target character not found")
        return
    end
    
    if not myChar or not myChar:FindFirstChild("HumanoidRootPart") then
        print("âœ— Your character not found")
        return
    end
    
    self.State.IsAttached = true
    self.State.OriginalCFrame = myChar.HumanoidRootPart.CFrame
    
    -- Create highlight on target
    local highlight = Instance.new("Highlight")
    highlight.Name = "PlayerAttach_Highlight"
    highlight.FillColor = self.Config.HighlightColor
    highlight.OutlineColor = self.Config.HighlightColor
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.Adornee = targetChar
    highlight.Parent = targetChar
    
    -- Attach loop
    self.State.Connections.AttachLoop = RunService.Heartbeat:Connect(function()
        local tChar = targetPlayer.Character
        local tRoot = tChar and tChar:FindFirstChild("HumanoidRootPart")
        local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
        
        if not (tRoot and myRoot and tRoot.Parent) then
            self:DetachFromPlayer()
            return
        end
        
        -- Calculate position behind target
        local offset = CFrame.new(
            self.Config.HorizontalOffset,
            self.Config.VerticalOffset,
            self.Config.Distance
        )
        
        local targetCFrame
        if self.Config.FollowRotation then
            targetCFrame = tRoot.CFrame * offset
        else
            targetCFrame = CFrame.new(tRoot.Position) * offset
        end
        
        -- Apply position
        if self.Config.SmoothFollow then
            myRoot.CFrame = myRoot.CFrame:Lerp(targetCFrame, self.Config.SmoothSpeed)
        else
            myRoot.CFrame = targetCFrame
        end
        
        -- Reset velocity to prevent falling
        myRoot.Velocity = Vector3.new(0, 0, 0)
        myRoot.RotVelocity = Vector3.new(0, 0, 0)
    end)
    
    print(string.format("âœ“ Attached to: %s", targetPlayer.Name))
    self:UpdateDisplay()
end

function Modules.PlayerAttach:DetachFromPlayer()
    if not self.State.IsAttached then
        print("âš  Not currently attached")
        return
    end
    
    self.State.IsAttached = false
    
    -- Disconnect attach loop
    if self.State.Connections.AttachLoop then
        self.State.Connections.AttachLoop:Disconnect()
        self.State.Connections.AttachLoop = nil
    end
    
    -- Remove highlight
    if self.State.AttachedTo and self.State.AttachedTo.Character then
        local highlight = self.State.AttachedTo.Character:FindFirstChild("PlayerAttach_Highlight")
        if highlight then
            highlight:Destroy()
        end
    end
    
    print("âœ“ Detached from player")
    self:UpdateDisplay()
end

function Modules.PlayerAttach:UpdateDisplay()
    if not self.State.UI then return end
    
    local targetLabel = self.State.UI.MainFrame.Content.TargetLabel
    local statusIndicator = self.State.UI.MainFrame.TitleBar.StatusIndicator
    local attachBtn = self.State.UI.MainFrame.Content.AttachButton
    
    -- Update target label
    if self.State.AttachedTo then
        targetLabel.Text = "Target: " .. self.State.AttachedTo.Name
        targetLabel.TextColor3 = Color3.fromRGB(100, 255, 255)
    else
        targetLabel.Text = "No target selected"
        targetLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    end
    
    -- Update status
    if self.State.IsAttached then
        statusIndicator.Text = "ATTACHED"
        statusIndicator.BackgroundColor3 = Color3.fromRGB(0, 200, 150)
        statusIndicator.TextColor3 = Color3.new(1, 1, 1)
        attachBtn.Text = "DETACH FROM PLAYER"
        attachBtn.BackgroundColor3 = Color3.fromRGB(255, 100, 50)
    else
        statusIndicator.Text = "DETACHED"
        statusIndicator.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
        statusIndicator.TextColor3 = Color3.fromRGB(200, 200, 200)
        attachBtn.Text = "ATTACH TO PLAYER"
        attachBtn.BackgroundColor3 = Color3.fromRGB(0, 200, 255)
    end
end

function Modules.PlayerAttach:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    
    self:_createUI()
    self:PopulatePlayerList()
    
    -- Refresh player list when players join/leave
    self.State.Connections.PlayerAdded = Players.PlayerAdded:Connect(function()
        task.wait(0.1)
        self:PopulatePlayerList()
    end)
    
    self.State.Connections.PlayerRemoving = Players.PlayerRemoving:Connect(function(player)
        if self.State.AttachedTo == player then
            self:DetachFromPlayer()
        end
        task.wait(0.1)
        self:PopulatePlayerList()
    end)
    
    print("âœ“ Player Attach enabled")
end

function Modules.PlayerAttach:Disable()
    if not self.State.IsEnabled then return end
    
    -- Detach if attached
    if self.State.IsAttached then
        self:DetachFromPlayer()
    end
    
    self.State.IsEnabled = false
    
    -- Disconnect all connections
    for _, conn in pairs(self.State.Connections) do
        if conn then
            conn:Disconnect()
        end
    end
    table.clear(self.State.Connections)
    
    -- Destroy UI
    if self.State.UI then
        self.State.UI:Destroy()
        self.State.UI = nil
    end
    
    self.State.AttachedTo = nil
    
    print("âœ“ Player Attach disabled")
end

function Modules.PlayerAttach:Toggle()
    if self.State.IsEnabled then
        self:Disable()
    else
        self:Enable()
    end
end

RegisterCommand({
    Name = "attach",
    Aliases = {"playerattach", "follow", "stick"},
    Description = "Attaches you behind a target player like an auto-farmer. Float and follow them anywhere."
}, function()
    Modules.PlayerAttach:Toggle()
end)
Modules.ProximityPromptTools = {
    State = {
        InstantPromptConnection = nil
    },
    Dependencies = {"Workspace", "ProximityPromptService"},
    Services = {}
}
function Modules.ProximityPromptTools:DisableInstantPrompts()
    if self.State.InstantPromptConnection then
        self.State.InstantPromptConnection:Disconnect()
        self.State.InstantPromptConnection = nil
        DoNotif("Instant Proximity Prompts: DISABLED", 2)
    end
end
function Modules.ProximityPromptTools:EnableInstantPrompts()
    if not fireproximityprompt then
        return DoNotif("Environment does not support 'fireproximityprompt'.", 4)
    end
    self:DisableInstantPrompts()
    self.State.InstantPromptConnection = self.Services.ProximityPromptService.PromptButtonHoldBegan:Connect(function(prompt)
        fireproximityprompt(prompt)
    end)
    DoNotif("Instant Proximity Prompts: ENABLED", 2)
end
function Modules.ProximityPromptTools:Initialize()
    for _, serviceName in ipairs(self.Dependencies) do
        self.Services[serviceName] = game:GetService(serviceName)
    end
    RegisterCommand({
        Name = "removepplimits",
        Aliases = {},
        Description = "Removes the distance limit for all ProximityPrompts."
    }, function()
        local count = 0
        for _, v in pairs(self.Services.Workspace:GetDescendants()) do
            if v:IsA("ProximityPrompt") then
                v.MaxActivationDistance = math.huge
                count = count + 1
            end
        end
        DoNotif("Removed distance limits on " .. count .. " ProximityPrompts.", 2)
    end)
    RegisterCommand({
        Name = "fireproximityprompts",
        Aliases = {"firepp"},
        Description = "Fires all ProximityPrompts, or a specific one by name."
    }, function(args)
        if not fireproximityprompt then
            return DoNotif("Environment does not support 'fireproximityprompt'.", 4)
        end
        local count = 0
        if args[1] then
            local name = table.concat(args, " ")
            for _, descendant in ipairs(self.Services.Workspace:GetDescendants()) do
                if descendant:IsA("ProximityPrompt") and (descendant.Name == name or descendant.Parent.Name == name) then
                    fireproximityprompt(descendant)
                    count = count + 1
                end
            end
        else
            for _, descendant in ipairs(self.Services.Workspace:GetDescendants()) do
                if descendant:IsA("ProximityPrompt") then
                    fireproximityprompt(descendant)
                    count = count + 1
                end
            end
        end
        DoNotif("Fired " .. count .. " ProximityPrompt(s).", 2)
    end)
    RegisterCommand({
        Name = "instantproximityprompts",
        Aliases = {"instantpp"},
        Description = "Toggles instant triggering of proximity prompts."
    }, function()
        if self.State.InstantPromptConnection then
            self:DisableInstantPrompts()
        else
            self:EnableInstantPrompts()
        end
    end)
    RegisterCommand({
        Name = "uninstantproximityprompts",
        Aliases = {"uninstantpp"},
        Description = "Explicitly disables instant proximity prompts."
    }, function()
        self:DisableInstantPrompts()
    end)
end
Modules.RevealInvisible = {
    State = {
        Connection = nil,
        OriginalTransparency = setmetatable({}, {__mode="k"}),
    },
    Dependencies = {"RunService", "Workspace"},
}
function Modules.RevealInvisible:Disable()
    if not self.State.Connection then return end
    self.State.Connection:Disconnect()
    self.State.Connection = nil
    for part, originalValue in pairs(self.State.OriginalTransparency) do
        if part and part.Parent then
            part.Transparency = originalValue
        end
    end
    table.clear(self.State.OriginalTransparency)
    DoNotif("Invisible parts have been hidden again.", 2)
end
function Modules.RevealInvisible:Enable()
    self:Disable()
    local partsRevealed = 0
    for _, part in ipairs(self.Services.Workspace:GetDescendants()) do
        if part:IsA("BasePart") and part.Transparency > 0.95 then
            if self.State.OriginalTransparency[part] == nil then
                self.State.OriginalTransparency[part] = part.Transparency
                part.Transparency = 0.5
                partsRevealed = partsRevealed + 1
            end
        end
    end
    DoNotif("Initial scan revealed " .. partsRevealed .. " invisible parts.", 2)
    self.State.Connection = self.Services.RunService.RenderStepped:Connect(function()
        for _, part in ipairs(self.Services.Workspace:GetDescendants()) do
            if part:IsA("BasePart") and part.Transparency > 0.95 and not self.State.OriginalTransparency[part] then
                self.State.OriginalTransparency[part] = part.Transparency
                part.Transparency = 0.5
            end
        end
    end)
end
function Modules.RevealInvisible:Initialize()
    self.Services = {}
    for _, service in ipairs(self.Dependencies) do
        self.Services[service] = game:GetService(service)
    end
    RegisterCommand({
        Name = "invisibleparts",
        Aliases = {"invisparts", "showinvisible"},
        Description = "Toggles the visibility of all invisible parts in the workspace."
    }, function()
        if self.State.Connection then
            self:Disable()
        else
            self:Enable()
        end
    end)
end
Modules.GripEditor = {
    State = {
        UI = {},
        GripConnection = nil
    },
    Dependencies = {"Players", "CoreGui", "UserInputService"},
    Services = {}
}
function Modules.GripEditor:_makeDraggable(guiObject, dragHandle)
    local isDragging = false
    local dragStart, startPosition
    dragHandle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging = true
            dragStart = input.Position
            startPosition = guiObject.Position
            local inputEndedConn
            inputEndedConn = self.Services.UserInputService.InputEnded:Connect(function(endInput)
                if endInput.UserInputType == input.UserInputType then
                    isDragging = false
                    inputEndedConn:Disconnect()
                end
            end)
        end
    end)
    self.Services.UserInputService.InputChanged:Connect(function(input)
        if (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) and isDragging then
            local delta = input.Position - dragStart
            guiObject.Position = UDim2.new(
                startPosition.X.Scale, startPosition.X.Offset + delta.X,
                startPosition.Y.Scale, startPosition.Y.Offset + delta.Y
            )
        end
    end)
end
function Modules.GripEditor:_applyGrip()
    local localPlayer = self.Services.Players.LocalPlayer
    local char = localPlayer.Character
    local backpack = localPlayer:FindFirstChildOfClass("Backpack")
    local tool = char and char:FindFirstChildOfClass("Tool")
    if not (tool and backpack) then
        return DoNotif("You must be holding a tool to edit its grip.", 3)
    end
    if self.State.GripConnection then
        self.State.GripConnection:Disconnect()
        self.State.GripConnection = nil
    end
    local function getVal(name)
        return tonumber(self.State.UI.TextBoxes[name].Text) or 0
    end
    local pos = Vector3.new(getVal("X"), getVal("Y"), getVal("Z"))
    local rot = Vector3.new(getVal("RX"), getVal("RY"), getVal("RZ"))
    local gripCFrame = CFrame.new(pos) * CFrame.Angles(math.rad(rot.X), math.rad(rot.Y), math.rad(rot.Z))
    tool.Parent = backpack
    task.wait()
    tool.Grip = gripCFrame
    tool.Parent = char
    self.State.GripConnection = tool.Changed:Connect(function(property)
        if property == "Grip" and tool.Grip ~= gripCFrame then
            tool.Grip = gripCFrame
        end
    end)
end
function Modules.GripEditor:CreateUI()
    if self.State.UI.ScreenGui then return end
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "GripEditorUI_Module"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = self.Services.CoreGui
    self.State.UI.ScreenGui = screenGui
    local frame = Instance.new("Frame")
    frame.Size = UDim2.fromOffset(320, 270)
    frame.Position = UDim2.fromScale(0.5, 0.5)
    frame.AnchorPoint = Vector2.new(0.5, 0.5)
    frame.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    frame.Parent = screenGui
    Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 6)
    local titleBar = Instance.new("Frame")
    titleBar.Size = UDim2.new(1, 0, 0, 30)
    titleBar.BackgroundColor3 = Color3.fromRGB(60, 60, 75)
    titleBar.Parent = frame
    Instance.new("UICorner", titleBar).CornerRadius = UDim.new(0, 6)
    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, 0, 1, 0)
    title.BackgroundTransparency = 1
    title.Text = "Grip Position Editor"
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.Font = Enum.Font.GothamBold
    title.TextSize = 16
    title.Parent = titleBar
    local labels = {"X", "Y", "Z", "RX", "RY", "RZ"}
    self.State.UI.TextBoxes = {}
    for i, label in ipairs(labels) do
        local xOffset = ((i - 1) % 3) * 100
        local yOffset = 40 + math.floor((i - 1) / 3) * 50
        local labelUI = Instance.new("TextLabel", frame)
        labelUI.Size = UDim2.fromOffset(40, 25)
        labelUI.Position = UDim2.fromOffset(10 + xOffset, yOffset)
        labelUI.BackgroundTransparency = 1
        labelUI.Text = label
        labelUI.TextColor3 = Color3.fromRGB(255, 255, 255)
        labelUI.Font = Enum.Font.Gotham
        labelUI.TextSize = 14
        local box = Instance.new("TextBox", frame)
        box.Size = UDim2.fromOffset(50, 25)
        box.Position = UDim2.fromOffset(50 + xOffset, yOffset)
        box.PlaceholderText = "0"
        box.Text = ""
        box.Font = Enum.Font.Gotham
        box.TextSize = 14
        box.BackgroundColor3 = Color3.fromRGB(45, 45, 55)
        box.TextColor3 = Color3.fromRGB(255, 255, 255)
        box.ClearTextOnFocus = false
        Instance.new("UICorner", box).CornerRadius = UDim.new(0, 4)
        self.State.UI.TextBoxes[label] = box
    end
    local previewBtn = Instance.new("TextButton", frame)
    previewBtn.Size = UDim2.fromOffset(280, 28)
    previewBtn.Position = UDim2.fromOffset(20, 150)
    previewBtn.Text = "Preview Changes"
    previewBtn.Font = Enum.Font.GothamBold
    previewBtn.BackgroundColor3 = Color3.fromRGB(75, 75, 95)
    previewBtn.TextColor3 = Color3.new(1, 1, 1)
    Instance.new("UICorner", previewBtn).CornerRadius = UDim.new(0, 4)
    local applyBtn = Instance.new("TextButton", frame)
    applyBtn.Size = UDim2.fromOffset(135, 32)
    applyBtn.Position = UDim2.fromOffset(20, 200)
    applyBtn.Text = "Apply & Close"
    applyBtn.Font = Enum.Font.GothamBold
    applyBtn.BackgroundColor3 = Color3.fromRGB(0, 170, 80)
    applyBtn.TextColor3 = Color3.new(1, 1, 1)
    Instance.new("UICorner", applyBtn).CornerRadius = UDim.new(0, 4)
    local closeBtn = Instance.new("TextButton", frame)
    closeBtn.Size = UDim2.fromOffset(135, 32)
    closeBtn.Position = UDim2.fromOffset(165, 200)
    closeBtn.Text = "Close"
    closeBtn.Font = Enum.Font.GothamBold
    closeBtn.BackgroundColor3 = Color3.fromRGB(180, 40, 40)
    closeBtn.TextColor3 = Color3.new(1, 1, 1)
    Instance.new("UICorner", closeBtn).CornerRadius = UDim.new(0, 4)
    previewBtn.MouseButton1Click:Connect(function() self:_applyGrip() end)
    applyBtn.MouseButton1Click:Connect(function() self:_applyGrip(); self:DestroyUI() end)
    closeBtn.MouseButton1Click:Connect(function() self:DestroyUI() end)
    self:_makeDraggable(frame, titleBar)
    DoNotif("Grip Editor opened.", 2)
end
function Modules.GripEditor:DestroyUI()
    if self.State.UI.ScreenGui then
        self.State.UI.ScreenGui:Destroy()
    end
    if self.State.GripConnection then
        self.State.GripConnection:Disconnect()
    end
    self.State = { UI = {} }
    DoNotif("Grip Editor closed.", 2)
end
function Modules.GripEditor:Initialize()
    local module = self
    for _, service in ipairs(self.Dependencies) do
        module.Services[service] = game:GetService(service)
    end
    RegisterCommand({
        Name = "grippos",
        Aliases = {"setgrip", "gripeditor"},
        Description = "Toggles a UI to manually edit your tool's grip CFrame."
    }, function()
        if module.State.UI.ScreenGui then
            module:DestroyUI()
        else
            module:CreateUI()
        end
    end)
end
Modules.AnimationBuilder = {
    State = {
        UI = nil,
        OriginalAnimations = nil
    },
    Dependencies = {"Players", "CoreGui", "TweenService", "UserInputService"},
    Services = {}
}
function Modules.AnimationBuilder:_makeDraggable(guiObject, dragHandle)
    local isDragging = false
    local dragStart, startPosition
    dragHandle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging = true
            dragStart = input.Position
            startPosition = guiObject.Position
            local inputEndedConn
            inputEndedConn = self.Services.UserInputService.InputEnded:Connect(function(endInput)
                if endInput.UserInputType == input.UserInputType then
                    isDragging = false
                    inputEndedConn:Disconnect()
                end
            end)
        end
    end)
    self.Services.UserInputService.InputChanged:Connect(function(input)
        if (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) and isDragging then
            local delta = input.Position - dragStart
            guiObject.Position = UDim2.new(
                startPosition.X.Scale, startPosition.X.Offset + delta.X,
                startPosition.Y.Scale, startPosition.Y.Offset + delta.Y
            )
        end
    end)
end
function Modules.AnimationBuilder:DestroyUI()
    if not self.State.UI then return end
    local mainFrame = self.State.UI.main
    local tween = self.Services.TweenService:Create(mainFrame, TweenInfo.new(0.25, Enum.EasingStyle.Quint), {
        Size = UDim2.fromScale(0.01, 0.01),
        Position = UDim2.new(0.99, 0, 0.01, 0),
        BackgroundTransparency = 1
    })
    tween:Play()
    tween.Completed:Wait()
    self.State.UI.screenGui:Destroy()
    self.State.UI = nil
    DoNotif("Animation Builder closed.", 2)
end
function Modules.AnimationBuilder:CreateUI()
    if self.State.UI then return end
    local localPlayer = self.Services.Players.LocalPlayer
    local char = localPlayer.Character
    local animateScript = char and char:FindFirstChild("Animate")
    if not animateScript then
        return DoNotif("Could not find 'Animate' script in character.", 4)
    end
    if not self.State.OriginalAnimations then
        self.State.OriginalAnimations = {}
        for _, valueObject in ipairs(animateScript:GetChildren()) do
            if valueObject:IsA("StringValue") then
                local anim = valueObject:FindFirstChildOfClass("Animation")
                if anim then
                    self.State.OriginalAnimations[valueObject.Name:lower()] = anim.AnimationId
                end
            end
        end
    end
    self.State.UI = {}
    local ui = self.State.UI
    ui.screenGui = Instance.new("ScreenGui")
    ui.screenGui.Name = "AnimationBuilder_Module"
    ui.screenGui.ResetOnSpawn = false
    ui.screenGui.Parent = self.Services.CoreGui
    ui.main = Instance.new("Frame", ui.screenGui)
    ui.main.Size = UDim2.new(0, 400, 0, 450)
    ui.main.Position = UDim2.fromScale(0.5, 0.5)
    ui.main.AnchorPoint = Vector2.new(0.5, 0.5)
    ui.main.BackgroundColor3 = Color3.fromRGB(28, 28, 32)
    ui.main.BorderSizePixel = 0
    Instance.new("UICorner", ui.main).CornerRadius = UDim.new(0, 8)
    local header = Instance.new("Frame", ui.main)
    header.Size = UDim2.new(1, 0, 0, 40)
    header.BackgroundColor3 = Color3.fromRGB(24, 24, 26)
    Instance.new("UICorner", header).CornerRadius = UDim.new(0, 8)
    local title = Instance.new("TextLabel", header)
    title.Size = UDim2.new(1, -50, 1, 0)
    title.Position = UDim2.fromOffset(15, 0)
    title.BackgroundTransparency = 1
    title.Text = "Animation Builder"
    title.TextColor3 = Color3.fromRGB(240, 240, 240)
    title.Font = Enum.Font.GothamBold
    title.TextSize = 18
    title.TextXAlignment = Enum.TextXAlignment.Left
    local closeBtn = Instance.new("TextButton", header)
    closeBtn.Size = UDim2.fromOffset(40, 40)
    closeBtn.Position = UDim2.new(1, 0, 0.5, 0)
    closeBtn.AnchorPoint = Vector2.new(1, 0.5)
    closeBtn.BackgroundTransparency = 1
    closeBtn.Text = "X"
    closeBtn.TextColor3 = Color3.fromRGB(255, 90, 90)
    closeBtn.Font = Enum.Font.GothamBold
    closeBtn.TextSize = 20
    local scroll = Instance.new("ScrollingFrame", ui.main)
    scroll.Size = UDim2.new(1, 0, 1, -100)
    scroll.Position = UDim2.fromOffset(0, 40)
    scroll.BackgroundTransparency = 1
    scroll.BorderSizePixel = 0
    scroll.ScrollBarThickness = 6
    local listLayout = Instance.new("UIListLayout", scroll)
    listLayout.Padding = UDim.new(0, 8)
    listLayout.SortOrder = Enum.SortOrder.LayoutOrder
    local padding = Instance.new("UIPadding", scroll)
    padding.PaddingLeft = UDim.new(0, 15)
    padding.PaddingRight = UDim.new(0, 15)
    padding.PaddingTop = UDim.new(0, 15)
    local footer = Instance.new("Frame", ui.main)
    footer.Size = UDim2.new(1, 0, 0, 60)
    footer.Position = UDim2.new(0, 0, 1, -60)
    footer.BackgroundTransparency = 1
    local saveBtn = Instance.new("TextButton", footer)
    saveBtn.Size = UDim2.new(0.5, -15, 0.7, 0)
    saveBtn.Position = UDim2.fromOffset(10, 10)
    saveBtn.BackgroundColor3 = Color3.fromRGB(60, 140, 80)
    saveBtn.Text = "ðŸ’¾ Save"
    saveBtn.TextColor3 = Color3.new(1,1,1)
    saveBtn.Font = Enum.Font.GothamSemibold
    saveBtn.TextSize = 16
    Instance.new("UICorner", saveBtn).CornerRadius = UDim.new(0, 6)
    local revertBtn = saveBtn:Clone()
    revertBtn.Position = UDim2.new(0.5, 5, 0, 10)
    revertBtn.BackgroundColor3 = Color3.fromRGB(160, 80, 80)
    revertBtn.Text = "â†©ï¸ Revert"
    revertBtn.Parent = footer
    ui.inputs = {}
    local states = {"Idle", "Walk", "Run", "Jump", "Fall", "Climb", "Sit"}
    for _, name in ipairs(states) do
        local row = Instance.new("Frame", scroll)
        row.Size = UDim2.new(1, 0, 0, 40)
        row.BackgroundColor3 = Color3.fromRGB(36, 36, 40)
        Instance.new("UICorner", row).CornerRadius = UDim.new(0, 6)
        local label = Instance.new("TextLabel", row)
        label.Size = UDim2.new(0.25, 0, 1, 0)
        label.Position = UDim2.fromOffset(10, 0)
        label.BackgroundTransparency = 1
        label.Text = name
        label.TextColor3 = Color3.new(1,1,1)
        label.Font = Enum.Font.GothamSemibold
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.TextSize = 15
        local box = Instance.new("TextBox", row)
        box.Size = UDim2.new(0.75, -20, 0.8, 0)
        box.Position = UDim2.new(0.25, 0, 0.5, 0)
        box.AnchorPoint = Vector2.new(0, 0.5)
        box.PlaceholderText = "rbxassetid://"
        box.ClearTextOnFocus = false
        box.TextColor3 = Color3.new(1,1,1)
        box.BackgroundColor3 = Color3.fromRGB(50, 50, 55)
        box.Font = Enum.Font.Code
        box.TextSize = 14
        Instance.new("UICorner", box).CornerRadius = UDim.new(0, 4)
        ui.inputs[name:lower()] = box
    end
    local function applyAnims(mode)
        local currentAnimate = localPlayer.Character and localPlayer.Character:FindFirstChild("Animate")
        if not currentAnimate then return DoNotif("Animate script not found.", 3) end
        for stateName, animId in pairs(mode == "save" and ui.inputs or self.State.OriginalAnimations) do
            local valueObj = currentAnimate:FindFirstChild(stateName, true)
            if valueObj then
                local anim = valueObj:FindFirstChildOfClass("Animation")
                if anim then
                    if mode == "save" then
                        local text = animId.Text
                        if tonumber(text) then
                            anim.AnimationId = "rbxassetid://" .. text
                        end
                    else
                        anim.AnimationId = animId
                        local num = animId:match("%d+")
                        if num and ui.inputs[stateName] then
                            ui.inputs[stateName].Text = num
                        end
                    end
                end
            end
        end
        DoNotif(mode == "save" and "Animations saved." or "Animations reverted.", 2)
    end
    for stateName, textBox in pairs(ui.inputs) do
        local originalId = self.State.OriginalAnimations[stateName]
        if originalId then
            local num = originalId:match("%d+")
            if num then textBox.Text = num end
        end
    end
    closeBtn.MouseButton1Click:Connect(function() self:DestroyUI() end)
    saveBtn.MouseButton1Click:Connect(function() applyAnims("save") end)
    revertBtn.MouseButton1Click:Connect(function() applyAnims("revert") end)
    self:_makeDraggable(ui.main, header)
    DoNotif("Animation Builder opened.", 2)
end
function Modules.AnimationBuilder:Initialize()
    local module = self
    for _, service in ipairs(self.Dependencies) do
        module.Services[service] = game:GetService(service)
    end
    RegisterCommand({
        Name = "animbuilder",
        Aliases = {"abuilder"},
        Description = "Toggles a UI to edit your character's default animations."
    }, function()
        if module.State.UI then
            module:DestroyUI()
        else
            module:CreateUI()
        end
    end)
end
Modules.CharacterMorph = {
    State = {
        IsMorphed = false,
        OriginalDescription = nil,
        CharacterAddedConnection = nil
    },
    Dependencies = {"Players"},
    Services = {}
}
function Modules.CharacterMorph:_resolveDescription(target: string)
    local targetId = tonumber(target)
    if not targetId then
        local success, idFromName = pcall(function()
            return self.Services.Players:GetUserIdFromNameAsync(target)
        end)
        if not success or not idFromName then
            DoNotif("Could not find a user with the name: " .. tostring(target), 3)
            return nil
        end
        targetId = idFromName
    end
    DoNotif("Loading avatar for UserId: " .. targetId, 1.5)
    local success, description = pcall(function()
        return self.Services.Players:GetHumanoidDescriptionFromUserId(targetId)
    end)
    if not success or not description then
        DoNotif("Unable to load avatar description for that user.", 3)
        return nil
    end
    return description
end
function Modules.CharacterMorph:_applyAndRespawn(description: HumanoidDescription)
    local localPlayer = self.Services.Players.LocalPlayer
    if not description then return end
    if self.State.CharacterAddedConnection then
        self.State.CharacterAddedConnection:Disconnect()
        self.State.CharacterAddedConnection = nil
    end
    self.State.CharacterAddedConnection = localPlayer.CharacterAdded:Once(function(character)
        local humanoid = character:WaitForChild("Humanoid", 5)
        if humanoid then
            pcall(humanoid.ApplyDescription, humanoid, description)
        end
    end)
    localPlayer:LoadCharacter()
end
function Modules.CharacterMorph:Morph(target: string)
    if not target then
        return DoNotif("Usage: ;avatar <username/userid>", 3)
    end
    if not self.State.OriginalDescription then
        local success, originalDesc = pcall(function()
            return self.Services.Players:GetHumanoidDescriptionFromUserId(self.Services.Players.LocalPlayer.UserId)
        end)
        if success then
            self.State.OriginalDescription = originalDesc
        else
            warn("[CharacterMorph] Could not cache original character description.")
        end
    end
    task.spawn(function()
        local newDescription = self:_resolveDescription(target)
        if newDescription then
            self.State.IsMorphed = true
            self:_applyAndRespawn(newDescription)
            DoNotif("Applying character morph...", 2)
        end
    end)
end
function Modules.CharacterMorph:Revert()
    if not self.State.IsMorphed then
        return DoNotif("You are not currently morphed.", 2)
    end
    if not self.State.OriginalDescription then
        return DoNotif("Failed to revert: Original avatar description is missing.", 4)
    end
    self:_applyAndRespawn(self.State.OriginalDescription)
    self.State.IsMorphed = false
    DoNotif("Reverting to original character...", 2)
end
function Modules.CharacterMorph:Initialize()
    local module = self
    for _, service in ipairs(self.Dependencies) do
        module.Services[service] = game:GetService(service)
    end
    RegisterCommand({
        Name = "swapinto",
        Aliases = {"morph"},
        Description = "Change your character's appearance to someone else's."
    }, function(args)
        module:Morph(args[1])
    end)
    RegisterCommand({
        Name = "default",
        Aliases = {},
        Description = "Reverts your character's appearance to your own."
    }, function()
        module:Revert()
    end)
end
Modules.Chams = {
    State = {
        IsEnabled = false,
        TrackedCharacters = setmetatable({}, {__mode = "k"}),
        OriginalProperties = setmetatable({}, {__mode = "k"}),
        Connections = {}
    },
    Config = {
        VisibleColor = Color3.fromRGB(0, 255, 0),
        OccludedColor = Color3.fromRGB(255, 0, 0),
        Material = Enum.Material.Neon,
        HighlightTransparency = 0
    },
    Services = {
        Players = game:GetService("Players"),
        RunService = game:GetService("RunService")
    }
}
function Modules.Chams:_apply(character)
    if not character or self.State.TrackedCharacters[character] then return end
    local highlight = Instance.new("Highlight", character)
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.FillColor = self.Config.OccludedColor
    highlight.OutlineColor = Color3.fromRGB(0, 0, 0)
    highlight.FillTransparency = self.Config.HighlightTransparency
    local innerHighlight = Instance.new("Highlight", character)
    innerHighlight.DepthMode = Enum.HighlightDepthMode.Occluded
    innerHighlight.FillColor = self.Config.VisibleColor
    innerHighlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    innerHighlight.FillTransparency = self.Config.HighlightTransparency
    self.State.TrackedCharacters[character] = {highlight, innerHighlight}
end
function Modules.Chams:_revert(character)
    if not character or not self.State.TrackedCharacters[character] then return end
    for _, effect in ipairs(self.State.TrackedCharacters[character]) do
        pcall(function() effect:Destroy() end)
    end
    self.State.TrackedCharacters[character] = nil
end
function Modules.Chams:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    local function setupPlayer(player)
        if player == self.Services.Players.LocalPlayer then return end
        if player.Character then
            self:_apply(player.Character)
        end
        self.State.Connections[player] = {}
        self.State.Connections[player].CharacterAdded = player.CharacterAdded:Connect(function(char) self:_apply(char) end)
        self.State.Connections[player].CharacterRemoving = player.CharacterRemoving:Connect(function(char) self:_revert(char) end)
    end
    for _, player in ipairs(self.Services.Players:GetPlayers()) do
        setupPlayer(player)
    end
    self.State.Connections.PlayerAdded = self.Services.Players.PlayerAdded:Connect(setupPlayer)
    self.State.Connections.PlayerRemoving = self.Services.Players.PlayerRemoving:Connect(function(player)
        if self.State.Connections[player] then
            for _, conn in pairs(self.State.Connections[player]) do
                conn:Disconnect()
            end
            self.State.Connections[player] = nil
        end
    end)
    DoNotif("Chams: ENABLED", 2)
end
function Modules.Chams:Disable()
    if not self.State.IsEnabled then return end
    self.State.IsEnabled = false
    for player, conns in pairs(self.State.Connections) do
        if type(conns) == "table" then
            for _, conn in pairs(conns) do
                conn:Disconnect()
            end
        else
            conns:Disconnect()
        end
    end
    table.clear(self.State.Connections)
    for character, _ in pairs(self.State.TrackedCharacters) do
        self:_revert(character)
    end
    DoNotif("Chams: DISABLED", 2)
end
RegisterCommand({
    Name = "chams",
    Aliases = {},
    Description = "Toggles a solid color ESP on all other players."
}, function()
    if Modules.Chams.State.IsEnabled then
        Modules.Chams:Disable()
    else
        Modules.Chams:Enable()
    end
end)
Modules.InfiniteJump = {
    State = {
        IsEnabled = false,
        Connection = nil
    },
    Services = {
        Players = game:GetService("Players"),
        UserInputService = game:GetService("UserInputService")
    }
}
function Modules.InfiniteJump:OnInput(input, gameProcessed)
    if gameProcessed or not self.State.IsEnabled then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.Space then
        local character = self.Services.Players.LocalPlayer.Character
        local humanoid = character and character:FindFirstChildOfClass("Humanoid")
        if humanoid and humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end
end
function Modules.InfiniteJump:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    self.State.Connection = self.Services.UserInputService.JumpRequest:Connect(function()
        self:OnInput({UserInputType = Enum.UserInputType.Keyboard, KeyCode = Enum.KeyCode.Space}, false)
    end)
    DoNotif("Infinite Jump: ENABLED", 2)
end
function Modules.InfiniteJump:Disable()
    if not self.State.IsEnabled then return end
    self.State.IsEnabled = false
    if self.State.Connection then
        self.State.Connection:Disconnect()
        self.State.Connection = nil
    end
    DoNotif("Infinite Jump: DISABLED", 2)
end
RegisterCommand({
    Name = "infjump",
    Aliases = {"infinitejump"},
    Description = "Toggles the ability to jump infinitely in the air."
}, function()
    if Modules.InfiniteJump.State.IsEnabled then
        Modules.InfiniteJump:Disable()
    else
        Modules.InfiniteJump:Enable()
    end
end)
Modules.ScriptView = {
    State = {
        IsEnabled = false,
        UI = nil,
        Syntax = true,
        CurrentSource = "",
        CurrentName = "",
        Open = false,
        OtherDone = 1
    },
    Config = {
        Operators = {
            ['bracket'] = Color3.fromRGB(204, 104, 147),
            ['math']    = Color3.fromRGB(204, 104, 147),
            ['compare'] = Color3.fromRGB(204, 104, 147),
            ['misc']    = Color3.fromRGB(204, 104, 147),
        },
        Textures = {
            ['folder']       = "2950788693",
            ['localscript']  = "99340858",
            ['modulescript'] = "413367412",
            ['function']     = "2759601950",
            ['variable']     = "2759602224",
            ['table']        = "2757039628",
            ['constant']     = "2717878542",
            ['upvalue']      = "2717876089",
        }
    }
}
function Modules.ScriptView:Initialize()
    local module = self
    local state = self.State
    local config = self.Config
    RegisterCommand({
        Name = "scriptview",
        Aliases = {"sv", "forensics", "decompile"},
        Description = "Opens ScriptView (Home/RShift). Decompile scripts and explore memory."
    }, function()
        if state.UI then
            state.Open = not state.Open
            if state.Open then module:Open() else module:Close() end
            return
        end
        local success, err = pcall(function()
            local screenGui = game:GetObjects("rbxassetid://2971927607")[1]
            local backdrop = screenGui.Backdrop
            local lexer_mod = game:GetObjects('rbxassetid://2798231692')[1]
            local lexer = loadstring(lexer_mod.Source)()
            screenGui.Parent = CoreGui
            state.UI = screenGui
            local scriptList = backdrop.Debugger.Scripts
            local sourceFrame = backdrop.ScriptFrame.Source
            local debugTemplate = scriptList.Template; debugTemplate.Parent = nil
            local lineTemplate = sourceFrame.Line; lineTemplate.Parent = nil
            local wordTemplate = lineTemplate.Word; wordTemplate.Parent = nil
            local tabsFrame = backdrop.Tabs
            local tabTemplate = tabsFrame.Deselected; tabTemplate.Parent = nil
            local ttemp = tabsFrame.Selected; ttemp.Parent = nil
            local function GVT(v, def)
                return (type(v) == "function" and "function") or (type(v) == "table" and "table") or def or "variable"
            end
            local function getEnv(scr)
                local g_env = getsenv or getmenv
                if not g_env then return {ERROR = "No env access"} end
                return (scr:IsA("LocalScript") and (getsenv and getsenv(scr))) or (getmenv and getmenv(scr))
            end
            local function Tween(Obj, Dir, Style, Duration, Goal)
                local tween = game:GetService("TweenService"):Create(Obj, TweenInfo.new(Duration, Enum.EasingStyle[Style], Enum.EasingDirection[Dir]), Goal)
                tween:Play()
                return tween
            end
            local function loadSource(source)
                state.CurrentSource = source
                for _, v in pairs(sourceFrame:GetChildren()) do
                    if v.Name == "Line" then v:Destroy() end
                end
                local lines = {}
                local tblLine = {}
                for typ, word in lexer.scan(source) do
                    if word:find("\n") then
                        word = word:gsub("\n", "")
                        if word == "" then word = " " end
                        table.insert(tblLine, {typ, word})
                        table.insert(lines, tblLine)
                        tblLine = {}
                    else
                        table.insert(tblLine, {typ, word})
                    end
                end
                table.insert(lines, tblLine)
                for num, lineTable in ipairs(lines) do
                    local line = lineTemplate:Clone()
                    line.LineNumber.Text = tostring(num).."  "
                    line.Parent = sourceFrame
                    for _, wordData in ipairs(lineTable) do
                        local word = wordTemplate:Clone()
                        word.Parent = line
                        word.String.Text = wordData[2]
                        local txtSize = game:GetService("TextService"):GetTextSize(word.String.Text, word.String.TextSize, word.String.Font, Vector2.new(10000, 25))
                        word.String.Size = UDim2.new(0, txtSize.X, 1, 0)
                        word.Size = word.String.Size
                        if state.Syntax then
                        end
                    end
                end
            end
            local function createButton(parent, info)
                local button = debugTemplate:Clone()
                local par = (parent:FindFirstChild("Contents")) or parent
                button.Label.Text = info.Name
                button.Icon.Image = "rbxassetid://" .. (config.Textures[info.Type:lower()] or config.Textures.variable)
                button.Parent = par
                button.Clicked.MouseButton1Click:Connect(function()
                    if info.Type:lower():find("script") then
                        local success, src = pcall(decompile, info.Obj)
                        loadSource(success and src or "-- Decompilation Failed")
                    end
                end)
                button.Expand.MouseButton1Click:Connect(function()
                    button.Contents.Visible = not button.Contents.Visible
                    if button.Contents.Visible then
                        for _, child in ipairs(info.Obj:GetChildren()) do
                            createButton(button, {Name = child.Name, Type = child.ClassName, Obj = child})
                        end
                    end
                end)
            end
            createButton(scriptList, {Name="Active Scripts", Type="Folder", Obj=game})
            createButton(scriptList, {Name="LocalPlayer", Type="Folder", Obj=game:GetService("Players").LocalPlayer})
            createButton(scriptList, {Name="Nil", Type="Folder", Obj=nil})
            module.Open = function()
                Tween(backdrop, "Out", "Sine", 0.2, {
                    Position = UDim2.new(0.5, -400, 0.5, -250),
                    Size = UDim2.new(0, 800, 0, 500)
                })
                state.Open = true
            end
            module.Close = function()
                Tween(backdrop, "Out", "Sine", 0.2, {
                    Position = UDim2.new(0.5, 0, 1, 2),
                    Size = UDim2.new(0.25, 0, 0.25, 0)
                })
                state.Open = false
            end
            UserInputService.InputBegan:Connect(function(input)
                if input.KeyCode == Enum.KeyCode.Home or input.KeyCode == Enum.KeyCode.RightShift then
                    state.Open = not state.Open
                    if state.Open then module.Open() else module.Close() end
                end
            end)
            DoNotif("ScriptView forensic module enabled.", 3)
        end)
        if not success then
            warn("--> [FORENSIC]: ScriptView Failed to Load Assets: " .. tostring(err))
            DoNotif("ScriptView failed: Assets unavailable.", 5)
        end
    end)
end
Modules.Gravity = {
    State = {
        IsEnabled = false,
        OriginalGravity = nil
    },
    Services = {
        Workspace = game:GetService("Workspace")
    }
}
function Modules.Gravity:Enable(newGravityValue)
    if not self.State.IsEnabled then
        self.State.OriginalGravity = self.Services.Workspace.Gravity
    end
    self.State.IsEnabled = true
    local newGravity = tonumber(newGravityValue)
    if not newGravity or newGravity <= 0 then
        newGravity = 75
        DoNotif("No gravity value provided. Defaulting to " .. newGravity, 2)
    end
    self.Services.Workspace.Gravity = newGravity
    DoNotif("Client gravity set to: " .. newGravity, 2)
end
function Modules.Gravity:Disable()
    if not self.State.IsEnabled then return end
    if self.State.OriginalGravity then
        self.Services.Workspace.Gravity = self.State.OriginalGravity
    end
    self.State.IsEnabled = false
    self.State.OriginalGravity = nil
    DoNotif("Client gravity restored to default.", 2)
end
RegisterCommand({
    Name = "gravity",
    Aliases = {"grav"},
    Description = "Sets the client-sided workspace gravity. Use 'reset' to disable."
}, function(args)
    local argument = args[1]
    if argument and (argument:lower() == "reset" or argument:lower() == "off") then
        Modules.Gravity:Disable()
    else
        Modules.Gravity:Enable(argument)
    end
end)
Modules.FixCamera = {
    State = {
        Enabled = false,
        Connection = nil,
        OriginalMaxZoom = nil,
        OriginalOcclusionMode = nil,
    }
}
RegisterCommand({
    Name = "fixcam",
    Aliases = {"unlockcam"},
    Description = "Unlocks camera, allows zooming through walls, and forces third-person."
}, function(args)
    if not LocalPlayer then return end
    local self = Modules.FixCamera
    self.State.Enabled = not self.State.Enabled
    if self.State.Enabled then
        self.State.OriginalMaxZoom = LocalPlayer.CameraMaxZoomDistance
        self.State.OriginalOcclusionMode = LocalPlayer.DevCameraOcclusionMode
        LocalPlayer.CameraMaxZoomDistance = 10000
        local success, err = pcall(function()
            LocalPlayer.DevCameraOcclusionMode = Enum.DevCameraOcclusionMode.None
        end)
        if not success then
            warn("FixCamera: Failed to set DevCameraOcclusionMode via Enum. Falling back to 0. Error:", err)
            LocalPlayer.DevCameraOcclusionMode = 0
        end
        self.State.Connection = RunService.RenderStepped:Connect(function()
            if LocalPlayer.CameraMode ~= Enum.CameraMode.Classic then
                LocalPlayer.CameraMode = Enum.CameraMode.Classic
            end
        end)
        DoNotif("Camera override enabled (with wall-zoom).", 3)
    else
        if self.State.Connection and self.State.Connection.Connected then
            self.State.Connection:Disconnect()
            self.State.Connection = nil
        end
        pcall(function()
            if self.State.OriginalOcclusionMode ~= nil then
                LocalPlayer.DevCameraOcclusionMode = self.State.OriginalOcclusionMode
            end
            if self.State.OriginalMaxZoom ~= nil then
                LocalPlayer.CameraMaxZoomDistance = self.State.OriginalMaxZoom
            end
        end)
        self.State.OriginalOcclusionMode = nil
        self.State.OriginalMaxZoom = nil
        DoNotif("Camera override disabled.", 3)
    end
end)
Modules.NoFog = {
    State = {
        IsEnabled = false,
        OriginalProperties = {}
    },
    Services = {
        Lighting = game:GetService("Lighting")
    }
}
function Modules.NoFog:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    self.State.OriginalProperties.FogEnd = self.Services.Lighting.FogEnd
    self.State.OriginalProperties.FogStart = self.Services.Lighting.FogStart
    local atmosphere = self.Services.Lighting:FindFirstChildOfClass("Atmosphere")
    if atmosphere then
        self.State.OriginalProperties.AtmosphereEnabled = atmosphere.Enabled
        atmosphere.Enabled = false
    end
    self.Services.Lighting.FogEnd = 1000000
    self.Services.Lighting.FogStart = 0
    DoNotif("No Fog: ENABLED.", 2)
end
function Modules.NoFog:Disable()
    if not self.State.IsEnabled then return end
    self.State.IsEnabled = false
    if self.State.OriginalProperties.FogEnd then
        self.Services.Lighting.FogEnd = self.State.OriginalProperties.FogEnd
    end
    if self.State.OriginalProperties.FogStart then
        self.Services.Lighting.FogStart = self.State.OriginalProperties.FogStart
    end
    local atmosphere = self.Services.Lighting:FindFirstChildOfClass("Atmosphere")
    if atmosphere and self.State.OriginalProperties.AtmosphereEnabled ~= nil then
        atmosphere.Enabled = self.State.OriginalProperties.AtmosphereEnabled
    end
    self.State.OriginalProperties = {}
    DoNotif("No Fog: DISABLED.", 2)
end
function Modules.NoFog:Toggle()
    if self.State.IsEnabled then
        self:Disable()
    else
        self:Enable()
    end
end
RegisterCommand({
    Name = "nofog",
    Aliases = {"removefog", "antifog"},
    Description = "Toggles client-sided fog."
}, function()
    Modules.NoFog:Toggle()
end)
Modules.Waypoint = {
    State = {
        Waypoints = {},
        Visuals = {}
    },
    Services = {
        Players = game:GetService("Players"),
        Workspace = game:GetService("Workspace"),
        CoreGui = game:GetService("CoreGui")
    }
}
function Modules.Waypoint:_cleanupVisual(name)
    local visual = self.State.Visuals[name:lower()]
    if visual then
        pcall(function()
            visual:Destroy()
        end)
        self.State.Visuals[name:lower()] = nil
    end
end
function Modules.Waypoint:_createVisual(name, cframe)
    self:_cleanupVisual(name)
    local container = Instance.new("Part")
    container.Name = "WaypointVisual_" .. name
    container.Size = Vector3.new(0.1, 0.1, 0.1)
    container.CFrame = cframe
    container.Anchored = true
    container.CanCollide = false
    container.Transparency = 1
    container.Parent = self.Services.Workspace
    local billboard = Instance.new("BillboardGui", container)
    billboard.AlwaysOnTop = true
    billboard.Size = UDim2.fromOffset(200, 50)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    local label = Instance.new("TextLabel", billboard)
    label.Size = UDim2.fromScale(1, 1)
    label.BackgroundTransparency = 1
    label.Font = Enum.Font.GothamSemibold
    label.Text = name
    label.TextColor3 = Color3.fromRGB(0, 255, 255)
    label.TextSize = 24
    label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    label.TextStrokeTransparency = 0.5
    local attachment1 = Instance.new("Attachment", container)
    local attachment2 = Instance.new("Attachment", container)
    attachment2.Position = Vector3.new(0, 1000, 0)
    local beam = Instance.new("Beam", container)
    beam.Attachment0 = attachment1
    beam.Attachment1 = attachment2
    beam.Color = ColorSequence.new(Color3.fromRGB(0, 255, 255))
    beam.FaceCamera = true
    beam.LightEmission = 1
    beam.Width0 = 2
    beam.Width1 = 0
    beam.Transparency = NumberSequence.new(0.25)
    self.State.Visuals[name:lower()] = container
end
function Modules.Waypoint:Add(name)
    if not name or name == "" then
        return DoNotif("You must provide a name for the waypoint.", 3)
    end
    local character = self.Services.Players.LocalPlayer.Character
    local hrp = character and character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        return DoNotif("Cannot set waypoint: Character not found.", 3)
    end
    local key = name:lower()
    self.State.Waypoints[key] = hrp.CFrame
    self:_createVisual(name, hrp.CFrame)
    DoNotif("Waypoint '" .. name .. "' created at your position.", 2)
end
function Modules.Waypoint:Remove(name)
    if not name or name == "" then
        return DoNotif("You must provide a name to remove.", 3)
    end
    local key = name:lower()
    if not self.State.Waypoints[key] then
        return DoNotif("Waypoint '" .. name .. "' does not exist.", 3)
    end
    self.State.Waypoints[key] = nil
    self:_cleanupVisual(name)
    DoNotif("Waypoint '" .. name .. "' removed.", 2)
end
function Modules.Waypoint:Teleport(name)
    if not name or name == "" then
        return DoNotif("You must provide a name to teleport to.", 3)
    end
    local key = name:lower()
    local targetCFrame = self.State.Waypoints[key]
    if not targetCFrame then
        return DoNotif("Waypoint '" .. name .. "' does not exist.", 3)
    end
    local character = self.Services.Players.LocalPlayer.Character
    local hrp = character and character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        return DoNotif("Cannot teleport: Character not found.", 3)
    end
    hrp.CFrame = targetCFrame + Vector3.new(0, 3, 0)
    DoNotif("Teleported to '" .. name .. "'.", 2)
end
function Modules.Waypoint:List()
    local waypointNames = {}
    for name in pairs(self.State.Waypoints) do
        table.insert(waypointNames, name)
    end
    if #waypointNames == 0 then
        return DoNotif("No waypoints have been set.", 3)
    end
    local message = "Waypoints: " .. table.concat(waypointNames, ", ")
    DoNotif(message, 5)
end
function Modules.Waypoint:Clear()
    for name in pairs(self.State.Waypoints) do
        self:_cleanupVisual(name)
    end
    self.State.Waypoints = {}
    DoNotif("All waypoints cleared.", 2)
end
RegisterCommand({
    Name = "waypoint",
    Aliases = {"wp"},
    Description = "Manages waypoints."
}, function(args)
    local subCommand = args[1] and args[1]:lower()
    local name = args[2]
    if subCommand == "add" then
        Modules.Waypoint:Add(name)
    elseif subCommand == "remove" or subCommand == "del" then
        Modules.Waypoint:Remove(name)
    elseif subCommand == "tp" or subCommand == "goto" then
        Modules.Waypoint:Teleport(name)
    elseif subCommand == "list" then
        Modules.Waypoint:List()
    elseif subCommand == "clear" then
        Modules.Waypoint:Clear()
    else
        DoNotif("Usage: ;wp add,remove,tp,list", 4)
    end
end)
Modules.FpsMeter = {
    State = {
        IsEnabled = false,
        UI = {},
        Connection = nil
    },
    Services = {
        RunService = game:GetService("RunService"),
        CoreGui = game:GetService("CoreGui")
    }
}
function Modules.FpsMeter:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "FpsMeter_Zuka"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
    screenGui.Parent = self.Services.CoreGui
    self.State.UI.ScreenGui = screenGui
    local background = Instance.new("Frame", screenGui)
    background.Size = UDim2.fromOffset(140, 30)
    background.Position = UDim2.new(1, -150, 0, 10)
    background.AnchorPoint = Vector2.new(1, 0)
    background.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
    background.BackgroundTransparency = 0.3
    local corner = Instance.new("UICorner", background)
    corner.CornerRadius = UDim.new(0, 4)
    local label = Instance.new("TextLabel", background)
    label.Size = UDim2.fromScale(1, 1)
    label.BackgroundTransparency = 1
    label.Font = Enum.Font.GothamSemibold
    label.TextColor3 = Color3.fromRGB(0, 255, 127)
    label.TextSize = 18
    label.Text = "FPS: ..."
    self.State.UI.Label = label
    local lastUpdate = 0
    local updateInterval = 0.25
    self.State.Connection = self.Services.RunService.Heartbeat:Connect(function(deltaTime)
        local now = os.clock()
        if now - lastUpdate > updateInterval then
            local fps = 1 / deltaTime
            label.Text = string.format("FPS: %.1f", fps)
            lastUpdate = now
        end
    end)
    DoNotif("FPS Meter: ENABLED", 2)
end
function Modules.FpsMeter:Disable()
    if not self.State.IsEnabled then return end
    self.State.IsEnabled = false
    if self.State.Connection then
        self.State.Connection:Disconnect()
        self.State.Connection = nil
    end
    if self.State.UI.ScreenGui then
        self.State.UI.ScreenGui:Destroy()
    end
    self.State.UI = {}
    DoNotif("FPS Meter: DISABLED", 2)
end
function Modules.FpsMeter:Toggle()
    if self.State.IsEnabled then
        self:Disable()
    else
        self:Enable()
    end
end
RegisterCommand({
    Name = "fpsmeter",
    Aliases = {"showfps", "fps"},
    Description = "Toggles a client-side FPS meter."
}, function()
    Modules.FpsMeter:Toggle()
end)
Modules.HitboxESP = {
    State = {
        IsEnabled = false,
        EspEnabled = false,
        HitboxSize = 15,
        IsMinimized = false,
        CurrentTheme = "dark",
        IsDragging = false,
        EspLabels = {},
        EspBoxes = {},
        Connections = {},
        UI = nil,
        LastAnimTime = 0,
        AnimCooldown = 0.15
    },
    Services = {
        Players = game:GetService("Players"),
        RunService = game:GetService("RunService"),
        TweenService = game:GetService("TweenService"),
        UserInputService = game:GetService("UserInputService"),
        CoreGui = game:GetService("CoreGui")
    }
}
function Modules.HitboxESP:AnimateButton(button)
    local currentTime = tick()
    if currentTime - self.State.LastAnimTime < self.State.AnimCooldown then
        return
    end
    self.State.LastAnimTime = currentTime
    local originalSize = button.Size
    local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    self.Services.TweenService:Create(button, tweenInfo, {Size = originalSize + UDim2.new(0, 4, 0, 4)}):Play()
    task.wait(0.1)
    self.Services.TweenService:Create(button, tweenInfo, {Size = originalSize}):Play()
end
function Modules.HitboxESP:ApplyTheme(theme)
    self.State.CurrentTheme = theme
    local ui = self.State.UI
    if not ui then return end
    local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local TS = self.Services.TweenService
    if theme == "light" then
        TS:Create(ui.MainFrame, tweenInfo, {BackgroundColor3 = Color3.fromRGB(255, 255, 255)}):Play()
        TS:Create(ui.ContentFrame, tweenInfo, {BackgroundColor3 = Color3.fromRGB(255, 255, 255)}):Play()
        TS:Create(ui.MainStroke, tweenInfo, {Color = Color3.fromRGB(200, 200, 210)}):Play()
        TS:Create(ui.TitleBar, tweenInfo, {BackgroundColor3 = Color3.fromRGB(245, 245, 250)}):Play()
        TS:Create(ui.TitleFix, tweenInfo, {BackgroundColor3 = Color3.fromRGB(245, 245, 250)}):Play()
        TS:Create(ui.TitleLabel, tweenInfo, {TextColor3 = Color3.fromRGB(30, 30, 40)}):Play()
        TS:Create(ui.SizeLabel, tweenInfo, {TextColor3 = Color3.fromRGB(60, 60, 70)}):Play()
        TS:Create(ui.TextBox, tweenInfo, {BackgroundColor3 = Color3.fromRGB(235, 235, 245), TextColor3 = Color3.fromRGB(30, 30, 40)}):Play()
        TS:Create(ui.TextBoxStroke, tweenInfo, {Color = Color3.fromRGB(200, 200, 210)}):Play()
        TS:Create(ui.FooterLabel, tweenInfo, {TextColor3 = Color3.fromRGB(100, 100, 110)}):Play()
        TS:Create(ui.FooterLabelMinimized, tweenInfo, {TextColor3 = Color3.fromRGB(100, 100, 110)}):Play()
        TS:Create(ui.ConfirmFrame, tweenInfo, {BackgroundColor3 = Color3.fromRGB(255, 255, 255)}):Play()
        TS:Create(ui.ConfirmText, tweenInfo, {TextColor3 = Color3.fromRGB(30, 30, 40)}):Play()
        TS:Create(ui.SettingsFrame, tweenInfo, {BackgroundColor3 = Color3.fromRGB(255, 255, 255)}):Play()
        TS:Create(ui.SettingsTitleBar, tweenInfo, {BackgroundColor3 = Color3.fromRGB(245, 245, 250)}):Play()
        TS:Create(ui.SettingsTitleFix, tweenInfo, {BackgroundColor3 = Color3.fromRGB(245, 245, 250)}):Play()
        TS:Create(ui.SettingsTitleLabel, tweenInfo, {TextColor3 = Color3.fromRGB(30, 30, 40)}):Play()
        TS:Create(ui.ThemeLabel, tweenInfo, {TextColor3 = Color3.fromRGB(60, 60, 70)}):Play()
        TS:Create(ui.SettingsButtonTop, tweenInfo, {BackgroundColor3 = Color3.fromRGB(200, 200, 220), TextColor3 = Color3.fromRGB(30, 30, 40)}):Play()
        TS:Create(ui.DarkStroke, tweenInfo, {Color = Color3.fromRGB(200, 200, 210)}):Play()
        if not ui.LightButton:FindFirstChild("UIStroke") then
            local lightStroke = Instance.new("UIStroke")
            lightStroke.Color = Color3.fromRGB(80, 150, 255)
            lightStroke.Thickness = 3
            lightStroke.Transparency = 1
            lightStroke.ZIndex = 11
            lightStroke.Parent = ui.LightButton
            TS:Create(lightStroke, tweenInfo, {Transparency = 0}):Play()
        end
    else
        TS:Create(ui.MainFrame, tweenInfo, {BackgroundColor3 = Color3.fromRGB(20, 20, 25)}):Play()
        TS:Create(ui.ContentFrame, tweenInfo, {BackgroundColor3 = Color3.fromRGB(20, 20, 25)}):Play()
        TS:Create(ui.MainStroke, tweenInfo, {Color = Color3.fromRGB(60, 60, 70)}):Play()
        TS:Create(ui.TitleBar, tweenInfo, {BackgroundColor3 = Color3.fromRGB(30, 30, 40)}):Play()
        TS:Create(ui.TitleFix, tweenInfo, {BackgroundColor3 = Color3.fromRGB(30, 30, 40)}):Play()
        TS:Create(ui.TitleLabel, tweenInfo, {TextColor3 = Color3.fromRGB(255, 255, 255)}):Play()
        TS:Create(ui.SizeLabel, tweenInfo, {TextColor3 = Color3.fromRGB(200, 200, 210)}):Play()
        TS:Create(ui.TextBox, tweenInfo, {BackgroundColor3 = Color3.fromRGB(40, 40, 50), TextColor3 = Color3.fromRGB(255, 255, 255)}):Play()
        TS:Create(ui.TextBoxStroke, tweenInfo, {Color = Color3.fromRGB(80, 80, 90)}):Play()
        TS:Create(ui.FooterLabel, tweenInfo, {TextColor3 = Color3.fromRGB(120, 120, 130)}):Play()
        TS:Create(ui.FooterLabelMinimized, tweenInfo, {TextColor3 = Color3.fromRGB(120, 120, 130)}):Play()
        TS:Create(ui.ConfirmFrame, tweenInfo, {BackgroundColor3 = Color3.fromRGB(15, 15, 20)}):Play()
        TS:Create(ui.ConfirmText, tweenInfo, {TextColor3 = Color3.fromRGB(255, 255, 255)}):Play()
        TS:Create(ui.SettingsFrame, tweenInfo, {BackgroundColor3 = Color3.fromRGB(20, 20, 25)}):Play()
        TS:Create(ui.SettingsTitleBar, tweenInfo, {BackgroundColor3 = Color3.fromRGB(30, 30, 40)}):Play()
        TS:Create(ui.SettingsTitleFix, tweenInfo, {BackgroundColor3 = Color3.fromRGB(30, 30, 40)}):Play()
        TS:Create(ui.SettingsTitleLabel, tweenInfo, {TextColor3 = Color3.fromRGB(255, 255, 255)}):Play()
        TS:Create(ui.ThemeLabel, tweenInfo, {TextColor3 = Color3.fromRGB(200, 200, 210)}):Play()
        TS:Create(ui.SettingsButtonTop, tweenInfo, {BackgroundColor3 = Color3.fromRGB(100, 100, 120), TextColor3 = Color3.fromRGB(255, 255, 255)}):Play()
        if ui.LightButton:FindFirstChild("UIStroke") then
            local lightStroke = ui.LightButton:FindFirstChild("UIStroke")
            TS:Create(lightStroke, tweenInfo, {Transparency = 1}):Play()
            task.wait(0.1)
            lightStroke:Destroy()
        end
        TS:Create(ui.DarkStroke, tweenInfo, {Color = Color3.fromRGB(80, 150, 255)}):Play()
    end
end
function Modules.HitboxESP:CreateESP(targetPlayer)
    if self.State.EspLabels[targetPlayer] or self.State.EspBoxes[targetPlayer] then
        return
    end
    local char = targetPlayer.Character
    if not char then return end
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = "ZukaESP_" .. targetPlayer.Name
    billboardGui.AlwaysOnTop = true
    billboardGui.Size = UDim2.new(0, 200, 0, 50)
    billboardGui.StudsOffset = Vector3.new(0, 3, 0)
    billboardGui.Parent = char:FindFirstChild("Head") or char:FindFirstChild("HumanoidRootPart")
    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.TextColor3 = Color3.fromRGB(80, 150, 255)
    textLabel.TextStrokeTransparency = 0.5
    textLabel.TextSize = 14
    textLabel.Font = Enum.Font.GothamBold
    textLabel.Parent = billboardGui
    self.State.EspLabels[targetPlayer] = {gui = billboardGui, label = textLabel}
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if hrp then
        local highlight = Instance.new("Highlight")
        highlight.Name = "ZukaHighlight_" .. targetPlayer.Name
        highlight.Adornee = char
        highlight.FillColor = Color3.fromRGB(80, 150, 255)
        highlight.OutlineColor = Color3.fromRGB(80, 150, 255)
        highlight.FillTransparency = 0.5
        highlight.OutlineTransparency = 0
        highlight.Parent = char
        self.State.EspBoxes[targetPlayer] = highlight
    end
end
function Modules.HitboxESP:RemoveESP(targetPlayer)
    if self.State.EspLabels[targetPlayer] then
        if self.State.EspLabels[targetPlayer].gui then
            self.State.EspLabels[targetPlayer].gui:Destroy()
        end
        self.State.EspLabels[targetPlayer] = nil
    end
    if self.State.EspBoxes[targetPlayer] then
        self.State.EspBoxes[targetPlayer]:Destroy()
        self.State.EspBoxes[targetPlayer] = nil
    end
end
function Modules.HitboxESP:UpdateESP()
    if not self.State.EspEnabled then return end
    local lp = self.Services.Players.LocalPlayer
    for _, targetPlayer in pairs(self.Services.Players:GetPlayers()) do
        if targetPlayer ~= lp and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
            if not self.State.EspLabels[targetPlayer] then
                self:CreateESP(targetPlayer)
            end
            if self.State.EspLabels[targetPlayer] and self.State.EspLabels[targetPlayer].gui.Parent == nil then
                local head = targetPlayer.Character:FindFirstChild("Head")
                if head then
                    self.State.EspLabels[targetPlayer].gui.Parent = head
                end
            end
            local hrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
            local targetHrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
            if hrp and targetHrp and self.State.EspLabels[targetPlayer] then
                local distance = (hrp.Position - targetHrp.Position).Magnitude
                local studs = math.floor(distance)
                self.State.EspLabels[targetPlayer].label.Text = targetPlayer.Name .. "\n" .. studs .. " studs"
            end
        elseif self.State.EspLabels[targetPlayer] or self.State.EspBoxes[targetPlayer] then
            self:RemoveESP(targetPlayer)
        end
    end
end
function Modules.HitboxESP:UpdateHitboxes()
    if not self.State.IsEnabled then return end
    local lp = self.Services.Players.LocalPlayer
    for _, v in pairs(self.Services.Players:GetPlayers()) do
        if v ~= lp and v.Character then
            local hrp = v.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                hrp.Size = Vector3.new(self.State.HitboxSize, self.State.HitboxSize, self.State.HitboxSize)
                hrp.Transparency = 0.7
                hrp.CanCollide = false
            end
        end
    end
end
function Modules.HitboxESP:Initialize()
    local module = self
    local Players = self.Services.Players
    local TS = self.Services.TweenService
    RegisterCommand({
        Name = "hitboxchanger",
        Aliases = {},
        Description = "Opens the Hitbox Changer & ESP GUI."
    }, function()
        module:CreateUI()
    end)
    self.State.Connections.PlayerAdded = Players.PlayerAdded:Connect(function(newPlayer)
        newPlayer.CharacterAdded:Connect(function()
            task.wait(0.1)
            module:UpdateHitboxes()
            if module.State.EspEnabled then
                module:CreateESP(newPlayer)
            end
        end)
    end)
    self.State.Connections.PlayerRemoving = Players.PlayerRemoving:Connect(function(removedPlayer)
        module:RemoveESP(removedPlayer)
    end)
    self.State.Connections.Loop = self.Services.RunService.Heartbeat:Connect(function()
        module:UpdateHitboxes()
        module:UpdateESP()
    end)
end
function Modules.HitboxESP:CreateUI()
    if self.State.UI then self.State.UI.ScreenGui.Enabled = true return end
    local module = self
    local TS = self.Services.TweenService
    local UIS = self.Services.UserInputService
    local lp = self.Services.Players.LocalPlayer
    local ui = {}
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "HitboxChanger_Zuka"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.Parent = self.Services.CoreGui
    ui.ScreenGui = screenGui
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"; mainFrame.Size = UDim2.new(0, 260, 0, 180)
    mainFrame.Position = UDim2.new(0.5, -130, 0.5, -90)
    mainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
    mainFrame.BorderSizePixel = 0; mainFrame.Active = true; mainFrame.ClipsDescendants = true
    mainFrame.Parent = screenGui
    ui.MainFrame = mainFrame
    Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 12)
    local mainStroke = Instance.new("UIStroke", mainFrame)
    mainStroke.Color = Color3.fromRGB(60, 60, 70); mainStroke.Thickness = 2; mainStroke.Transparency = 0.5
    ui.MainStroke = mainStroke
    local titleBar = Instance.new("Frame", mainFrame)
    titleBar.Name = "TitleBar"; titleBar.Size = UDim2.new(1, 0, 0, 35)
    titleBar.BackgroundColor3 = Color3.fromRGB(30, 30, 40); titleBar.BorderSizePixel = 0
    ui.TitleBar = titleBar
    Instance.new("UICorner", titleBar).CornerRadius = UDim.new(0, 12)
    local titleFix = Instance.new("Frame", titleBar)
    titleFix.Size = UDim2.new(1, 0, 0, 12); titleFix.Position = UDim2.new(0, 0, 1, -12)
    titleFix.BackgroundColor3 = Color3.fromRGB(30, 30, 40); titleFix.BorderSizePixel = 0
    ui.TitleFix = titleFix
    local titleLabel = Instance.new("TextLabel", titleBar)
    titleLabel.Size = UDim2.new(1, -100, 1, 0); titleLabel.Position = UDim2.new(0, 10, 0, 0)
    titleLabel.BackgroundTransparency = 1; titleLabel.Text = "Hitbox changer & esp"
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255); titleLabel.TextSize = 15
    titleLabel.Font = Enum.Font.GothamBold; titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    ui.TitleLabel = titleLabel
    local settingsButtonTop = Instance.new("TextButton", titleBar)
    settingsButtonTop.Name = "SettingsButtonTop"; settingsButtonTop.Size = UDim2.new(0, 26, 0, 26)
    settingsButtonTop.Position = UDim2.new(1, -90, 0, 4); settingsButtonTop.BackgroundColor3 = Color3.fromRGB(100, 100, 120)
    settingsButtonTop.Text = "âš™"; settingsButtonTop.TextColor3 = Color3.new(1, 1, 1); settingsButtonTop.Font = Enum.Font.GothamBold
    Instance.new("UICorner", settingsButtonTop).CornerRadius = UDim.new(0, 6)
    ui.SettingsButtonTop = settingsButtonTop
    local minimizeButton = Instance.new("TextButton", titleBar)
    minimizeButton.Size = UDim2.new(0, 26, 0, 26); minimizeButton.Position = UDim2.new(1, -58, 0, 4)
    minimizeButton.BackgroundColor3 = Color3.fromRGB(255, 200, 50); minimizeButton.Text = "_"
    minimizeButton.TextColor3 = Color3.new(0, 0, 0); minimizeButton.Font = Enum.Font.GothamBold
    Instance.new("UICorner", minimizeButton).CornerRadius = UDim.new(0, 6)
    local closeButton = Instance.new("TextButton", titleBar)
    closeButton.Size = UDim2.new(0, 26, 0, 26); closeButton.Position = UDim2.new(1, -28, 0, 4)
    closeButton.BackgroundColor3 = Color3.fromRGB(220, 50, 50); closeButton.Text = "X"
    closeButton.TextColor3 = Color3.new(1, 1, 1); closeButton.Font = Enum.Font.GothamBold
    Instance.new("UICorner", closeButton).CornerRadius = UDim.new(0, 6)
    local contentFrame = Instance.new("Frame", mainFrame)
    contentFrame.Name = "ContentFrame"; contentFrame.Size = UDim2.new(1, 0, 1, -35); contentFrame.Position = UDim2.new(0, 0, 0, 35)
    contentFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 25); contentFrame.BorderSizePixel = 0
    ui.ContentFrame = contentFrame
    local sizeLabel = Instance.new("TextLabel", contentFrame)
    sizeLabel.Size = UDim2.new(0, 75, 0, 22); sizeLabel.Position = UDim2.new(0, 12, 0, 8)
    sizeLabel.BackgroundTransparency = 1; sizeLabel.Text = "Hitbox Size:"
    sizeLabel.TextColor3 = Color3.fromRGB(200, 200, 210); sizeLabel.TextSize = 12; sizeLabel.Font = Enum.Font.Gotham
    sizeLabel.TextXAlignment = Enum.TextXAlignment.Left
    ui.SizeLabel = sizeLabel
    local textBox = Instance.new("TextBox", contentFrame)
    textBox.Size = UDim2.new(0, 80, 0, 28); textBox.Position = UDim2.new(0, 90, 0, 6)
    textBox.BackgroundColor3 = Color3.fromRGB(40, 40, 50); textBox.Text = tostring(self.State.HitboxSize)
    textBox.PlaceholderText = "Size"; textBox.TextColor3 = Color3.new(1, 1, 1); textBox.Font = Enum.Font.Gotham
    Instance.new("UICorner", textBox).CornerRadius = UDim.new(0, 7)
    local textBoxStroke = Instance.new("UIStroke", textBox)
    textBoxStroke.Color = Color3.fromRGB(80, 80, 90); ui.TextBoxStroke = textBoxStroke
    ui.TextBox = textBox
    local applyButton = Instance.new("TextButton", contentFrame)
    applyButton.Size = UDim2.new(0, 50, 0, 28); applyButton.Position = UDim2.new(0, 178, 0, 6)
    applyButton.BackgroundColor3 = Color3.fromRGB(80, 150, 255); applyButton.Text = "Apply"
    applyButton.TextColor3 = Color3.new(1, 1, 1); applyButton.Font = Enum.Font.GothamBold
    Instance.new("UICorner", applyButton).CornerRadius = UDim.new(0, 7)
    local toggleButton = Instance.new("TextButton", contentFrame)
    toggleButton.Size = UDim2.new(0, 236, 0, 32); toggleButton.Position = UDim2.new(0, 12, 0, 42)
    toggleButton.BackgroundColor3 = Color3.fromRGB(220, 50, 50); toggleButton.Text = "Hitbox: OFF"
    toggleButton.TextColor3 = Color3.new(1, 1, 1); toggleButton.Font = Enum.Font.GothamBold
    Instance.new("UICorner", toggleButton).CornerRadius = UDim.new(0, 7)
    local espToggleButton = Instance.new("TextButton", contentFrame)
    espToggleButton.Size = UDim2.new(0, 236, 0, 32); espToggleButton.Position = UDim2.new(0, 12, 0, 80)
    espToggleButton.BackgroundColor3 = Color3.fromRGB(220, 50, 50); espToggleButton.Text = "ESP: OFF"
    espToggleButton.TextColor3 = Color3.new(1, 1, 1); espToggleButton.Font = Enum.Font.GothamBold
    Instance.new("UICorner", espToggleButton).CornerRadius = UDim.new(0, 7)
    local footerLabel = Instance.new("TextButton", contentFrame)
    footerLabel.Size = UDim2.new(1, 0, 0, 25); footerLabel.Position = UDim2.new(0, 0, 1, -25)
    footerLabel.BackgroundTransparency = 1; footerLabel.Text = "by: romokaso"
    footerLabel.TextColor3 = Color3.fromRGB(120, 120, 130); footerLabel.TextSize = 10; footerLabel.Font = Enum.Font.GothamBold
    ui.FooterLabel = footerLabel
    local footerLabelMinimized = Instance.new("TextButton", mainFrame)
    footerLabelMinimized.Size = UDim2.new(1, 0, 0, 25); footerLabelMinimized.Position = UDim2.new(0, 0, 1, -25)
    footerLabelMinimized.BackgroundTransparency = 1; footerLabelMinimized.Text = "by: romokaso"
    footerLabelMinimized.TextColor3 = Color3.fromRGB(120, 120, 130); footerLabelMinimized.TextSize = 10; footerLabelMinimized.Visible = false
    ui.FooterLabelMinimized = footerLabelMinimized
    local confirmFrame = Instance.new("Frame", mainFrame)
    confirmFrame.Size = UDim2.new(1, 0, 1, 0); confirmFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 20)
    confirmFrame.BackgroundTransparency = 1; confirmFrame.Visible = false; confirmFrame.ZIndex = 10
    Instance.new("UICorner", confirmFrame)
    ui.ConfirmFrame = confirmFrame
    local confirmText = Instance.new("TextLabel", confirmFrame)
    confirmText.Size = UDim2.new(1, -24, 0, 40); confirmText.Position = UDim2.new(0, 12, 0, 45); confirmText.BackgroundTransparency = 1
    confirmText.Text = "Are you sure you want\nto close the GUI?"; confirmText.TextColor3 = Color3.new(1, 1, 1); confirmText.ZIndex = 11
    ui.ConfirmText = confirmText
    local yesButton = Instance.new("TextButton", confirmFrame)
    yesButton.Size = UDim2.new(0, 105, 0, 32); yesButton.Position = UDim2.new(0, 20, 0, 100); yesButton.BackgroundColor3 = Color3.fromRGB(50, 200, 100)
    yesButton.Text = "Yes"; yesButton.TextColor3 = Color3.new(1, 1, 1); yesButton.ZIndex = 11
    Instance.new("UICorner", yesButton)
    local noButton = Instance.new("TextButton", confirmFrame)
    noButton.Size = UDim2.new(0, 105, 0, 32); noButton.Position = UDim2.new(0, 135, 0, 100); noButton.BackgroundColor3 = Color3.fromRGB(220, 50, 50)
    noButton.Text = "No"; noButton.TextColor3 = Color3.new(1, 1, 1); noButton.ZIndex = 11
    Instance.new("UICorner", noButton)
    local settingsFrame = Instance.new("Frame", mainFrame)
    settingsFrame.Size = UDim2.new(1, 0, 1, 0); settingsFrame.Position = UDim2.new(1, 0, 0, 0); settingsFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
    settingsFrame.Visible = false; settingsFrame.ZIndex = 10
    Instance.new("UICorner", settingsFrame); ui.SettingsFrame = settingsFrame
    local settingsTitleBar = Instance.new("Frame", settingsFrame)
    settingsTitleBar.Size = UDim2.new(1, 0, 0, 35); settingsTitleBar.BackgroundColor3 = Color3.fromRGB(30, 30, 40); settingsTitleBar.ZIndex = 11
    Instance.new("UICorner", settingsTitleBar); ui.SettingsTitleBar = settingsTitleBar
    local settingsTitleFix = Instance.new("Frame", settingsTitleBar)
    settingsTitleFix.Size = UDim2.new(1, 0, 0, 12); settingsTitleFix.Position = UDim2.new(0, 0, 1, -12); settingsTitleFix.BackgroundColor3 = Color3.fromRGB(30, 30, 40); settingsTitleFix.ZIndex = 11
    ui.SettingsTitleFix = settingsTitleFix
    local settingsTitleLabel = Instance.new("TextLabel", settingsTitleBar)
    settingsTitleLabel.Size = UDim2.new(1, -50, 1, 0); settingsTitleLabel.Position = UDim2.new(0, 10, 0, 0); settingsTitleLabel.BackgroundTransparency = 1
    settingsTitleLabel.Text = "Settings"; settingsTitleLabel.TextColor3 = Color3.new(1, 1, 1); settingsTitleLabel.ZIndex = 11; ui.SettingsTitleLabel = settingsTitleLabel
    local backButton = Instance.new("TextButton", settingsTitleBar)
    backButton.Size = UDim2.new(0, 26, 0, 26); backButton.Position = UDim2.new(1, -28, 0, 4); backButton.BackgroundColor3 = Color3.fromRGB(80, 80, 90)
    backButton.Text = "â†"; backButton.TextColor3 = Color3.new(1, 1, 1); backButton.ZIndex = 11
    Instance.new("UICorner", backButton)
    local settingsContentFrame = Instance.new("Frame", settingsFrame)
    settingsContentFrame.Size = UDim2.new(1, 0, 1, -35); settingsContentFrame.Position = UDim2.new(0, 0, 0, 35); settingsContentFrame.BackgroundTransparency = 1; settingsContentFrame.ZIndex = 11
    local themeLabel = Instance.new("TextLabel", settingsContentFrame)
    themeLabel.Size = UDim2.new(1, -24, 0, 22); themeLabel.Position = UDim2.new(0, 12, 0, 15); themeLabel.BackgroundTransparency = 1
    themeLabel.Text = "Theme:"; themeLabel.TextColor3 = Color3.fromRGB(200, 200, 210); themeLabel.ZIndex = 11; ui.ThemeLabel = themeLabel
    local darkButton = Instance.new("TextButton", settingsContentFrame)
    darkButton.Size = UDim2.new(0, 110, 0, 38); darkButton.Position = UDim2.new(0, 12, 0, 45); darkButton.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
    darkButton.Text = "Dark"; darkButton.TextColor3 = Color3.new(1, 1, 1); darkButton.ZIndex = 11
    Instance.new("UICorner", darkButton); local darkStroke = Instance.new("UIStroke", darkButton); darkStroke.Color = Color3.fromRGB(80, 150, 255); darkStroke.Thickness = 3; ui.DarkStroke = darkStroke
    local lightButton = Instance.new("TextButton", settingsContentFrame)
    lightButton.Size = UDim2.new(0, 110, 0, 38); lightButton.Position = UDim2.new(0, 138, 0, 45); lightButton.BackgroundColor3 = Color3.fromRGB(240, 240, 250)
    lightButton.Text = "Light"; lightButton.TextColor3 = Color3.fromRGB(30, 30, 40); lightButton.ZIndex = 11
    Instance.new("UICorner", lightButton); ui.LightButton = lightButton
    applyButton.MouseButton1Click:Connect(function()
        module:AnimateButton(applyButton)
        local val = tonumber(textBox.Text)
        if val then module.State.HitboxSize = val end
    end)
    toggleButton.MouseButton1Click:Connect(function()
        module:AnimateButton(toggleButton)
        module.State.IsEnabled = not module.State.IsEnabled
        if module.State.IsEnabled then
            TS:Create(toggleButton, TweenInfo.new(0.1, Enum.EasingStyle.Quad), {BackgroundColor3 = Color3.fromRGB(50, 200, 100)}):Play()
            toggleButton.Text = "Hitbox: ON"
        else
            TS:Create(toggleButton, TweenInfo.new(0.1, Enum.EasingStyle.Quad), {BackgroundColor3 = Color3.fromRGB(220, 50, 50)}):Play()
            toggleButton.Text = "Hitbox: OFF"
            for _, v in pairs(module.Services.Players:GetPlayers()) do
                if v ~= lp and v.Character then
                    local hrp = v.Character:FindFirstChild("HumanoidRootPart")
                    if hrp then hrp.Size = Vector3.new(2, 2, 1); hrp.Transparency = 1 end
                end
            end
        end
    end)
    espToggleButton.MouseButton1Click:Connect(function()
        module:AnimateButton(espToggleButton)
        module.State.EspEnabled = not module.State.EspEnabled
        if module.State.EspEnabled then
            TS:Create(espToggleButton, TweenInfo.new(0.1, Enum.EasingStyle.Quad), {BackgroundColor3 = Color3.fromRGB(50, 200, 100)}):Play()
            espToggleButton.Text = "ESP: ON"
        else
            TS:Create(espToggleButton, TweenInfo.new(0.1, Enum.EasingStyle.Quad), {BackgroundColor3 = Color3.fromRGB(220, 50, 50)}):Play()
            espToggleButton.Text = "ESP: OFF"
            for p, _ in pairs(module.State.EspLabels) do module:RemoveESP(p) end
        end
    end)
    minimizeButton.MouseButton1Click:Connect(function()
        if confirmFrame.Visible or settingsFrame.Visible then return end
        module:AnimateButton(minimizeButton)
        module.State.IsMinimized = not module.State.IsMinimized
        if module.State.IsMinimized then
            TS:Create(mainFrame, TweenInfo.new(0.1, Enum.EasingStyle.Quad), {Size = UDim2.new(0, 260, 0, 60)}):Play()
            contentFrame.Visible = false; footerLabel.Visible = false; footerLabelMinimized.Visible = true
        else
            TS:Create(mainFrame, TweenInfo.new(0.1, Enum.EasingStyle.Quad), {Size = UDim2.new(0, 260, 0, 180)}):Play()
            contentFrame.Visible = true; footerLabel.Visible = true; footerLabelMinimized.Visible = false
        end
    end)
    closeButton.MouseButton1Click:Connect(function()
        if confirmFrame.Visible or settingsFrame.Visible then return end
        module:AnimateButton(closeButton)
        confirmFrame.Visible = true
        TS:Create(confirmFrame, TweenInfo.new(0.1, Enum.EasingStyle.Quad), {BackgroundTransparency = 0.05}):Play()
    end)
    yesButton.MouseButton1Click:Connect(function()
        module:AnimateButton(yesButton)
        TS:Create(mainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {Size = UDim2.new(0, 0, 0, 0)}):Play()
        task.wait(0.3)
        screenGui.Enabled = false
    end)
    noButton.MouseButton1Click:Connect(function()
        module:AnimateButton(noButton)
        TS:Create(confirmFrame, TweenInfo.new(0.1, Enum.EasingStyle.Quad), {BackgroundTransparency = 1}):Play()
        task.wait(0.1); confirmFrame.Visible = false
    end)
    settingsButtonTop.MouseButton1Click:Connect(function()
        module:AnimateButton(settingsButtonTop)
        settingsFrame.Visible = true
        TS:Create(settingsFrame, TweenInfo.new(0.1, Enum.EasingStyle.Quad), {Position = UDim2.new(0, 0, 0, 0)}):Play()
    end)
    backButton.MouseButton1Click:Connect(function()
        module:AnimateButton(backButton)
        TS:Create(settingsFrame, TweenInfo.new(0.1, Enum.EasingStyle.Quad), {Position = UDim2.new(1, 0, 0, 0)}):Play()
        task.wait(0.1); settingsFrame.Visible = false
    end)
    darkButton.MouseButton1Click:Connect(function() module:AnimateButton(darkButton); module:ApplyTheme("dark") end)
    lightButton.MouseButton1Click:Connect(function() module:AnimateButton(lightButton); module:ApplyTheme("light") end)
    local dragStart, startPos
    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            module.State.IsDragging = true
            dragStart = input.Position; startPos = mainFrame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then module.State.IsDragging = false end
            end)
        end
    end)
    UIS.InputChanged:Connect(function(input)
        if module.State.IsDragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - dragStart
            mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
    self.State.UI = ui
    DoNotif("Hitbox & ESP Panel: INITIALIZED", 2)
end
RegisterCommand({
    Name = "hitboxgui",
    Aliases = {},
    Description = "Toggles the advanced Hitbox Changer and ESP interface."
}, function()
    if not Modules.HitboxESP.State.UI then
        Modules.HitboxESP:CreateUI()
    else
        Modules.HitboxESP.State.UI.ScreenGui.Enabled = not Modules.HitboxESP.State.UI.ScreenGui.Enabled
    end
end)
Modules.AntiSit = {
    State = {
        IsEnabled = false,
        CharacterConnections = {}
    },
    Services = {
        Players = game:GetService("Players")
    }
}
function Modules.AntiSit:_applyToCharacter(character)
    if not character then return end
    local humanoid = character:WaitForChild("Humanoid", 2)
    if not humanoid then return end
    humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
    local sitConnection = humanoid:GetPropertyChangedSignal("Sit"):Connect(function()
        if humanoid.Sit == true then
            humanoid.Sit = false
        end
    end)
    self.State.CharacterConnections[character] = sitConnection
end
function Modules.AntiSit:_revertForCharacter(character)
    if not character then return end
    if self.State.CharacterConnections[character] then
        self.State.CharacterConnections[character]:Disconnect()
        self.State.CharacterConnections[character] = nil
    end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        pcall(function()
            humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        end)
    end
end
function Modules.AntiSit:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    local localPlayer = self.Services.Players.LocalPlayer
    if localPlayer.Character then
        self:_applyToCharacter(localPlayer.Character)
    end
    self.State.CharacterConnections.Added = localPlayer.CharacterAdded:Connect(function(char)
        self:_applyToCharacter(char)
    end)
    self.State.CharacterConnections.Removing = localPlayer.CharacterRemoving:Connect(function(char)
        self:_revertForCharacter(char)
    end)
    DoNotif("Anti-Sit: ENABLED", 2)
end
function Modules.AntiSit:Disable()
    if not self.State.IsEnabled then return end
    self.State.IsEnabled = false
    if self.State.CharacterConnections.Added then
        self.State.CharacterConnections.Added:Disconnect()
    end
    if self.State.CharacterConnections.Removing then
        self.State.CharacterConnections.Removing:Disconnect()
    end
    local localPlayer = self.Services.Players.LocalPlayer
    if localPlayer.Character then
        self:_revertForCharacter(localPlayer.Character)
    end
    table.clear(self.State.CharacterConnections)
    DoNotif("Anti-Sit: DISABLED", 2)
end
function Modules.AntiSit:Toggle()
    if self.State.IsEnabled then
        self:Disable()
    else
        self:Enable()
    end
end
RegisterCommand({
    Name = "antisit",
    Aliases = {"nosit"},
    Description = "Toggles a system to prevent your character from sitting."
}, function()
    Modules.AntiSit:Toggle()
end)
RegisterCommand({
    Name = "night",
    Aliases = {},
    Description = "Sets the time to night on your client."
}, function(args)
    local Lighting = game:GetService("Lighting")
    local targetTime = tonumber(args[1])
    if not targetTime or targetTime < 0 or targetTime >= 24 then
        targetTime = 0
    end
    Lighting.ClockTime = targetTime
    DoNotif(string.format("Client time set to %02d:00", targetTime), 2)
end)
RegisterCommand({
    Name = "day",
    Aliases = {},
    Description = "Sets the time to day on your client."
}, function(args)
    local Lighting = game:GetService("Lighting")
    local targetTime = tonumber(args[1])
    if not targetTime or targetTime < 0 or targetTime >= 24 then
        targetTime = 14
    end
    Lighting.ClockTime = targetTime
    DoNotif(string.format("Client time set to %02d:00", targetTime), 2)
end)
Modules.FullBright = {
    State = {
        IsEnabled = false,
        OriginalSettings = {}
    }
}
function Modules.FullBright:Enable(): ()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    self.State.OriginalSettings = {
        Ambient = Lighting.Ambient,
        OutdoorAmbient = Lighting.OutdoorAmbient,
        Brightness = Lighting.Brightness,
        ClockTime = Lighting.ClockTime,
        GlobalShadows = Lighting.GlobalShadows
    }
    Lighting.Ambient = Color3.fromRGB(255, 255, 255)
    Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
    Lighting.Brightness = 2
    Lighting.GlobalShadows = false
    self.State.Connection = Lighting.Changed:Connect(function()
        if self.State.IsEnabled then
            Lighting.Ambient = Color3.fromRGB(255, 255, 255)
            Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
            Lighting.Brightness = 2
            Lighting.GlobalShadows = false
        end
    end)
    DoNotif("FullBright: ENABLED", 2)
end
function Modules.FullBright:Disable(): ()
    if not self.State.IsEnabled then return end
    self.State.IsEnabled = false
    if self.State.Connection then
        self.State.Connection:Disconnect()
        self.State.Connection = nil
    end
    local settings = self.State.OriginalSettings
    Lighting.Ambient = settings.Ambient
    Lighting.OutdoorAmbient = settings.OutdoorAmbient
    Lighting.Brightness = settings.Brightness
    Lighting.ClockTime = settings.ClockTime
    Lighting.GlobalShadows = settings.GlobalShadows
    DoNotif("FullBright: DISABLED", 2)
end
RegisterCommand({
    Name = "fullbright",
    Aliases = {"fb", "bright"},
    Description = "Removes all shadows and maximizes ambient light."
}, function()
    if Modules.FullBright.State.IsEnabled then
        Modules.FullBright:Disable()
    else
        Modules.FullBright:Enable()
    end
end)
Modules.ObjectESP = {
    State = {
        IsEnabled = false,
        Targets = {},
        Visuals = {}
    }
}
function Modules.ObjectESP:_apply(object: Instance): ()
    if not object:IsA("BasePart") or self.State.Visuals[object] then return end
    local highlight = Instance.new("Highlight")
    highlight.FillColor = Color3.fromRGB(255, 170, 0)
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.FillTransparency = 0.5
    highlight.Parent = object
    local billboard = Instance.new("BillboardGui")
    billboard.AlwaysOnTop = true
    billboard.Size = UDim2.fromOffset(100, 40)
    billboard.StudsOffset = Vector3.new(0, 2, 0)
    local label = Instance.new("TextLabel")
    label.Size = UDim2.fromScale(1, 1)
    label.BackgroundTransparency = 1
    label.Text = object.Name
    label.TextColor3 = Color3.fromRGB(255, 170, 0)
    label.Font = Enum.Font.Code
    label.TextSize = 14
    label.Parent = billboard
    billboard.Parent = object
    self.State.Visuals[object] = {highlight, billboard}
end
function Modules.ObjectESP:Toggle(name: string): ()
    if not name then return DoNotif("Usage: ;itemesp <name>", 3) end
    self.State.IsEnabled = true
    local count = 0
    for _, descendant in ipairs(Workspace:GetDescendants()) do
        if descendant.Name:lower():find(name:lower()) and descendant:IsA("BasePart") then
            self:_apply(descendant)
            count = count + 1
        end
    end
    DoNotif("Found " .. count .. " items matching: " .. name, 3)
end
function Modules.ObjectESP:Clear(): ()
    for part, effects in pairs(self.State.Visuals) do
        for _, effect in ipairs(effects) do
            pcall(function() effect:Destroy() end)
        end
    end
    table.clear(self.State.Visuals)
    DoNotif("Object ESP Cleared", 2)
end
RegisterCommand({
    Name = "itemesp",
    Aliases = {"finditem", "iesp"},
    Description = "Highlights specific objects in the workspace by name."
}, function(args)
    local name = table.concat(args, " ")
    if name == "clear" or name == "off" then
        Modules.ObjectESP:Clear()
    else
        Modules.ObjectESP:Toggle(name)
    end
end)
Modules.InternalAntiAfk = {
    State = {
        IsEnabled = false,
        Connection = nil
    }
}
function Modules.InternalAntiAfk:Toggle(): ()
    self.State.IsEnabled = not self.State.IsEnabled
    if self.State.IsEnabled then
        local virtualUser = game:GetService("VirtualUser")
        self.State.Connection = LocalPlayer.Idled:Connect(function()
            virtualUser:CaptureController()
            virtualUser:ClickButton2(Vector2.new())
        end)
        DoNotif("Internal Anti-AFK: ENABLED", 2)
    else
        if self.State.Connection then
            self.State.Connection:Disconnect()
            self.State.Connection = nil
        end
        DoNotif("Internal Anti-AFK: DISABLED", 2)
    end
end
RegisterCommand({
    Name = "idlesaver",
    Aliases = {"afk", "antiafk"},
    Description = "Prevents being disconnected for inactivity via internal engine signals."
}, function()
    Modules.InternalAntiAfk:Toggle()
end)
Modules.ToolSpy = {
    State = {
        IsEnabled = false
    }
}
function Modules.ToolSpy:Scan(): ()
    print("--- [Tool Spy Report] ---")
    local found = 0
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local char = player.Character
            local backpack = player:FindFirstChild("Backpack")
            local tools = {}
            if char then
                for _, item in ipairs(char:GetChildren()) do
                    if item:IsA("Tool") then
                        table.insert(tools, "[EQUIPPED] " .. item.Name)
                    end
                end
            end
            if backpack then
                for _, item in ipairs(backpack:GetChildren()) do
                    if item:IsA("Tool") then
                        table.insert(tools, item.Name)
                    end
                end
            end
            if #tools > 0 then
                found = found + 1
                print(string.format("Player: %s | Tools: %s", player.Name, table.concat(tools, ", ")))
            end
        end
    end
    print("--- End of Report ---")
    DoNotif("Tool Spy: Found inventory for " .. found .. " players. Check Console (F9).", 4)
end
RegisterCommand({
    Name = "toolspy",
    Aliases = {"invspy", "checktools"},
    Description = "Dumps the inventory of every player in the server to the developer console."
}, function()
    Modules.ToolSpy:Scan()
end)
Modules.LightingLock = {
    State = {
        IsEnabled = false,
        OriginalNamecall = nil,
        Properties = {
            Brightness = 2,
            ClockTime = 14,
            FogEnd = 100000,
            GlobalShadows = false
        }
    }
}
function Modules.LightingLock:Toggle()
    self.State.IsEnabled = not self.State.IsEnabled
    if self.State.IsEnabled then
        local mt = getrawmetatable(game)
        self.State.OriginalNamecall = mt.__newindex
        local original = self.State.OriginalNamecall
        setreadonly(mt, false)
        mt.__newindex = newcclosure(function(t, k, v)
            if t == Lighting and Modules.LightingLock.State.IsEnabled then
                if Modules.LightingLock.State.Properties[k] ~= nil then
                    return
                end
            end
            return original(t, k, v)
        end)
        setreadonly(mt, true)
        for k, v in pairs(self.State.Properties) do
            pcall(function() Lighting[k] = v end)
        end
        DoNotif("Lighting Lock: ENABLED", 2)
    else
        self.State.IsEnabled = false
        DoNotif("Lighting Lock: DISABLED", 2)
    end
end
Modules.PromptAura = {
    State = {
        IsEnabled = false,
        Connection = nil,
        Distance = 15
    }
}
function Modules.PromptAura:Toggle(dist)
    self.State.IsEnabled = not self.State.IsEnabled
    self.State.Distance = tonumber(dist) or 15
    if self.State.IsEnabled then
        self.State.Connection = RunService.Heartbeat:Connect(function()
            local char = Players.LocalPlayer.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            if not hrp then return end
            for _, prompt in ipairs(Workspace:GetDescendants()) do
                if prompt:IsA("ProximityPrompt") then
                    local part = prompt.Parent
                    if part and part:IsA("BasePart") then
                        if (hrp.Position - part.Position).Magnitude <= self.State.Distance then
                            if fireproximityprompt then fireproximityprompt(prompt) end
                        end
                    end
                end
            end
        end)
        DoNotif("Prompt Aura: ENABLED", 2)
    else
        if self.State.Connection then self.State.Connection:Disconnect() end
        self.State.IsEnabled = false
        DoNotif("Prompt Aura: DISABLED", 2)
    end
end
Modules.SafeTeleport = {
    State = {
        IsEnabled = false
    }
}
function Modules.SafeTeleport:Execute(targetName: string)
    local target = Utilities.findPlayer(targetName)
    if not target or not target.Character then return DoNotif("Target not found.", 2) end
    local hrp = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    local targetHrp = target.Character:FindFirstChild("HumanoidRootPart")
    if hrp and targetHrp then
        local rayParams = RaycastParams.new()
        rayParams.FilterDescendantsInstances = {Players.LocalPlayer.Character, target.Character}
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        local result = Workspace:Raycast(targetHrp.Position, Vector3.new(0, 5, 0), rayParams)
        local finalPos = result and result.Position or (targetHrp.Position + Vector3.new(0, 3, 0))
        hrp.CFrame = CFrame.new(finalPos)
        DoNotif("Safe Teleport to " .. target.Name, 2)
    end
end
RegisterCommand({
    Name = "locklighting",
    Aliases = {"lightlock", "ll"},
    Description = "Prevents the server from changing your local lighting settings."
}, function()
    Modules.LightingLock:Toggle()
end)
RegisterCommand({
    Name = "promptaura",
    Aliases = {"pa"},
    Description = "Automatically triggers proximity prompts in a radius."
}, function(args)
    Modules.PromptAura:Toggle(args[1])
end)
RegisterCommand({
    Name = "stp",
    Aliases = {"safeteleport"},
    Description = "Teleports to a player while checking for ceiling/wall obstructions."
}, function(args)
    Modules.SafeTeleport:Execute(args[1])
end)
Modules.HitboxExtender = {
    State = {
        IsEnabled = false,
        TrackedCharacters = setmetatable({}, {__mode = "k"}),
        OriginalSizes = setmetatable({}, {__mode = "k"}),
        Connections = {}
    },
    Config = {
        TargetPartName = "HumanoidRootPart",
        SizeMultiplier = 3
    },
    Services = {
        Players = game:GetService("Players")
    }
}
function Modules.HitboxExtender:_apply(character)
    if not character or self.State.TrackedCharacters[character] then return end
    local targetPart = character:FindFirstChild(self.Config.TargetPartName)
    if not targetPart then return end
    if not self.State.OriginalSizes[targetPart] then
        self.State.OriginalSizes[targetPart] = targetPart.Size
    end
    targetPart.Size = self.State.OriginalSizes[targetPart] * self.Config.SizeMultiplier
    targetPart.Transparency = 1
    targetPart.CanCollide = false
    self.State.TrackedCharacters[character] = true
end
function Modules.HitboxExtender:_revert(character)
    if not character or not self.State.TrackedCharacters[character] then return end
    local targetPart = character:FindFirstChild(self.Config.TargetPartName)
    if targetPart and self.State.OriginalSizes[targetPart] then
        targetPart.Size = self.State.OriginalSizes[targetPart]
        targetPart.Transparency = self.State.OriginalSizes[targetPart].Transparency or 0
        targetPart.CanCollide = self.State.OriginalSizes[targetPart].CanCollide or true
        self.State.OriginalSizes[targetPart] = nil
    end
    self.State.TrackedCharacters[character] = nil
end
function Modules.HitboxExtender:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    local function setupPlayer(player)
        if player == self.Services.Players.LocalPlayer then return end
        if player.Character then
            self:_apply(player.Character)
        end
        self.State.Connections[player] = {}
        self.State.Connections[player].CharacterAdded = player.CharacterAdded:Connect(function(char) self:_apply(char) end)
        self.State.Connections[player].CharacterRemoving = player.CharacterRemoving:Connect(function(char) self:_revert(char) end)
    end
    for _, player in ipairs(self.Services.Players:GetPlayers()) do
        setupPlayer(player)
    end
    self.State.Connections.PlayerAdded = self.Services.Players.PlayerAdded:Connect(setupPlayer)
    self.State.Connections.PlayerRemoving = self.Services.Players.PlayerRemoving:Connect(function(player)
        if self.State.Connections[player] then
            for _, conn in pairs(self.State.Connections[player]) do
                conn:Disconnect()
            end
            self.State.Connections[player] = nil
        end
    end)
    DoNotif("Hitbox Extender: ENABLED", 2)
end
function Modules.HitboxExtender:Disable()
    if not self.State.IsEnabled then return end
    self.State.IsEnabled = false
    for player, conns in pairs(self.State.Connections) do
        if type(conns) == "table" then
            for _, conn in pairs(conns) do conn:Disconnect() end
        else
            conns:Disconnect()
        end
    end
    table.clear(self.State.Connections)
    for character in pairs(self.State.TrackedCharacters) do
        self:_revert(character)
    end
    table.clear(self.State.OriginalSizes)
    DoNotif("Hitbox Extender: DISABLED", 2)
end
RegisterCommand({
    Name = "hitbox",
    Aliases = {},
    Description = "Enlarges other players' hitboxes locally for easier melee hits."
}, function(args)
    local multiplier = tonumber(args[1])
    if multiplier and multiplier > 0 then
        Modules.HitboxExtender.Config.SizeMultiplier = multiplier
        DoNotif("Hitbox multiplier set to " .. multiplier, 2)
    end
    if Modules.HitboxExtender.State.IsEnabled then
        if not multiplier then
            Modules.HitboxExtender:Disable()
        end
    else
        Modules.HitboxExtender:Enable()
    end
end)
Modules.NetworkSaturator = {
    State = {
        Active = false
    }
}
function Modules.NetworkSaturator:Start(): ()
    self.State.Active = true
    task.spawn(function()
        while self.State.Active do
            for _: number, obj: Instance in ipairs(game:GetDescendants()) do
                if obj:IsA("RemoteEvent") then
                    pcall(obj.FireServer, obj, math.huge, "Zuka_Saturate", string.rep("0", 100))
                end
            end
            task.wait(0.1)
        end
    end)
    DoNotif("Network Saturation: ACTIVE", 2)
end
RegisterCommand({
    Name = "rempayload",
    Aliases = {},
    Description = "Saturates discoverable remotes with high-density data payloads."
}, function()
    if Modules.NetworkSaturator.State.Active then
        Modules.NetworkSaturator.State.Active = false
        DoNotif("Network Saturation: DISABLED", 2)
    else
        Modules.NetworkSaturator:Start()
    end
end)
Modules.UltimateGod = {
    State = {
        IsEnabled = false,
        Connection = nil
    }
}
function Modules.UltimateGod:Toggle(): ()
    self.State.IsEnabled = not self.State.IsEnabled
    if self.State.IsEnabled then
        self.State.Connection = RunService.Heartbeat:Connect(function()
            local char: Model? = LocalPlayer.Character
            local hum: Humanoid? = char and char:FindFirstChildOfClass("Humanoid")
            if hum then
                hum:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
                hum:SetStateEnabled(Enum.HumanoidStateType.Physics, false)
                if hum.Health <= 0 then
                    hum.Health = hum.MaxHealth
                end
            end
        end)
        DoNotif("Ultimate Godmode: ENABLED", 2)
    else
        if self.State.Connection then self.State.Connection:Disconnect() end
        local hum: Humanoid? = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if hum then
            hum:SetStateEnabled(Enum.HumanoidStateType.Dead, true)
        end
        DoNotif("Ultimate Godmode: DISABLED", 2)
    end
end
RegisterCommand({
    Name = "god",
    Aliases = {},
    Description = "Aggressively locks humanoid state and health to prevent death."
}, function()
    Modules.UltimateGod:Toggle()
end)
Modules.NetworkNormalizer = {
    State = {
        IsNormalized = false,
        OriginalNames = {}
    },
    Config = {
        TARGET_CONTAINERS = {ReplicatedStorage},
        PREFIX = ""
    }
}
function Modules.NetworkNormalizer:Normalize()
    local count = 0
    table.clear(self.State.OriginalNames)
    print("--- [Network Normalization Started] ---")
    for _, container in ipairs(self.Config.TARGET_CONTAINERS) do
        local descendants = container:GetDescendants()
        for _, obj in ipairs(descendants) do
            if obj:IsA("RemoteEvent") or obj:IsA("RemoteFunction") then
                count += 1
                local oldPath = obj:GetFullName()
                local newName = self.Config.PREFIX .. tostring(count)
                self.State.OriginalNames[obj] = {
                    Name = obj.Name,
                    Path = oldPath
                }
                local success, err = pcall(function()
                    obj.Name = newName
                end)
                if success then
                    print(string.format("[ID: %d] Normalized: %s", count, oldPath))
                else
                    warn(string.format("[ID: %d] Failed to rename: %s | Error: %s", count, oldPath, err))
                end
            end
        end
    end
    self.State.IsNormalized = true
    DoNotif(string.format("Normalized %d network objects. Check F9 for the map.", count), 4)
    print("--- [Normalization Complete] ---")
end
function Modules.NetworkNormalizer:Restore()
    if not self.State.IsNormalized then
        return DoNotif("Network is not currently normalized.", 3)
    end
    local count = 0
    for obj, data in pairs(self.State.OriginalNames) do
        if obj and obj.Parent then
            pcall(function()
                obj.Name = data.Name
                count += 1
            end)
        end
    end
    self.State.IsNormalized = false
    table.clear(self.State.OriginalNames)
    DoNotif(string.format("Restored %d network objects to original states.", count), 3)
end
function Modules.NetworkNormalizer:Initialize()
    local module = self
    RegisterCommand({
        Name = "normalize",
        Aliases = {"renameremotes", "simplifynet"},
        Description = "Renames all Remotes in ReplicatedStorage to a numerical sequence (1-100+)."
    }, function()
        module:Normalize()
    end)
    RegisterCommand({
        Name = "unnormalize",
        Aliases = {"restoreremotes"},
        Description = "Restores all renamed remotes to their original obfuscated names."
    }, function()
        module:Restore()
    end)
end
Modules.UpvalueSurgeon = {
    State = {
        IsScanning = false
    },
    Config = {
        MAX_RESULTS = 50,
        BLACKLIST = {"Chat", "PlayerScripts", "CharacterSounds", "BubbleChat"}
    }
}
function Modules.UpvalueSurgeon:_convert(val: string): any
    if val:lower() == "true" then return true end
    if val:lower() == "false" then return false end
    if tonumber(val) then return tonumber(val) end
    return val
end
function Modules.UpvalueSurgeon:ScanGC(targetName: string)
    local matches = {}
    local getUpvalue = (debug and debug.getupvalue) or getupvalue
    local getInfo = (debug and debug.getinfo) or getinfo
    local isL = (islclosure or function(f) return true end)
    if not (getgc and getUpvalue and getInfo) then
        return matches
    end
    for _, obj in ipairs(getgc()) do
        if type(obj) == "function" and isL(obj) then
            local success, info = pcall(getInfo, obj)
            if success and info.source then
                local blacklisted = false
                for _, word in ipairs(self.Config.BLACKLIST) do
                    if info.source:find(word) then
                        blacklisted = true
                        break
                    end
                end
                if not blacklisted then
                    local idx = 1
                    while true do
                        local name, val = nil, nil
                        local ok, err = pcall(function()
                            name, val = getUpvalue(obj, idx)
                        end)
                        if not ok or not name then break end
                        if tostring(name) == targetName or (type(name) == "string" and name:lower() == targetName:lower()) then
                            table.insert(matches, {
                                Function = obj,
                                Index = idx,
                                Value = val,
                                Source = info.source,
                                FuncName = info.name or "Anonymous"
                            })
                        end
                        idx += 1
                        if idx > 100 then break end
                    end
                end
            end
        end
        if #matches >= self.Config.MAX_RESULTS then break end
    end
    return matches
end
function Modules.UpvalueSurgeon:Operate(targetName: string, rawValue: string)
    local newValue = self:_convert(rawValue)
    local setUpvalue = (debug and debug.setupvalue) or setupvalue
    local matches = self:ScanGC(targetName)
    local count = 0
    if not setUpvalue then return DoNotif("Executor lacks 'setupvalue'.", 3) end
    for _, m in ipairs(matches) do
        local ok = pcall(setUpvalue, m.Function, m.Index, newValue)
        if ok then
            count += 1
            print(string.format("[SURGEON] Modified upvalue '%s' in %s", targetName, m.Source))
        end
    end
    DoNotif(string.format("Surgery successful. Patched %d functions.", count), 3)
end
function Modules.UpvalueSurgeon:Initialize()
    local module = self
    RegisterCommand({
        Name = "upvalue",
        Aliases = {"surgeon", "ups"},
        Description = "Globally overwrites a local variable (upvalue) by name."
    }, function(args)
        local target, val = args[1], args[2]
        if not target or not val then return DoNotif("Usage: ;upvalue <name> <value>", 3) end
        module:Operate(target, val)
    end)
    RegisterCommand({
        Name = "scanup",
        Aliases = {"fup"},
        Description = "Scans game memory for functions containing a specific variable name."
    }, function(args)
        local target = args[1]
        if not target then return DoNotif("Variable name required.", 3) end
        DoNotif("Performing memory scan for: " .. target, 2)
        task.spawn(function()
            local matches = module:ScanGC(target)
            if #matches == 0 then
                DoNotif("No instances found in memory.", 3)
            else
                print("--- [Surgeon Scan Report] ---")
                for i, m in ipairs(matches) do
                    print(string.format("[%d] %s | Value: %s | Source: %s", i, m.FuncName, tostring(m.Value), m.Source))
                end
                DoNotif("Scan Complete. Found " .. #matches .. " matches. Check F9.", 4)
            end
        end)
    end)
end
Modules.FolderBringer = {
    State = {
        IsEnabled = true
    },
    Dependencies = {"Workspace", "Players"},
    Services = {}
}
function Modules.FolderBringer:Execute(args)
    if #args == 0 then
        return DoNotif("Usage: ;bringfolder {folderName} [partName]", 3)
    end
    local folder, partFilter
    local workspace = self.Services.Workspace
    local lp = self.Services.Players.LocalPlayer
    local char = lp.Character
    if not char then
        return DoNotif("Character not found.", 3)
    end
    for i = #args, 1, -1 do
        local potentialName = table.concat(args, " ", 1, i):lower()
        local potentialFilter = table.concat(args, " ", i + 1):lower()
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("Folder") and obj.Name:lower() == potentialName then
                folder = obj
                partFilter = potentialFilter
                break
            end
        end
        if folder then break end
    end
    if not folder then
        return DoNotif("Folder sequence not found in Workspace.", 3)
    end
    local pivot = char:GetPivot()
    local bringCount = 0
    for _, desc in ipairs(folder:GetDescendants()) do
        if desc:IsA("BasePart") then
            local shouldBring = true
            if partFilter and partFilter ~= "" then
                local n = desc.Name:lower()
                shouldBring = (n == partFilter) or (n:find(partFilter, 1, true) ~= nil)
            end
            if shouldBring then
                desc:PivotTo(pivot)
                bringCount = bringCount + 1
            end
        end
    end
    if bringCount > 0 then
        DoNotif(string.format("Brought %d parts from '%s'.", bringCount, folder.Name), 2)
    else
        DoNotif("No matching parts found in the folder.", 2)
    end
end
function Modules.FolderBringer:Initialize()
    local module = self
    for _, serviceName in ipairs(module.Dependencies) do
        module.Services[serviceName] = game:GetService(serviceName)
    end
    RegisterCommand({
        Name = "bringfolder",
        Aliases = {"bfldr", "folderbring"},
        Description = "Teleports all parts (or a specific part) from a Workspace folder to you."
    }, function(args)
        module:Execute(args)
    end)
end
Modules.QuickExecutor = {
    State = {
        IsEnabled = true
    }
}
function Modules.QuickExecutor:RunCode(args)
    local code = table.concat(args, " ")
    if not code or code == "" then
        return DoNotif("Quick Executor: No code provided.", 2)
    end
    local func, compileError = loadstring(code)
    if not func then
        warn("--> [QuickExecutor] Syntax Error:", compileError)
        return DoNotif("Syntax Error: Check F9 for details.", 3)
    end
    local success, runError = pcall(function()
        task.spawn(func)
    end)
    if not success then
        warn("--> [QuickExecutor] Runtime Error:", runError)
        DoNotif("Runtime Error occurred. Check F9 console.", 3)
    else
        DoNotif("Code executed.", 1)
    end
end
function Modules.QuickExecutor:Initialize()
    local module = self
    RegisterCommand({
        Name = "loadstring",
        Aliases = {"ls", "lstring", "loads", "execute", "run"},
        Description = "Compiles and executes Lua code directly from the command bar."
    }, function(args)
        module:RunCode(args)
    end)
end
Modules.CommandHistory = {
    State = {
        LastCommand = nil,
        PrevCommand = nil
    }
}
function Modules.CommandHistory:Record(message)
    local cmdName = message:sub(#Prefix + 1):match("%S+")
    if not cmdName then return end
    cmdName = cmdName:lower()
    local blacklist = {["lastcommand"] = true, ["lastcmd"] = true, ["re"] = true}
    if not blacklist[cmdName] then
        self.State.PrevCommand = self.State.LastCommand
        self.State.LastCommand = message
    end
end
function Modules.CommandHistory:ExecuteLast()
    local toRun = self.State.LastCommand
    if not toRun then
        return DoNotif("No previous command recorded.", 2)
    end
    if Modules.CommandBar and Modules.CommandBar.AddOutput then
        Modules.CommandBar:AddOutput("Replaying: " .. toRun, Modules.CommandBar.Theme.Accent)
    end
    processCommand(toRun)
end
function Modules.CommandHistory:Initialize()
    local module = self
    local oldProcess = processCommand
    getgenv().processCommand = function(message)
        module:Record(message)
        return oldProcess(message)
    end
    RegisterCommand({
        Name = "lastcommand",
        Aliases = {"lastcmd", "re", "redo"},
        Description = "Re-runs the last command you successfully executed."
    }, function()
        module:ExecuteLast()
    end)
end
Modules.CommandLooper = {
    State = {
        IsRunning = false,
        LoopThread = nil,
        CurrentCommand = nil
    },
    Config = {
        Interval = 1
    }
}
function Modules.CommandLooper:Start(commandName, args)
    local cmdFunc = Commands[commandName:lower()]
    if not cmdFunc then
        return DoNotif(string.format("Loop Error: Command ';%s' not found.", commandName), 3)
    end
    if commandName:lower() == "cmdloop" or commandName:lower() == "commandloop" then
        return DoNotif("Architect Error: Infinite recursion prevented.", 3)
    end
    self:Stop()
    self.State.IsRunning = true
    self.State.CurrentCommand = commandName
    DoNotif(string.format("Looping command ';%s' every %ds.", commandName, self.Config.Interval), 2)
    self.State.LoopThread = task.spawn(function()
        while self.State.IsRunning do
            local success, err = pcall(cmdFunc, args)
            if not success then
                warn("--> [CommandLooper] Error in loop:", err)
            end
            task.wait(self.Config.Interval)
        end
    end)
end
function Modules.CommandLooper:Stop()
    if not self.State.IsRunning then return end
    self.State.IsRunning = false
    if self.State.LoopThread then
        task.cancel(self.State.LoopThread)
        self.State.LoopThread = nil
    end
    DoNotif(string.format("Stopped loop for ';%s'.", self.State.CurrentCommand or "unknown"), 2)
    self.State.CurrentCommand = nil
end
function Modules.CommandLooper:Initialize()
    local module = self
    RegisterCommand({
        Name = "commandloop",
        Aliases = {"cmdloop", "cloop"},
        Description = "Runs a command repeatedly."
    }, function(args)
        if #args == 0 then
            return DoNotif("Usage: ;cmdloop <command> [args]", 3)
        end
        local cmdTarget = table.remove(args, 1)
        module:Start(cmdTarget, args)
    end)
    RegisterCommand({
        Name = "stoploop",
        Aliases = {"uncmdloop", "sloop", "stopl", "unloop"},
        Description = "Stops the currently running command loop."
    }, function()
        if not module.State.IsRunning then
            return DoNotif("No command is currently looping.", 2)
        end
        module:Stop()
    end)
end
Modules.ChatFilterReseter = {
    State = {
        IsEnabled = true
    },
    Dependencies = {"Players"},
    Services = {}
}
function Modules.ChatFilterReseter:Reset()
    local lp = self.Services.Players.LocalPlayer
    if not lp then return end
    DoNotif("Resetting chat filter...", 2)
    for i = 1, 3 do
        pcall(function()
            lp:Chat("/e hi")
        end)
        task.wait(0.1)
    end
    DoNotif("Filter Reset: Complete.", 2)
end
function Modules.ChatFilterReseter:Initialize()
    local module = self
    for _, serviceName in ipairs(module.Dependencies) do
        module.Services[serviceName] = game:GetService(serviceName)
    end
    RegisterCommand({
        Name = "resetfilter",
        Aliases = {"ref", "resetchat", "unfilter"},
        Description = "Sends emote commands to try and stop Roblox from tagging your messages."
    }, function()
        module:Reset()
    end)
end
Modules.ToolMasher = {
    State = {
        IsExecuting = false
    },
    Dependencies = {"Players"},
    Services = {}
}
function Modules.ToolMasher:Mash()
    if self.State.IsExecuting then return end
    local lp = self.Services.Players.LocalPlayer
    local char = lp.Character
    local backpack = lp:FindFirstChildOfClass("Backpack")
    if not char or not backpack then
        return DoNotif("Tool Masher: Character or Backpack missing.", 3)
    end
    self.State.IsExecuting = true
    local toolBuffer = {}
    for _, tool in ipairs(backpack:GetChildren()) do
        if tool:IsA("Tool") then
            table.insert(toolBuffer, tool)
            tool.Parent = char
        end
    end
    for _, tool in ipairs(char:GetChildren()) do
        if tool:IsA("Tool") and not table.find(toolBuffer, tool) then
            table.insert(toolBuffer, tool)
        end
    end
    if #toolBuffer == 0 then
        self.State.IsExecuting = false
        return DoNotif("No tools found to mash.", 2)
    end
    task.wait(0.1)
    local successCount = 0
    for _, tool in ipairs(toolBuffer) do
        pcall(function()
            tool:Activate()
            successCount = successCount + 1
        end)
    end
    task.wait(0.1)
    for _, tool in ipairs(toolBuffer) do
        pcall(function()
            tool.Parent = backpack
        end)
    end
    DoNotif(string.format("Mashed %d tools successfully.", successCount), 2)
    self.State.IsExecuting = false
end
function Modules.ToolMasher:Initialize()
    local module = self
    for _, serviceName in ipairs(module.Dependencies) do
        module.Services[serviceName] = game:GetService(serviceName)
    end
    RegisterCommand({
        Name = "usetools",
        Aliases = {"uset", "mash", "useall"},
        Description = "Equips every tool you own, uses them once, and puts them back."
    }, function()
        module:Mash()
    end)
end
Modules.InvisDeleter = {
    State = {
        IsScanning = false
    },
    Dependencies = {"Workspace"},
    Services = {}
}
function Modules.InvisDeleter:Purge()
    if self.State.IsScanning then
        return DoNotif("Purge already in progress...", 2)
    end
    local workspace = self.Services.Workspace
    local count = 0
    self.State.IsScanning = true
    DoNotif("Scanning for invisible walls...", 2)
    task.spawn(function()
        local descendants = workspace:GetDescendants()
        for i, part in ipairs(descendants) do
            if i % 500 == 0 then task.wait() end
            if part:IsA("BasePart") then
                if part.Transparency >= 1 and part.CanCollide then
                    local char = game:GetService("Players").LocalPlayer.Character
                    if not (char and part:IsDescendantOf(char)) then
                        pcall(function()
                            part:Destroy()
                            count = count + 1
                        end)
                    end
                end
            end
        end
        self.State.IsScanning = false
        DoNotif(string.format("Purge complete. Destroyed %d parts.", count), 3)
    end)
end
function Modules.InvisDeleter:Initialize()
    local module = self
    for _, serviceName in ipairs(module.Dependencies) do
        module.Services[serviceName] = game:GetService(serviceName)
    end
    RegisterCommand({
        Name = "deleteinvisparts",
        Aliases = {"deleteinvisibleparts", "dip", "delinvis", "unblock"},
        Description = "Removes all invisible parts that have collisions enabled (Invisible Walls)."
    }, function()
        module:Purge()
    end)
end
Modules.AutoInteract = {
    State = {
        IsEnabled = false,
        Radius = 15,
        Connection = nil
    }
}
function Modules.AutoInteract:Enable(radius: number)
    if self.State.IsEnabled then self:Disable() end
    self.State.Radius = tonumber(radius) or 15
    self.State.IsEnabled = true
    self.State.Connection = RunService.Heartbeat:Connect(function()
        local character = Players.LocalPlayer.Character
        local hrp = character and character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        for _, prompt in ipairs(Workspace:GetDescendants()) do
            if prompt:IsA("ProximityPrompt") then
                local part = prompt.Parent
                if part and part:IsA("BasePart") then
                    local distance = (hrp.Position - part.Position).Magnitude
                    if distance <= self.State.Radius then
                        if fireproximityprompt then
                            fireproximityprompt(prompt)
                        end
                    end
                end
            end
        end
    end)
    DoNotif("Auto-Interact: ENABLED (Radius: " .. self.State.Radius .. ")", 2)
end
function Modules.AutoInteract:Disable()
    if not self.State.IsEnabled then return end
    if self.State.Connection then
        self.State.Connection:Disconnect()
        self.State.Connection = nil
    end
    self.State.IsEnabled = false
    DoNotif("Auto-Interact: DISABLED", 2)
end
RegisterCommand({
    Name = "autoprompt",
    Aliases = {"autointeract", "ap"},
    Description = "Automatically triggers proximity prompts within a radius."
}, function(args)
    if args[1] == "off" then
        Modules.AutoInteract:Disable()
    else
        Modules.AutoInteract:Enable(args[1])
    end
end)
Modules.PhysicsGun = {
    State = {
        IsEnabled = false,
        SelectedPart = nil,
        Connection = nil,
        AlignPos = nil,
        AlignOri = nil,
        Attachment0 = nil,
        Attachment1 = nil
    }
}
function Modules.PhysicsGun:Toggle()
    self.State.IsEnabled = not self.State.IsEnabled
    if self.State.IsEnabled then
        local mouse = Players.LocalPlayer:GetMouse()
        self.State.Connection = RunService.RenderStepped:Connect(function()
            if UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
                if not self.State.SelectedPart then
                    local target = mouse.Target
                    if target and not target.Anchored and not target:FindFirstAncestorOfClass("Model"):FindFirstChild("Humanoid") then
                        self.State.SelectedPart = target
                        self.State.Attachment1 = Instance.new("Attachment", Workspace.Terrain)
                        self.State.Attachment0 = Instance.new("Attachment", target)
                        local ap = Instance.new("AlignPosition")
                        ap.Attachment0 = self.State.Attachment0
                        ap.Attachment1 = self.State.Attachment1
                        ap.MaxForce = 1e9
                        ap.Responsiveness = 200
                        ap.Parent = target
                        self.State.AlignPos = ap
                        local ao = Instance.new("AlignOrientation")
                        ao.Attachment0 = self.State.Attachment0
                        ao.Attachment1 = self.State.Attachment1
                        ao.MaxTorque = 1e9
                        ao.Responsiveness = 200
                        ao.Parent = target
                        self.State.AlignOri = ao
                    end
                end
                if self.State.SelectedPart and self.State.Attachment1 then
                    self.State.Attachment1.WorldCFrame = mouse.Hit
                end
            else
                if self.State.AlignPos then self.State.AlignPos:Destroy() end
                if self.State.AlignOri then self.State.AlignOri:Destroy() end
                if self.State.Attachment0 then self.State.Attachment0:Destroy() end
                if self.State.Attachment1 then self.State.Attachment1:Destroy() end
                self.State.SelectedPart = nil
            end
        end)
        DoNotif("Physics Gun: ENABLED (Hold LMB)", 2)
    else
        if self.State.Connection then self.State.Connection:Disconnect() end
        self.State.IsEnabled = false
        DoNotif("Physics Gun: DISABLED", 2)
    end
end
RegisterCommand({
    Name = "physicsgun",
    Aliases = {},
    Description = "Allows you to grab and move unanchored parts with your mouse."
}, function()
    Modules.PhysicsGun:Toggle()
end)
Modules.VisualClear = {
    State = {
        IsEnabled = false,
        OriginalStates = {}
    }
}
function Modules.VisualClear:Toggle()
    self.State.IsEnabled = not self.State.IsEnabled
    if self.State.IsEnabled then
        for _, effect in ipairs(Lighting:GetChildren()) do
            if effect:IsA("PostProcessEffect") then
                self.State.OriginalStates[effect] = effect.Enabled
                effect.Enabled = false
            end
        end
        for _, effect in ipairs(Workspace.CurrentCamera:GetChildren()) do
            if effect:IsA("PostProcessEffect") then
                self.State.OriginalStates[effect] = effect.Enabled
                effect.Enabled = false
            end
        end
        DoNotif("Visual Clear: ENABLED (Blur/Bloom Removed)", 2)
    else
        for effect, state in pairs(self.State.OriginalStates) do
            if effect and effect.Parent then
                effect.Enabled = state
            end
        end
        table.clear(self.State.OriginalStates)
        DoNotif("Visual Clear: DISABLED", 2)
    end
end
RegisterCommand({
    Name = "clearvisuals",
    Aliases = {},
    Description = "Removes all post-processing effects like Blur, Bloom, and ColorCorrection."
}, function()
    Modules.VisualClear:Toggle()
end)
Modules.NetworkOwner = {
    State = {
        IsEnabled = false,
        Connection = nil,
        CharacterAddedConn = nil,
        CachedParts = {}
    },
    Config = {
        NETWORK_VELOCITY = Vector3.new(0, 30.01, 0)
    }
}
function Modules.NetworkOwner:CacheCharacterParts(character: Model)
    table.clear(self.State.CachedParts)
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            table.insert(self.State.CachedParts, part)
        end
    end
end
function Modules.NetworkOwner:Enable(): ()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    local localPlayer = Players.LocalPlayer
    local function setup(character)
        self:CacheCharacterParts(character)
    end
    if localPlayer.Character then
        setup(localPlayer.Character)
    end
    self.State.CharacterAddedConn = localPlayer.CharacterAdded:Connect(setup)
    self.State.Connection = RunService.Heartbeat:Connect(function()
        local character = localPlayer.Character
        if not character then return end
        for i = #self.State.CachedParts, 1, -1 do
            local part = self.State.CachedParts[i]
            if part and part.Parent then
                part.AssemblyLinearVelocity = self.Config.NETWORK_VELOCITY
            else
                table.remove(self.State.CachedParts, i)
            end
        end
    end)
    DoNotif("Netless: ENABLED (Persistent Physics Authority)", 2)
end
function Modules.NetworkOwner:Disable(): ()
    if not self.State.IsEnabled then return end
    self.State.IsEnabled = false
    if self.State.Connection then
        self.State.Connection:Disconnect()
        self.State.Connection = nil
    end
    if self.State.CharacterAddedConn then
        self.State.CharacterAddedConn:Disconnect()
        self.State.CharacterAddedConn = nil
    end
    table.clear(self.State.CachedParts)
    DoNotif("Netless: DISABLED", 2)
end
function Modules.NetworkOwner:Toggle(): ()
    if self.State.IsEnabled then
        self:Disable()
    else
        self:Enable()
    end
end
RegisterCommand({
    Name = "netless",
    Aliases = {"networkowner", "net"},
    Description = "Optimized persistence of network ownership for character parts."
}, function()
    Modules.NetworkOwner:Toggle()
end)
Modules.ToolAttributeLister = {
    State = {}
}
function Modules.ToolAttributeLister:Scan(): ()
    local character = LocalPlayer.Character
    if not character then
        return DoNotif("Character not found.", 3)
    end
    local tool = character:FindFirstChildOfClass("Tool")
    if not tool then
        return DoNotif("You must have a tool equipped to scan it.", 3)
    end
    local attributes = tool:GetAttributes()
    local attributeCount = 0
    print("--- [Attribute Scan: " .. tool.Name .. "] ---")
    for name, value in pairs(attributes) do
        attributeCount = attributeCount + 1
        local valueType = typeof(value)
        local formattedValue = tostring(value)
        if valueType == "Color3" then
            formattedValue = string.format("RGB(%d, %d, %d)", value.R * 255, value.G * 255, value.B * 255)
        elseif valueType == "Vector3" then
            formattedValue = string.format("(%.2f, %.2f, %.2f)", value.X, value.Y, value.Z)
        end
        print(string.format("  [!] %s [%s]: %s", name, valueType, formattedValue))
    end
    if attributeCount == 0 then
        print("  (No attributes found on this tool)")
        DoNotif("No attributes found on " .. tool.Name, 3)
    else
        print("--- Total Attributes: " .. attributeCount .. " ---")
        DoNotif("Listed " .. attributeCount .. " attributes for " .. tool.Name .. " in F9 console.", 4)
    end
end
RegisterCommand({
    Name = "listattributes",
    Aliases = {"toolattrs", "getattr", "scantool"},
    Description = "Dumps every attribute and value of the equipped tool to the developer console (F9)."
}, function()
    Modules.ToolAttributeLister:Scan()
end)
Modules.NeuralOverride = {
    State = {
        IsScanning = false
    }
}
function Modules.NeuralOverride:OverwriteData(targetVar: string, newValue: any): ()
    if not (getgc and debug.getupvalue and debug.setupvalue) then
        return DoNotif("NeuralOverride: Executor lacks debug library support.", 3)
    end
    local count: number = 0
    local convertedValue: any = newValue
    if newValue == "true" then convertedValue = true
    elseif newValue == "false" then convertedValue = false
    elseif tonumber(newValue) then convertedValue = tonumber(newValue) end
    for _: number, obj: any in ipairs(getgc()) do
        if type(obj) == "function" and islclosure(obj) then
            local idx: number = 1
            while true do
                local name: string?, val: any = debug.getupvalue(obj, idx)
                if not name then break end
                if name == targetVar then
                    pcall(debug.setupvalue, obj, idx, convertedValue)
                    count = count + 1
                end
                idx = idx + 1
            end
        end
    end
    DoNotif(string.format("NeuralOverride: Patched %d instances of '%s'", count, targetVar), 3)
end
RegisterCommand({
    Name = "patch",
    Aliases = {},
    Description = "Scans game memory and overwrites internal script variables. ;neural isAdmin true"
}, function(args: {string})
    if #args < 2 then return DoNotif("Usage: ;neural [varName] [value]", 3) end
    Modules.NeuralOverride:OverwriteData(args[1], args[2])
end)
Modules.InterstellarInteraction = {
    State = {
        Active = false,
        Connection = nil
    }
}
function Modules.InterstellarInteraction:Toggle(): ()
    self.State.Active = not self.State.Active
    if self.State.Active then
        self.State.Connection = RunService.Heartbeat:Connect(function()
            for _: number, obj: Instance in ipairs(Workspace:GetDescendants()) do
                if obj:IsA("ProximityPrompt") then
                    obj.RequiresLineOfSight = false
                    obj.MaxActivationDistance = 1e7
                    if fireproximityprompt then
                        fireproximityprompt(obj)
                    end
                end
                if obj:IsA("ClickDetector") then
                    obj.MaxActivationDistance = 1e7
                    if fireclickdetector then
                        fireclickdetector(obj)
                    end
                end
            end
        end)
        DoNotif("Interstellar: Global Interaction ACTIVE", 2)
    else
        if self.State.Connection then self.State.Connection:Disconnect() end
        DoNotif("Interstellar: Global Interaction DISABLED", 2)
    end
end
RegisterCommand({
    Name = "fireallclickprompt",
    Aliases = {"massfire", "autofireall"},
    Description = "Automatically triggers every Prompt and ClickDetector in the game regardless of distance."
}, function()
    Modules.InterstellarInteraction:Toggle()
end)
Modules.IdentityPhantom = {
    State = {
        IsEnabled = false,
        OriginalIndex = nil
    }
}
function Modules.IdentityPhantom:Toggle(targetUser: string?): ()
    local success, mt = pcall(getrawmetatable, game)
    if not success or not mt then return end
    self.State.IsEnabled = not self.State.IsEnabled
    if self.State.IsEnabled then
        self.State.OriginalIndex = mt.__index
        local originalIndex = self.State.OriginalIndex
        local fakeId: number = 1
        local fakeName: string = targetUser or "Roblox"
        pcall(function()
            if targetUser then
                fakeId = Players:GetUserIdFromNameAsync(targetUser)
            end
        end)
        setreadonly(mt, false)
        mt.__index = newcclosure(function(selfArg, key)
            if Modules.IdentityPhantom.State.IsEnabled and selfArg == LocalPlayer then
                if key == "UserId" or key == "userId" then return fakeId end
                if key == "Name" or key == "name" then return fakeName end
            end
            return originalIndex(selfArg, key)
        end)
        setreadonly(mt, true)
        DoNotif("Identity Phantom: Masked as " .. fakeName, 3)
    else
        setreadonly(mt, false)
        mt.__index = self.State.OriginalIndex
        setreadonly(mt, true)
        DoNotif("Identity Phantom: Mask REMOVED", 2)
    end
end
RegisterCommand({
    Name = "nchange",
    Aliases = {"mask"},
    Description = "Locally spoofs your Name and UserId to fool group-based admin scripts."
}, function(args: {string})
    Modules.IdentityPhantom:Toggle(args[1])
end)
Modules.InventorySynth = {
    State = {
        DiscoveredTools = {}
    }
}
function Modules.InventorySynth:Scan()
    table.clear(self.State.DiscoveredTools)
    for _, obj in ipairs(ReplicatedStorage:GetDescendants()) do
        if obj:IsA("Tool") then
            table.insert(self.State.DiscoveredTools, obj)
        end
    end
    DoNotif("Synthesis: Found " .. #self.State.DiscoveredTools .. " tool templates.", 3)
end
function Modules.InventorySynth:CloneTool(name)
    local lowerName = name:lower()
    for _, tool in ipairs(self.State.DiscoveredTools) do
        if tool.Name:lower():find(lowerName) then
            local clone = tool:Clone()
            clone.Parent = Players.LocalPlayer.Backpack
            DoNotif("Synthesized: " .. tool.Name, 2)
            return
        end
    end
    DoNotif("Tool not found in cache. Run ;scantools first.", 3)
end
RegisterCommand({
    Name = "scantools",
    Aliases = {"findgears"},
    Description = "Scans ReplicatedStorage for Tool templates."
}, function()
    Modules.InventorySynth:Scan()
end)
RegisterCommand({
    Name = "gettool",
    Aliases = {},
    Description = "Clones a discovered tool to your backpack."
}, function(args)
    if #args > 0 then
        Modules.InventorySynth:CloneTool(args[1])
    else
        DoNotif("Usage: ;gettool [ToolName]", 3)
    end
end)
Modules.PromptForensics = {
    State = {
        OriginalSettings = {}
    }
}
function Modules.PromptForensics:Expose()
    local count = 0
    for _, prompt in ipairs(Workspace:GetDescendants()) do
        if prompt:IsA("ProximityPrompt") then
            prompt.HoldDuration = 0
            prompt.MaxActivationDistance = 50
            prompt.Enabled = true
            prompt.RequiresLineOfSight = false
            count = count + 1
        end
    end
    DoNotif("Forensics: Optimized " .. count .. " prompts. (0s Hold, 50 Distance)", 3)
end
RegisterCommand({
    Name = "forceprompt",
    Aliases = {},
    Description = "Forces all proximity prompts to be instant and high-range."
}, function()
    Modules.PromptForensics:Expose()
end)
Modules.AnimSynth = {
    State = {
        GeneratedID = nil
    }
}
function Modules.AnimSynth:GenerateCustomPose(poseType)
    local sequence = Instance.new("KeyframeSequence")
    local keyframe = Instance.new("Keyframe")
    keyframe.Time = 0
    keyframe.Parent = sequence
    local hash = "rbxassetid://0"
    local root = Instance.new("Pose")
    root.Name = "HumanoidRootPart"
    root.Weight = 1
    local torso = Instance.new("Pose")
    torso.Name = "Torso"
    torso.CFrame = CFrame.Angles(math.rad(45), 0, 0)
    torso.Parent = root
    if poseType == "ghost" then
        torso.CFrame = CFrame.new(0, 5, 0)
    elseif poseType == "broken" then
        torso.CFrame = CFrame.Angles(0, math.rad(180), 0)
    end
    root.Parent = keyframe
    pcall(function()
        local provider = game:GetService("KeyframeSequenceProvider")
        hash = provider:RegisterActiveKeyframeSequence(sequence)
    end)
    self.State.GeneratedID = hash
    print("  [!] Custom Animation Generated: " .. hash)
    setclipboard(hash)
    DoNotif("Custom Pose Ready! ID copied to clipboard.", 4)
end
RegisterCommand({
    Name = "localanim",
    Aliases = {},
    Description = "Generates a custom local animation ID. Options: ghost, broken, normal"
}, function(args)
    Modules.AnimSynth:GenerateCustomPose(args[1] or "normal")
end)
Modules.ToolAnimForensics = {
    State = {
        IsEnabled = false,
        ToolAnims = {},
        SwappedIds = {},
        OriginalNamecall = nil
    }
}
function Modules.ToolAnimForensics:Scan()
    local char = Players.LocalPlayer.Character
    local tool = char and char:FindFirstChildOfClass("Tool")
    if not tool then
        return DoNotif("Tool Anim: No tool equipped to scan.", 3)
    end
    table.clear(self.State.ToolAnims)
    local count = 0
    for _, obj in ipairs(tool:GetDescendants()) do
        if obj:IsA("Animation") then
            count = count + 1
            local animName = obj.Name:lower()
            self.State.ToolAnims[animName] = obj
            print(string.format("  [+] Found Animation: '%s' | ID: %s", obj.Name, obj.AnimationId))
        end
    end
    DoNotif(string.format("Scan Complete: Found %d animations in %s. Check F9.", count, tool.Name), 4)
end
function Modules.ToolAnimForensics:Hook()
    if self.State.OriginalNamecall then return end
    local mt = getrawmetatable(game)
    self.State.OriginalNamecall = mt.__namecall
    setreadonly(mt, false)
    mt.__namecall = newcclosure(function(selfArg, ...)
        local method = getnamecallmethod()
        local args = {...}
        if (method == "LoadAnimation" or method == "loadAnimation") and args[1]:IsA("Animation") then
            local animObj = args[1]
            local replacement = Modules.ToolAnimForensics.State.SwappedIds[animObj.AnimationId]
            if replacement then
                animObj.AnimationId = replacement
            end
        end
        return Modules.ToolAnimForensics.State.OriginalNamecall(selfArg, ...)
    end)
    setreadonly(mt, true)
end
function Modules.ToolAnimForensics:Set(name, newId)
    local targetName = name:lower()
    local animObj = self.State.ToolAnims[targetName]
    if not animObj then
        local tool = Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
        animObj = tool and tool:FindFirstChild(name, true)
    end
    if animObj and animObj:IsA("Animation") then
        local rawId = "rbxassetid://" .. newId:match("%d+")
        self.State.SwappedIds[animObj.AnimationId] = rawId
        animObj.AnimationId = rawId
        self:Hook()
        DoNotif("Swapped '" .. name .. "' with " .. rawId, 3)
        local humanoid = Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
                if track.Animation.AnimationId == animObj.AnimationId then
                    track:Stop()
                end
            end
        end
    else
        DoNotif("Animation '" .. name .. "' not found. Use ;scananim first.", 3)
    end
end
RegisterCommand({
    Name = "scananim",
    Aliases = {"listanims", "toolanims"},
    Description = "Scans the equipped tool for animations and lists them in the console."
}, function()
    Modules.ToolAnimForensics:Scan()
end)
RegisterCommand({
    Name = "setanim",
    Aliases = {"swapanim"},
    Description = "Swaps a tool animation. Usage: ;setanim [name] [id]"
}, function(args)
    if #args < 2 then
        return DoNotif("Usage: ;setanim [Idle/Attack/etc] [ID]", 3)
    end
    Modules.ToolAnimForensics:Set(args[1], args[2])
end)
Modules.Aggressor = {
    State = {
        IsEnabled = false,
        TargetPlayer = nil,
        LoopThread = nil,
        Index = 0
    },
    Config = {
        Frequency = 0.35,
        OffsetDistance = 1.5,
        VerticalAdjustment = 1
    },
    Dependencies = {"Players", "RunService"},
    Services = {}
}
function Modules.Aggressor:Stop()
    self.State.IsEnabled = false
    if self.State.LoopThread then
        task.cancel(self.State.LoopThread)
        self.State.LoopThread = nil
    end
    local char = game:GetService("Players").LocalPlayer.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    if hum then
        hum:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
    end
    self.State.TargetPlayer = nil
    DoNotif("Aggressor sequence terminated.", 2)
end
function Modules.Aggressor:Start(targetPlayer)
    if self.State.IsEnabled then self:Stop() end
    local lp = game:GetService("Players").LocalPlayer
    local char = lp.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not (hum and root) then return DoNotif("Character not found.", 3) end
    self.State.IsEnabled = true
    self.State.TargetPlayer = targetPlayer
    self.State.Index = 0
    hum:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
    hum.Sit = false
    self.State.LoopThread = task.spawn(function()
        while self.State.IsEnabled do
            local tChar = targetPlayer.Character
            local tHum = tChar and tChar:FindFirstChildOfClass("Humanoid")
            local tRoot = tChar and tChar:FindFirstChild("HumanoidRootPart")
            if not (tChar and tHum and tRoot and char.Parent and hum.Health > 0) then
                self:Stop()
                break
            end
            self.State.Index += self.Config.Frequency
            if tHum.FloorMaterial == Enum.Material.Air and hum.FloorMaterial ~= Enum.Material.Air and not tHum.Sit then
                hum:ChangeState(Enum.HumanoidStateType.Jumping)
            end
            local sinValue = math.sin(self.State.Index) * self.Config.OffsetDistance
            local offset
            if tHum.Sit then
                offset = CFrame.new(0, 0, -self.Config.OffsetDistance + sinValue)
            else
                offset = CFrame.new(0, 0, self.Config.OffsetDistance + sinValue)
            end
            local targetGoal = tRoot.CFrame * offset
            root.CFrame = CFrame.new(targetGoal.Position, Vector3.new(tRoot.Position.X, root.Position.Y, tRoot.Position.Z))
            task.wait()
        end
    end)
    DoNotif("Aggressor sequence started on " .. targetPlayer.Name, 2)
end
RegisterCommand({
    Name = "bang",
    Aliases = {},
    Description = "Starts a baby making process."
}, function(args)
    local target = Utilities.findPlayer(args[1] or "")
    if target and target ~= game:GetService("Players").LocalPlayer then
        Modules.Aggressor:Start(target)
    else
        DoNotif("Invalid player target.", 3)
    end
end)
RegisterCommand({
    Name = "unbang",
    Aliases = {},
    Description = "Stops the baby making process."
}, function()
    Modules.Aggressor:Stop()
end)
Modules.Hugger = {
    State = {
        IsEnabled = false,
        FromFront = false,
        Target = nil,
        Tracks = {},
        Walls = {},
        UI = nil,
        Connections = {}
    },
    Config = {
        ANIM_1 = "rbxassetid://283545583",
        ANIM_2 = "rbxassetid://225975820",
        OFFSET = 1.5
    },
    Dependencies = {"Players", "RunService", "CoreGui", "UserInputService"},
    Services = {}
}
function Modules.Hugger:_clearCurrent()
    for _, track in pairs(self.State.Tracks) do
        pcall(function() track:Stop() end)
    end
    self.State.Tracks = {}
    for _, part in pairs(self.State.Walls) do
        pcall(function() part:Destroy() end)
    end
    self.State.Walls = {}
    if self.State.Connections.Loop then
        self.State.Connections.Loop:Disconnect()
        self.State.Connections.Loop = nil
    end
    self.State.Target = nil
end
function Modules.Hugger:_createCage(root)
    local thick = 0.2
    local size = 4
    local height = 6
    local wallData = {
        {off = CFrame.new(0, 0, 2), sz = Vector3.new(size, height, thick)},
        {off = CFrame.new(0, 0, -2), sz = Vector3.new(size, height, thick)},
        {off = CFrame.new(2, 0, 0), sz = Vector3.new(thick, height, size)},
        {off = CFrame.new(-2, 0, 0), sz = Vector3.new(thick, height, size)},
        {off = CFrame.new(0, 3, 0), sz = Vector3.new(size, thick, size)},
        {off = CFrame.new(0, -3, 0), sz = Vector3.new(size, thick, size)}
    }
    for _, data in ipairs(wallData) do
        local p = Instance.new("Part")
        p.Size = data.sz
        p.Transparency = 1
        p.Anchored = true
        p.CanCollide = true
        p.Parent = workspace
        table.insert(self.State.Walls, p)
    end
    self.State.Connections.Cage = self.Services.RunService.Stepped:Connect(function()
        if not self.State.IsEnabled or not root.Parent then return end
        for i, data in ipairs(wallData) do
            local part = self.State.Walls[i]
            if part then part.CFrame = root.CFrame * data.off end
        end
    end)
end
function Modules.Hugger:Apply(targetChar)
    local lp = self.Services.Players.LocalPlayer
    local myChar = lp.Character
    local myHum = myChar and myChar:FindFirstChildOfClass("Humanoid")
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    local tRoot = targetChar:FindFirstChild("HumanoidRootPart")
    if not (myHum and myRoot and tRoot) then return end
    self:_clearCurrent()
    self.State.Target = targetChar
    local a1, a2 = Instance.new("Animation"), Instance.new("Animation")
    a1.AnimationId = self.Config.ANIM_1
    a2.AnimationId = self.Config.ANIM_2
    local tr1 = myHum:LoadAnimation(a1)
    local tr2 = myHum:LoadAnimation(a2)
    table.insert(self.State.Tracks, tr1)
    table.insert(self.State.Tracks, tr2)
    tr1:Play()
    tr2:Play()
    self:_createCage(myRoot)
    self.State.Connections.Loop = self.Services.RunService.Heartbeat:Connect(function()
        if not self.State.IsEnabled or not tRoot.Parent or myHum.Health <= 0 then
            self:Toggle()
            return
        end
        local look = tRoot.CFrame.LookVector
        local offset = self.State.FromFront and (look * self.Config.OFFSET) or (-look * self.Config.OFFSET)
        myRoot.CFrame = CFrame.lookAt(tRoot.Position + offset, tRoot.Position)
    end)
end
function Modules.Hugger:CreateUI()
    if self.State.UI then self.State.UI.Enabled = true return end
    local sg = Instance.new("ScreenGui", self.Services.CoreGui)
    sg.Name = "HugController_Zuka"
    self.State.UI = sg
    local frame = Instance.new("Frame", sg)
    frame.Size = UDim2.fromOffset(200, 100)
    frame.Position = UDim2.new(0.5, -100, 0.1, 0)
    frame.BackgroundColor3 = Color3.new(0,0,0)
    frame.BackgroundTransparency = 0.5
    Instance.new("UICorner", frame)
    local toggle = Instance.new("TextButton", frame)
    toggle.Size = UDim2.new(1, -10, 0, 40)
    toggle.Position = UDim2.fromOffset(5, 5)
    toggle.Text = "Hug Mode: OFF"
    toggle.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    toggle.TextColor3 = Color3.new(1,1,1)
    toggle.Font = Enum.Font.Code
    local side = toggle:Clone()
    side.Parent = frame
    side.Position = UDim2.fromOffset(5, 50)
    side.Text = "Hug Side: Back"
    toggle.MouseButton1Click:Connect(function()
        self.State.IsEnabled = not self.State.IsEnabled
        toggle.Text = "Hug Mode: " .. (self.State.IsEnabled and "ON" or "OFF")
        toggle.TextColor3 = self.State.IsEnabled and Color3.new(0, 1, 0.5) or Color3.new(1,1,1)
        if not self.State.IsEnabled then self:_clearCurrent() end
    end)
    side.MouseButton1Click:Connect(function()
        self.State.FromFront = not self.State.FromFront
        side.Text = "Hug Side: " .. (self.State.FromFront and "Front" or "Back")
    end)
    local mouse = self.Services.Players.LocalPlayer:GetMouse()
    self.State.Connections.Click = mouse.Button1Down:Connect(function()
        if not self.State.IsEnabled then return end
        local target = mouse.Target
        if target and target.Parent then
            local p = self.Services.Players:GetPlayerFromCharacter(target.Parent)
            if p and p ~= self.Services.Players.LocalPlayer then
                self:Apply(p.Character)
            end
        end
    end)
    DoNotif("Hugger UI Loaded. Enable and Click a player.", 3)
end
function Modules.Hugger:Initialize()
    for _, s in ipairs(self.Dependencies) do self.Services[s] = game:GetService(s) end
    RegisterCommand({
        Name = "hug",
        Aliases = {"huggies", "clickhug"},
        Description = "Toggles a UI for physical character interaction (R6 Only)."
    }, function()
        local lp = game:GetService("Players").LocalPlayer
        local hum = lp.Character and lp.Character:FindFirstChildOfClass("Humanoid")
        if hum and hum.RigType == Enum.HumanoidRigType.R6 then
            self:CreateUI()
        else
            DoNotif("This command requires an R6 Avatar.", 3)
        end
    end)
    RegisterCommand({
        Name = "unhug",
        Description = "Force stops all hug interactions and UI."
    }, function()
        self.State.IsEnabled = false
        self:_clearCurrent()
        if self.State.UI then self.State.UI:Destroy(); self.State.UI = nil end
        if self.State.Connections.Click then self.State.Connections.Click:Disconnect() end
    end)
end
Modules.TeamChanger = {
    State = {
        IsExecuting = false
    },
    Dependencies = {"Teams", "Players", "Workspace"},
    Services = {}
}
function Modules.TeamChanger:Execute(teamNameInput)
    if not teamNameInput or teamNameInput == "" then
        return DoNotif("Usage: ;team <TeamName>", 3)
    end
    local Teams = self.Services.Teams
    if not Teams then return end
    local targetTeam = nil
    local lookup = teamNameInput:lower()
    for _, team in ipairs(Teams:GetChildren()) do
        if team:IsA("Team") and team.Name:lower():find(lookup, 1, true) then
            targetTeam = team
            break
        end
    end
    if not targetTeam then
        return DoNotif("Invalid team: '" .. teamNameInput .. "'", 3)
    end
    local lp = self.Services.Players.LocalPlayer
    local char = lp.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    local function forceClientSide()
        pcall(function()
            lp.Neutral = false
            lp.Team = targetTeam
        end)
    end
    if typeof(firetouchinterest) == "function" and root then
        local foundSpawn = false
        for _, obj in ipairs(self.Services.Workspace:GetDescendants()) do
            if obj:IsA("SpawnLocation") and obj.BrickColor == targetTeam.TeamColor and obj.AllowTeamChangeOnTouch then
                firetouchinterest(root, obj, 0)
                task.wait()
                firetouchinterest(root, obj, 1)
                foundSpawn = true
                break
            end
        end
        if foundSpawn then
            DoNotif("Spawn sequence triggered for " .. targetTeam.Name, 2)
        end
    end
    forceClientSide()
    DoNotif("Joined Team: " .. targetTeam.Name, 2)
end
function Modules.TeamChanger:Initialize()
    local module = self
    for _, s in ipairs(self.Dependencies) do
        module.Services[s] = game:GetService(s)
    end
    RegisterCommand({
        Name = "team",
        Aliases = {"setteam"},
        Description = "Forces a team change via spawn-touch emulation or property spoofing."
    }, function(args)
        module:Execute(table.concat(args, " "))
    end)
end
Modules.ScriptSearcher = {
    State = {
        IsEnabled = false,
        UI = {},
        Connections = {},
        IsSearching = false,
        LastQuery = "",
        LastResults = {},
        CurrentPage = 1,
        ResultsPerPage = 20,
        SearchHistory = {},
        SortMode = "newest",
        ActiveFilters = {},
        CurrentSource = "scriptblox",
        GameInfo = {},
        GameScripts = {}
    },
    Config = {
        ACCENT = Color3.fromRGB(0, 255, 255),
        BG = Color3.fromRGB(20, 20, 20),
        APIs = {
            scriptblox = "https://scriptblox.com/api/script/search?q=%s&mode=free&max=100",
            pastebin = "https://pastebin.com/api/v1/paste/list?api_dev_key=YOUR_KEY&results_limit=100",
        },
        MAX_HISTORY = 15
    },
    Dependencies = {"HttpService", "Players", "CoreGui", "UserInputService", "RunService"},
    Services = {}
}
function Modules.ScriptSearcher:SearchGameScripts()
    if self.State.IsSearching then return end
    self.State.IsSearching = true
    self.State.CurrentPage = 1
    self.State.LastResults = {}
    local gameId = game.GameId
    self.State.LastQuery = "game:" .. gameId
    local scroll = self.State.UI.ResultScroll
    for _, v in ipairs(scroll:GetChildren()) do
        if not v:IsA("UIListLayout") then v:Destroy() end
    end
    local status = Instance.new("TextLabel", scroll)
    status.Size = UDim2.new(1, 0, 0, 30); status.BackgroundTransparency = 1
    status.Text = "Searching scripts for game " .. gameId .. "..."; status.TextColor3 = self.Config.ACCENT
    status.Font = Enum.Font.Code; status.TextSize = 14
    task.spawn(function()
        local requestFunc = (typeof(request) == "function" and request) or (typeof(syn) == "table" and syn.request) or (typeof(http) == "table" and http.request)
        if not requestFunc then
            status.Text = "ERR: NO HTTP CAPABILITY"
            self.State.IsSearching = false
            return
        end
        local apiUrl = self.Config.APIs[self.State.CurrentSource] or self.Config.APIs.scriptblox
        local url = apiUrl:format(self.Services.HttpService:UrlEncode("game:" .. gameId))
        local success, res = pcall(function() return requestFunc({Url = url, Method = "GET"}) end)
        if success and res.StatusCode == 200 then
            status:Destroy()
            local data = self.Services.HttpService:JSONDecode(res.Body)
            if data.result and data.result.scripts then
                self.State.LastResults = data.result.scripts
                self.State.GameScripts = self.State.LastResults
                self:_displayPage(1)
                DoNotif("Found " .. #self.State.LastResults .. " scripts for this game.", 2)
            else
                status.Text = "No scripts found for this game."
            end
        else
            status.Text = "API Link Failed."
        end
        self.State.IsSearching = false
    end)
end
function Modules.ScriptSearcher:FetchGameInfo()
    local gameId = game.GameId
    local players = self.Services.Players:GetPlayers()
    self.State.GameInfo = {
        GameId = gameId,
        GameName = game:GetService("MarketplaceService"):GetProductInfo(gameId).Name,
        Creator = "Unknown",
        PlayerCount = #players,
        MaxPlayers = self.Services.Players.MaxPlayers,
        Description = game:GetService("MarketplaceService"):GetProductInfo(gameId).Description
    }
    return self.State.GameInfo
end
function Modules.ScriptSearcher:PerformSearch(query)
    if self.State.IsSearching then return end
    if query == "" then return DoNotif("Enter a search query.", 2) end
    self.State.IsSearching = true
    self.State.LastQuery = query
    self.State.CurrentPage = 1
    self.State.LastResults = {}
    if not table.find(self.State.SearchHistory, query) then
        table.insert(self.State.SearchHistory, 1, query)
        if #self.State.SearchHistory > self.Config.MAX_HISTORY then
            table.remove(self.State.SearchHistory, #self.State.SearchHistory)
        end
    end
    local scroll = self.State.UI.ResultScroll
    for _, v in ipairs(scroll:GetChildren()) do
        if not v:IsA("UIListLayout") then v:Destroy() end
    end
    local status = Instance.new("TextLabel", scroll)
    status.Size = UDim2.new(1, 0, 0, 30); status.BackgroundTransparency = 1
    status.Text = "Searching '" .. self.State.CurrentSource .. "'..."; status.TextColor3 = self.Config.ACCENT
    status.Font = Enum.Font.Code; status.TextSize = 14
    task.spawn(function()
        local requestFunc = (typeof(request) == "function" and request) or (typeof(syn) == "table" and syn.request) or (typeof(http) == "table" and http.request)
        if not requestFunc then
            status.Text = "ERR: NO HTTP CAPABILITY"
            self.State.IsSearching = false
            return
        end
        local apiUrl = self.Config.APIs[self.State.CurrentSource] or self.Config.APIs.scriptblox
        local url = apiUrl:format(self.Services.HttpService:UrlEncode(query))
        local success, res = pcall(function() return requestFunc({Url = url, Method = "GET"}) end)
        if success and res.StatusCode == 200 then
            status:Destroy()
            local data = self.Services.HttpService:JSONDecode(res.Body)
            if data.result and data.result.scripts then
                self.State.LastResults = data.result.scripts
                self:_displayPage(1)
                DoNotif("Found " .. #self.State.LastResults .. " results.", 2)
            else
                status.Text = "No results found."
            end
        else
            status.Text = "API Link Failed."
        end
        self.State.IsSearching = false
    end)
end
function Modules.ScriptSearcher:_displayPage(page)
    local scroll = self.State.UI.ResultScroll
    for _, v in ipairs(scroll:GetChildren()) do
        if not v:IsA("UIListLayout") then v:Destroy() end
    end
    local startIdx = (page - 1) * self.State.ResultsPerPage + 1
    local endIdx = math.min(page * self.State.ResultsPerPage, #self.State.LastResults)
    if startIdx > #self.State.LastResults then
        local noMore = Instance.new("TextLabel", scroll)
        noMore.Size = UDim2.new(1, 0, 0, 30); noMore.BackgroundTransparency = 1
        noMore.Text = "No more results."; noMore.TextColor3 = Color3.fromRGB(150, 150, 150)
        return
    end
    for i = startIdx, endIdx do
        self:_createResultCard(self.State.LastResults[i])
    end
    local pageInfo = Instance.new("TextLabel", scroll)
    pageInfo.Size = UDim2.new(1, 0, 0, 20); pageInfo.BackgroundTransparency = 1
    pageInfo.Text = "Page " .. page .. " of " .. math.ceil(#self.State.LastResults / self.State.ResultsPerPage)
    pageInfo.TextColor3 = self.Config.ACCENT; pageInfo.Font = Enum.Font.Code; pageInfo.TextSize = 10
    self.State.CurrentPage = page
end
function Modules.ScriptSearcher:RefreshSearch()
    if self.State.LastQuery == "" then
        return DoNotif("No previous search to refresh.", 2)
    end
    self:PerformSearch(self.State.LastQuery)
end
function Modules.ScriptSearcher:NextPage()
    local maxPage = math.ceil(#self.State.LastResults / self.State.ResultsPerPage)
    if self.State.CurrentPage < maxPage then
        self:_displayPage(self.State.CurrentPage + 1)
    else
        DoNotif("Already on last page.", 2)
    end
end
function Modules.ScriptSearcher:PrevPage()
    if self.State.CurrentPage > 1 then
        self:_displayPage(self.State.CurrentPage - 1)
    else
        DoNotif("Already on first page.", 2)
    end
end
function Modules.ScriptSearcher:SetSort(mode)
    self.State.SortMode = mode
    if #self.State.LastResults > 0 then
        if mode == "popular" then
            table.sort(self.State.LastResults, function(a, b)
                return (a.favorites or 0) > (b.favorites or 0)
            end)
        elseif mode == "newest" then
            table.sort(self.State.LastResults, function(a, b)
                return (a.updated_at or 0) > (b.updated_at or 0)
            end)
        end
        self:_displayPage(1)
    end
end
function Modules.ScriptSearcher:SetSource(source)
    if self.Config.APIs[source] then
        self.State.CurrentSource = source
        DoNotif("Source switched to: " .. source, 2)
    end
end
function Modules.ScriptSearcher:ShowHistory()
    local scroll = self.State.UI.ResultScroll
    for _, v in ipairs(scroll:GetChildren()) do
        if not v:IsA("UIListLayout") then v:Destroy() end
    end
    if #self.State.SearchHistory == 0 then
        local empty = Instance.new("TextLabel", scroll)
        empty.Size = UDim2.new(1, 0, 0, 30); empty.BackgroundTransparency = 1
        empty.Text = "No search history."; empty.TextColor3 = Color3.fromRGB(150, 150, 150)
        return
    end
    for _, query in ipairs(self.State.SearchHistory) do
        local historyBtn = Instance.new("TextButton", scroll)
        historyBtn.Size = UDim2.new(1, -10, 0, 30)
        historyBtn.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        historyBtn.BorderSizePixel = 1; historyBtn.BorderColor3 = Color3.fromRGB(60, 60, 60)
        historyBtn.Text = "ðŸ” " .. query; historyBtn.TextColor3 = self.Config.ACCENT
        historyBtn.Font = Enum.Font.Code; historyBtn.TextSize = 11
        historyBtn.MouseButton1Click:Connect(function()
            self:PerformSearch(query)
        end)
    end
end
function Modules.ScriptSearcher:_createResultCard(data)
    local scroll = self.State.UI.ResultScroll
    local card = Instance.new("Frame", scroll)
    card.Size = UDim2.new(1, -10, 0, 65)
    card.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    card.BorderSizePixel = 1; card.BorderColor3 = Color3.fromRGB(60, 60, 60)
    local title = Instance.new("TextLabel", card)
    title.Size = UDim2.new(1, -100, 0, 25); title.Position = UDim2.fromOffset(5, 5)
    title.Text = data.title; title.TextColor3 = Color3.new(1,1,1)
    title.Font = Enum.Font.Code; title.TextSize = 13; title.TextXAlignment = "Left"
    title.BackgroundTransparency = 1; title.ClipsDescendants = true
    local gameLabel = Instance.new("TextLabel", card)
    gameLabel.Size = UDim2.new(1, -100, 0, 20); gameLabel.Position = UDim2.fromOffset(5, 30)
    gameLabel.Text = "Game: " .. (data.game.name or "Universal")
    gameLabel.TextColor3 = Color3.fromRGB(150, 150, 150); gameLabel.Font = Enum.Font.Code
    gameLabel.TextSize = 11; gameLabel.TextXAlignment = "Left"; gameLabel.BackgroundTransparency = 1
    local function mkBtn(text, xPos, color, callback)
        local b = Instance.new("TextButton", card)
        b.Size = UDim2.fromOffset(80, 22); b.Position = UDim2.new(1, xPos, 0, 20)
        b.BackgroundColor3 = Color3.fromRGB(20, 20, 20); b.BorderSizePixel = 1; b.BorderColor3 = color
        b.Text = text; b.TextColor3 = color; b.Font = Enum.Font.Code; b.TextSize = 10
        b.MouseButton1Click:Connect(callback)
        return b
    end
    mkBtn("EXECUTE", -85, self.Config.ACCENT, function()
        local func, err = loadstring(data.script)
        if func then task.spawn(func); DoNotif("Executed: " .. data.title, 2)
        else warn(err); DoNotif("Syntax Error in script.", 3) end
    end)
    mkBtn("COPY", -170, Color3.fromRGB(200, 150, 100), function()
        setclipboard(data.script)
        DoNotif("Script copied to clipboard.", 2)
    end)
    mkBtn("VIEW", -255, Color3.fromRGB(200, 100, 255), function()
        print("--- [SOURCE: " .. data.title .. "] ---")
        print(data.script)
        print("--------------------------------------")
        DoNotif("Source printed to F9 Console.", 2)
    end)
end
function Modules.ScriptSearcher:CreateUI()
    if self.State.UI.Main then self.State.UI.Main.Visible = true return end
    local sg = Instance.new("ScreenGui", self.Services.CoreGui)
    sg.Name = "Zuka_ScriptHub_RC8"
    local main = Instance.new("Frame", sg)
    main.Size = UDim2.fromOffset(600, 550)
    main.Position = UDim2.fromScale(0.5, 0.5)
    main.AnchorPoint = Vector2.new(0.5, 0.5)
    main.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
    main.BorderSizePixel = 2; main.BorderColor3 = self.Config.ACCENT; main.Active = true
    local header = Instance.new("Frame", main)
    header.Size = UDim2.new(1, 0, 0, 30); header.BackgroundColor3 = Color3.fromRGB(30, 30, 30); header.BorderSizePixel = 0
    local title = Instance.new("TextLabel", header)
    title.Size = UDim2.new(0.7, -60, 1, 0); title.Position = UDim2.fromOffset(10, 0)
    title.Text = "DATABASE BROWSER v2"; title.TextColor3 = self.Config.ACCENT
    title.Font = Enum.Font.Code; title.TextSize = 14; title.TextXAlignment = "Left"; title.BackgroundTransparency = 1
    local close = Instance.new("TextButton", header)
    close.Size = UDim2.fromOffset(30, 30); close.Position = UDim2.new(1, -30, 0, 0)
    close.Text = "X"; close.TextColor3 = Color3.new(1,0,0); close.BackgroundTransparency = 1
    close.MouseButton1Click:Connect(function() sg:Destroy(); self.State.UI = {} end)
    local searchBar = Instance.new("TextBox", main)
    searchBar.Size = UDim2.new(1, -230, 0, 30); searchBar.Position = UDim2.fromOffset(10, 40)
    searchBar.BackgroundColor3 = Color3.fromRGB(20, 20, 20); searchBar.BorderSizePixel = 1; searchBar.BorderColor3 = Color3.fromRGB(80, 80, 80)
    searchBar.PlaceholderText = "Enter keywords..."; searchBar.Text = ""
    searchBar.TextColor3 = Color3.new(1,1,1); searchBar.Font = Enum.Font.Code; searchBar.TextSize = 14
    local gameSearchBtn = Instance.new("TextButton", main)
    gameSearchBtn.Size = UDim2.fromOffset(80, 30); gameSearchBtn.Position = UDim2.new(1, -300, 0, 40)
    gameSearchBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 40); gameSearchBtn.BorderSizePixel = 1; gameSearchBtn.BorderColor3 = Color3.fromRGB(100, 200, 150)
    gameSearchBtn.Text = "GAME"; gameSearchBtn.TextColor3 = Color3.fromRGB(100, 255, 150); gameSearchBtn.Font = Enum.Font.Code; gameSearchBtn.TextSize = 10
    gameSearchBtn.MouseButton1Click:Connect(function() self:SearchGameScripts() end)
    local searchBtn = Instance.new("TextButton", main)
    searchBtn.Size = UDim2.fromOffset(70, 30); searchBtn.Position = UDim2.new(1, -210, 0, 40)
    searchBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 40); searchBtn.BorderSizePixel = 1; searchBtn.BorderColor3 = self.Config.ACCENT
    searchBtn.Text = "SEARCH"; searchBtn.TextColor3 = self.Config.ACCENT; searchBtn.Font = Enum.Font.Code; searchBtn.TextSize = 10
    searchBtn.MouseButton1Click:Connect(function() self:PerformSearch(searchBar.Text) end)
    local refreshBtn = Instance.new("TextButton", main)
    refreshBtn.Size = UDim2.fromOffset(70, 30); refreshBtn.Position = UDim2.new(1, -140, 0, 40)
    refreshBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 40); refreshBtn.BorderSizePixel = 1; refreshBtn.BorderColor3 = Color3.fromRGB(100, 150, 100)
    refreshBtn.Text = "REFRESH"; refreshBtn.TextColor3 = Color3.fromRGB(100, 200, 100); refreshBtn.Font = Enum.Font.Code; refreshBtn.TextSize = 10
    refreshBtn.MouseButton1Click:Connect(function() self:RefreshSearch() end)
    local historyBtn = Instance.new("TextButton", main)
    historyBtn.Size = UDim2.fromOffset(60, 30); historyBtn.Position = UDim2.new(1, -70, 0, 40)
    historyBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 40); historyBtn.BorderSizePixel = 1; historyBtn.BorderColor3 = Color3.fromRGB(150, 100, 200)
    historyBtn.Text = "HISTORY"; historyBtn.TextColor3 = Color3.fromRGB(200, 150, 255); historyBtn.Font = Enum.Font.Code; historyBtn.TextSize = 9
    historyBtn.MouseButton1Click:Connect(function() self:ShowHistory() end)
    local sortLabel = Instance.new("TextLabel", main)
    sortLabel.Size = UDim2.fromOffset(40, 25); sortLabel.Position = UDim2.fromOffset(10, 75)
    sortLabel.Text = "Sort:"; sortLabel.TextColor3 = self.Config.ACCENT; sortLabel.BackgroundTransparency = 1
    sortLabel.Font = Enum.Font.Code; sortLabel.TextSize = 10
    local sortBtn = Instance.new("TextButton", main)
    sortBtn.Size = UDim2.fromOffset(80, 25); sortBtn.Position = UDim2.fromOffset(55, 75)
    sortBtn.BackgroundColor3 = Color3.fromRGB(30, 30, 30); sortBtn.BorderSizePixel = 1; sortBtn.BorderColor3 = Color3.fromRGB(80, 80, 80)
    sortBtn.Text = "NEWEST"; sortBtn.TextColor3 = Color3.new(1,1,1); sortBtn.Font = Enum.Font.Code; sortBtn.TextSize = 9
    local sortModes = {"newest", "popular"}
    local sortIndex = 1
    sortBtn.MouseButton1Click:Connect(function()
        sortIndex = sortIndex % #sortModes + 1
        sortBtn.Text = sortModes[sortIndex]:upper()
        self:SetSort(sortModes[sortIndex])
    end)
    local sourceLabel = Instance.new("TextLabel", main)
    sourceLabel.Size = UDim2.fromOffset(45, 25); sourceLabel.Position = UDim2.fromOffset(145, 75)
    sourceLabel.Text = "Source:"; sourceLabel.TextColor3 = self.Config.ACCENT; sourceLabel.BackgroundTransparency = 1
    sourceLabel.Font = Enum.Font.Code; sourceLabel.TextSize = 10
    local sourceBtn = Instance.new("TextButton", main)
    sourceBtn.Size = UDim2.fromOffset(90, 25); sourceBtn.Position = UDim2.fromOffset(195, 75)
    sourceBtn.BackgroundColor3 = Color3.fromRGB(30, 30, 30); sourceBtn.BorderSizePixel = 1; sourceBtn.BorderColor3 = Color3.fromRGB(80, 80, 80)
    sourceBtn.Text = "SCRIPTBLOX"; sourceBtn.TextColor3 = Color3.new(1,1,1); sourceBtn.Font = Enum.Font.Code; sourceBtn.TextSize = 9
    local sources = {"scriptblox"}
    local sourceIndex = 1
    sourceBtn.MouseButton1Click:Connect(function()
        sourceIndex = sourceIndex % #sources + 1
        sourceBtn.Text = sources[sourceIndex]:upper()
        self:SetSource(sources[sourceIndex])
    end)
    local resultsPerPageLabel = Instance.new("TextLabel", main)
    resultsPerPageLabel.Size = UDim2.fromOffset(55, 25); resultsPerPageLabel.Position = UDim2.fromOffset(295, 75)
    resultsPerPageLabel.Text = "Per Page:"; resultsPerPageLabel.TextColor3 = self.Config.ACCENT; resultsPerPageLabel.BackgroundTransparency = 1
    resultsPerPageLabel.Font = Enum.Font.Code; resultsPerPageLabel.TextSize = 10
    local resultsPerPageBtn = Instance.new("TextButton", main)
    resultsPerPageBtn.Size = UDim2.fromOffset(60, 25); resultsPerPageBtn.Position = UDim2.fromOffset(355, 75)
    resultsPerPageBtn.BackgroundColor3 = Color3.fromRGB(30, 30, 30); resultsPerPageBtn.BorderSizePixel = 1; resultsPerPageBtn.BorderColor3 = Color3.fromRGB(80, 80, 80)
    resultsPerPageBtn.Text = "20"; resultsPerPageBtn.TextColor3 = Color3.new(1,1,1); resultsPerPageBtn.Font = Enum.Font.Code; resultsPerPageBtn.TextSize = 9
    local pageOptions = {10, 20, 50}
    local pageIndex = 2
    resultsPerPageBtn.MouseButton1Click:Connect(function()
        pageIndex = pageIndex % #pageOptions + 1
        self.State.ResultsPerPage = pageOptions[pageIndex]
        resultsPerPageBtn.Text = tostring(pageOptions[pageIndex])
        if #self.State.LastResults > 0 then
            self:_displayPage(1)
        end
    end)
    local prevPageBtn = Instance.new("TextButton", main)
    prevPageBtn.Size = UDim2.fromOffset(60, 25); prevPageBtn.Position = UDim2.new(1, -180, 0, 75)
    prevPageBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 40); prevPageBtn.BorderSizePixel = 1; prevPageBtn.BorderColor3 = self.Config.ACCENT
    prevPageBtn.Text = "â—„ PREV"; prevPageBtn.TextColor3 = self.Config.ACCENT; prevPageBtn.Font = Enum.Font.Code; prevPageBtn.TextSize = 9
    prevPageBtn.MouseButton1Click:Connect(function() self:PrevPage() end)
    local nextPageBtn = Instance.new("TextButton", main)
    nextPageBtn.Size = UDim2.fromOffset(60, 25); nextPageBtn.Position = UDim2.new(1, -110, 0, 75)
    nextPageBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 40); nextPageBtn.BorderSizePixel = 1; nextPageBtn.BorderColor3 = self.Config.ACCENT
    nextPageBtn.Text = "NEXT â–º"; nextPageBtn.TextColor3 = self.Config.ACCENT; nextPageBtn.Font = Enum.Font.Code; nextPageBtn.TextSize = 9
    nextPageBtn.MouseButton1Click:Connect(function() self:NextPage() end)
    local gameInfoPanel = Instance.new("Frame", main)
    gameInfoPanel.Size = UDim2.new(1, -20, 0, 85); gameInfoPanel.Position = UDim2.fromOffset(10, 105)
    gameInfoPanel.BackgroundColor3 = Color3.fromRGB(25, 35, 40); gameInfoPanel.BorderSizePixel = 1; gameInfoPanel.BorderColor3 = Color3.fromRGB(100, 200, 150)
    local gameNameLabel = Instance.new("TextLabel", gameInfoPanel)
    gameNameLabel.Size = UDim2.new(1, -10, 0, 20); gameNameLabel.Position = UDim2.fromOffset(5, 3)
    gameNameLabel.Text = "ðŸŽ® Game: Loading..."; gameNameLabel.TextColor3 = Color3.fromRGB(100, 255, 150)
    gameNameLabel.Font = Enum.Font.Code; gameNameLabel.TextSize = 11; gameNameLabel.TextXAlignment = "Left"; gameNameLabel.BackgroundTransparency = 1
    local gameIdLabel = Instance.new("TextLabel", gameInfoPanel)
    gameIdLabel.Size = UDim2.new(1, -10, 0, 15); gameIdLabel.Position = UDim2.fromOffset(5, 23)
    gameIdLabel.Text = "ID: " .. game.GameId; gameIdLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
    gameIdLabel.Font = Enum.Font.Code; gameIdLabel.TextSize = 9; gameIdLabel.TextXAlignment = "Left"; gameIdLabel.BackgroundTransparency = 1
    local playerCountLabel = Instance.new("TextLabel", gameInfoPanel)
    playerCountLabel.Size = UDim2.new(0.5, -5, 0, 15); playerCountLabel.Position = UDim2.fromOffset(5, 38)
    playerCountLabel.Text = "ðŸ‘¥ Players: " .. #self.Services.Players:GetPlayers() .. "/" .. self.Services.Players.MaxPlayers
    playerCountLabel.TextColor3 = Color3.fromRGB(150, 150, 150); playerCountLabel.Font = Enum.Font.Code
    playerCountLabel.TextSize = 9; playerCountLabel.TextXAlignment = "Left"; playerCountLabel.BackgroundTransparency = 1
    local scriptCountLabel = Instance.new("TextLabel", gameInfoPanel)
    scriptCountLabel.Size = UDim2.new(0.5, -5, 0, 15); scriptCountLabel.Position = UDim2.new(0.5, 5, 0, 38)
    scriptCountLabel.Text = "ðŸ“„ Scripts: Searching..."; scriptCountLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
    scriptCountLabel.Font = Enum.Font.Code; scriptCountLabel.TextSize = 9; scriptCountLabel.TextXAlignment = "Left"; scriptCountLabel.BackgroundTransparency = 1
    local descLabel = Instance.new("TextLabel", gameInfoPanel)
    descLabel.Size = UDim2.new(1, -10, 0, 20); descLabel.Position = UDim2.fromOffset(5, 53)
    descLabel.Text = "Description: Loading..."; descLabel.TextColor3 = Color3.fromRGB(130, 130, 130)
    descLabel.Font = Enum.Font.Code; descLabel.TextSize = 8; descLabel.TextXAlignment = "Left"; descLabel.TextWrapped = true
    descLabel.BackgroundTransparency = 1
    task.spawn(function()
        local success, gameInfo = pcall(function() return self:FetchGameInfo() end)
        if success and gameInfo then
            gameNameLabel.Text = "ðŸŽ® Game: " .. (gameInfo.GameName or "Unknown")
            scriptCountLabel.Text = "ðŸ“„ Scripts: " .. #self.State.GameScripts .. " available"
            descLabel.Text = "ðŸ“ " .. (gameInfo.Description or "No description available"):sub(1, 120)
        else
            gameNameLabel.Text = "ðŸŽ® Game: " .. tostring(game.GameId)
            descLabel.Text = "ðŸ“ Could not fetch game info"
        end
    end)
    local scroll = Instance.new("ScrollingFrame", main)
    scroll.Size = UDim2.new(1, -20, 1, -205); scroll.Position = UDim2.fromOffset(10, 195)
    scroll.BackgroundColor3 = Color3.fromRGB(15, 15, 15); scroll.BorderSizePixel = 1; scroll.BorderColor3 = Color3.fromRGB(50, 50, 50)
    scroll.ScrollBarThickness = 3; scroll.ScrollBarImageColor3 = self.Config.ACCENT; scroll.AutomaticCanvasSize = "Y"
    local layout = Instance.new("UIListLayout", scroll)
    layout.Padding = UDim.new(0, 5); layout.HorizontalAlignment = "Center"
    local dragging, dragStart, startPos
    header.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging, dragStart, startPos = true, input.Position, main.Position
        end
    end)
    self.Services.UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local delta = input.Position - dragStart
            main.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
    self.Services.UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
    end)
    self.State.UI = {Main = main, ResultScroll = scroll}
    DoNotif("ScriptHub v2 Initialized - Full Featured Search", 2)
end
function Modules.ScriptSearcher:Initialize()
    for _, s in ipairs(self.Dependencies) do self.Services[s] = game:GetService(s) end
    RegisterCommand({
        Name = "Hub",
        Aliases = {"search", "scripts"},
        Description = "Opens the ScriptBlox database searcher."
    }, function()
        self:CreateUI()
    end)
end
if not getgenv().Modules then getgenv().Modules = {} end
Modules.InternalExecutor = {
    State = {
        IsEnabled = false,
        UI = {},
        Connections = {},
        IsLifting = false,
        VFS_Cache = {},
        VFS_Loading = {},
        VFS_Base = "https://raw.githubusercontent.com/zukatech1/Lifter/main/src/"
    },
    Config = {
        ACCENT = Color3.fromRGB(0, 255, 255),
        BG = Color3.fromRGB(20, 20, 20),
        LIFT_COLOR = Color3.fromRGB(170, 0, 255),
        KEYWORDS = {"and", "break", "do", "else", "elseif", "end", "false", "for", "function", "goto", "if", "in", "local", "nil", "not", "or", "repeat", "return", "then", "true", "until", "while", "execute", "syn", "HttpGet", "HttpPost"},
        GLOBALS = {"getrawmetatable", "game", "Workspace", "script", "math", "string", "table", "print", "wait", "Instance", "Vector3", "CFrame", "Enum", "loadstring", "getgenv", "getrenv", "getreg", "getgc"},
        REMOTES = {"FireServer", "InvokeServer"},
        TOKENS = {["="]=true, ["."]=true, [","]=true, ["("]=true, [")"]=true, ["["]=true, ["]"]=true, ["{"]=true, ["}"]=true, [":"]=true, ["*"]=true, ["/"]=true, ["+"]=true, ["-"]=true, ["%"]=true, [";"]=true, ["~"]=true}
    },
    Dependencies = {"Players", "CoreGui", "UserInputService", "RunService", "TextService", "HttpService"},
    Services = {}
}
function Modules.InternalExecutor:_vRequire(modulePath)
    local state = self.State
    if state.VFS_Cache[modulePath] then
        return state.VFS_Cache[modulePath]
    end
    if state.VFS_Loading[modulePath] then
        return state.VFS_Loading[modulePath]
    end
    local internalPath = modulePath:gsub("%.", "/") .. ".lua"
    local url = state.VFS_Base .. internalPath
    local success, content = pcall(game.HttpGet, game, url)
    if not success or content:find("404: Not Found") then
        local fallbackUrl = "https://raw.githubusercontent.com/zukatech1/Lifter/main/" .. internalPath
        success, content = pcall(game.HttpGet, game, fallbackUrl)
    end
    if not success or content:find("404: Not Found") then
        warn("--> [VFS] Resolution Failed: " .. modulePath)
        return nil
    end
    local func, err = loadstring(content, "@VFS/" .. modulePath)
    if not func then
        warn("--> [VFS] Syntax Error in " .. modulePath .. ": " .. err)
        return nil
    end
    local modulePlaceholder = {}
    state.VFS_Loading[modulePath] = modulePlaceholder
    local env = getfenv(func)
    env.require = function(path) return self:_vRequire(path) end
    env.arg = {}
    env.print = function(...) print("[LIFTER]:", ...) end
    setfenv(func, env)
    local result = func()
    local finalData = result or modulePlaceholder
    state.VFS_Cache[modulePath] = finalData
    state.VFS_Loading[modulePath] = nil
    return finalData
end
function Modules.InternalExecutor:_initializeLifter()
    self.State.VFS_Cache = {}
    self.State.VFS_Loading = {}
    local Parser = self:_vRequire("prometheus.parser")
    local Ast = self:_vRequire("prometheus.ast")
    local VisitAst = self:_vRequire("prometheus.visitast")
    local Unparser = self:_vRequire("prometheus.unparser")
    return {
        Parser = Parser,
        Ast = Ast,
        VisitAst = VisitAst,
        Unparser = Unparser
    }
end
function Modules.InternalExecutor:_process(str, keywordList)
    local K = {}
    for _, v in pairs(keywordList) do K[v] = true end
    local S = str:gsub(".", function(c) return self.Config.TOKENS[c] and " " or c end)
    S = S:gsub("%S+", function(c) return K[c] and c or (" "):rep(#c) end)
    return S
end
function Modules.InternalExecutor:_update()
    local ui = self.State.UI
    if not ui.Source then return end
    local text = ui.Source.Text:gsub("\r", ""):gsub("\t", "    ")
    local textHeight = self.Services.TextService:GetTextSize(text, 14, Enum.Font.Code, Vector2.new(ui.EditorScroll.AbsoluteSize.X - 40, math.huge)).Y
    local finalHeight = math.max(textHeight + 50, ui.EditorScroll.AbsoluteSize.Y)
    ui.EditorScroll.CanvasSize = UDim2.fromOffset(0, finalHeight)
    ui.Source.Size = UDim2.new(1, -40, 0, finalHeight)
    ui.Keywords.Text = self:_process(text, self.Config.KEYWORDS)
    ui.Globals.Text = self:_process(text, self.Config.GLOBALS)
    ui.Remotes.Text = self:_process(text, self.Config.REMOTES)
    local _, lineCount = text:gsub("\n", "")
    ui.Lines.Text = ""
    for i = 1, lineCount + 1 do
        ui.Lines.Text ..= i .. "\n"
    end
end
function Modules.InternalExecutor:CreateUI()
    if self.State.UI.Main then self.State.UI.Main.Visible = true return end
    local sg = Instance.new("ScreenGui", self.Services.CoreGui)
    sg.Name = "Zuka_RC7_Editor"
    sg.ResetOnSpawn = false
    local main = Instance.new("Frame", sg)
    main.Size = UDim2.fromOffset(600, 420)
    main.Position = UDim2.fromScale(0.5, 0.5)
    main.AnchorPoint = Vector2.new(0.5, 0.5)
    main.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
    main.BackgroundTransparency = 0.2
    main.BorderSizePixel = 1
    main.BorderColor3 = self.Config.ACCENT
    main.ClipsDescendants = true
    main.Active = true
    local header = Instance.new("Frame", main)
    header.Size = UDim2.new(1, 0, 0, 30)
    header.BackgroundColor3 = Color3.fromRGB(255, 85, 127)
    header.BorderSizePixel = 0
    local title = Instance.new("TextLabel", header)
    title.Size = UDim2.new(1, -60, 1, 0)
    title.Position = UDim2.fromOffset(10, 0)
    title.Text = "Zukas Lifter."
    title.TextColor3 = self.Config.ACCENT
    title.Font = Enum.Font.Code
    title.TextSize = 14
    title.TextXAlignment = Enum.TextXAlignment.Left; title.BackgroundTransparency = 1
    local close = Instance.new("TextButton", header)
    close.Size = UDim2.fromOffset(30, 30)
    close.Position = UDim2.new(1, -30, 0, 0)
    close.Text = "X"; close.TextColor3 = Color3.new(1,0,0); close.BackgroundTransparency = 1
    close.MouseButton1Click:Connect(function() sg:Destroy(); self.State.UI = {} end)
    local scroll = Instance.new("ScrollingFrame", main)
    scroll.Size = UDim2.new(1, -10, 1, -85)
    scroll.Position = UDim2.fromOffset(5, 35)
    scroll.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
    scroll.BackgroundTransparency = 0.4
    scroll.BorderSizePixel = 1
    scroll.BorderColor3 = Color3.fromRGB(50, 50, 50)
    scroll.ScrollBarThickness = 4
    scroll.ScrollBarImageColor3 = self.Config.ACCENT
    local lines = Instance.new("TextLabel", scroll)
    lines.Size = UDim2.new(0, 30, 1, 0)
    lines.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
    lines.BorderSizePixel = 0
    lines.Text = "1"; lines.TextColor3 = Color3.fromRGB(100, 100, 100)
    lines.Font = Enum.Font.Code; lines.TextSize = 14; lines.TextYAlignment = "Top"
    local source = Instance.new("TextBox", scroll)
    source.Size = UDim2.new(1, -35, 1, 0)
    source.Position = UDim2.fromOffset(35, 0)
    source.BackgroundTransparency = 1
    source.TextColor3 = Color3.fromRGB(220, 220, 220)
    source.Font = Enum.Font.Code
    source.TextSize = 14
    source.TextXAlignment = Enum.TextXAlignment.Left; source.TextYAlignment = "Top"
    source.MultiLine = true; source.ClearTextOnFocus = false
    source.Text = ""
    local function mkOverlay(name, color)
        local l = Instance.new("TextLabel", source)
        l.Name = name; l.Size = UDim2.fromScale(1, 1); l.BackgroundTransparency = 1
        l.Font = Enum.Font.Code; l.TextSize = 14; l.TextXAlignment = "Left"; l.TextYAlignment = "Top"
        l.TextColor3 = color; l.Text = ""; l.ZIndex = 3
        return l
    end
    local kw = mkOverlay("Keywords", Color3.fromRGB(255, 80, 80))
    local gb = mkOverlay("Globals", Color3.fromRGB(80, 180, 255))
    local rm = mkOverlay("Remotes", Color3.fromRGB(0, 255, 150))
    local footer = Instance.new("Frame", main)
    footer.Size = UDim2.new(1, 0, 0, 45)
    footer.Position = UDim2.new(0, 0, 1, -45)
    footer.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
    footer.BorderSizePixel = 0
    local function mkBtn(text, pos, color, cb)
        local b = Instance.new("TextButton", footer)
        b.Size = UDim2.fromOffset(110, 30)
        b.Position = pos
        b.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
        b.BorderSizePixel = 1; b.BorderColor3 = color
        b.Text = text; b.TextColor3 = color; b.Font = Enum.Font.Code; b.TextSize = 13
        b.MouseButton1Click:Connect(cb)
        return b
    end
    mkBtn("EXECUTE", UDim2.fromOffset(10, 7), self.Config.ACCENT, function()
        local f, e = loadstring(source.Text)
        if f then task.spawn(f); DoNotif("Executed.", 1) else warn(e); DoNotif("Syntax Error", 2) end
    end)
    mkBtn("LIFT (PROM)", UDim2.fromOffset(130, 7), self.Config.LIFT_COLOR, function()
        if self.State.IsLifting then return end
        self.State.IsLifting = true
        task.spawn(function()
            local _old_info = debug.getinfo
            getgenv().debug.getinfo = function(f, ...)
                local res = _old_info(f, ...)
                if res and res.source and res.source:find("VFS") then
                    res.source = "=[C]"
                end
                return res
            end
            local components = self:_initializeLifter()
            if not components.Parser then
                self.State.IsLifting = false
                return DoNotif("VFS Error. Check F9.", 3)
            end
            local inputCode = source.Text
            if #inputCode == 0 then
                self.State.IsLifting = false
                return DoNotif("Source empty.", 2)
            end
            DoNotif("Lifting: Analyzing AST...", 2)
            local success, ast = pcall(function()
                local p = components.Parser:new({ LuaVersion = "LuaU" })
                return p:parse(inputCode)
            end)
            if not success or not ast then
                warn("--> [Lifter] Fatal Error: " .. tostring(ast))
                self.State.IsLifting = false
                return DoNotif("Deobfuscation Failed.", 3)
            end
            local u = components.Unparser:new({ LuaVersion = "LuaU", PrettyPrint = true, IndentSpaces = 4 })
            local liftedCode = u:unparse(ast)
            liftedCode = liftedCode:gsub('"([^"]*)"%s*%.%.%s*"([^"]*)"', '"%1%2"')
            source.Text = liftedCode
            self:_update()
            self.State.IsLifting = false
            DoNotif("Code Lifted.", 2)
            getgenv().debug.getinfo = _old_info
        end)
    end)
    mkBtn("CLEAR", UDim2.fromOffset(250, 7), Color3.fromRGB(255, 150, 0), function()
        source.Text = ""
    end)
    source:GetPropertyChangedSignal("Text"):Connect(function()
        self:_update()
    end)
    local dragging, dragStart, startPos
    header.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging, dragStart, startPos = true, input.Position, main.Position
        end
    end)
    self.Services.UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local delta = input.Position - dragStart
            main.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
    self.Services.UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
    end)
    self.State.UI = {Main = main, Source = source, EditorScroll = scroll, Lines = lines, Keywords = kw, Globals = gb, Remotes = rm}
    DoNotif("Forensic IDE Ready.", 2)
end
function Modules.InternalExecutor:Initialize()
    for _, s in ipairs(self.Dependencies) do self.Services[s] = game:GetService(s) end
    RegisterCommand({
        Name = "ide",
        Aliases = {"lift", "exe", "internal"},
        Description = "Stable Forensic IDE with circular-dependency protection."
    }, function()
        self:CreateUI()
    end)
end
Modules.GoToPart = {
    State = {
        LastSearchResults = {},
        IsSearching = false
    },
    Services = {
        Players = game:GetService("Players"),
        Workspace = game:GetService("Workspace")
    }
}
function Modules.GoToPart:_findParts(searchTerm)
    if not searchTerm or searchTerm == "" then
        return {}
    end
    local results = {}
    local lowerSearch = searchTerm:lower()
    for _, descendant in ipairs(self.Services.Workspace:GetDescendants()) do
        local isValidTarget = descendant:IsA("BasePart") or descendant:IsA("Model")
        if isValidTarget and descendant.Name:lower():find(lowerSearch, 1, true) then
            table.insert(results, descendant)
            if #results >= 50 then
                break
            end
        end
    end
    return results
end
function Modules.GoToPart:_getPrimaryPosition(instance)
    if instance:IsA("Model") then
        if instance.PrimaryPart then
            return instance.PrimaryPart.Position
        end
        for _, child in ipairs(instance:GetDescendants()) do
            if child:IsA("BasePart") then
                return child.Position
            end
        end
        return instance:GetPivot().Position
    elseif instance:IsA("BasePart") then
        return instance.Position
    end
    return nil
end
function Modules.GoToPart:TeleportToInstance(instance)
    local character = self.Services.Players.LocalPlayer.Character
    local hrp = character and character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        return DoNotif("HumanoidRootPart not found.", 3)
    end
    local targetPos = self:_getPrimaryPosition(instance)
    if not targetPos then
        return DoNotif("Could not determine position for: " .. instance.Name, 3)
    end
    hrp.CFrame = CFrame.new(targetPos + Vector3.new(0, 5, 0))
    DoNotif("Teleported to: " .. instance.Name, 2)
end
function Modules.GoToPart:SearchAndTeleport(searchTerm)
    if self.State.IsSearching then
        return DoNotif("Already searching...", 2)
    end
    self.State.IsSearching = true
    DoNotif("Searching for: " .. searchTerm, 1.5)
    task.spawn(function()
        local results = self:_findParts(searchTerm)
        self.State.IsSearching = false
        if #results == 0 then
            DoNotif("No parts/models found matching: " .. searchTerm, 3)
            return
        end
        if #results == 1 then
            self:TeleportToInstance(results[1])
        else
            self.State.LastSearchResults = results
            DoNotif("Found " .. #results .. " matches. Use ;gotopart # to select.", 4)
            print("=== GoToPart Results ===")
            for i, result in ipairs(results) do
                local path = result:GetFullName()
                print(string.format("[%d] %s (%s)", i, result.Name, result.ClassName))
            end
            print("========================")
            print("Use: ;gotopart " .. math.min(#results, 5) .. " (for example)")
        end
    end)
end
function Modules.GoToPart:TeleportToIndex(index)
    if #self.State.LastSearchResults == 0 then
        return DoNotif("No search results. Use ;gotopart <name> first.", 3)
    end
    local idx = tonumber(index)
    if not idx or idx < 1 or idx > #self.State.LastSearchResults then
        return DoNotif("Invalid index. Choose 1-" .. #self.State.LastSearchResults, 3)
    end
    local targetInstance = self.State.LastSearchResults[idx]
    if targetInstance and targetInstance.Parent then
        self:TeleportToInstance(targetInstance)
    else
        DoNotif("Selected part no longer exists.", 3)
    end
end
function Modules.GoToPart:Initialize()
    local module = self
    RegisterCommand({
        Name = "gotopart",
        Aliases = {"gtp", "tppart", "topart"},
        Description = "Teleports to a part or model by name. Use number to select from results."
    }, function(args)
        if not args[1] then
            return DoNotif("Usage: ;gotopart <part name> OR ;gotopart <#>", 3)
        end
        local firstArg = args[1]
        local asNumber = tonumber(firstArg)
        if asNumber then
            module:TeleportToIndex(asNumber)
        else
            local searchTerm = table.concat(args, " ")
            module:SearchAndTeleport(searchTerm)
        end
    end)
end
Modules.Disarmer = {
    State = {
        IsEnabled = false,
        Connections = {}
    },
    Config = {
        ARM_PARTS = {
            "Left Arm", "Right Arm",
            "LeftUpperArm", "LeftLowerArm", "LeftHand",
            "RightUpperArm", "RightLowerArm", "RightHand"
        }
    },
    Dependencies = {"Players", "Workspace", "RunService"},
    Services = {}
}
function Modules.Disarmer:_strip(model)
    if not model or not self.State.IsEnabled then return end
    local player = self.Services.Players:GetPlayerFromCharacter(model)
    if player == self.Services.Players.LocalPlayer then return end
    if not model:FindFirstChild("HumanoidRootPart") then return end
    for _, limbName in ipairs(self.Config.ARM_PARTS) do
        local limb = model:FindFirstChild(limbName)
        if limb then
            pcall(function()
                limb:Destroy()
            end)
        end
    end
end
function Modules.Disarmer:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    for _, obj in ipairs(self.Services.Workspace:GetDescendants()) do
        if obj:IsA("Model") and obj:FindFirstChildOfClass("Humanoid") then
            self:_strip(obj)
        end
    end
    self.State.Connections.DescendantAdded = self.Services.Workspace.DescendantAdded:Connect(function(obj)
        if obj:IsA("Model") then
            task.defer(function()
                if obj:FindFirstChildOfClass("Humanoid") then
                    self:_strip(obj)
                end
            end)
        end
    end)
    DoNotif("Disarmer: ENABLED (Limbs Purged)", 2)
end
function Modules.Disarmer:Disable()
    if not self.State.IsEnabled then return end
    self.State.IsEnabled = false
    for _, conn in pairs(self.State.Connections) do
        conn:Disconnect()
    end
    table.clear(self.State.Connections)
    DoNotif("Disarmer: DISABLED (Requires respawn to restore)", 2)
end
function Modules.Disarmer:Initialize()
    for _, s in ipairs(self.Dependencies) do self.Services[s] = game:GetService(s) end
    RegisterCommand({
        Name = "disarm",
        Aliases = {"noarms"},
        Description = "Removes arms from every player and NPC in the game except you."
    }, function()
        if self.State.IsEnabled then
            self:Disable()
        else
            self:Enable()
        end
    end)
end
local function loadstringCmd(url, notif)
    pcall(function()
        loadstring(game:HttpGet(url))()
    end)
    DoNotif(notif, 3)
end
RegisterCommand({Name = "zsniper", Aliases = {}, Description = "For https://www.roblox.com/games/14419907512/Zombie-game"}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/ZukaTechPanel/refs/heads/main/sniperZG.lua", "Loading..") end)
RegisterCommand({Name = "zshotgun", Aliases = {}, Description = "For https://www.roblox.com/games/14419907512/Zombie-game"}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/ZukaTechPanel/refs/heads/main/ShotgunMinigunScriptWorking.lua", "Loading..") end)
RegisterCommand({Name = "noanim", Aliases = {}, Description = "Pauses/Removes All animations for the player."}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/ZukaTechPanel/refs/heads/main/animationremover.lua", " Loading.. ") end)
RegisterCommand({Name = "gunlagger2", Aliases = {}, Description = "For Protect the house from Monsters."}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/ZukaTechPanel/refs/heads/main/machinegun.lua", " Loading.. ") end)
RegisterCommand({Name = "gunlagger", Aliases = {}, Description = "For Protect the house from Monsters."}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/ZukaTechPanel/refs/heads/main/Lagger.lua", " Loading.. ") end)
RegisterCommand({Name = "lagserv", Aliases = {"spayload"}, Description = "WIP"}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/ZukaTechPanel/refs/heads/main/gamelagger.lua", " Loading.. ") end)
RegisterCommand({Name = "doomshammer", Aliases = {}, Description = "For Dumb bossfights"}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/ZukaTechPanel/refs/heads/main/doomshammer.lua", " Loading.. ") end)
RegisterCommand({Name = "tptoswords", Aliases = {}, Description = "For Dumb bossfights"}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/ZukaTechPanel/refs/heads/main/SwordGrabberBossfightGame.lua", " Loading.. ") end)
RegisterCommand({Name = "removeff", Aliases = {}, Description = "Removes Forcefields on the client, can be useful with low security"}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/ZukaTechPanel/refs/heads/main/removeforcefield.txt", " Loading.. ") end)
RegisterCommand({Name = "AttachHub", Aliases = {}, Description = "Anthony's Script 2"}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/ZukaTechPanel/refs/heads/main/AttachHub.lua", " Loading.. ") end)
RegisterCommand({Name = "simplespy", Aliases = {"sz"}, Description = "Better than ketamine."}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/Main-Repo/refs/heads/main/simplespy.lua", " Loading.. ") end)
RegisterCommand({Name = "buildts", Aliases = {}, Description = "Script Lookup"}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/Main-Repo/refs/heads/main/bts.lua", " Loading.. ") end)
RegisterCommand({Name = "teleporter", Aliases = {"tpui"}, Description = "Loads the Game Universe."}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/ZukaTechPanel/refs/heads/main/GameFinder.lua", "stolen from nameless-admin") end)
RegisterCommand({Name = "autofling", Aliases = {"pwned"}, Description = "Pwned Flinger"}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/ZukaTechPanel/refs/heads/main/Ultimatefling.lua", "Loaded!") end)
RegisterCommand({Name = "wallwalk", Aliases = {"ww"}, Description = "WIP"}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/Main-Repo/refs/heads/main/WorkINPro.lua", "Anti Gay Shield Activated.") end)
RegisterCommand({Name = "plag", Aliases = {}, Description = "For https://www.roblox.com/games/115286378269814/Protect-The-House-From-Monsters"}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/ZukaTechPanel/refs/heads/main/GameLaggerPlauncher.lua", "Loading Modification") end)
RegisterCommand({Name = "pumpkin", Aliases = {}, Description = "For https://www.roblox.com/games/115286378269814/Protect-The-House-From-Monsters"}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/ZukaTechPanel/refs/heads/main/RAPIDFIREPumpkinlauncher.lua", "Loading") end)
RegisterCommand({Name = "zukahub", Aliases = {"zuka"}, Description = "Loads the Zuka Hub"}, function() loadstringCmd("https://raw.githubusercontent.com/legalize8ga-maker/Scripts/refs/heads/main/ZukaHub.lua", "Loading Zuka's Hub...") end)
RegisterCommand({Name = "noacid", Aliases = {"unfuck"}, Description = "For https://www.roblox.com/games/14419907512/Zombie-game"}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/ZukaTechPanel/refs/heads/main/AntiAcidRainLag.lua", "Loading...") end)
RegisterCommand({Name = "stats", Aliases = {}, Description = "Edit and lock your properties."}, function() loadstringCmd("https://raw.githubusercontent.com/legalize8ga-maker/Scripts/refs/heads/main/statlock.lua", "Loading Stats..") end)
RegisterCommand({Name = "plasmasniper", Aliases = {}, Description = "For Backrooms."}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/ZukaTechPanel/refs/heads/main/plasmasniper.lua", "Loaded") end)
RegisterCommand({Name = "creepyanim", Aliases = {"canim"}, Description = "Uncanny Animation GUI"}, function() loadstringCmd("https://raw.githubusercontent.com/legalize8ga-maker/Scripts/refs/heads/main/uncannyanim.lua", "Loaded GUI") end)
RegisterCommand({Name = "swordbot", Aliases = {"sf", "sfbot"}, Description = "Auto Sword Fighter, use E and R"}, function() loadstringCmd("https://raw.githubusercontent.com/bloxtech1/luaprojects2/refs/heads/main/swordnpc", "Bot loaded.") end)
RegisterCommand({Name = "touchfling", Aliases = {}, Description = "Loads the touchfling GUI"}, function() loadstringCmd("https://raw.githubusercontent.com/legalize8ga-maker/Scripts/refs/heads/main/SimpleTouchFlingGui.lua", "Loaded") end)
RegisterCommand({Name = "umpff", Aliases = {}, Description = "For Backrooms." }, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/ZukaTechPanel/refs/heads/main/UMPteamkiller.lua", "Loaded") end)
RegisterCommand({Name = "lunaaimbot", Aliases = {"lunagc"}, Description = "Work In Progress" }, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/Main-Repo/refs/heads/main/GamingChair.lua", "Loaded") end)
RegisterCommand({Name = "ibtools", Aliases = {"btools"}, Description = "Upgraded Gui For Btools"}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/ZukaTechPanel/refs/heads/main/buildtools.lua", "Loading Revamped Btools Gui") end)
RegisterCommand({Name = "Zex", Aliases = {"Dex"}, Description = "Updated Dex+"}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/Main-Repo/refs/heads/main/Zex.lua", "Loading Zex..") end)
RegisterCommand({Name = "walkvoid", Aliases = {"wv"}, Description = "Stops you from falling into the void."}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/Main-Repo/refs/heads/main/WalkVoid.lua", "You are now safe from falling into the void.") end)
RegisterCommand({Name = "zspy", Aliases = {"adonisrspy"}, Description = "in beta"}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/Main-Repo/refs/heads/main/executor_scripts/SimpleSpyRework.lua", "in beta...") end)
RegisterCommand({Name = "csgo", Aliases = {"bhop"}, Description = "Bhop movement"}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/ZukaTechPanel/refs/heads/main/phoon.lua", "Loading") end)
RegisterCommand({Name = "lineofsight", Aliases = {}, Description = "Logger for players looking at you"}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/ZukaTechPanel/refs/heads/main/LineOfSightLogger.lua", "Loading...") end)
RegisterCommand({Name = "zcooldowns", Aliases = {"ncd"}, Description = "For https://www.roblox.com/games/14419907512/Zombie-game"}, function() loadstringCmd("https://raw.githubusercontent.com/legalize8ga-maker/Scripts/refs/heads/main/NocooldownsZombieUpd3.txt", "Loading Cooldownremover...") end)
RegisterCommand({Name = "zshovel", Aliases = {}, Description = "For https://www.roblox.com/games/14419907512/Zombie-game"}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/ZukaTechPanel/refs/heads/main/ShovelAnimation.lua", "Loading Shovel.") end)
RegisterCommand({Name = "patchgun", Aliases = {}, Description = "Avoid being kicked for being idle."}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/Main-Repo/refs/heads/main/PatchedGuns.lua", "Guns Patched.") end)
RegisterCommand({Name = "zmelee", Aliases = {}, Description = "For https://www.roblox.com/games/6850833423/Zombie-Infection-Game."}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/ZukaTechPanel/refs/heads/main/MeleeDamagex2.lua", "Loading..") end)
RegisterCommand({Name = "flinger", Aliases = {"flingui"}, Description = "Loads a Fling GUI."}, function() loadstringCmd("https://raw.githubusercontent.com/legalize8ga-maker/Scripts/refs/heads/main/SkidFling.lua", "Loading GUI..") end)
RegisterCommand({Name = "rem", Aliases = {}, Description = "In game exploit creation kit.."}, function() loadstringCmd("https://e-vil.com/anbu/rem.lua", "Loading Rem.") end)
RegisterCommand({Name = "Copyconsole", Aliases = {"copy"}, Description = "Allows you to copy errors from the console.."}, function() loadstringCmd("https://raw.githubusercontent.com/scriptlisenbe-stack/luaprojectse3/refs/heads/main/consolecopy.lua", "Copy Console Activated.") end)
RegisterCommand({Name = "zhp", Aliases = {}, Description = "For https://www.roblox.com/games/14419907512/Zombie-game"}, function() loadstringCmd("https://raw.githubusercontent.com/legalize8ga-maker/Scripts/refs/heads/main/zgamemedkit.lua", "Loading HP Teleport") end)
RegisterCommand({Name = "reachfix", Aliases = {"fix"}, Description = "Makes your equipped tool invisible when using reach"}, function() loadstringCmd("https://raw.githubusercontent.com/legalize8ga-maker/Scripts/refs/heads/main/InvisibleEquippedTool.lua", "Fixed") end)
RegisterCommand({Name = "worldofstands", Aliases = {"wos"}, Description = "For https://www.roblox.com/games/6728870912/World-of-Stands - Removes dash cooldown"}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/ZukaTechPanel/refs/heads/main/WOS.lua", "Loading, Wait a sec.") end)
RegisterCommand({Name = "zfucker", Aliases = {}, Description = "zfucker for the zl series."}, function() loadstringCmd("https://raw.githubusercontent.com/osukfcdays/zlfucker/refs/heads/main/main.luau", "Loading, Wait a sec.") end)
RegisterCommand({Name = "antiesp", Aliases = {}, Description = "Testing"}, function() loadstringCmd("https://raw.githubusercontent.com/zukatech1/Main-Repo/refs/heads/main/espwip.lua", "Loading, Wait a sec.") end)
Modules.AntiESP = {
    State = {
        IsEnabled = false,
        IsActive = false,
        Character = nil,
        HumanoidRootPart = nil,
        Humanoid = nil,
        OriginalCFrame = nil,
        FakeCharacter = nil,
        Connections = {},
        UI = nil
    },
    Config = {
        VoidDepth = -50000,
        UpdateRate = 0.03,
        EnableDummyDecoy = true,
        DecoyOffset = Vector3.new(50, 0, 50),
        AntiRaycast = true,
        SuppressNametags = true
    }
}
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer
local TweenService = game:GetService("TweenService")
function Modules.AntiESP:_createUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "AntiESP_Zuka"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
    self.State.UI = screenGui
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.fromOffset(350, 450)
    mainFrame.Position = UDim2.new(1, -360, 0.5, -225)
    mainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
    mainFrame.BorderSizePixel = 0
    mainFrame.Parent = screenGui
    Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 12)
    local stroke = Instance.new("UIStroke", mainFrame)
    stroke.Color = Color3.fromRGB(255, 0, 150)
    stroke.Thickness = 2
    local glowTween = TweenService:Create(stroke, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {
        Thickness = 3
    })
    glowTween:Play()
    local titleBar = Instance.new("Frame", mainFrame)
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1, 0, 0, 40)
    titleBar.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
    titleBar.BorderSizePixel = 0
    Instance.new("UICorner", titleBar).CornerRadius = UDim.new(0, 12)
    local title = Instance.new("TextLabel", titleBar)
    title.Size = UDim2.new(1, -90, 1, 0)
    title.Position = UDim2.fromOffset(15, 0)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.Code
    title.Text = "â–¸ ANTI-ESP/AIMBOT"
    title.TextColor3 = Color3.fromRGB(255, 0, 150)
    title.TextSize = 16
    title.TextXAlignment = Enum.TextXAlignment.Left
    local statusIndicator = Instance.new("TextLabel", titleBar)
    statusIndicator.Name = "StatusIndicator"
    statusIndicator.Size = UDim2.fromOffset(80, 20)
    statusIndicator.Position = UDim2.new(1, -150, 0.5, -10)
    statusIndicator.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    statusIndicator.BorderSizePixel = 0
    statusIndicator.Font = Enum.Font.GothamBold
    statusIndicator.Text = "INACTIVE"
    statusIndicator.TextColor3 = Color3.fromRGB(200, 200, 200)
    statusIndicator.TextSize = 10
    Instance.new("UICorner", statusIndicator).CornerRadius = UDim.new(0, 4)
    local closeBtn = Instance.new("TextButton", titleBar)
    closeBtn.Size = UDim2.fromOffset(30, 30)
    closeBtn.Position = UDim2.new(1, -35, 0, 5)
    closeBtn.BackgroundColor3 = Color3.fromRGB(255, 50, 100)
    closeBtn.BorderSizePixel = 0
    closeBtn.Text = "Ã—"
    closeBtn.TextColor3 = Color3.new(1, 1, 1)
    closeBtn.Font = Enum.Font.GothamBold
    closeBtn.TextSize = 20
    Instance.new("UICorner", closeBtn).CornerRadius = UDim.new(0, 8)
    closeBtn.MouseButton1Click:Connect(function()
        self:Disable()
    end)
    self:MakeDraggable(titleBar, mainFrame)
    local content = Instance.new("Frame", mainFrame)
    content.Name = "Content"
    content.Size = UDim2.new(1, -20, 1, -50)
    content.Position = UDim2.fromOffset(10, 45)
    content.BackgroundTransparency = 1
    local statusLabel = Instance.new("TextLabel", content)
    statusLabel.Name = "StatusLabel"
    statusLabel.Size = UDim2.new(1, 0, 0, 80)
    statusLabel.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    statusLabel.BorderSizePixel = 0
    statusLabel.Font = Enum.Font.Code
    statusLabel.Text = "Status: Inactive\nServer Position: Normal\nDecoy: Off"
    statusLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    statusLabel.TextSize = 11
    statusLabel.TextWrapped = true
    statusLabel.TextYAlignment = Enum.TextYAlignment.Top
    Instance.new("UICorner", statusLabel).CornerRadius = UDim.new(0, 6)
    local padding = Instance.new("UIPadding", statusLabel)
    padding.PaddingLeft = UDim.new(0, 10)
    padding.PaddingTop = UDim.new(0, 10)
    local activateBtn = Instance.new("TextButton", content)
    activateBtn.Name = "ActivateButton"
    activateBtn.Size = UDim2.new(1, 0, 0, 50)
    activateBtn.Position = UDim2.fromOffset(0, 90)
    activateBtn.BackgroundColor3 = Color3.fromRGB(0, 200, 100)
    activateBtn.BorderSizePixel = 0
    activateBtn.Font = Enum.Font.GothamBold
    activateBtn.Text = "ACTIVATE ANTI-ESP"
    activateBtn.TextColor3 = Color3.new(1, 1, 1)
    activateBtn.TextSize = 14
    Instance.new("UICorner", activateBtn).CornerRadius = UDim.new(0, 8)
    activateBtn.MouseButton1Click:Connect(function()
        self:ToggleActive()
    end)
    local settingsLabel = Instance.new("TextLabel", content)
    settingsLabel.Size = UDim2.new(1, 0, 0, 20)
    settingsLabel.Position = UDim2.fromOffset(0, 150)
    settingsLabel.BackgroundTransparency = 1
    settingsLabel.Font = Enum.Font.GothamBold
    settingsLabel.Text = "Settings:"
    settingsLabel.TextColor3 = Color3.new(1, 1, 1)
    settingsLabel.TextSize = 13
    settingsLabel.TextXAlignment = Enum.TextXAlignment.Left
    local decoyToggle = Instance.new("TextButton", content)
    decoyToggle.Name = "DecoyToggle"
    decoyToggle.Size = UDim2.new(1, 0, 0, 35)
    decoyToggle.Position = UDim2.fromOffset(0, 180)
    decoyToggle.BackgroundColor3 = Color3.fromRGB(0, 150, 200)
    decoyToggle.BorderSizePixel = 0
    decoyToggle.Font = Enum.Font.GothamBold
    decoyToggle.Text = "DUMMY DECOY: ON"
    decoyToggle.TextColor3 = Color3.new(1, 1, 1)
    decoyToggle.TextSize = 12
    Instance.new("UICorner", decoyToggle).CornerRadius = UDim.new(0, 6)
    decoyToggle.MouseButton1Click:Connect(function()
        self.Config.EnableDummyDecoy = not self.Config.EnableDummyDecoy
        decoyToggle.Text = "DUMMY DECOY: " .. (self.Config.EnableDummyDecoy and "ON" or "OFF")
        decoyToggle.BackgroundColor3 = self.Config.EnableDummyDecoy and Color3.fromRGB(0, 150, 200) or Color3.fromRGB(50, 50, 65)
        self:UpdateDisplay()
    end)
    local raycastToggle = Instance.new("TextButton", content)
    raycastToggle.Name = "RaycastToggle"
    raycastToggle.Size = UDim2.new(1, 0, 0, 35)
    raycastToggle.Position = UDim2.fromOffset(0, 225)
    raycastToggle.BackgroundColor3 = Color3.fromRGB(0, 150, 200)
    raycastToggle.BorderSizePixel = 0
    raycastToggle.Font = Enum.Font.GothamBold
    raycastToggle.Text = "ANTI-RAYCAST: ON"
    raycastToggle.TextColor3 = Color3.new(1, 1, 1)
    raycastToggle.TextSize = 12
    Instance.new("UICorner", raycastToggle).CornerRadius = UDim.new(0, 6)
    raycastToggle.MouseButton1Click:Connect(function()
        self.Config.AntiRaycast = not self.Config.AntiRaycast
        raycastToggle.Text = "ANTI-RAYCAST: " .. (self.Config.AntiRaycast and "ON" or "OFF")
        raycastToggle.BackgroundColor3 = self.Config.AntiRaycast and Color3.fromRGB(0, 150, 200) or Color3.fromRGB(50, 50, 65)
    end)
    local nametagToggle = Instance.new("TextButton", content)
    nametagToggle.Name = "NametagToggle"
    nametagToggle.Size = UDim2.new(1, 0, 0, 35)
    nametagToggle.Position = UDim2.fromOffset(0, 270)
    nametagToggle.BackgroundColor3 = Color3.fromRGB(0, 150, 200)
    nametagToggle.BorderSizePixel = 0
    nametagToggle.Font = Enum.Font.GothamBold
    nametagToggle.Text = "HIDE NAMETAGS: ON"
    nametagToggle.TextColor3 = Color3.new(1, 1, 1)
    nametagToggle.TextSize = 12
    Instance.new("UICorner", nametagToggle).CornerRadius = UDim.new(0, 6)
    nametagToggle.MouseButton1Click:Connect(function()
        self.Config.SuppressNametags = not self.Config.SuppressNametags
        nametagToggle.Text = "HIDE NAMETAGS: " .. (self.Config.SuppressNametags and "ON" or "OFF")
        nametagToggle.BackgroundColor3 = self.Config.SuppressNametags and Color3.fromRGB(0, 150, 200) or Color3.fromRGB(50, 50, 65)
        if self.State.IsActive then
            self:SuppressNametags()
        end
    end)
    local infoLabel = Instance.new("TextLabel", content)
    infoLabel.Size = UDim2.new(1, 0, 0, 80)
    infoLabel.Position = UDim2.fromOffset(0, 315)
    infoLabel.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    infoLabel.BorderSizePixel = 0
    infoLabel.Font = Enum.Font.Code
    infoLabel.Text = "How it works:\nâ€¢ Server sees you in the void\nâ€¢ ESP shows wrong position\nâ€¢ Aimbot can't hit you"
    infoLabel.TextColor3 = Color3.fromRGB(150, 150, 200)
    infoLabel.TextSize = 10
    infoLabel.TextWrapped = true
    infoLabel.TextYAlignment = Enum.TextYAlignment.Top
    Instance.new("UICorner", infoLabel).CornerRadius = UDim.new(0, 6)
    local infoPadding = Instance.new("UIPadding", infoLabel)
    infoPadding.PaddingLeft = UDim.new(0, 10)
    infoPadding.PaddingTop = UDim.new(0, 10)
    screenGui.Parent = CoreGui
    return statusLabel, statusIndicator, activateBtn
end
function Modules.AntiESP:MakeDraggable(handle, object)
    local dragging = false
    local dragStart, startPos
    handle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = object.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    handle.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            if dragging then
                local delta = input.Position - dragStart
                object.Position = UDim2.new(
                    startPos.X.Scale, startPos.X.Offset + delta.X,
                    startPos.Y.Scale, startPos.Y.Offset + delta.Y
                )
            end
        end
    end)
end
function Modules.AntiESP:SuppressNametags()
    if not self.Config.SuppressNametags or not self.State.Character then return end
    for _, descendant in pairs(self.State.Character:GetDescendants()) do
        if descendant:IsA("BillboardGui") or descendant:IsA("SurfaceGui") then
            descendant.Enabled = false
        end
    end
    if self.State.Character:FindFirstChild("Head") then
        local head = self.State.Character.Head
        for _, child in pairs(head:GetChildren()) do
            if child:IsA("BillboardGui") or child.Name:lower():find("nametag") or child.Name:lower():find("tag") then
                child.Enabled = false
            end
        end
    end
end
function Modules.AntiESP:CreateDummyDecoy()
    if not self.Config.EnableDummyDecoy or not self.State.Character then return end
    if self.State.FakeCharacter then
        self.State.FakeCharacter:Destroy()
    end
    local fakeChar = self.State.Character:Clone()
    for _, part in pairs(fakeChar:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
            part.Anchored = true
            part.Transparency = 0
        end
    end
    for _, obj in pairs(fakeChar:GetDescendants()) do
        if obj:IsA("Script") or obj:IsA("LocalScript") or obj:IsA("ModuleScript") then
            obj:Destroy()
        end
    end
    if fakeChar:FindFirstChild("Humanoid") then
        fakeChar.Humanoid:Destroy()
    end
    if self.State.HumanoidRootPart then
        fakeChar:SetPrimaryPartCFrame(self.State.HumanoidRootPart.CFrame + self.Config.DecoyOffset)
    end
    fakeChar.Parent = Workspace
    fakeChar.Name = LocalPlayer.Name .. "_Decoy"
    self.State.FakeCharacter = fakeChar
    print("âœ“ Dummy decoy created")
end
function Modules.AntiESP:UpdateDecoyPosition()
    if not self.State.FakeCharacter or not self.State.FakeCharacter.Parent or not self.State.HumanoidRootPart then return end
    local fakePosition = self.State.HumanoidRootPart.CFrame + self.Config.DecoyOffset
    self.State.FakeCharacter:SetPrimaryPartCFrame(fakePosition)
end
function Modules.AntiESP:VoidTeleport()
    if not self.State.HumanoidRootPart or not self.State.HumanoidRootPart.Parent then return end
    local currentPos = self.State.HumanoidRootPart.Position
    local targetY = self.Config.AntiRaycast and -100 or self.Config.VoidDepth
    local voidPosition = Vector3.new(currentPos.X, targetY, currentPos.Z)
    self.State.HumanoidRootPart.CFrame = CFrame.new(voidPosition)
end
function Modules.AntiESP:MainLoop()
    while self.State.IsActive and self.State.Character and self.State.Character.Parent do
        task.wait(self.Config.UpdateRate)
        self:VoidTeleport()
        if self.Config.EnableDummyDecoy then
            self:UpdateDecoyPosition()
        end
        if self.Config.SuppressNametags then
            self:SuppressNametags()
        end
    end
end
function Modules.AntiESP:ToggleActive()
    if not self.State.Character or not self.State.HumanoidRootPart then
        print("âœ— Character not ready")
        return
    end
    self.State.IsActive = not self.State.IsActive
    if self.State.IsActive then
        self.State.OriginalCFrame = self.State.HumanoidRootPart.CFrame
        self:SuppressNametags()
        if self.Config.EnableDummyDecoy then
            self:CreateDummyDecoy()
        end
        task.spawn(function()
            self:MainLoop()
        end)
        print("âœ“ Anti-ESP ACTIVATED")
    else
        if self.State.FakeCharacter then
            self.State.FakeCharacter:Destroy()
            self.State.FakeCharacter = nil
        end
        if self.State.OriginalCFrame then
            self.State.HumanoidRootPart.CFrame = self.State.OriginalCFrame
        end
        print("âœ“ Anti-ESP DEACTIVATED")
    end
    self:UpdateDisplay()
end
function Modules.AntiESP:UpdateDisplay()
    if not self.State.UI then return end
    local statusLabel = self.State.UI.MainFrame.Content.StatusLabel
    local statusIndicator = self.State.UI.MainFrame.TitleBar.StatusIndicator
    local activateBtn = self.State.UI.MainFrame.Content.ActivateButton
    if self.State.IsActive then
        local depth = self.Config.AntiRaycast and "-100" or self.Config.VoidDepth
        statusLabel.Text = string.format(
            "Status: ACTIVE\nServer Position: Y=%s\nDecoy: %s\nNametags: %s",
            depth,
            self.Config.EnableDummyDecoy and "Active" or "Off",
            self.Config.SuppressNametags and "Hidden" or "Visible"
        )
        statusLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
        statusIndicator.Text = "ACTIVE"
        statusIndicator.BackgroundColor3 = Color3.fromRGB(0, 255, 100)
        statusIndicator.TextColor3 = Color3.new(1, 1, 1)
        activateBtn.Text = "DEACTIVATE"
        activateBtn.BackgroundColor3 = Color3.fromRGB(255, 100, 50)
    else
        statusLabel.Text = "Status: Inactive\nServer Position: Normal\nDecoy: Off"
        statusLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        statusIndicator.Text = "INACTIVE"
        statusIndicator.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
        statusIndicator.TextColor3 = Color3.fromRGB(200, 200, 200)
        activateBtn.Text = "ACTIVATE ANTI-ESP"
        activateBtn.BackgroundColor3 = Color3.fromRGB(0, 200, 100)
    end
end
function Modules.AntiESP:OnCharacterAdded(character)
    self.State.Character = character
    self.State.HumanoidRootPart = character:WaitForChild("HumanoidRootPart")
    self.State.Humanoid = character:WaitForChild("Humanoid")
    if self.State.FakeCharacter then
        self.State.FakeCharacter:Destroy()
        self.State.FakeCharacter = nil
    end
    self.State.IsActive = false
    self:UpdateDisplay()
    self.State.Humanoid.Died:Connect(function()
        self.State.IsActive = false
        if self.State.FakeCharacter then
            self.State.FakeCharacter:Destroy()
            self.State.FakeCharacter = nil
        end
        self:UpdateDisplay()
    end)
end
function Modules.AntiESP:Enable()
    if self.State.IsEnabled then return end
    self.State.IsEnabled = true
    if LocalPlayer.Character then
        self:OnCharacterAdded(LocalPlayer.Character)
    end
    self.State.Connections.CharacterAdded = LocalPlayer.CharacterAdded:Connect(function(character)
        task.wait(1)
        self:OnCharacterAdded(character)
    end)
    self:_createUI()
    self:UpdateDisplay()
    print("âœ“ Anti-ESP/Aimbot GUI enabled")
end
function Modules.AntiESP:Disable()
    if not self.State.IsEnabled then return end
    if self.State.IsActive then
        self.State.IsActive = false
        if self.State.FakeCharacter then
            self.State.FakeCharacter:Destroy()
            self.State.FakeCharacter = nil
        end
        if self.State.OriginalCFrame and self.State.HumanoidRootPart then
            self.State.HumanoidRootPart.CFrame = self.State.OriginalCFrame
        end
    end
    self.State.IsEnabled = false
    for _, conn in pairs(self.State.Connections) do
        if conn then
            conn:Disconnect()
        end
    end
    table.clear(self.State.Connections)
    if self.State.UI then
        self.State.UI:Destroy()
        self.State.UI = nil
    end
    print("âœ“ Anti-ESP/Aimbot disabled")
end
function Modules.AntiESP:Toggle()
    if self.State.IsEnabled then
        self:Disable()
    else
        self:Enable()
    end
end
RegisterCommand({
    Name = "antiesp2",
    Aliases = {"voidspoof"},
    Description = "Anti-ESP/Aimbot system. Sends server position to void while keeping client normal."
}, function()
    Modules.AntiESP:Toggle()
end)
Modules.IYPluginManager = {
    State = {
        IsEnabled = false,
        PluginsTable = {},
        LoadedPlugins = {},
        UI = nil,
        ScreenGui = nil,
    },
    Config = {
        SAVE_FILE = "workspace/iy_plugins.json",
        SAVE_FOLDER = "workspace",
        PLUGINS_FOLDER = "Infinite_Yield",
        BG_COLOR = Color3.fromRGB(15, 15, 20),
        HEADER_COLOR = Color3.fromRGB(25, 25, 35),
        SECONDARY_COLOR = Color3.fromRGB(30, 30, 40),
        ACCENT_COLOR = Color3.fromRGB(0, 255, 255),
        TEXT_COLOR = Color3.fromRGB(220, 220, 220),
        DANGER_COLOR = Color3.fromRGB(200, 60, 60),
        SUCCESS_COLOR = Color3.fromRGB(60, 200, 100),
        ROW_COLOR = Color3.fromRGB(35, 35, 48),
        ROW_HOVER = Color3.fromRGB(45, 45, 60),
    }
}
local function IYfindInTable(tbl, val)
    for _, v in pairs(tbl) do
        if v == val then return true end
    end
    return false
end
local function IYisNumber(val)
    return tonumber(val) ~= nil
end
local function IYmakeCorner(parent, radius)
    local corner = Instance.new("UICorner", parent)
    corner.CornerRadius = UDim.new(0, radius or 6)
    return corner
end
local function IYmakeStroke(parent, color, thickness)
    local stroke = Instance.new("UIStroke", parent)
    stroke.Color = color or Color3.fromRGB(60, 60, 80)
    stroke.Thickness = thickness or 1
    return stroke
end
function Modules.IYPluginManager:SavePluginList()
    if not writefile or not makefolder then
        DoNotif("IY Plugins: File system not available", 3)
        return false
    end
    pcall(function()
        if not isfolder or not isfolder(self.Config.SAVE_FOLDER) then
            makefolder(self.Config.SAVE_FOLDER)
        end
    end)
    local success = pcall(function()
        local data = game:GetService("HttpService"):JSONEncode({
            plugins = self.State.PluginsTable,
            savedAt = os.time()
        })
        writefile(self.Config.SAVE_FILE, data)
    end)
    if success then
        DoNotif("IY Plugins: List saved (" .. #self.State.PluginsTable .. " plugins)", 2)
    else
        DoNotif("IY Plugins: Failed to save list", 3)
    end
    return success
end
function Modules.IYPluginManager:LoadPluginList()
    if not readfile or not isfile then return end
    local success, result = pcall(function()
        if isfile(self.Config.SAVE_FILE) then
            return readfile(self.Config.SAVE_FILE)
        end
        return nil
    end)
    if success and result then
        local decodeSuccess, data = pcall(function()
            return game:GetService("HttpService"):JSONDecode(result)
        end)
        if decodeSuccess and data and data.plugins then
            self.State.PluginsTable = data.plugins
        end
    end
end
function Modules.IYPluginManager:LoadPlugin(fileName, isStartup)
    local plugin = nil
    local filePath = fileName
    local function tryLoad()
        local iyPath = self.Config.PLUGINS_FOLDER .. "/" .. fileName
        local ok, content = pcall(readfile, iyPath)
        if ok and content then
            filePath = iyPath
            return content
        end
        ok, content = pcall(readfile, fileName)
        if ok and content then
            filePath = fileName
            return content
        end
        if fileName:sub(-3) ~= ".iy" then
            ok, content = pcall(readfile, fileName .. ".iy")
            if ok and content then
                filePath = fileName .. ".iy"
                return content
            end
        end
        return nil
    end
    local fileContent = tryLoad()
    if not fileContent then
        DoNotif("IY Plugin Error: Cannot find '" .. fileName .. "'", 4)
        for i, v in pairs(self.State.PluginsTable) do
            if v == fileName then
                table.remove(self.State.PluginsTable, i)
                break
            end
        end
        self:RefreshPluginList()
        return false
    end
    local loadSuccess, loadErr = pcall(function()
        local func, err = loadstring(fileContent)
        if not func then
            error(err)
        end
        plugin = func()
    end)
    if not loadSuccess or plugin == nil then
        DoNotif("IY Plugin Error: '" .. fileName .. "' failed to execute", 4)
        warn("[IYPluginManager] Error loading " .. fileName .. ": " .. tostring(loadErr))
        for i, v in pairs(self.State.PluginsTable) do
            if v == fileName then
                table.remove(self.State.PluginsTable, i)
                break
            end
        end
        self:RefreshPluginList()
        self:SavePluginList()
        return false
    end
    local cmdCount = 0
    if plugin["Commands"] then
        for cmdKey, cmdData in pairs(plugin["Commands"]) do
            local cmdExt = ""
            local cmdName = cmdKey
            local function resolveCommandName()
                cmdName = cmdKey
                if Commands[cmdName .. cmdExt] then
                    if IYisNumber(cmdExt) then
                        cmdExt = cmdExt + 1
                    else
                        cmdExt = 1
                    end
                    resolveCommandName()
                else
                    cmdName = cmdName .. cmdExt
                end
            end
            resolveCommandName()
            local aliases = {}
            if cmdData["Aliases"] then
                for _, alias in ipairs(cmdData["Aliases"]) do
                    table.insert(aliases, alias)
                end
            end
            pcall(function()
                RegisterCommand({
                    Name = cmdName,
                    Aliases = aliases,
                    Description = cmdData["Description"] or "IY Plugin Command",
                }, cmdData["Function"])
            end)
            cmdCount = cmdCount + 1
        end
    end
    self.State.LoadedPlugins[fileName] = {
        PluginName = plugin["PluginName"] or fileName,
        PluginDescription = plugin["PluginDescription"] or "No description",
        CommandCount = cmdCount,
        FilePath = filePath,
        LoadedAt = os.time()
    }
    if not isStartup then
        DoNotif("IY Plugin Loaded: " .. (plugin["PluginName"] or fileName) .. " (" .. cmdCount .. " commands)", 3)
    end
    return true
end
function Modules.IYPluginManager:AddPlugin(name)
    if not name or name == "" or name:lower() == "plugin file name" then
        DoNotif("IY Plugins: Enter a valid plugin name", 3)
        return
    end
    local fileName = name
    if name:sub(-3) ~= ".iy" then
        fileName = name .. ".iy"
    end
    if IYfindInTable(self.State.PluginsTable, fileName) then
        DoNotif("IY Plugins: '" .. fileName .. "' is already loaded", 3)
        return
    end
    local loaded = self:LoadPlugin(fileName, false)
    if loaded then
        table.insert(self.State.PluginsTable, fileName)
        self:SavePluginList()
        self:RefreshPluginList()
    end
end
function Modules.IYPluginManager:RemovePlugin(fileName)
    for i, v in pairs(self.State.PluginsTable) do
        if v == fileName then
            table.remove(self.State.PluginsTable, i)
            break
        end
    end
    self.State.LoadedPlugins[fileName] = nil
    DoNotif("IY Plugin Removed: " .. fileName, 2)
    self:SavePluginList()
    self:RefreshPluginList()
end
function Modules.IYPluginManager:LoadAllSaved()
    self:LoadPluginList()
    local count = 0
    local failed = 0
    for _, fileName in ipairs(self.State.PluginsTable) do
        local success = self:LoadPlugin(fileName, true)
        if success then
            count = count + 1
        else
            failed = failed + 1
        end
    end
    if count > 0 then
        DoNotif("IY Plugins: " .. count .. " plugin(s) loaded" .. (failed > 0 and (", " .. failed .. " failed") or ""), 3)
    end
    self:RefreshPluginList()
end
function Modules.IYPluginManager:ScanFolder()
    if not listfiles or not isfolder then
        DoNotif("IY Plugins: listfiles not available in this executor", 3)
        return {}
    end
    local found = {}
    local success, files = pcall(function()
        if isfolder(self.Config.PLUGINS_FOLDER) then
            return listfiles(self.Config.PLUGINS_FOLDER)
        end
        return {}
    end)
    if success and files then
        for _, filePath in ipairs(files) do
            if filePath:lower():match("%.iy$") then
                local shortName = filePath:match("([^/\\]+)$") or filePath
                table.insert(found, shortName)
            end
        end
    end
    return found
end
function Modules.IYPluginManager:CreateUI()
    local cfg = self.Config
    local CoreGui = game:GetService("CoreGui")
    local UserInputService = game:GetService("UserInputService")
    if self.State.ScreenGui and self.State.ScreenGui.Parent then
        self.State.ScreenGui:Destroy()
    end
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "IYPluginManager_Zuka"
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
    screenGui.ResetOnSpawn = false
    screenGui.Parent = CoreGui
    self.State.ScreenGui = screenGui
    local window = Instance.new("Frame", screenGui)
    window.Name = "Window"
    window.Size = UDim2.new(0, 420, 0, 500)
    window.Position = UDim2.new(0.5, -210, 0.5, -250)
    window.BackgroundColor3 = cfg.BG_COLOR
    window.BorderSizePixel = 0
    window.Active = true
    window.ClipsDescendants = true
    IYmakeCorner(window, 10)
    IYmakeStroke(window, Color3.fromRGB(0, 200, 200), 1)
    self.State.UI = window
    local isDragging = false
    local dragStart, startPos
    window.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging = true
            dragStart = input.Position
            startPos = window.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    isDragging = false
                end
            end)
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if isDragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - dragStart
            window.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
    local topBar = Instance.new("Frame", window)
    topBar.Name = "TopBar"
    topBar.Size = UDim2.new(1, 0, 0, 36)
    topBar.BackgroundColor3 = cfg.HEADER_COLOR
    topBar.BorderSizePixel = 0
    IYmakeCorner(topBar, 10)
    local accentLine = Instance.new("Frame", topBar)
    accentLine.Size = UDim2.new(1, 0, 0, 2)
    accentLine.Position = UDim2.new(0, 0, 1, -2)
    accentLine.BackgroundColor3 = cfg.ACCENT_COLOR
    accentLine.BorderSizePixel = 0
    local titleLabel = Instance.new("TextLabel", topBar)
    titleLabel.Size = UDim2.new(1, -70, 1, 0)
    titleLabel.Position = UDim2.new(0, 12, 0, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.Text = "IY Plugin Manager"
    titleLabel.TextColor3 = cfg.ACCENT_COLOR
    titleLabel.TextSize = 14
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    local closeBtn = Instance.new("TextButton", topBar)
    closeBtn.Size = UDim2.new(0, 26, 0, 26)
    closeBtn.Position = UDim2.new(1, -32, 0.5, -13)
    closeBtn.BackgroundColor3 = cfg.DANGER_COLOR
    closeBtn.Font = Enum.Font.GothamBold
    closeBtn.Text = "âœ•"
    closeBtn.TextColor3 = Color3.new(1, 1, 1)
    closeBtn.TextSize = 12
    closeBtn.BorderSizePixel = 0
    IYmakeCorner(closeBtn, 6)
    closeBtn.MouseButton1Click:Connect(function()
        screenGui:Destroy()
        self.State.ScreenGui = nil
        self.State.UI = nil
    end)
    local addBar = Instance.new("Frame", window)
    addBar.Name = "AddBar"
    addBar.Size = UDim2.new(1, -20, 0, 36)
    addBar.Position = UDim2.new(0, 10, 0, 44)
    addBar.BackgroundColor3 = cfg.SECONDARY_COLOR
    addBar.BorderSizePixel = 0
    IYmakeCorner(addBar, 8)
    IYmakeStroke(addBar, Color3.fromRGB(50, 50, 70))
    local inputBox = Instance.new("TextBox", addBar)
    inputBox.Name = "PluginInput"
    inputBox.Size = UDim2.new(1, -100, 1, -8)
    inputBox.Position = UDim2.new(0, 8, 0, 4)
    inputBox.BackgroundTransparency = 1
    inputBox.Font = Enum.Font.Code
    inputBox.PlaceholderText = "plugin_name or plugin_name.iy"
    inputBox.PlaceholderColor3 = Color3.fromRGB(80, 80, 100)
    inputBox.Text = ""
    inputBox.TextColor3 = cfg.TEXT_COLOR
    inputBox.TextSize = 12
    inputBox.TextXAlignment = Enum.TextXAlignment.Left
    inputBox.ClearTextOnFocus = false
    local addBtn = Instance.new("TextButton", addBar)
    addBtn.Size = UDim2.new(0, 80, 1, -8)
    addBtn.Position = UDim2.new(1, -86, 0, 4)
    addBtn.BackgroundColor3 = cfg.ACCENT_COLOR
    addBtn.Font = Enum.Font.GothamBold
    addBtn.Text = "+ ADD"
    addBtn.TextColor3 = Color3.fromRGB(0, 0, 0)
    addBtn.TextSize = 11
    addBtn.BorderSizePixel = 0
    IYmakeCorner(addBtn, 6)
    addBtn.MouseButton1Click:Connect(function()
        local name = inputBox.Text
        if name ~= "" then
            self:AddPlugin(name)
            inputBox.Text = ""
        else
            DoNotif("IY Plugins: Enter a plugin filename", 2)
        end
    end)
    inputBox.FocusLost:Connect(function(enterPressed)
        if enterPressed and inputBox.Text ~= "" then
            self:AddPlugin(inputBox.Text)
            inputBox.Text = ""
        end
    end)
    local toolbar = Instance.new("Frame", window)
    toolbar.Name = "Toolbar"
    toolbar.Size = UDim2.new(1, -20, 0, 28)
    toolbar.Position = UDim2.new(0, 10, 0, 88)
    toolbar.BackgroundTransparency = 1
    local toolLayout = Instance.new("UIListLayout", toolbar)
    toolLayout.FillDirection = Enum.FillDirection.Horizontal
    toolLayout.SortOrder = Enum.SortOrder.LayoutOrder
    toolLayout.Padding = UDim.new(0, 6)
    local function makeToolBtn(text, color, callback, order)
        local btn = Instance.new("TextButton", toolbar)
        btn.LayoutOrder = order
        btn.Size = UDim2.new(0, 118, 1, 0)
        btn.BackgroundColor3 = color
        btn.Font = Enum.Font.GothamBold
        btn.Text = text
        btn.TextColor3 = Color3.new(1, 1, 1)
        btn.TextSize = 10
        btn.BorderSizePixel = 0
        IYmakeCorner(btn, 6)
        btn.MouseButton1Click:Connect(callback)
        return btn
    end
    makeToolBtn("SCAN FOLDER", Color3.fromRGB(50, 80, 130), function()
        self:ShowScanResults()
    end, 1)
    makeToolBtn("RELOAD ALL", Color3.fromRGB(50, 100, 60), function()
        local count = 0
        for _, fileName in ipairs(self.State.PluginsTable) do
            if self:LoadPlugin(fileName, false) then
                count = count + 1
            end
        end
        DoNotif("IY Plugins: Reloaded " .. count .. " plugin(s)", 3)
        self:RefreshPluginList()
    end, 2)
    makeToolBtn("CLEAR ALL", cfg.DANGER_COLOR, function()
        self.State.PluginsTable = {}
        self.State.LoadedPlugins = {}
        self:SavePluginList()
        self:RefreshPluginList()
        DoNotif("IY Plugins: All plugins cleared", 2)
    end, 3)
    local statusBar = Instance.new("Frame", window)
    statusBar.Name = "StatusBar"
    statusBar.Size = UDim2.new(1, -20, 0, 22)
    statusBar.Position = UDim2.new(0, 10, 0, 124)
    statusBar.BackgroundColor3 = cfg.SECONDARY_COLOR
    statusBar.BorderSizePixel = 0
    IYmakeCorner(statusBar, 5)
    local statusLabel = Instance.new("TextLabel", statusBar)
    statusLabel.Name = "StatusLabel"
    statusLabel.Size = UDim2.new(1, -8, 1, 0)
    statusLabel.Position = UDim2.new(0, 8, 0, 0)
    statusLabel.BackgroundTransparency = 1
    statusLabel.Font = Enum.Font.Code
    statusLabel.Text = " " .. #self.State.PluginsTable .. " plugin(s) loaded | IY Folder: " .. self.Config.PLUGINS_FOLDER
    statusLabel.TextColor3 = Color3.fromRGB(150, 150, 180)
    statusLabel.TextSize = 10
    statusLabel.TextXAlignment = Enum.TextXAlignment.Left
    self.State.StatusLabel = statusLabel
    local listHeader = Instance.new("Frame", window)
    listHeader.Size = UDim2.new(1, -20, 0, 22)
    listHeader.Position = UDim2.new(0, 10, 0, 152)
    listHeader.BackgroundColor3 = cfg.HEADER_COLOR
    listHeader.BorderSizePixel = 0
    IYmakeCorner(listHeader, 5)
    local function makeHeaderLabel(text, xPos, width, align)
        local lbl = Instance.new("TextLabel", listHeader)
        lbl.Size = UDim2.new(0, width, 1, 0)
        lbl.Position = UDim2.new(0, xPos, 0, 0)
        lbl.BackgroundTransparency = 1
        lbl.Font = Enum.Font.GothamBold
        lbl.Text = text
        lbl.TextColor3 = cfg.ACCENT_COLOR
        lbl.TextSize = 9
        lbl.TextXAlignment = align or Enum.TextXAlignment.Left
    end
    makeHeaderLabel("PLUGIN NAME", 8, 130)
    makeHeaderLabel("DESCRIPTION", 142, 160)
    makeHeaderLabel("CMDS", 306, 36, Enum.TextXAlignment.Center)
    makeHeaderLabel("ACTION", 346, 60, Enum.TextXAlignment.Center)
    local listContainer = Instance.new("ScrollingFrame", window)
    listContainer.Name = "PluginList"
    listContainer.Size = UDim2.new(1, -20, 1, -188)
    listContainer.Position = UDim2.new(0, 10, 0, 178)
    listContainer.BackgroundColor3 = Color3.fromRGB(12, 12, 16)
    listContainer.BorderSizePixel = 0
    listContainer.ScrollBarThickness = 4
    listContainer.ScrollBarImageColor3 = cfg.ACCENT_COLOR
    listContainer.CanvasSize = UDim2.new(0, 0, 0, 0)
    IYmakeCorner(listContainer, 6)
    IYmakeStroke(listContainer, Color3.fromRGB(40, 40, 60))
    local listLayout = Instance.new("UIListLayout", listContainer)
    listLayout.SortOrder = Enum.SortOrder.LayoutOrder
    listLayout.Padding = UDim.new(0, 2)
    local listPadding = Instance.new("UIPadding", listContainer)
    listPadding.PaddingTop = UDim.new(0, 4)
    listPadding.PaddingLeft = UDim.new(0, 4)
    listPadding.PaddingRight = UDim.new(0, 4)
    listLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        listContainer.CanvasSize = UDim2.new(0, 0, 0, listLayout.AbsoluteContentSize.Y + 8)
    end)
    self.State.PluginList = listContainer
    self.State.ListLayout = listLayout
    self:RefreshPluginList()
end
function Modules.IYPluginManager:RefreshPluginList()
    local listContainer = self.State.PluginList
    if not listContainer then return end
    for _, child in ipairs(listContainer:GetChildren()) do
        if child:IsA("Frame") then
            child:Destroy()
        end
    end
    local cfg = self.Config
    if self.State.StatusLabel then
        self.State.StatusLabel.Text = " " .. #self.State.PluginsTable .. " plugin(s) loaded | IY Folder: " .. self.Config.PLUGINS_FOLDER
    end
    if #self.State.PluginsTable == 0 then
        local emptyLabel = Instance.new("TextLabel", listContainer)
        emptyLabel.Size = UDim2.new(1, 0, 0, 60)
        emptyLabel.BackgroundTransparency = 1
        emptyLabel.Font = Enum.Font.GothamMedium
        emptyLabel.Text = "No plugins loaded.\nAdd a .iy file above or use ;addplugin"
        emptyLabel.TextColor3 = Color3.fromRGB(80, 80, 100)
        emptyLabel.TextSize = 12
        emptyLabel.TextWrapped = true
        return
    end
    for i, fileName in ipairs(self.State.PluginsTable) do
        local pluginData = self.State.LoadedPlugins[fileName]
        local pluginName = pluginData and pluginData.PluginName or fileName
        local pluginDesc = pluginData and pluginData.PluginDescription or "Not loaded yet"
        local cmdCount = pluginData and tostring(pluginData.CommandCount) or "?"
        local isLoaded = pluginData ~= nil
        local row = Instance.new("Frame", listContainer)
        row.Name = "Plugin_" .. fileName
        row.Size = UDim2.new(1, -8, 0, 38)
        row.BackgroundColor3 = (i % 2 == 0) and cfg.ROW_COLOR or Color3.fromRGB(28, 28, 38)
        row.BorderSizePixel = 0
        IYmakeCorner(row, 5)
        local dot = Instance.new("Frame", row)
        dot.Size = UDim2.new(0, 6, 0, 6)
        dot.Position = UDim2.new(0, 5, 0.5, -3)
        dot.BackgroundColor3 = isLoaded and cfg.SUCCESS_COLOR or cfg.DANGER_COLOR
        dot.BorderSizePixel = 0
        IYmakeCorner(dot, 3)
        local nameLabel = Instance.new("TextLabel", row)
        nameLabel.Size = UDim2.new(0, 120, 1, 0)
        nameLabel.Position = UDim2.new(0, 16, 0, 0)
        nameLabel.BackgroundTransparency = 1
        nameLabel.Font = Enum.Font.GothamBold
        nameLabel.Text = pluginName
        nameLabel.TextColor3 = isLoaded and cfg.TEXT_COLOR or Color3.fromRGB(120, 120, 140)
        nameLabel.TextSize = 11
        nameLabel.TextXAlignment = Enum.TextXAlignment.Left
        nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
        nameLabel.ClipsDescendants = true
        local descLabel = Instance.new("TextLabel", row)
        descLabel.Size = UDim2.new(0, 155, 1, 0)
        descLabel.Position = UDim2.new(0, 138, 0, 0)
        descLabel.BackgroundTransparency = 1
        descLabel.Font = Enum.Font.Code
        descLabel.Text = pluginDesc
        descLabel.TextColor3 = Color3.fromRGB(120, 120, 150)
        descLabel.TextSize = 9
        descLabel.TextXAlignment = Enum.TextXAlignment.Left
        descLabel.TextTruncate = Enum.TextTruncate.AtEnd
        descLabel.ClipsDescendants = true
        local cmdLabel = Instance.new("TextLabel", row)
        cmdLabel.Size = UDim2.new(0, 30, 1, 0)
        cmdLabel.Position = UDim2.new(0, 296, 0, 0)
        cmdLabel.BackgroundTransparency = 1
        cmdLabel.Font = Enum.Font.GothamBold
        cmdLabel.Text = cmdCount
        cmdLabel.TextColor3 = cfg.ACCENT_COLOR
        cmdLabel.TextSize = 11
        cmdLabel.TextXAlignment = Enum.TextXAlignment.Center
        local reloadBtn = Instance.new("TextButton", row)
        reloadBtn.Size = UDim2.new(0, 26, 0, 26)
        reloadBtn.Position = UDim2.new(0, 330, 0.5, -13)
        reloadBtn.BackgroundColor3 = Color3.fromRGB(50, 100, 60)
        reloadBtn.Font = Enum.Font.GothamBold
        reloadBtn.Text = "â†»"
        reloadBtn.TextColor3 = Color3.new(1, 1, 1)
        reloadBtn.TextSize = 14
        reloadBtn.BorderSizePixel = 0
        IYmakeCorner(reloadBtn, 5)
        local capturedFileName = fileName
        reloadBtn.MouseButton1Click:Connect(function()
            self.State.LoadedPlugins[capturedFileName] = nil
            local success = self:LoadPlugin(capturedFileName, false)
            if success then
                self:RefreshPluginList()
            end
        end)
        local removeBtn = Instance.new("TextButton", row)
        removeBtn.Size = UDim2.new(0, 26, 0, 26)
        removeBtn.Position = UDim2.new(0, 360, 0.5, -13)
        removeBtn.BackgroundColor3 = cfg.DANGER_COLOR
        removeBtn.Font = Enum.Font.GothamBold
        removeBtn.Text = "âœ•"
        removeBtn.TextColor3 = Color3.new(1, 1, 1)
        removeBtn.TextSize = 12
        removeBtn.BorderSizePixel = 0
        IYmakeCorner(removeBtn, 5)
        removeBtn.MouseButton1Click:Connect(function()
            self:RemovePlugin(capturedFileName)
        end)
    end
end
function Modules.IYPluginManager:ShowScanResults()
    local available = self:ScanFolder()
    if #available == 0 then
        DoNotif("IY Scan: No .iy files found in '" .. self.Config.PLUGINS_FOLDER .. "' folder", 4)
        return
    end
    local cfg = self.Config
    local screenGui = self.State.ScreenGui
    if not screenGui then return end
    local overlay = Instance.new("Frame", screenGui)
    overlay.Size = UDim2.new(0, 300, 0, 360)
    overlay.Position = UDim2.new(0.5, 20, 0.5, -180)
    overlay.BackgroundColor3 = cfg.BG_COLOR
    overlay.BorderSizePixel = 0
    overlay.ZIndex = 10
    IYmakeCorner(overlay, 10)
    IYmakeStroke(overlay, cfg.ACCENT_COLOR)
    local header = Instance.new("Frame", overlay)
    header.Size = UDim2.new(1, 0, 0, 32)
    header.BackgroundColor3 = cfg.HEADER_COLOR
    header.BorderSizePixel = 0
    IYmakeCorner(header, 10)
    local headerLabel = Instance.new("TextLabel", header)
    headerLabel.Size = UDim2.new(1, -40, 1, 0)
    headerLabel.Position = UDim2.new(0, 10, 0, 0)
    headerLabel.BackgroundTransparency = 1
    headerLabel.Font = Enum.Font.GothamBold
    headerLabel.Text = "- Found " .. #available .. " Plugin(s)"
    headerLabel.TextColor3 = cfg.ACCENT_COLOR
    headerLabel.TextSize = 12
    headerLabel.TextXAlignment = Enum.TextXAlignment.Left
    local closeOverlay = Instance.new("TextButton", header)
    closeOverlay.Size = UDim2.new(0, 24, 0, 24)
    closeOverlay.Position = UDim2.new(1, -28, 0.5, -12)
    closeOverlay.BackgroundColor3 = cfg.DANGER_COLOR
    closeOverlay.Font = Enum.Font.GothamBold
    closeOverlay.Text = "âœ•"
    closeOverlay.TextColor3 = Color3.new(1, 1, 1)
    closeOverlay.TextSize = 11
    closeOverlay.BorderSizePixel = 0
    IYmakeCorner(closeOverlay, 5)
    closeOverlay.MouseButton1Click:Connect(function()
        overlay:Destroy()
    end)
    local scroll = Instance.new("ScrollingFrame", overlay)
    scroll.Size = UDim2.new(1, -10, 1, -44)
    scroll.Position = UDim2.new(0, 5, 0, 38)
    scroll.BackgroundTransparency = 1
    scroll.BorderSizePixel = 0
    scroll.ScrollBarThickness = 4
    scroll.ScrollBarImageColor3 = cfg.ACCENT_COLOR
    scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
    local layout = Instance.new("UIListLayout", scroll)
    layout.Padding = UDim.new(0, 3)
    layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        scroll.CanvasSize = UDim2.new(0, 0, 0, layout.AbsoluteContentSize.Y + 4)
    end)
    for _, fileName in ipairs(available) do
        local alreadyAdded = IYfindInTable(self.State.PluginsTable, fileName)
        local row = Instance.new("Frame", scroll)
        row.Size = UDim2.new(1, -4, 0, 32)
        row.BackgroundColor3 = cfg.SECONDARY_COLOR
        row.BorderSizePixel = 0
        IYmakeCorner(row, 5)
        local fileLabel = Instance.new("TextLabel", row)
        fileLabel.Size = UDim2.new(1, -60, 1, 0)
        fileLabel.Position = UDim2.new(0, 8, 0, 0)
        fileLabel.BackgroundTransparency = 1
        fileLabel.Font = Enum.Font.Code
        fileLabel.Text = fileName
        fileLabel.TextColor3 = alreadyAdded and Color3.fromRGB(100, 180, 100) or cfg.TEXT_COLOR
        fileLabel.TextSize = 11
        fileLabel.TextXAlignment = Enum.TextXAlignment.Left
        fileLabel.TextTruncate = Enum.TextTruncate.AtEnd
        local addFileBtn = Instance.new("TextButton", row)
        addFileBtn.Size = UDim2.new(0, 50, 0, 24)
        addFileBtn.Position = UDim2.new(1, -54, 0.5, -12)
        addFileBtn.BackgroundColor3 = alreadyAdded and Color3.fromRGB(40, 60, 40) or cfg.ACCENT_COLOR
        addFileBtn.Font = Enum.Font.GothamBold
        addFileBtn.Text = alreadyAdded and "âœ“ ON" or "+ ADD"
        addFileBtn.TextColor3 = alreadyAdded and Color3.fromRGB(100, 200, 100) or Color3.fromRGB(0, 0, 0)
        addFileBtn.TextSize = 9
        addFileBtn.BorderSizePixel = 0
        IYmakeCorner(addFileBtn, 5)
        if not alreadyAdded then
            local capturedFile = fileName
            addFileBtn.MouseButton1Click:Connect(function()
                self:AddPlugin(capturedFile)
                addFileBtn.Text = "âœ“ ON"
                addFileBtn.BackgroundColor3 = Color3.fromRGB(40, 60, 40)
                addFileBtn.TextColor3 = Color3.fromRGB(100, 200, 100)
                fileLabel.TextColor3 = Color3.fromRGB(100, 180, 100)
            end)
        end
    end
end
function Modules.IYPluginManager:Initialize()
    pcall(function()
        if makefolder and (not isfolder or not isfolder(self.Config.SAVE_FOLDER)) then
            makefolder(self.Config.SAVE_FOLDER)
        end
    end)
    self:LoadAllSaved()
end
RegisterCommand({
    Name = "plugins",
    Aliases = { "iy", "iyplugins", "pluginmanager" },
    Description = "Open the IY Plugin Manager UI"
}, function(args)
    Modules.IYPluginManager:CreateUI()
    DoNotif("IY Plugin Manager opened", 2)
end)
RegisterCommand({
    Name = "addplugin",
    Aliases = { "loadplugin", "plugin" },
    Description = "Load an .iy plugin. Usage: ;addplugin filename"
}, function(args)
    if not args[1] then
        DoNotif("Usage: ;addplugin <filename>", 2)
        return
    end
    Modules.IYPluginManager:AddPlugin(args[1])
end)
RegisterCommand({
    Name = "removeplugin",
    Aliases = { "delplugin", "rmplugin" },
    Description = "Remove a loaded plugin. Usage: ;removeplugin filename"
}, function(args)
    if not args[1] then
        DoNotif("Usage: ;removeplugin <filename>", 2)
        return
    end
    local fileName = args[1]
    if fileName:sub(-3) ~= ".iy" then
        fileName = fileName .. ".iy"
    end
    Modules.IYPluginManager:RemovePlugin(fileName)
end)
RegisterCommand({
    Name = "reloadplugins",
    Aliases = { "refreshplugins" },
    Description = "Reload all saved plugins from disk"
}, function(args)
    for _, fileName in ipairs(Modules.IYPluginManager.State.PluginsTable) do
        Modules.IYPluginManager.State.LoadedPlugins[fileName] = nil
        Modules.IYPluginManager:LoadPlugin(fileName, false)
    end
    Modules.IYPluginManager:RefreshPluginList()
    DoNotif("IY Plugins: All plugins reloaded", 2)
end)
RegisterCommand({
    Name = "listplugins",
    Aliases = { "pluginlist" },
    Description = "List all loaded plugins in chat"
}, function(args)
    local pm = Modules.IYPluginManager
    if #pm.State.PluginsTable == 0 then
        DoNotif("IY Plugins: No plugins loaded", 2)
        return
    end
    for i, fileName in ipairs(pm.State.PluginsTable) do
        local data = pm.State.LoadedPlugins[fileName]
        local name = data and data.PluginName or fileName
        local cmds = data and data.CommandCount or 0
        DoNotif("[" .. i .. "] " .. name .. " (" .. cmds .. " cmds)", 3)
    end
end)
RegisterCommand({
    Name = "scanplugins",
    Aliases = { "pluginscan" },
    Description = "Scan IY folder for available .iy files"
}, function(args)
    local found = Modules.IYPluginManager:ScanFolder()
    if #found == 0 then
        DoNotif("IY Scan: No .iy files found in '" .. Modules.IYPluginManager.Config.PLUGINS_FOLDER .. "'", 4)
    else
        DoNotif("IY Scan: Found " .. #found .. " plugin(s). Open ;plugins to add them.", 4)
        for _, f in ipairs(found) do
            DoNotif("  â†’ " .. f, 2)
        end
    end
end)

function processCommand(message)
    if not (message:sub(1, #Prefix) == Prefix) then
        return false
    end
    local args = {}
    for word in message:sub(#Prefix + 1):gmatch("%S+") do
        table.insert(args, word)
    end
    if #args == 0 then
        return true
    end
    local cmdName = table.remove(args, 1):lower()
    local cmdFunc = Commands[cmdName]
    if cmdFunc then
        local success, err = pcall(cmdFunc, args)
        if not success then
            warn("Command Error:", err)
            DoNotif("Error: " .. tostring(err), 5)
        end
    else
        local lowestDistance = math.huge
        local closestMatch = nil
        local SUGGESTION_THRESHOLD = 2
        for command, _ in pairs(Commands) do
            local distance = Utilities.calculateLevenshteinDistance(cmdName, command)
            if distance < lowestDistance then
                lowestDistance = distance
                closestMatch = command
            end
        end
        if closestMatch and lowestDistance <= SUGGESTION_THRESHOLD then
            DoNotif(string.format("Unknown command: %s. Did you mean ;%s?", cmdName, closestMatch), 4)
        else
            DoNotif("Unknown command: " .. cmdName, 3)
        end
    end
    return true
end
for moduleName, module in pairs(Modules) do
       if type(module) == "table" and type(module.Initialize) == "function" then
           pcall(function()
           module:Initialize()
        end)
    end
end
local function CreateMobileCommandButton()
    local UserInputService = game:GetService("UserInputService")
    local CoreGui = game:GetService("CoreGui")
    if not UserInputService.TouchEnabled then
        return
    end
    if CoreGui:FindFirstChild("MobileCommandButton_Zuka") then
        return
    end
    local buttonGui = Instance.new("ScreenGui")
    buttonGui.Name = "MobileCommandButton_Zuka"
    buttonGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
    buttonGui.ResetOnSpawn = false
    buttonGui.Parent = CoreGui
    local cmdButton = Instance.new("ImageButton")
    cmdButton.Name = "DraggableCommandButton"
    cmdButton.Size = UDim2.fromOffset(60, 60)
    cmdButton.Position = UDim2.new(0, 20, 0.5, -30)
    cmdButton.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    cmdButton.BackgroundTransparency = 0.2
    cmdButton.Image = "rbxassetid://7243158473"
    cmdButton.ImageColor3 = Color3.fromRGB(0, 255, 255)
    cmdButton.Parent = buttonGui
    Instance.new("UICorner", cmdButton).CornerRadius = UDim.new(1, 0)
    Instance.new("UIStroke", cmdButton).Color = Color3.fromRGB(80, 80, 100)
    local isDragging = false
    local dragStartPos = nil
    local startGuiPosition = nil
    local DRAG_THRESHOLD = 8
    cmdButton.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch then
            dragStartPos = input.Position
            startGuiPosition = cmdButton.Position
            isDragging = false
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch and dragStartPos then
            local delta = input.Position - dragStartPos
            if not isDragging and delta.Magnitude > DRAG_THRESHOLD then
                isDragging = true
            end
            if isDragging then
                cmdButton.Position = UDim2.new(startGuiPosition.X.Scale, startGuiPosition.X.Offset + delta.X, startGuiPosition.Y.Scale, startGuiPosition.Y.Offset + delta.Y)
            end
        end
    end)
    cmdButton.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch then
            dragStartPos = nil
            startGuiPosition = nil
        end
    end)
    cmdButton.Activated:Connect(function()
        if not isDragging then
            if Modules.CommandBar and Modules.CommandBar.Toggle then
                Modules.CommandBar:Toggle()
            end
        end
        isDragging = false
    end)
end
CreateMobileCommandButton()
Modules.CommandList:Initialize()
if TextChatService then
    TextChatService.SendingMessage:Connect(function(messageObject)
    local wasCommand = processCommand(messageObject.Text)
    if wasCommand then
        messageObject.ShouldSend = false
    end
end)
else
LocalPlayer.Chatted:Connect(processCommand)
end
local TeleportService = game:GetService("TeleportService")
local ClientReplicator = game:GetService("NetworkClient").ClientReplicator
local CurrentServer = game["JobId"]
ClientReplicator.AncestryChanged:Connect(function()
    TeleportService:TeleportToPlaceInstance(game["PlaceId"], CurrentServer)
end)
DoNotif("We're So back. The Best Underground Panel.")


--[[local getgenv, getnamecallmethod, hookmetamethod, newcclosure, checkcaller, stringlower = getgenv, getnamecallmethod, hookmetamethod, newcclosure, checkcaller, string.lower;
local function ClonedService(name)
	local Service = game.GetService;
	local Reference = cloneref or function(reference)
		return reference;
	end;
	return Reference(Service(game, name));
end;
if (getgenv()).ED_AntiKick then
	return;
end;
local Players, StarterGui, OldNamecall = ClonedService("Players"), ClonedService("StarterGui");
(getgenv()).ED_AntiKick = {
	Enabled = true,
	SendNotifications = true,
	CheckCaller = true
};
OldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(...)
	if ((getgenv()).ED_AntiKick.CheckCaller and (not checkcaller()) or true) and stringlower(getnamecallmethod()) == "kick" and ED_AntiKick.Enabled then
		if (getgenv()).ED_AntiKick.SendNotifications then
			StarterGui:SetCore("SendNotification", {
				Title = "Zuka Tech",
				Text = "The script has successfully intercepted an attempted kick.",
				Icon = "rbxassetid://6238540373",
				Duration = 2
			});
		end;
		return nil;
	end;
	return OldNamecall(...);
end));
if (getgenv()).ED_AntiKick.SendNotifications then
	StarterGui:SetCore("SendNotification", {
		Title = "Zuka Tech",
		Text = "Shield Loaded",
		Icon = "rbxassetid://6238537240",
		Duration = 3
	});
end;]]
